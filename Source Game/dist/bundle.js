(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnemyStates = void 0;
const StateMachineAI_1 = require("./../Wolfie2D/AI/StateMachineAI");
const AABB_1 = require("./../Wolfie2D/DataTypes/Shapes/AABB");
const Vec2_1 = require("./../Wolfie2D/DataTypes/Vec2");
const Attack_1 = require("./BatStates/Attack");
const Idle_1 = require("./BatStates/Idle");
class EnemyAI extends StateMachineAI_1.default {
    constructor() {
        super(...arguments);
        /** The default movement speed of this AI */
        this.speed = 20;
        // State machine defers updates and event handling to its children
        // Check super classes for details
    }
    initializeAI(owner, options) {
        this.owner = owner;
        this.addState(EnemyStates.IDLE, new Idle_1.default(this, owner));
        this.addState(EnemyStates.ATTACKING, new Attack_1.default(this, owner));
        this.health = options.health;
        this.player = options.player;
        // Initialize to the default state
        this.initialize(EnemyStates.DEFAULT);
        this.getPlayerPosition();
    }
    activate(options) {
    }
    damage(damage) {
        console.log("Took damage");
        this.health -= damage;
        if (this.health <= 0) {
            this.owner.setAIActive(false, {});
            this.owner.isCollidable = false;
            this.owner.visible = false;
            if (Math.random() < 0.2) {
                // Spawn a healthpack
                this.emitter.fireEvent("healthpack", { position: this.owner.position });
            }
        }
    }
    getPlayerPosition() {
        let pos = this.player.position;
        // Get the new player location
        let start = this.owner.position.clone();
        let delta = pos.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, pos.x);
        let maxX = Math.max(start.x, pos.x);
        let minY = Math.min(start.y, pos.y);
        let maxY = Math.max(start.y, pos.y);
        // Get the wall tilemap
        let walls = this.owner.getScene().getLayer("Wall").getItems()[0];
        let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
        let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
        let tileSize = walls.getTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(pos)) {
                        // We hit a wall, we can't see the player
                        return null;
                    }
                }
            }
        }
        return pos;
    }
}
exports.default = EnemyAI;
var EnemyStates;
(function (EnemyStates) {
    EnemyStates["DEFAULT"] = "default";
    EnemyStates["IDLE"] = "idle";
    EnemyStates["ATTACKING"] = "attacking";
    EnemyStates["PREVIOUS"] = "previous";
})(EnemyStates = exports.EnemyStates || (exports.EnemyStates = {}));
},{"./../Wolfie2D/AI/StateMachineAI":10,"./../Wolfie2D/DataTypes/Shapes/AABB":22,"./../Wolfie2D/DataTypes/Vec2":29,"./BatStates/Attack":2,"./BatStates/Idle":4}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("./../../Wolfie2D/DataTypes/Vec2");
const Timer_1 = require("./../../Wolfie2D/Timing/Timer");
const BatAI_1 = require("../BatAI");
const EnemyState_1 = require("./EnemyState");
class Attack extends EnemyState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
        // Regularly update the player location
        this.pollTimer = new Timer_1.default(100);
        this.exitTimer = new Timer_1.default(1000);
    }
    onEnter(options) {
        this.lastPlayerPos = this.parent.getPlayerPosition();
        // Reset the return object
        this.retObj = {};
    }
    handleInput(event) { }
    update(deltaT) {
        if (this.pollTimer.isStopped()) {
            // Restart the timer
            this.pollTimer.start();
            this.playerPos = this.parent.getPlayerPosition();
            if (this.playerPos !== null) {
                // If we see a new player position, update the last position
                this.lastPlayerPos = this.playerPos;
            }
        }
        if (this.playerPos !== null) {
            // Player is visible, restart the exitTimer
            this.exitTimer.start();
            // Face player
            let dir = this.playerPos.clone().sub(this.owner.position).normalize();
            dir.rotateCCW(Math.PI / 4 * Math.random() - Math.PI / 8);
            this.owner.rotation = Vec2_1.default.UP.angleToCCW(dir);
        }
        if (this.exitTimer.isStopped()) {
            // We haven't seen the player in a while, go check out where we last saw them, if possible
            if (this.lastPlayerPos !== null) {
            }
            else {
                this.finished(BatAI_1.EnemyStates.IDLE);
            }
        }
    }
    onExit() {
        return this.retObj;
    }
}
exports.default = Attack;
},{"../BatAI":1,"./../../Wolfie2D/DataTypes/Vec2":29,"./../../Wolfie2D/Timing/Timer":100,"./EnemyState":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const State_1 = require("./../../Wolfie2D/DataTypes/State/State");
class EnemyState extends State_1.default {
    constructor(parent, owner) {
        super(parent);
        this.owner = owner;
    }
}
exports.default = EnemyState;
},{"./../../Wolfie2D/DataTypes/State/State":26}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BatAI_1 = require("../BatAI");
const EnemyState_1 = require("./EnemyState");
class Idle extends EnemyState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
    }
    onEnter(options) {
    }
    handleInput(event) {
    }
    update(deltaT) {
        if (this.parent.getPlayerPosition() !== null) {
            this.finished(BatAI_1.EnemyStates.ATTACKING);
        }
    }
    onExit() {
        return this.retObj;
    }
}
exports.default = Idle;
},{"../BatAI":1,"./EnemyState":3}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const Input_1 = require("../Wolfie2D/Input/Input");
class PlayerController {
    initializeAI(owner, options) {
        this.owner = owner;
        this.direction = Vec2_1.default.ZERO;
        this.curr_velocity = Vec2_1.default.ZERO; // for use with slippery movement
        this.attack_direction = Vec2_1.default.ZERO;
        this.speed = options.speed;
        this.health = 5;
        this.slippery = options.slippery !== undefined ? options.slippery : false;
    }
    activate(options) { }
    handleEvent(event) { }
    update(deltaT) {
        // get the movement direction
        this.direction.x = (Input_1.default.isPressed("left") ? -1 : 0) + (Input_1.default.isPressed("right") ? 1 : 0);
        this.direction.y = (Input_1.default.isPressed("up") ? -1 : 0) + (Input_1.default.isPressed("down") ? 1 : 0);
        if (!this.direction.isZero()) {
            if (this.slippery) {
                // slippery movement
                if (this.direction.x !== 0) {
                    this.curr_velocity.x += this.direction.normalized().scale(this.speed * deltaT).x / 20;
                }
                else {
                    this.curr_velocity.x -= this.curr_velocity.normalized().scale(this.speed * deltaT).x / 40;
                }
                if (this.direction.y !== 0) {
                    this.curr_velocity.y += this.direction.normalized().scale(this.speed * deltaT).y / 20;
                }
                else {
                    this.curr_velocity.y -= this.curr_velocity.normalized().scale(this.speed * deltaT).y / 40;
                }
                this.owner.move(this.curr_velocity);
                this.owner.animation.playIfNotAlready("WALK", true);
            }
            else {
                // normal movement
                this.owner.move(this.direction.normalized().scale(this.speed * deltaT));
                this.owner.animation.playIfNotAlready("WALK", true);
            }
        }
        else {
            // Player is idle
            if (this.slippery && (Math.abs(this.curr_velocity.x) > 0 || Math.abs(this.curr_velocity.y) > 0)) {
                // slide a bit
                // console.log("slide cap up");
                this.curr_velocity.x -= this.curr_velocity.normalized().scale(this.speed * deltaT).x / 40;
                this.curr_velocity.y -= this.curr_velocity.normalized().scale(this.speed * deltaT).y / 40;
                if (Math.abs(this.curr_velocity.x) < .05) {
                    this.curr_velocity.x = 0;
                }
                if (Math.abs(this.curr_velocity.y) < .05) {
                    this.curr_velocity.y = 0;
                }
                this.owner.move(this.curr_velocity);
                this.owner.animation.playIfNotAlready("WALK", true);
            }
            else {
                this.owner.animation.playIfNotAlready("IDLE", true);
            }
        }
        // Get the unit vector in the attack direction
        this.attack_direction = this.owner.position.dirTo(Input_1.default.getGlobalMousePosition());
        // punch attack
        if (Input_1.default.isMouseJustPressed()) {
            // TODO PROJECT - implement punch attack here
            console.log("punch event");
            this.owner.animation.play("ATTACK", true);
        }
        // have player face left or right
        let mouse_position = Input_1.default.getGlobalMousePosition();
        if (mouse_position.x < this.owner.position.x) {
            this.owner.invertX = true;
        }
        else {
            this.owner.invertX = false;
        }
    }
    damage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
            console.log("Game Over");
        }
    }
    destroy() {
        delete this.owner;
    }
}
exports.default = PlayerController;
},{"../Wolfie2D/DataTypes/Vec2":29,"../Wolfie2D/Input/Input":37}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const Scene_1 = require("../Wolfie2D/Scene/Scene");
const AABB_1 = require("../Wolfie2D/DataTypes/Shapes/AABB");
const PlayerController_1 = require("../AI/PlayerController");
const BatAI_1 = require("../AI/BatAI");
class GluttonyLevel extends Scene_1.default {
    // use initScene to differentiate between level select start and game continue?
    loadScene() {
        // load the player and enemy spritesheets
        this.load.spritesheet("player", "game_assets/spritesheets/zara.json");
        // TODO PROJECT - add enemy spritesheets
        // Load in the enemy info
        this.load.spritesheet("bat", "game_assets/spritesheets/hellbat.json");
        this.load.object("enemyData", "game_assets/data/enemy.json");
        // load the tilemap
        // TODO PROJECT - switch with correct tilemap
        this.load.tilemap("gluttonyLevel", "game_assets/tilemaps/hells_fury.json");
    }
    startScene() {
        // Add in the tilemap
        let tilemap_layers = this.add.tilemap("gluttonyLevel");
        // get the wall layer
        this.walls = tilemap_layers[1].getItems()[0];
        // set the viewport bounds to the tilemap
        let tilemap_size = this.walls.size;
        this.viewport.setBounds(0, 0, tilemap_size.x, tilemap_size.y);
        // add primary layer
        this.addLayer("primary", 10);
        this.initializePlayer();
        // TODO PROJECT - write initializeEnemies()
        // this.initializeEnemies();
        // setup viewport
        this.viewport.follow(this.player);
        this.viewport.setZoomLevel(3);
        // TODO PROJECT - receiver subscribe to events
        // this.receiver.subscribe(EVENTSTRING);
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
        }
    }
    initializePlayer() {
        // Create the player
        this.player = this.add.animatedSprite("player", "primary");
        this.player.position.set(30 * 16, 62 * 16);
        this.player.addPhysics(new AABB_1.default(new Vec2_1.default(0, 14), new Vec2_1.default(8, 10)));
        this.player.addAI(PlayerController_1.default, {
            speed: 150,
            slippery: true
        });
        this.player.animation.play("IDLE", true);
    }
    initializeEnemies() {
        // Get the enemy data
        const enemyData = this.load.getObject("enemyData");
        // Create an enemies array
        this.enemies = new Array(enemyData.numEnemies);
        // Initialize the enemies
        for (let i = 0; i < enemyData.numEnemies; i++) {
            let data = enemyData.enemies[i];
            // Create an enemy
            this.enemies[i] = this.add.animatedSprite("hellbat", "primary");
            this.enemies[i].position.set(data.position[0], data.position[1]);
            this.enemies[i].animation.play("IDLE");
            // Activate physics
            //Only one enemy for now
            this.enemies[i].addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(5, 5)));
            let enemyOptions = {
                health: data.health,
                player: this.player,
            };
            this.enemies[i].addAI(BatAI_1.default, enemyOptions);
        }
    }
}
exports.default = GluttonyLevel;
},{"../AI/BatAI":1,"../AI/PlayerController":5,"../Wolfie2D/DataTypes/Shapes/AABB":22,"../Wolfie2D/DataTypes/Vec2":29,"../Wolfie2D/Scene/Scene":96}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../Wolfie2D/Scene/Scene");
const Color_1 = require("../Wolfie2D/Utils/Color");
const GluttonyLevel_1 = require("./GluttonyLevel");
class MainMenu extends Scene_1.default {
    loadScene() {
        this.load.image("mainMenuImage", "game_assets/images/main_menu_background.png");
        this.load.image("levelSelectImage", "game_assets/images/level_select_background.png");
        this.load.image("helpImage", "game_assets/images/help_background.png");
        this.load.image("controlsImage", "game_assets/images/controls_background.png");
    }
    startScene() {
        const center = this.viewport.getCenter();
        // subscribe to button events
        this.receiver.subscribe("newGame");
        this.receiver.subscribe("levelSelect");
        this.receiver.subscribe("help");
        this.receiver.subscribe("controls");
        this.receiver.subscribe("mainMenu");
        this.receiver.subscribe("levelGluttony");
        this.receiver.subscribe("levelLust");
        this.receiver.subscribe("levelWrath");
        this.receiver.subscribe("levelGreed");
        this.receiver.subscribe("levelSloth");
        this.receiver.subscribe("levelEnvy");
        this.receiver.subscribe("levelPride");
        /* ################ MAIN MENU ################ */
        // create main menu layer
        this.main_menu = this.addUILayer("mainMenu");
        // add main menu background image
        let mmb = this.add.sprite("mainMenuImage", "mainMenu");
        mmb.position.set(mmb.size.x / 2, mmb.size.y / 2);
        // Add new game button, and give it an event to emit on press
        const new_game_button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x - 14, center.y - 170), text: "" });
        new_game_button.size.set(330, 70);
        new_game_button.borderWidth = 2;
        new_game_button.borderColor = Color_1.default.TRANSPARENT;
        new_game_button.backgroundColor = Color_1.default.TRANSPARENT;
        new_game_button.onClickEventId = "newGame";
        // Add level select button
        const level_select_button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x - 13, center.y - 60), text: "" });
        level_select_button.size.set(420, 70);
        level_select_button.borderWidth = 2;
        level_select_button.borderColor = Color_1.default.TRANSPARENT;
        level_select_button.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_button.onClickEventId = "levelSelect";
        // Add help button
        const help_button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x - 21, center.y + 55), text: "" });
        help_button.size.set(145, 75);
        help_button.borderWidth = 2;
        help_button.borderColor = Color_1.default.TRANSPARENT;
        help_button.backgroundColor = Color_1.default.TRANSPARENT;
        help_button.onClickEventId = "help";
        // Add controls
        const controls_button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x - 13, center.y + 150), text: "" });
        controls_button.size.set(268, 70);
        controls_button.borderWidth = 2;
        controls_button.borderColor = Color_1.default.TRANSPARENT;
        controls_button.backgroundColor = Color_1.default.TRANSPARENT;
        controls_button.onClickEventId = "controls";
        /* ################ LEVEL SELECT ################ */
        // create level select layer
        this.level_select = this.addUILayer("levelSelect");
        this.level_select.setHidden(true);
        // add level select background image
        let lsb = this.add.sprite("levelSelectImage", "levelSelect");
        lsb.position.set(lsb.size.x / 2, lsb.size.y / 2);
        const level_select_back = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x + 518, center.y + 308), text: "" });
        level_select_back.size.set(168, 65);
        level_select_back.borderWidth = 2;
        level_select_back.borderColor = Color_1.default.TRANSPARENT;
        level_select_back.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_back.onClickEventId = "mainMenu";
        const level_select_gluttony = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 20, center.y - 195), text: "" });
        level_select_gluttony.size.set(285, 75);
        level_select_gluttony.borderWidth = 2;
        level_select_gluttony.borderColor = Color_1.default.TRANSPARENT;
        level_select_gluttony.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_gluttony.onClickEventId = "levelGluttony";
        const level_select_lust = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 27, center.y - 95), text: "" });
        level_select_lust.size.set(140, 58);
        level_select_lust.borderWidth = 2;
        level_select_lust.borderColor = Color_1.default.TRANSPARENT;
        level_select_lust.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_lust.onClickEventId = "levelLust";
        const level_select_wrath = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 21, center.y + 3), text: "" });
        level_select_wrath.size.set(164, 54);
        level_select_wrath.borderWidth = 2;
        level_select_wrath.borderColor = Color_1.default.TRANSPARENT;
        level_select_wrath.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_wrath.onClickEventId = "levelWrath";
        const level_select_greed = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 21, center.y + 85), text: "" });
        level_select_greed.size.set(150, 50);
        level_select_greed.borderWidth = 2;
        level_select_greed.borderColor = Color_1.default.TRANSPARENT;
        level_select_greed.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_greed.onClickEventId = "levelGreed";
        const level_select_sloth = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 19, center.y + 160), text: "" });
        level_select_sloth.size.set(135, 50);
        level_select_sloth.borderWidth = 2;
        level_select_sloth.borderColor = Color_1.default.TRANSPARENT;
        level_select_sloth.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_sloth.onClickEventId = "levelSloth";
        const level_select_envy = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 20, center.y + 230), text: "" });
        level_select_envy.size.set(114, 50);
        level_select_envy.borderWidth = 2;
        level_select_envy.borderColor = Color_1.default.TRANSPARENT;
        level_select_envy.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_envy.onClickEventId = "levelEnvy";
        const level_select_pride = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 22, center.y + 295), text: "" });
        level_select_pride.size.set(107, 47);
        level_select_pride.borderWidth = 2;
        level_select_pride.borderColor = Color_1.default.TRANSPARENT;
        level_select_pride.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_pride.onClickEventId = "levelPride";
        /* ################ HELP ################ */
        // create help layer
        this.help = this.addUILayer("help");
        this.help.setHidden(true);
        // add help background image
        let hb = this.add.sprite("helpImage", "help");
        hb.position.set(hb.size.x / 2, hb.size.y / 2);
        const help_back = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "help", { position: new Vec2_1.default(center.x + 518, center.y + 308), text: "" });
        help_back.size.set(168, 65);
        help_back.borderWidth = 2;
        help_back.borderColor = Color_1.default.TRANSPARENT;
        help_back.backgroundColor = Color_1.default.TRANSPARENT;
        help_back.onClickEventId = "mainMenu";
        /* ################ CONTROLS ################ */
        // create controls layer
        this.controls = this.addUILayer("controls");
        this.controls.setHidden(true);
        // add controls background image
        let cb = this.add.sprite("controlsImage", "controls");
        cb.position.set(cb.size.x / 2, cb.size.y / 2);
        const controls_back = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "controls", { position: new Vec2_1.default(center.x + 518, center.y + 308), text: "" });
        controls_back.size.set(168, 65);
        controls_back.borderWidth = 2;
        controls_back.borderColor = Color_1.default.TRANSPARENT;
        controls_back.backgroundColor = Color_1.default.TRANSPARENT;
        controls_back.onClickEventId = "mainMenu";
    }
    updateScene() {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            // let scene_options = {
            //     physics: {
            //         groupNames: ["ground", "player"],
            //         collisions: [
            //             [0, 1],
            //             [1, 0]
            //         ]
            //     }
            // }
            if (event.type === "newGame") {
                // TODO PROJECT - setup new game scene from here (maybe add options)
                console.log("New Game Event no scene_options");
                this.sceneManager.changeToScene(GluttonyLevel_1.default, {});
            }
            if (event.type === "mainMenu") {
                console.log("Main Menu Event");
                this.main_menu.setHidden(false);
                this.level_select.setHidden(true);
                this.help.setHidden(true);
                this.controls.setHidden(true);
            }
            if (event.type === "levelSelect") {
                console.log("Level Select Event");
                this.main_menu.setHidden(true);
                this.level_select.setHidden(false);
            }
            if (event.type === "help") {
                console.log("Help Event");
                this.main_menu.setHidden(true);
                this.help.setHidden(false);
            }
            if (event.type === "controls") {
                console.log("Controls Event");
                this.main_menu.setHidden(true);
                this.controls.setHidden(false);
            }
            if (event.type === "levelGluttony") {
                // TODO PROJECT - go to gluttony level (level 1)
                console.log("Gluttony Level");
                this.sceneManager.changeToScene(GluttonyLevel_1.default, {});
            }
            if (event.type === "levelLust") {
                // TODO PROJECT - go to lust level (level 2)
                console.log("Lust Level");
            }
            if (event.type === "levelWrath") {
                // TODO PROJECT - go to wrath level (level 3)
                console.log("Wrath Level");
            }
            if (event.type === "levelGreed") {
                // TODO PROJECT - go to greed level (level 4)
                console.log("Greed Level");
            }
            if (event.type === "levelSloth") {
                // TODO PROJECT - go to sloth level (level 5)
                console.log("Sloth Level");
            }
            if (event.type === "levelEnvy") {
                // TODO PROJECT - go to envy level (level 6)
                console.log("Envy Level");
            }
            if (event.type === "levelPride") {
                // TODO PROJECT - go to pride level (level 7)
                console.log("Pride Level");
            }
        }
    }
}
exports.default = MainMenu;
},{"../Wolfie2D/DataTypes/Vec2":29,"../Wolfie2D/Nodes/UIElements/UIElementTypes":60,"../Wolfie2D/Scene/Scene":96,"../Wolfie2D/Utils/Color":102,"./GluttonyLevel":6}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../Wolfie2D/Scene/Scene");
const Color_1 = require("../Wolfie2D/Utils/Color");
const MainMenu_1 = require("./MainMenu");
class SplashScreen extends Scene_1.default {
    loadScene() {
        this.load.image("splashImage", "game_assets/images/splash_screen.png");
    }
    startScene() {
        const center = this.viewport.getCenter();
        // The splash screen
        this.splash = this.addUILayer("splashScreen");
        // Add a background to the scene
        this.splash_background = this.addParallaxLayer("splash_background", new Vec2_1.default(0.5, 1), -1);
        let sb = this.add.sprite("splashImage", "splash_background");
        sb.position.set(sb.size.x / 2, sb.size.y / 2);
        // Add transparent button
        const confirm = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "splashScreen", { position: new Vec2_1.default(center.x, center.y), text: "" });
        confirm.size.set(1280, 720);
        confirm.borderWidth = 0;
        confirm.borderColor = Color_1.default.TRANSPARENT;
        confirm.backgroundColor = Color_1.default.TRANSPARENT;
        confirm.onClickEventId = "confirm";
        // Subscribe to the button events
        this.receiver.subscribe("confirm");
    }
    updateScene() {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === "confirm") {
                this.splash_background.disable();
                this.sceneManager.changeToScene(MainMenu_1.default, {});
            }
        }
    }
}
exports.default = SplashScreen;
},{"../Wolfie2D/DataTypes/Vec2":29,"../Wolfie2D/Nodes/UIElements/UIElementTypes":60,"../Wolfie2D/Scene/Scene":96,"../Wolfie2D/Utils/Color":102,"./MainMenu":7}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
class AIManager {
    constructor() {
        this.actors = new Array();
        this.registeredAI = new Map_1.default();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    registerActor(actor) {
        this.actors.push(actor);
    }
    removeActor(actor) {
        let index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    }
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    registerAI(name, constr) {
        this.registeredAI.add(name, constr);
    }
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    generateAI(name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw `Cannot create AI with name ${name}, no AI with that name is registered`;
        }
    }
    update(deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(actor => { if (actor.aiActive)
            actor.ai.update(deltaT); });
    }
}
exports.default = AIManager;
},{"../DataTypes/Map":16}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachine_1 = require("../DataTypes/State/StateMachine");
/**
 * A version of a @reference[StateMachine] that is configured to work as an AI controller for a @reference[GameNode]
 */
class StateMachineAI extends StateMachine_1.default {
    // @implemented
    initializeAI(owner, config) { }
    // @implemented
    destroy() {
        // Get rid of our reference to the owner
        delete this.owner;
        this.receiver.destroy();
    }
    // @implemented
    activate(options) { }
}
exports.default = StateMachineAI;
},{"../DataTypes/State/StateMachine":27}],11:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A placeholder function for No Operation. Does nothing
 */
const NullFunc = () => { };
exports.default = NullFunc;
},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A linked-list for the edges in a @reference[Graph].
 */
class EdgeNode {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    constructor(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
}
exports.default = EdgeNode;
},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_V = void 0;
const EdgeNode_1 = require("./EdgeNode");
exports.MAX_V = 100;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
class Graph {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
    */
    addNode() {
        this.numVertices++;
        return this.numVertices;
    }
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
    */
    addEdge(x, y, weight) {
        let edge = new EdgeNode_1.default(y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1.default(x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    }
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    edgeExists(x, y) {
        let edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    }
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    getEdges(x) {
        return this.edges[x];
    }
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    getDegree(x) {
        return this.degree[x];
    }
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    nodeToString(index) {
        return "Node " + index;
    }
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    toString() {
        let retval = "";
        for (let i = 0; i < this.numVertices; i++) {
            let edge = this.edges[i];
            let edgeStr = "";
            while (edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    }
}
exports.default = Graph;
},{"./EdgeNode":12}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = require("./Graph");
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
*/
class PositionGraph extends Graph_1.default {
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        super(directed);
        this.debugRender = () => {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        this.positions = new Array(Graph_1.MAX_V);
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    addPositionedNode(position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    }
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    setNodePosition(index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (let i = 0; i < this.numEdges; i++) {
            let edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    }
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    getNodePosition(index) {
        return this.positions[index];
    }
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    addEdge(x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        let weight = this.positions[x].distanceTo(this.positions[y]);
        super.addEdge(x, y, weight);
    }
    // @override
    nodeToString(index) {
        return "Node " + index + " - " + this.positions[index].toString();
    }
}
exports.default = PositionGraph;
},{"./Graph":13}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;
},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Associates strings with elements of type T
 */
class Map {
    /** Creates a new map */
    constructor() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    add(key, value) {
        this.map[key] = value;
    }
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    get(key) {
        return this.map[key];
    }
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    set(key, value) {
        this.add(key, value);
    }
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    has(key) {
        return this.map[key] !== undefined;
    }
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    keys() {
        return Object.keys(this.map);
    }
    // @implemented
    forEach(func) {
        Object.keys(this.map).forEach(key => func(key));
    }
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    delete(key) {
        delete this.map[key];
    }
    // @implemented
    clear() {
        this.forEach(key => delete this.map[key]);
    }
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    toString() {
        let str = "";
        this.forEach((key) => str += key + " -> " + this.get(key).toString() + "\n");
        return str;
    }
}
exports.default = Map;
},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("./Vec2");
/** A 4x4 matrix0 */
class Mat4x4 {
    constructor() {
        this.mat = new Float32Array([
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ]);
    }
    // Static members
    static get IDENTITY() {
        return new Mat4x4().identity();
    }
    static get ZERO() {
        return new Mat4x4().zero();
    }
    // Accessors
    set _00(x) {
        this.mat[0] = x;
    }
    set(col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
        }
        this.mat[row * 4 + col] = value;
        return this;
    }
    get(col, row) {
        return this.mat[row * 4 + col];
    }
    setAll(...items) {
        this.mat.set(items);
        return this;
    }
    identity() {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    zero() {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    rotate(zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    translate(translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1.default) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    }
    scale(scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1.default) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    mult(other, out) {
        let temp = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let value = 0;
                for (let k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll(...temp);
        }
        else {
            return new Mat4x4().setAll(...temp);
        }
    }
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    static MULT(...mats) {
        // Create a new array
        let temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (let i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    }
    toArray() {
        return this.mat;
    }
    toString() {
        return `|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
            `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
            `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
            `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`;
    }
}
exports.default = Mat4x4;
},{"./Vec2":29}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
class AreaCollision {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    constructor(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
}
exports.default = AreaCollision;
},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class Hit {
    constructor() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1.default.ZERO;
        /** The position of the collision */
        this.pos = Vec2_1.default.ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1.default.ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1.default.ZERO;
    }
}
exports.default = Hit;
},{"../Vec2":29}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FIFO queue with elements of type T
 */
class Queue {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    enqueue(item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    }
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    dequeue() {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        let item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    }
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    peekNext() {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        let item = this.q[this.head];
        return item;
    }
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    hasItems() {
        return this.head !== this.tail;
    }
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    getSize() {
        return this.size;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.q[index]);
        this.size = 0;
        this.head = this.tail;
    }
    // @implemented
    forEach(func) {
        let i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    }
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Queue;
},{}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A container for info about a webGL shader program */
class WebGLProgramType {
    /**
     * Deletes this shader program
     */
    delete(gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    }
}
exports.default = WebGLProgramType;
},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Shape_1 = require("./Shape");
const Vec2_1 = require("../Vec2");
const MathUtils_1 = require("../../Utils/MathUtils");
const Circle_1 = require("./Circle");
const Hit_1 = require("../Physics/Hit");
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class AABB extends Shape_1.default {
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    constructor(center, halfSize) {
        super();
        this.center = center ? center : new Vec2_1.default(0, 0);
        this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
    }
    /** Returns a point representing the top left corner of the AABB */
    get topLeft() {
        return new Vec2_1.default(this.left, this.top);
    }
    /** Returns a point representing the top right corner of the AABB */
    get topRight() {
        return new Vec2_1.default(this.right, this.top);
    }
    /** Returns a point representing the bottom left corner of the AABB */
    get bottomLeft() {
        return new Vec2_1.default(this.left, this.bottom);
    }
    /** Returns a point representing the bottom right corner of the AABB */
    get bottomRight() {
        return new Vec2_1.default(this.right, this.bottom);
    }
    // @override
    getBoundingRect() {
        return this.clone();
    }
    // @override
    getBoundingCircle() {
        let r = Math.max(this.hw, this.hh);
        return new Circle_1.default(this.center.clone(), r);
    }
    // @deprecated
    getHalfSize() {
        return this.halfSize;
    }
    // @deprecated
    setHalfSize(halfSize) {
        this.halfSize = halfSize;
    }
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return point.x >= this.x - this.hw && point.x <= this.x + this.hw
            && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    intersectPoint(point) {
        let dx = point.x - this.x;
        let px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = point.y - this.y;
        let py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPointSoft(point) {
        return point.x > this.x - this.hw && point.x <= this.x + this.hw
            && point.y > this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    intersectSegment(point, delta, padding) {
        let paddingX = padding ? padding.x : 0;
        let paddingY = padding ? padding.y : 0;
        let scaleX = 1 / delta.x;
        let scaleY = 1 / delta.y;
        let signX = MathUtils_1.default.sign(scaleX);
        let signY = MathUtils_1.default.sign(scaleY);
        let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        let tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        let tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        let hit = new Hit_1.default();
        hit.time = MathUtils_1.default.clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    }
    // @override
    overlaps(other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    }
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    overlapsAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    touchesAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    touchesAABBWithoutCorners(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    overlapArea(other) {
        let leftx = Math.max(this.x - this.hw, other.x - other.hw);
        let rightx = Math.min(this.x + this.hw, other.x + other.hw);
        let dx = rightx - leftx;
        let lefty = Math.max(this.y - this.hh, other.y - other.hh);
        let righty = Math.min(this.y + this.hh, other.y + other.hh);
        let dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    }
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    sweep(velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        let centerX = fromPosition.x + velocity.x / 2;
        let centerY = fromPosition.y + velocity.y / 2;
        let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    }
    // @override
    clone() {
        return new AABB(this.center.clone(), this.halfSize.clone());
    }
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    toString() {
        return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
    }
}
exports.default = AABB;
},{"../../Utils/MathUtils":105,"../Physics/Hit":19,"../Vec2":29,"./Circle":23,"./Shape":24}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
const Shape_1 = require("./Shape");
/**
 * A Circle
 */
class Circle extends Shape_1.default {
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    constructor(center, radius) {
        super();
        this._center = center ? center : new Vec2_1.default(0, 0);
        this.radius = radius ? radius : 0;
    }
    get center() {
        return this._center;
    }
    set center(center) {
        this._center = center;
    }
    get halfSize() {
        return new Vec2_1.default(this.radius, this.radius);
    }
    get r() {
        return this.radius;
    }
    set r(radius) {
        this.radius = radius;
    }
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    }
    // @override
    getBoundingRect() {
        return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
    }
    // @override
    getBoundingCircle() {
        return this.clone();
    }
    // @override
    overlaps(other) {
        throw new Error("Method not implemented.");
    }
    // @override
    clone() {
        return new Circle(this._center.clone(), this.radius);
    }
    toString() {
        return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
    }
}
exports.default = Circle;
},{"../Vec2":29,"./AABB":22,"./Shape":24}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
class Shape {
    get x() {
        return this.center.x;
    }
    get y() {
        return this.center.y;
    }
    get hw() {
        return this.halfSize.x;
    }
    get hh() {
        return this.halfSize.y;
    }
    get top() {
        return this.y - this.hh;
    }
    get bottom() {
        return this.y + this.hh;
    }
    get left() {
        return this.x - this.hw;
    }
    get right() {
        return this.x + this.hw;
    }
    static getTimeOfCollision(A, velA, B, velB) {
        if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    }
    static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
        let posSmaller = A.center;
        let posLarger = B.center;
        let sizeSmaller = A.halfSize;
        let sizeLarger = B.halfSize;
        let firstContact = new Vec2_1.default(0, 0);
        let lastContact = new Vec2_1.default(0, 0);
        let collidingX = false;
        let collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            let relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            let relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    }
}
exports.default = Shape;
},{"../Vec2":29,"./AABB":22}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A LIFO stack with items of type T
 */
class Stack {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    push(item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    }
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    pop() {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    }
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    peek() {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    }
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
    */
    isEmpty() {
        return this.head === -1;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.stack[index]);
        this.head = -1;
    }
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    size() {
        return this.head + 1;
    }
    // @implemented
    forEach(func) {
        let i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    }
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Stack;
},{}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = require("../../Events/Emitter");
/**
 * An abstract implementation of a state for a @reference[StateMachine].
 * This class should be extended to allow for custom state behaviors.
 */
class State {
    /**
     * Constructs a new State
     * @param parent The parent StateMachine of this state
     */
    constructor(parent) {
        this.parent = parent;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Tells the state machine that this state has ended, and makes it transition to the new state specified
     * @param stateName The name of the state to transition to
     */
    finished(stateName) {
        this.parent.changeState(stateName);
    }
}
exports.default = State;
},{"../../Events/Emitter":32}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../Stack");
const Map_1 = require("../Map");
const Receiver_1 = require("../../Events/Receiver");
const Emitter_1 = require("../../Events/Emitter");
/**
 * An implementation of a Push Down Automata State machine. States can also be hierarchical
 * for more flexibility, as described in @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/state.html).
 */
class StateMachine {
    /**
     * Creates a new StateMachine
     */
    constructor() {
        this.stack = new Stack_1.default();
        this.stateMap = new Map_1.default();
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.emitEventOnStateChange = false;
    }
    /**
     * Sets the activity state of this state machine
     * @param flag True if you want to set this machine running, false otherwise
     */
    setActive(flag) {
        this.active = flag;
    }
    /**
     * Makes this state machine emit an event any time its state changes
     * @param stateChangeEventName The name of the event to emit
     */
    setEmitEventOnStateChange(stateChangeEventName) {
        this.emitEventOnStateChange = true;
        this.stateChangeEventName = stateChangeEventName;
    }
    /**
     * Stops this state machine from emitting events on state change.
     */
    cancelEmitEventOnStateChange() {
        this.emitEventOnStateChange = false;
    }
    /**
     * Initializes this state machine with an initial state and sets it running
     * @param initialState The name of initial state of the state machine
     */
    initialize(initialState, options = {}) {
        this.stack.push(this.stateMap.get(initialState));
        this.currentState = this.stack.peek();
        this.currentState.onEnter(options);
        this.setActive(true);
    }
    /**
     * Adds a state to this state machine
     * @param stateName The name of the state to add
     * @param state The state to add
     */
    addState(stateName, state) {
        this.stateMap.add(stateName, state);
    }
    /**
     * Changes the state of this state machine to the provided string
     * @param state The string name of the state to change to
     */
    changeState(state) {
        // Exit the current state
        let options = this.currentState.onExit();
        // Make sure the correct state is at the top of the stack
        if (state === "previous") {
            // Pop the current state off the stack
            this.stack.pop();
        }
        else {
            // Retrieve the new state from the statemap and put it at the top of the stack
            this.stack.pop();
            this.stack.push(this.stateMap.get(state));
        }
        // Retreive the new state from the stack
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
        }
        // Enter the new state
        this.currentState.onEnter(options);
    }
    /**
     * Handles input. This happens at the very beginning of this state machine's update cycle.
     * @param event The game event to process
     */
    handleEvent(event) {
        if (this.active) {
            this.currentState.handleInput(event);
        }
    }
    // @implemented
    update(deltaT) {
        // Distribute events
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            this.handleEvent(event);
        }
        // Delegate the update to the current state
        this.currentState.update(deltaT);
    }
}
exports.default = StateMachine;
},{"../../Events/Emitter":32,"../../Events/Receiver":36,"../Map":16,"../Stack":25}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../Vec2");
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
class Tileset {
    // TODO: Change this to be more general and work with other tileset formats
    constructor(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    initFromTiledData(tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
    }
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    getImageKey() {
        return this.imageKey;
    }
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    getImageOffsetForTile(tileIndex) {
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        return new Vec2_1.default(left, top);
    }
    /**
     * Gets the start index
     * @returns The start index
     */
    getStartIndex() {
        return this.startIndex;
    }
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    getNumRows() {
        return this.numRows;
    }
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    getNumCols() {
        return this.numCols;
    }
    getTileCount() {
        return this.endIndex - this.startIndex + 1;
    }
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    hasTile(tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    }
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor((dataIndex % maxCols) * width * scale.x);
        let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    }
}
exports.default = Tileset;
},{"../../ResourceManager/ResourceManager":86,"../Vec2":29}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A two-dimensional vector (x, y)
 */
class Vec2 {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    constructor(x = 0, y = 0) {
        /**
         * When this vector changes its value, do something
         */
        this.onChange = () => { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    // Expose x and y with getters and setters
    get x() {
        return this.vec[0];
    }
    set x(x) {
        this.vec[0] = x;
        if (this.onChange) {
            this.onChange();
        }
    }
    get y() {
        return this.vec[1];
    }
    set y(y) {
        this.vec[1] = y;
        if (this.onChange) {
            this.onChange();
        }
    }
    static get ZERO() {
        return new Vec2(0, 0);
    }
    static get INF() {
        return new Vec2(Infinity, Infinity);
    }
    static get UP() {
        return new Vec2(0, -1);
    }
    static get DOWN() {
        return new Vec2(0, 1);
    }
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    magSq() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    normalize() {
        if (this.x === 0 && this.y === 0)
            return this;
        let mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    }
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    normalized() {
        if (this.isZero()) {
            return this;
        }
        let mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    }
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    zero() {
        return this.set(0, 0);
    }
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    setToAngle(angle, radius = 1) {
        this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    }
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    vecTo(other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    }
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    dirTo(other) {
        return this.vecTo(other).normalize();
    }
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    scaleTo(magnitude) {
        return this.normalize().scale(magnitude);
    }
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    scale(factor, yFactor = null) {
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    scaled(factor, yFactor = null) {
        return this.clone().scale(factor, yFactor);
    }
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    rotateCCW(angle) {
        let cs = Math.cos(angle);
        let sn = Math.sin(angle);
        let tempX = this.x * cs - this.y * sn;
        let tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    }
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    copy(other) {
        return this.set(other.x, other.y);
    }
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    inc(a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    }
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    mult(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    div(other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    remainder(other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    }
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    distanceSqTo(other) {
        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
    }
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    distanceTo(other) {
        return Math.sqrt(this.distanceSqTo(other));
    }
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    angleToCCW(other) {
        let dot = this.dot(other);
        let det = this.x * other.y - this.y * other.x;
        let angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    }
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    toString() {
        return this.toFixed();
    }
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    toFixed(numDecimalPoints = 1) {
        return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
    }
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    strictEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    equals(other) {
        let xEq = Math.abs(this.x - other.x) < 0.0000001;
        let yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    }
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    strictIsZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    isZero() {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    }
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    setOnChange(f) {
        this.onChange = f;
    }
    toArray() {
        return this.vec;
    }
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    static lerp(a, b, t) {
        return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
    }
}
exports.default = Vec2;
Vec2.ZERO_STATIC = new Vec2(0, 0);
},{"../Utils/MathUtils":105}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const Color_1 = require("../Utils/Color");
/**
 * A util class for rendering Debug messages to the canvas.
 */
class Debug {
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    static log(id, ...messages) {
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        let message = messages.map((m) => m.toString()).join(" ");
        this.logMessages.add(id, message);
    }
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    static clearLogItem(id) {
        this.logMessages.delete(id);
    }
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    static setNodes(nodes) {
        this.nodes = nodes;
    }
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    static drawBox(center, halfSize, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    static drawCircle(center, radius, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    static drawRay(from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    }
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    static drawPoint(pos, color) {
        let pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    }
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    static setDefaultTextColor(color) {
        this.defaultTextColor = color;
    }
    /**
     * Performs any necessary setup operations on the Debug canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    static initializeDebugCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1.default(width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    }
    /** Clears the debug canvas */
    static clearCanvas() {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    }
    /** Renders the text and nodes sent to the Debug system */
    static render() {
        this.renderText();
        this.renderNodes();
    }
    /** Renders the text sent to the Debug canvas */
    static renderText() {
        let y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach((key) => {
            this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
            y += 30;
        });
    }
    /** Renders the nodes registered with the debug canvas */
    static renderNodes() {
        if (this.nodes) {
            this.nodes.forEach(node => {
                node.debugRender();
            });
        }
    }
}
exports.default = Debug;
/** A map of log messages to display on the screen */
Debug.logMessages = new Map_1.default();
/** The rendering color for text */
Debug.defaultTextColor = Color_1.default.WHITE;
},{"../DataTypes/Map":16,"../DataTypes/Vec2":29,"../Utils/Color":102}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../Utils/Color");
// @ignorePage
class Stats extends Object {
    static initStats() {
        let canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        let clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        let fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        let updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        let queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        let br1 = document.createElement("br");
        let br2 = document.createElement("br");
        let br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = document.getElementById("chart-option");
        let option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        let option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        let option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        let option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        let option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        let optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    }
    static updateFPS(fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    }
    static log(key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    }
    static render() {
        // Display stats
        this.drawCharts();
    }
    static drawCharts() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        let paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            let param = this.prevfps;
            let color = Color_1.default.BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            let param = this.prevClearTimes;
            let color = Color_1.default.RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            let param = this.prevFillTimes;
            let color = Color_1.default.GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            let param = this.prevUpdateTimes;
            let color = Color_1.default.CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            let param = this.prevQueryTimes;
            let color = Color_1.default.ORANGE.toString();
            this.drawChart(param, color);
        }
    }
    static drawChart(param, color) {
        this.ctx.strokeStyle = Color_1.default.BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        let max = Math.max(...param);
        let prevX = 10;
        let prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (let i = 1; i < param.length; i++) {
            let fps = param[i];
            let x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
            let y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    }
    static updateSGStats() {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime = this.SGClearTimes.reduce((acc, val) => acc + val) / this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime = this.SGFillTimes.reduce((acc, val) => acc + val) / this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime = this.SGUpdateTimes.reduce((acc, val) => acc + val) / this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime = this.SGQueryTimes.reduce((acc, val) => acc + val) / this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
    }
}
exports.default = Stats;
Stats.NUM_POINTS = 60;
Stats.CANVAS_WIDTH = 300;
Stats.CANVAS_HEIGHT = 300;
},{"../Utils/Color":102}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("./EventQueue");
const GameEvent_1 = require("./GameEvent");
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
class Emitter {
    /** Creates a new Emitter */
    constructor() {
        this.eventQueue = EventQueue_1.default.getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    fireEvent(eventType, data = null) {
        this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
    }
}
exports.default = Emitter;
},{"./EventQueue":33,"./GameEvent":34}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Map_1 = require("../DataTypes/Map");
const GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
class EventQueue {
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
        this.receivers = new Map_1.default();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    static getInstance() {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    }
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    addEvent(event) {
        this.q.enqueue(event);
    }
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    subscribe(receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (let t of type) {
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    }
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    unsubscribe(receiver, ...events) {
        this.receivers.forEach(eventName => {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            let index = this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                this.receivers.get(eventName).splice(index, 1);
            }
        });
    }
    // Associate the receiver and the type
    addListener(receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    }
    update(deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            let event = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event.type)) {
                for (let receiver of this.receivers.get(event.type)) {
                    receiver.receive(event);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                    receiver.receive(event);
                }
            }
        }
    }
}
exports.default = EventQueue;
EventQueue.instance = null;
},{"../DataTypes/Map":16,"../DataTypes/Queue":20,"./GameEventType":35}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
class GameEvent {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    constructor(type, data = null) {
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1.default();
        }
        else if (!(data instanceof Map_1.default)) {
            // data is a raw object, unpack
            this.data = new Map_1.default();
            for (let key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    isType(type) {
        return this.type === type;
    }
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    toString() {
        return this.type + ": @" + this.time;
    }
}
exports.default = GameEvent;
},{"../DataTypes/Map":16}],35:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));
},{}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const EventQueue_1 = require("./EventQueue");
/**
 * Receives subscribed events from the EventQueue.
 */
class Receiver {
    /** Creates a new Receiver */
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
    }
    destroy() {
        EventQueue_1.default.getInstance().unsubscribe(this);
    }
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    subscribe(eventTypes) {
        EventQueue_1.default.getInstance().subscribe(this, eventTypes);
        this.q.clear();
    }
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    receive(event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    }
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    getNextEvent() {
        return this.q.dequeue();
    }
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    peekNextEvent() {
        return this.q.peekNext();
    }
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    hasNextEvent() {
        return this.q.hasItems();
    }
    /**
     * Ignore all events this frame
     */
    ignoreEvents() {
        this.q.clear();
    }
}
exports.default = Receiver;
},{"../DataTypes/Queue":20,"./EventQueue":33}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
class Input {
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     */
    static initialize(viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1.default();
        Input.keyJustPressed = new Map_1.default();
        Input.keyPressed = new Map_1.default();
        Input.mousePosition = new Vec2_1.default(0, 0);
        Input.mousePressPosition = new Vec2_1.default(0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1.default();
        // Add all keys to the keymap
        for (let entry in keyMap) {
            let name = keyMap[entry].name;
            let keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
        Input.eventQueue = EventQueue_1.default.getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
    }
    static update(deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            let event = Input.receiver.getNextEvent();
            // Handle each event type
            if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    }
    static clearKeyPresses() {
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
    }
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    static isKeyJustPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    static getKeysJustPressed() {
        if (Input.keysDisabled)
            return [];
        let keys = Array();
        Input.keyJustPressed.forEach(key => {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    static isKeyPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    static changeKeyBinding(inputName, keys) {
        Input.keyMap.set(inputName, keys);
    }
    /**
     * Clears all key bindings
     */
    static clearAllKeyBindings() {
        Input.keyMap.clear();
    }
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    static isJustPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let justPressed = false;
            for (let key of keys) {
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    static isPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let pressed = false;
            for (let key of keys) {
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not the mouse was newly pressed Input frame
     * @returns True if the mouse was just pressed, false otherwise
     */
    static isMouseJustPressed() {
        return Input.mouseJustPressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether or not the mouse is currently pressed
     * @returns True if the mouse is currently pressed, false otherwise
     */
    static isMousePressed() {
        return Input.mousePressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    static didJustScroll() {
        return Input.justScrolled && !Input.mouseDisabled;
    }
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    static getScrollDirection() {
        return Input.scrollDirection;
    }
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    static getMousePosition() {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    }
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePosition() {
        return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
    }
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    static getMousePressPosition() {
        return Input.mousePressPosition;
    }
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePressPosition() {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    }
    /**
     * Disables all keypress and mouse click inputs
     */
    static disableInput() {
        Input.keysDisabled = true;
        Input.mouseDisabled = true;
    }
    /**
     * Enables all keypress and mouse click inputs
     */
    static enableInput() {
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
    }
}
exports.default = Input;
},{"../DataTypes/Map":16,"../DataTypes/Vec2":29,"../Events/EventQueue":33,"../Events/GameEventType":35,"../Events/Receiver":36}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Vec2_1 = require("../DataTypes/Vec2");
const GameEvent_1 = require("../Events/GameEvent");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
class InputHandler {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    constructor(canvas) {
        this.handleMouseDown = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = (event) => {
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = (event) => {
            event.preventDefault();
            event.stopPropagation();
            let gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1.default.getInstance();
        canvas.onmousedown = (event) => this.handleMouseDown(event, canvas);
        canvas.onmouseup = (event) => this.handleMouseUp(event, canvas);
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = (event) => this.handleMouseMove(event, canvas);
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
    }
    getKey(keyEvent) {
        return keyEvent.key.toLowerCase();
    }
    getMousePosition(mouseEvent, canvas) {
        let rect = canvas.getBoundingClientRect();
        let x = mouseEvent.clientX - rect.left;
        let y = mouseEvent.clientY - rect.top;
        return new Vec2_1.default(x, y);
    }
}
exports.default = InputHandler;
},{"../DataTypes/Vec2":29,"../Events/EventQueue":33,"../Events/GameEvent":34,"../Events/GameEventType":35}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
class EnvironmentInitializer {
    static setup() {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    }
}
exports.default = EnvironmentInitializer;
},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLoop_1 = require("./GameLoop");
const Debug_1 = require("../Debug/Debug");
const Stats_1 = require("../Debug/Stats");
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
class FixedUpdateGameLoop extends GameLoop_1.default {
    constructor() {
        super();
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        this.doFrame = (timestamp) => {
            // If a pause was executed, stop doing the loop.
            if (this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame((t) => this.doFrame(t));
            // If we are trying to render too soon, do nothing.
            if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            this.numUpdateSteps = 0;
            let panic = false;
            while (this.frameDelta >= this.updateTimestep) {
                // Do an update
                this._doUpdate(this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                this.frameDelta -= this.updateTimestep;
                // Increment steps and check if we've done too many
                this.numUpdateSteps++;
                if (this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            this._doRender();
            // Wrap up the frame
            this.finishFrame(panic);
        };
        this.maxUpdateFPS = 60;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        this.frameDelta = 0;
        this.lastFrameTime = 0;
        this.minFrameDelay = 0;
        this.frame = 0;
        this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = 0;
        this.framesSinceLastFpsUpdate = 0;
        this.started = false;
        this.paused = false;
        this.running = false;
        this.numUpdateSteps = 0;
    }
    getFPS() {
        return 0;
    }
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    updateFPS(timestamp) {
        this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1.default.updateFPS(this.fps);
    }
    /**
 * Changes the maximum allowed physics framerate of the game
 * @param initMax The max framerate
 */
    setMaxUpdateFPS(initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    }
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    setMaxFPS(maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    }
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    resetFrameDelta() {
        let oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    }
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    start() {
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame((timestamp) => this.doFirstFrame(timestamp));
        }
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    doFirstFrame(timestamp) {
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame((t) => this.doFrame(t));
    }
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    startFrame(timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    }
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    finishFrame(panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
}
exports.default = FixedUpdateGameLoop;
},{"../Debug/Debug":30,"../Debug/Stats":31,"./GameLoop":42}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Input_1 = require("../Input/Input");
const InputHandler_1 = require("../Input/InputHandler");
const Recorder_1 = require("../Playback/Recorder");
const Debug_1 = require("../Debug/Debug");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Viewport_1 = require("../SceneGraph/Viewport");
const SceneManager_1 = require("../Scene/SceneManager");
const AudioManager_1 = require("../Sound/AudioManager");
const Stats_1 = require("../Debug/Stats");
const CanvasRenderer_1 = require("../Rendering/CanvasRenderer");
const Color_1 = require("../Utils/Color");
const GameOptions_1 = require("./GameOptions");
const FixedUpdateGameLoop_1 = require("./FixedUpdateGameLoop");
const EnvironmentInitializer_1 = require("./EnvironmentInitializer");
const Vec2_1 = require("../DataTypes/Vec2");
const RegistryManager_1 = require("../Registry/RegistryManager");
const WebGLRenderer_1 = require("../Rendering/WebGLRenderer");
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
class Game {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    constructor(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1.default.setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1.default.parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1.default();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = document.getElementById("game-canvas");
        this.DEBUG_CANVAS = document.getElementById("debug-canvas");
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1.default();
        }
        else {
            this.renderingManager = new CanvasRenderer_1.default();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1.default.initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1.default.getInstance();
        this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
        Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
        this.recorder = new Recorder_1.default();
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1.default.getInstance();
    }
    /**
     * Set up the game window that holds the canvases
     */
    initializeGameWindow() {
        const gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    }
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    getSceneManager() {
        return this.sceneManager;
    }
    /**
     * Starts the game
     */
    start(InitialScene, options) {
        // Set the update function of the loop
        this.loop.doUpdate = (deltaT) => this.update(deltaT);
        // Set the render function of the loop
        this.loop.doRender = () => this.render();
        // Preload registry items
        RegistryManager_1.default.preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(() => {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            this.sceneManager.changeToScene(InitialScene, options);
            this.loop.start();
        });
    }
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    update(deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1.default.update(deltaT);
            // Update the recording of the game
            this.recorder.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    }
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    render() {
        try {
            // Clear the canvases
            Debug_1.default.clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1.default.isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug render
            if (this.showDebug) {
                Debug_1.default.render();
            }
            if (this.showStats) {
                Stats_1.default.render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    }
}
exports.default = Game;
},{"../DataTypes/Vec2":29,"../Debug/Debug":30,"../Debug/Stats":31,"../Events/EventQueue":33,"../Input/Input":37,"../Input/InputHandler":38,"../Playback/Recorder":66,"../Registry/RegistryManager":69,"../Rendering/CanvasRenderer":74,"../Rendering/WebGLRenderer":79,"../ResourceManager/ResourceManager":86,"../Scene/SceneManager":97,"../SceneGraph/Viewport":89,"../Sound/AudioManager":99,"../Utils/Color":102,"./EnvironmentInitializer":39,"./FixedUpdateGameLoop":40,"./GameOptions":43}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NullFunc_1 = require("../DataTypes/Functions/NullFunc");
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
class GameLoop {
    constructor() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1.default;
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1.default;
    }
    set doUpdate(update) {
        this._doUpdate = update;
    }
    set doRender(render) {
        this._doRender = render;
    }
}
exports.default = GameLoop;
},{"../DataTypes/Functions/NullFunc":11}],43:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/** The options for initializing the @reference[GameLoop] */
class GameOptions {
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    static parse(options) {
        let gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    }
}
exports.default = GameOptions;
},{}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameNode_1 = require("./GameNode");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
class CanvasNode extends GameNode_1.default {
    constructor() {
        super();
        /** A flag for whether or not the CanvasNode is visible */
        this.visible = true;
        this._size = new Vec2_1.default(0, 0);
        this._size.setOnChange(() => this.sizeChanged());
        this._scale = new Vec2_1.default(1, 1);
        this._scale.setOnChange(() => this.scaleChanged());
        this._boundary = new AABB_1.default();
        this.updateBoundary();
        this._hasCustomShader = false;
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(a) {
        this._alpha = a;
    }
    get size() {
        return this._size;
    }
    set size(size) {
        this._size = size;
        // Enter as a lambda to bind "this"
        this._size.setOnChange(() => this.sizeChanged());
        this.sizeChanged();
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this._scale = scale;
        // Enter as a lambda to bind "this"
        this._scale.setOnChange(() => this.scaleChanged());
        this.scaleChanged();
    }
    set scaleX(value) {
        this.scale.x = value;
    }
    set scaleY(value) {
        this.scale.y = value;
    }
    get hasCustomShader() {
        return this._hasCustomShader;
    }
    get customShaderKey() {
        return this._customShaderKey;
    }
    // @override
    positionChanged() {
        super.positionChanged();
        this.updateBoundary();
    }
    /** Called if the size vector is changed or replaced. */
    sizeChanged() {
        this.updateBoundary();
    }
    /** Called if the scale vector is changed or replaced */
    scaleChanged() {
        this.updateBoundary();
    }
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    updateBoundary() {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
    }
    get boundary() {
        return this._boundary;
    }
    get sizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.boundary.halfSize.clone().scaled(zoom, zoom);
    }
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    useCustomShader(key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    }
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    contains(x, y) {
        return this._boundary.containsPoint(new Vec2_1.default(x, y));
    }
    // @implemented
    debugRender() {
        Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
        super.debugRender();
    }
}
exports.default = CanvasNode;
},{"../DataTypes/Shapes/AABB":22,"../DataTypes/Vec2":29,"../Debug/Debug":30,"../Utils/Color":102,"./GameNode":45}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenableProperties = void 0;
const Vec2_1 = require("../DataTypes/Vec2");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Region_1 = require("../DataTypes/Interfaces/Region");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const TweenController_1 = require("../Rendering/Animations/TweenController");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
const Circle_1 = require("../DataTypes/Shapes/Circle");
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
class GameNode {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    constructor() {
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1.default(0, 0);
        this._position.setOnChange(() => this.positionChanged());
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tweens = new TweenController_1.default(this);
        this.rotation = 0;
    }
    destroy() {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    }
    /*---------- POSITIONED ----------*/
    get position() {
        return this._position;
    }
    set position(pos) {
        this._position = pos;
        this._position.setOnChange(() => this.positionChanged());
        this.positionChanged();
    }
    get relativePosition() {
        return this.inRelativeCoordinates(this.position);
    }
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    inRelativeCoordinates(point) {
        let origin = this.scene.getViewTranslation(this);
        let zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    }
    /*---------- UNIQUE ----------*/
    get id() {
        return this._id;
    }
    set id(id) {
        // id can only be set once
        if (this._id === undefined) {
            this._id = id;
        }
        else {
            throw "Attempted to assign id to object that already has id.";
        }
    }
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    move(velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    }
    ;
    moveOnPath(speed, path) {
        if (this.frozen)
            return;
        this.path = path;
        let dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    }
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    finishMove() {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    }
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = new AABB_1.default();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if (Region_1.isRegion(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1.default.ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    }
    /** Removes this object from the physics system */
    removePhysics() {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1.default.ZERO;
        this.sweptRect = null;
    }
    /** Disables physics movement for this node */
    freeze() {
        this.frozen = true;
    }
    /** Reenables physics movement for this node */
    unfreeze() {
        this.frozen = false;
    }
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    disablePhysics() {
        this.active = false;
    }
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    enablePhysics() {
        this.active = true;
    }
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    setCollisionShape(collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    }
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    setTrigger(group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        let index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    }
    ;
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    setGroup(group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    }
    // @implemened
    getLastVelocity() {
        return this._velocity;
    }
    /*---------- ACTOR ----------*/
    get ai() {
        return this._ai;
    }
    set ai(ai) {
        if (!this._ai) {
            // If we haven't been previously had an ai, register us with the ai manager
            this.scene.getAIManager().registerActor(this);
        }
        this._ai = ai;
        this.aiActive = true;
    }
    // @implemented
    addAI(ai, options) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    }
    // @implemented
    setAIActive(active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    }
    /*---------- TWEENABLE PROPERTIES ----------*/
    set positionX(value) {
        this.position.x = value;
    }
    set positionY(value) {
        this.position.y = value;
    }
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
    */
    getScene() {
        return this.scene;
    }
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    setLayer(layer) {
        this.layer = layer;
    }
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
    */
    getLayer() {
        return this.layer;
    }
    /** Called if the position vector is modified or replaced */
    positionChanged() {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position.clone().add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    }
    ;
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    update(deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    }
    // @implemented
    debugRender() {
        // Draw the position of this GameNode
        Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
            if (this.isTrigger) {
                color = Color_1.default.MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1.default) {
                Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1.default) {
                Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    }
}
exports.default = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));
},{"../DataTypes/Interfaces/Region":15,"../DataTypes/Shapes/AABB":22,"../DataTypes/Shapes/Circle":23,"../DataTypes/Vec2":29,"../Debug/Debug":30,"../Events/Emitter":32,"../Events/Receiver":36,"../Rendering/Animations/TweenController":72,"../Utils/Color":102}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
class Graphic extends CanvasNode_1.default {
    constructor() {
        super();
        this.color = Color_1.default.RED;
    }
    get alpha() {
        return this.color.a;
    }
    set alpha(a) {
        this.color.a = a;
    }
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    setColor(color) {
        this.color = color;
    }
}
exports.default = Graphic;
},{"../Utils/Color":102,"./CanvasNode":44}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));
},{}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
class Line extends Graphic_1.default {
    constructor(start, end) {
        super();
        this.start = start;
        this.end = end;
        this.thickness = 2;
        // Does this really have a meaning for lines?
        this.size.set(5, 5);
    }
    set start(pos) {
        this.position = pos;
    }
    get start() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
}
exports.default = Line;
},{"../Graphic":46}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
/** A basic point to be drawn on the screen. */
class Point extends Graphic_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.size.set(5, 5);
    }
}
exports.default = Point;
},{"../Graphic":46}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
const Color_1 = require("../../Utils/Color");
/** A basic rectangle to be drawn on the screen. */
class Rect extends Graphic_1.default {
    constructor(position, size) {
        super();
        this.position = position;
        this.size = size;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = Rect;
},{"../../Utils/Color":102,"../Graphic":46}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("./Sprite");
const AnimationManager_1 = require("../../Rendering/Animations/AnimationManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/** An sprite with specified animation frames. */
class AnimatedSprite extends Sprite_1.default {
    constructor(spritesheet) {
        super(spritesheet.name);
        this.numCols = spritesheet.columns;
        this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        this.animation = new AnimationManager_1.default(this);
        // Add the animations to the animated sprite
        for (let animation of spritesheet.animations) {
            this.animation.add(animation.name, animation);
        }
    }
    get cols() {
        return this.numCols;
    }
    get rows() {
        return this.numRows;
    }
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    getAnimationOffset(index) {
        return new Vec2_1.default((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
    }
}
exports.default = AnimatedSprite;
},{"../../DataTypes/Vec2":29,"../../Rendering/Animations/AnimationManager":70,"./Sprite":52}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("../CanvasNode");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * The representation of a sprite - an in-game image
 */
class Sprite extends CanvasNode_1.default {
    constructor(imageId) {
        super();
        this.imageId = imageId;
        let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
        this.size = new Vec2_1.default(image.width, image.height);
        this.imageOffset = Vec2_1.default.ZERO;
        this.invertX = false;
        this.invertY = false;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    setImageOffset(offset) {
        this.imageOffset = offset;
    }
}
exports.default = Sprite;
},{"../../DataTypes/Vec2":29,"../../ResourceManager/ResourceManager":86,"../CanvasNode":44}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const CanvasNode_1 = require("./CanvasNode");
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
class Tilemap extends CanvasNode_1.default {
    // TODO: Make this no longer be specific to Tiled
    constructor(tilemapData, layer, tilesets, scale) {
        super();
        this.tilesets = tilesets;
        this.tileSize = new Vec2_1.default(0, 0);
        this.name = layer.name;
        let tilecount = 0;
        for (let tileset of tilesets) {
            tilecount += tileset.getTileCount() + 1;
        }
        this.collisionMap = new Array(tilecount);
        for (let i = 0; i < this.collisionMap.length; i++) {
            this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        this.parseTilemapData(tilemapData, layer);
        this.scale.set(scale.x, scale.y);
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    getTilesets() {
        return this.tilesets;
    }
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    getTileSize() {
        return this.tileSize.scaled(this.scale.x, this.scale.y);
    }
    /**
     * Gets the tile size taking zoom into account
     * @returns The tile size with zoom
    */
    getTileSizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.getTileSize().scale(zoom);
    }
    /**
     * Adds this tilemap to the physics system
    */
    addPhysics() {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    }
}
exports.default = Tilemap;
},{"../DataTypes/Vec2":29,"./CanvasNode":44}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Tilemap_1 = require("../Tilemap");
const Vec2_1 = require("../../DataTypes/Vec2");
const Debug_1 = require("../../Debug/Debug");
const Color_1 = require("../../Utils/Color");
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
class OrthogonalTilemap extends Tilemap_1.default {
    // @override
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    getDimensions() {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    /**
     * Gets the data value of the tile at the specified world position
     * @param worldCoords The coordinates in world space
     * @returns The data value of the tile
     */
    getTileAtWorldPosition(worldCoords) {
        let localCoords = this.getColRowAt(worldCoords);
        return this.getTileAtRowCol(localCoords);
    }
    /**
     * Get the tile at the specified row and column
     * @param rowCol The coordinates in tilemap space
     * @returns The data value of the tile
     */
    getTileAtRowCol(rowCol) {
        if (rowCol.x < 0 || rowCol.x >= this.numCols || rowCol.y < 0 || rowCol.y >= this.numRows) {
            return -1;
        }
        return this.data[rowCol.y * this.numCols + rowCol.x];
    }
    /**
     * Gets the world position of the tile at the specified index
     * @param index The index of the tile
     * @returns A Vec2 containing the world position of the tile
     */
    getTileWorldPosition(index) {
        // Get the local position
        let col = index % this.numCols;
        let row = Math.floor(index / this.numCols);
        // Get the world position
        let x = col * this.tileSize.x;
        let y = row * this.tileSize.y;
        return new Vec2_1.default(x, y);
    }
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    getTile(index) {
        return this.data[index];
    }
    // @override
    setTile(index, type) {
        this.data[index] = type;
    }
    /**
     * Sets the tile at the specified row and column
     * @param rowCol The position of the tile in tilemap space
     * @param type The new data value of the tile
     */
    setTileAtRowCol(rowCol, type) {
        let index = rowCol.y * this.numCols + rowCol.x;
        this.setTile(index, type);
    }
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param indexOrCol The index of the tile or the column it is in
     * @param row The row the tile is in
     * @returns A flag representing whether or not the tile is collidable.
     */
    isTileCollidable(indexOrCol, row) {
        // The value of the tile
        let tile = 0;
        if (row) {
            // We have a column and a row
            tile = this.getTileAtRowCol(new Vec2_1.default(indexOrCol, row));
            if (tile < 0) {
                return false;
            }
        }
        else {
            if (indexOrCol < 0 || indexOrCol >= this.data.length) {
                // Tiles that don't exist aren't collidable
                return false;
            }
            // We have an index
            tile = this.getTile(indexOrCol);
        }
        return this.collisionMap[tile];
    }
    /**
     * Takes in world coordinates and returns the row and column of the tile at that position
     * @param worldCoords The coordinates of the potential tile in world space
     * @returns A Vec2 containing the coordinates of the potential tile in tilemap space
     */
    getColRowAt(worldCoords) {
        let col = Math.floor(worldCoords.x / this.tileSize.x / this.scale.x);
        let row = Math.floor(worldCoords.y / this.tileSize.y / this.scale.y);
        return new Vec2_1.default(col, row);
    }
    // @override
    update(deltaT) { }
    // @override
    debugRender() {
        // Half of the tile size
        let zoomedHalfTileSize = this.getTileSizeWithZoom().scaled(0.5);
        let halfTileSize = this.getTileSize().scaled(0.5);
        // The center of the top left tile
        let topLeft = this.position.clone().sub(this.size.scaled(0.5));
        // A vec to store the center
        let center = Vec2_1.default.ZERO;
        for (let col = 0; col < this.numCols; col++) {
            // Calculate the x-position
            center.x = topLeft.x + col * 2 * halfTileSize.x + halfTileSize.x;
            for (let row = 0; row < this.numRows; row++) {
                if (this.isCollidable && this.isTileCollidable(col, row)) {
                    // Calculate the y-position
                    center.y = topLeft.y + row * 2 * halfTileSize.y + halfTileSize.y;
                    // Draw a box for this tile
                    Debug_1.default.drawBox(this.inRelativeCoordinates(center), zoomedHalfTileSize, false, Color_1.default.BLUE);
                }
            }
        }
    }
}
exports.default = OrthogonalTilemap;
},{"../../DataTypes/Vec2":29,"../../Debug/Debug":30,"../../Utils/Color":102,"../Tilemap":53}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
const Vec2_1 = require("../DataTypes/Vec2");
const Input_1 = require("../Input/Input");
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
class UIElement extends CanvasNode_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.backgroundColor = new Color_1.default(0, 0, 0, 0);
        this.borderColor = new Color_1.default(0, 0, 0, 0);
        this.borderRadius = 5;
        this.borderWidth = 1;
        this.padding = Vec2_1.default.ZERO;
        this.onClick = null;
        this.onClickEventId = null;
        this.onRelease = null;
        this.onReleaseEventId = null;
        this.onEnter = null;
        this.onEnterEventId = null;
        this.onLeave = null;
        this.onLeaveEventId = null;
        this.isClicked = false;
        this.isEntered = false;
    }
    // @deprecated
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    // @deprecated
    setPadding(padding) {
        this.padding.copy(padding);
    }
    update(deltaT) {
        super.update(deltaT);
        // See of this object was just clicked
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1.default.isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        let mousePos = Input_1.default.getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    }
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    calculateBackgroundColor() {
        return this.backgroundColor;
    }
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    calculateBorderColor() {
        return this.borderColor;
    }
}
exports.default = UIElement;
},{"../DataTypes/Vec2":29,"../Input/Input":37,"../Utils/Color":102,"./CanvasNode":44}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Label_1 = require("./Label");
const Color_1 = require("../../Utils/Color");
/** A clickable button UIElement */
class Button extends Label_1.default {
    constructor(position, text) {
        super(position, text);
        this.backgroundColor = new Color_1.default(150, 75, 203);
        this.borderColor = new Color_1.default(41, 46, 30);
        this.textColor = new Color_1.default(255, 255, 255);
    }
    // @override
    calculateBackgroundColor() {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    }
}
exports.default = Button;
},{"../../Utils/Color":102,"./Label":57}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAlign = exports.VAlign = void 0;
const Vec2_1 = require("../../DataTypes/Vec2");
const Color_1 = require("../../Utils/Color");
const UIElement_1 = require("../UIElement");
/** A basic text-containing label */
class Label extends UIElement_1.default {
    constructor(position, text) {
        super(position);
        this.text = text;
        this.textColor = new Color_1.default(0, 0, 0, 1);
        this.font = "Arial";
        this.fontSize = 30;
        this.hAlign = "center";
        this.vAlign = "center";
        this.sizeAssigned = false;
    }
    // @deprecated
    setText(text) {
        this.text = text;
    }
    // @deprecated
    setTextColor(color) {
        this.textColor = color;
    }
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    getFontString() {
        return this.fontSize + "px " + this.font;
    }
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    calculateTextColor() {
        return this.textColor.toStringRGBA();
    }
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    calculateTextWidth(ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    }
    setHAlign(align) {
        this.hAlign = align;
    }
    setVAlign(align) {
        this.vAlign = align;
    }
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    calculateTextOffset(ctx) {
        let textWidth = this.calculateTextWidth(ctx);
        let offset = new Vec2_1.default(0, 0);
        let hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    }
    sizeChanged() {
        super.sizeChanged();
        this.sizeAssigned = true;
    }
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    autoSize(ctx) {
        let width = this.calculateTextWidth(ctx);
        let height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    }
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    handleInitialSizing(ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    }
    /** On the next render, size this element to it's current text using its current font size */
    sizeToText() {
        this.sizeAssigned = false;
    }
}
exports.default = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));
},{"../../DataTypes/Vec2":29,"../../Utils/Color":102,"../UIElement":55}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const Input_1 = require("../../Input/Input");
const Color_1 = require("../../Utils/Color");
const MathUtils_1 = require("../../Utils/MathUtils");
const UIElement_1 = require("../UIElement");
/** A slider UIElement */
class Slider extends UIElement_1.default {
    constructor(position, initValue) {
        super(position);
        this.value = initValue;
        this.nibColor = Color_1.default.RED;
        this.sliderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.TRANSPARENT;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.nibSize = new Vec2_1.default(10, 20);
        // Set a default size
        this.size.set(200, 20);
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    getValue() {
        return this.value;
    }
    /** A method called in response to the value changing */
    valueChanged() {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.isClicked) {
            let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
            this.value = MathUtils_1.default.clamp01(val);
            this.valueChanged();
        }
    }
}
exports.default = Slider;
},{"../../DataTypes/Vec2":29,"../../Input/Input":37,"../../Utils/Color":102,"../../Utils/MathUtils":105,"../UIElement":55}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../../Utils/Color");
const Label_1 = require("./Label");
const Input_1 = require("../../Input/Input");
/** A text input UIElement */
class TextInput extends Label_1.default {
    constructor(position) {
        super(position, "");
        this.focused = false;
        this.cursorCounter = 0;
        // Give a default size to the x only
        this.size.set(200, this.fontSize);
        this.hAlign = "left";
        this.borderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.WHITE;
    }
    update(deltaT) {
        super.update(deltaT);
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            let keys = Input_1.default.getKeysJustPressed();
            let nums = "1234567890";
            let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            let letters = "qwertyuiopasdfghjklzxcvbnm";
            let mask = nums + specialChars + letters;
            keys = keys.filter(key => mask.includes(key));
            let shiftPressed = Input_1.default.isKeyPressed("shift");
            let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
            let spacePressed = Input_1.default.isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    }
}
exports.default = TextInput;
},{"../../Input/Input":37,"../../Utils/Color":102,"./Label":57}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));
},{}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
class NavigationManager {
    constructor() {
        this.navigableEntities = new Map_1.default();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    addNavigableEntity(navName, nav) {
        this.navigableEntities.add(navName, nav);
    }
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    getPath(navName, fromPosition, toPosition) {
        let nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone());
    }
}
exports.default = NavigationManager;
},{"../DataTypes/Map":16}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
class NavigationPath {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    constructor(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1.default.ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    isDone() {
        return this.path.isEmpty();
    }
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    getMoveDirection(node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    }
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    handlePathProgress(node) {
        if (node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    }
    toString() {
        return this.path.toString();
    }
}
exports.default = NavigationPath;
},{"../DataTypes/Vec2":29}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../DataTypes/Stack");
const GraphUtils_1 = require("../Utils/GraphUtils");
const NavigationPath_1 = require("./NavigationPath");
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
class Navmesh {
    /**
     * Creates a new Navmesh from the points in the speecified graph
     * @param graph The graph to construct a navmesh from
     */
    constructor(graph) {
        this.graph = graph;
    }
    // @implemented
    getNavigationPath(fromPosition, toPosition) {
        let start = this.getClosestNode(fromPosition);
        let end = this.getClosestNode(toPosition);
        let parent = GraphUtils_1.default.djikstra(this.graph, start);
        let pathStack = new Stack_1.default(this.graph.numVertices);
        // Push the final position and the final position in the graph
        pathStack.push(toPosition.clone());
        pathStack.push(this.graph.positions[end]);
        // Add all parents along the path
        let i = end;
        while (parent[i] !== -1) {
            pathStack.push(this.graph.positions[parent[i]]);
            i = parent[i];
        }
        return new NavigationPath_1.default(pathStack);
    }
    /**
     * Gets the closest node in this Navmesh to the specified position
     * @param position The position to query
     * @returns The index of the closest node in the Navmesh to the position
     */
    getClosestNode(position) {
        let n = this.graph.numVertices;
        let i = 1;
        let index = 0;
        let dist = position.distanceSqTo(this.graph.positions[0]);
        while (i < n) {
            let d = position.distanceSqTo(this.graph.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    }
}
exports.default = Navmesh;
},{"../DataTypes/Stack":25,"../Utils/GraphUtils":104,"./NavigationPath":62}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PhysicsManager_1 = require("./PhysicsManager");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const AreaCollision_1 = require("../DataTypes/Physics/AreaCollision");
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
class BasicPhysicsManager extends PhysicsManager_1.default {
    constructor(options) {
        super();
        this.staticNodes = new Array();
        this.dynamicNodes = new Array();
        this.tilemaps = new Array();
        this.collisionMasks = new Array(32);
        // Parse options
        this.parseOptions(options);
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    parseOptions(options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (let i = 0; i < options.groupNames.length; i++) {
                let group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                let collisionMask = 0;
                for (let j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    }
    // @override
    registerObject(node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    }
    // @override
    deregisterObject(node) {
        console.log("Deregistering physics object");
        if (node.isStatic) {
            // Remove the node from the static list
            const index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            const index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    }
    // @override
    registerTilemap(tilemap) {
        this.tilemaps.push(tilemap);
    }
    // @override
    deregisterTilemap(tilemap) {
        const index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    }
    // @override
    update(deltaT) {
        for (let node of this.dynamicNodes) {
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            let overlaps = new Array();
            let groupIndex = Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (let other of this.staticNodes) {
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (let other of this.dynamicNodes) {
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (let tilemap of this.tilemaps) {
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1.default) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort((a, b) => b.area - a.area);
            // Keep track of hits to use later
            let hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (let overlap of overlaps) {
                // Ignore nodes we don't interact with
                if (this.collisionMasks[groupIndex] !== undefined && (this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                const point = node.collisionShape.center;
                const delta = node._velocity;
                const padding = node.collisionShape.halfSize;
                const otherAABB = overlap.collider;
                const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    let tnearx = hit.nearTimes.x;
                    let tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (let overlap of overlaps) {
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group)) {
                    // Get the bit that this group is represented by
                    let index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if ((this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    }
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    collideWithOrthogonalTilemap(node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
        let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        let minIndex = tilemap.getColRowAt(min);
        let maxIndex = tilemap.getColRowAt(max);
        let tileSize = tilemap.getTileSize();
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a new collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    // Calculate collision area between the node and the tile
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                    }
                }
            }
        }
    }
}
exports.default = BasicPhysicsManager;
},{"../DataTypes/Physics/AreaCollision":18,"../DataTypes/Shapes/AABB":22,"../DataTypes/Vec2":29,"../Nodes/Tilemaps/OrthogonalTilemap":54,"./PhysicsManager":65}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Map_1 = require("../DataTypes/Map");
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
class PhysicsManager {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1.default();
        this.groupNames = new Array();
    }
    destroy() {
        this.receiver.destroy();
    }
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    setGroup(node, group) {
        node.group = this.groupMap.get(group);
    }
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    getGroupNumber(group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    }
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    getGroupNames(groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            let g = 1;
            let names = [];
            for (let i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    }
}
exports.default = PhysicsManager;
/** The default group name */
PhysicsManager.DEFAULT_GROUP = "Default";
},{"../DataTypes/Map":16,"../Events/Emitter":32,"../Events/Receiver":36}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Receiver_1 = require("../Events/Receiver");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
// @ignorePage
class Recorder {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.log = new Queue_1.default(1000);
        this.recording = false;
        this.playing = false;
        this.frame = 0;
        this.eventQueue = EventQueue_1.default.getInstance();
        this.eventQueue.subscribe(this.receiver, "all");
    }
    update(deltaT) {
        if (this.recording) {
            this.frame += 1;
        }
        if (this.playing) {
            // If playing, ignore events, just feed the record to the event queue
            this.receiver.ignoreEvents();
            /*
                While there is a next item, and while it should occur in this frame,
                send the event. i.e., while current_frame * current_delta_t is greater
                than recorded_frame * recorded_delta_t
            */
            while (this.log.hasItems()
                && this.log.peekNext().frame * this.log.peekNext().delta < this.frame * deltaT) {
                let event = this.log.dequeue().event;
                console.log(event);
                this.eventQueue.addEvent(event);
            }
            if (!this.log.hasItems()) {
                this.playing = false;
            }
            this.frame += 1;
        }
        else {
            // If not playing, handle events
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                if (event.type === GameEventType_1.GameEventType.STOP_RECORDING) {
                    this.recording = false;
                }
                if (this.recording) {
                    this.log.enqueue(new LogItem(this.frame, deltaT, event));
                }
                if (event.type === GameEventType_1.GameEventType.START_RECORDING) {
                    this.log.clear();
                    this.recording = true;
                    this.frame = 0;
                }
                if (event.type === GameEventType_1.GameEventType.PLAY_RECORDING) {
                    this.frame = 0;
                    this.recording = false;
                    this.playing = true;
                }
            }
        }
    }
}
exports.default = Recorder;
class LogItem {
    constructor(frame, deltaT, event) {
        this.frame = frame;
        this.delta = deltaT;
        this.event = event;
    }
}
},{"../DataTypes/Queue":20,"../Events/EventQueue":33,"../Events/GameEventType":35,"../Events/Receiver":36}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
class Registry extends Map_1.default {
}
exports.default = Registry;
},{"../../DataTypes/Map":16}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LabelShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType");
const PointShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType");
const RectShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType");
const SpriteShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Registry_1 = require("./Registry");
/**
 * A registry that handles shaders
 */
class ShaderRegistry extends Registry_1.default {
    constructor() {
        super(...arguments);
        this.registryItems = new Array();
    }
    /**
     * Preloads all built-in shaders
     */
    preload() {
        // Get the resourceManager and queue all built-in shaders for preloading
        const rm = ResourceManager_1.default.getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (let item of this.registryItems) {
            const shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    }
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
        let shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    }
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    registerItem(key, constr) {
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    }
}
exports.default = ShaderRegistry;
// Shader names
ShaderRegistry.POINT_SHADER = "point";
ShaderRegistry.RECT_SHADER = "rect";
ShaderRegistry.SPRITE_SHADER = "sprite";
ShaderRegistry.LABEL_SHADER = "label";
class ShaderRegistryItem {
}
class ShaderPreload {
}
},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":81,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":82,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":84,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":85,"../../ResourceManager/ResourceManager":86,"./Registry":67}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const ShaderRegistry_1 = require("./Registries/ShaderRegistry");
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
class RegistryManager {
    static preload() {
        this.shaders.preload();
        this.registries.forEach((key) => this.registries.get(key).preload());
    }
    static addCustomRegistry(name, registry) {
        this.registries.add(name, registry);
    }
    static getRegistry(key) {
        return this.registries.get(key);
    }
}
exports.default = RegistryManager;
RegistryManager.shaders = new ShaderRegistry_1.default();
/** Additional custom registries to add to the registry manager */
RegistryManager.registries = new Map_1.default();
},{"../DataTypes/Map":16,"./Registries/ShaderRegistry":68}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const Emitter_1 = require("../../Events/Emitter");
const AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
class AnimationManager {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    constructor(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1.default();
        this.onEndEvent = null;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    add(key, animation) {
        this.animations.add(key, animation);
    }
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    getIndex() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
            return 0;
        }
    }
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    isPlaying(key) {
        return this.currentAnimation === key && this.animationState === AnimationTypes_1.AnimationState.PLAYING;
    }
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    getIndexAndAdvanceAnimation() {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            let currentAnimation = this.animations.get(this.currentAnimation);
            let index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >= currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
            return 0;
        }
    }
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    endCurrentAnimation() {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, { owner: this.owner.id, animation: this.currentAnimation });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    }
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    playIfNotAlready(animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    }
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    play(animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    }
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    queue(animation, loop = false, onEnd) {
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    }
    /** Pauses the current animation */
    pause() {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    }
    /** Resumes the current animation if possible */
    resume() {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /** Stops the current animation. The animation cannot be resumed after this. */
    stop() {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    }
}
exports.default = AnimationManager;
},{"../../DataTypes/Map":16,"../../Events/Emitter":32,"./AnimationTypes":71}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
class AnimationData {
    constructor() {
        this.repeat = false;
    }
}
exports.AnimationData = AnimationData;
class TweenEffect {
}
exports.TweenEffect = TweenEffect;
class TweenData {
}
exports.TweenData = TweenData;
},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const AnimationTypes_1 = require("./AnimationTypes");
const EaseFunctions_1 = require("../../Utils/EaseFunctions");
const MathUtils_1 = require("../../Utils/MathUtils");
const TweenManager_1 = require("./TweenManager");
const Emitter_1 = require("../../Events/Emitter");
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
class TweenController {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    constructor(owner) {
        this.owner = owner;
        this.tweens = new Map_1.default();
        this.emitter = new Emitter_1.default();
        // Give ourselves to the TweenManager
        TweenManager_1.default.getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    destroy() {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1.default.getInstance().deregisterTweenController(this);
    }
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    add(key, tween) {
        let typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    }
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    play(key, loop) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
        }
    }
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    pause(key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    }
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    resume(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    stop(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    }
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    end(key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            let tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                this.emitter.fireEvent(tween.onEnd, { key: key, node: this.owner.id });
            }
        }
    }
    /**
     * Stops all currently playing tweens
     */
    stopAll() {
        this.tweens.forEach(key => this.stop(key));
    }
    update(deltaT) {
        this.tweens.forEach(key => {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (let effect of tween.effects) {
                        // Get the value from the ease function that corresponds to our progress
                        let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                        // Use the value to lerp the property
                        let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        this.owner[effect.property] = value;
                    }
                }
            }
        });
    }
}
exports.default = TweenController;
},{"../../DataTypes/Map":16,"../../Events/Emitter":32,"../../Utils/EaseFunctions":103,"../../Utils/MathUtils":105,"./AnimationTypes":71,"./TweenManager":73}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TweenManager {
    constructor() {
        this.tweenControllers = new Array();
    }
    static getInstance() {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    }
    registerTweenController(controller) {
        this.tweenControllers.push(controller);
    }
    deregisterTweenController(controller) {
        let index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    }
    clearTweenControllers() {
        this.tweenControllers = new Array();
    }
    update(deltaT) {
        for (let tweenController of this.tweenControllers) {
            tweenController.update(deltaT);
        }
    }
}
exports.default = TweenManager;
TweenManager.instance = null;
},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const UIElement_1 = require("../Nodes/UIElement");
const GraphicRenderer_1 = require("./CanvasRendering/GraphicRenderer");
const RenderingManager_1 = require("./RenderingManager");
const TilemapRenderer_1 = require("./CanvasRendering/TilemapRenderer");
const UIElementRenderer_1 = require("./CanvasRendering/UIElementRenderer");
const Label_1 = require("../Nodes/UIElements/Label");
const Button_1 = require("../Nodes/UIElements/Button");
const Slider_1 = require("../Nodes/UIElements/Slider");
const TextInput_1 = require("../Nodes/UIElements/TextInput");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Vec2_1 = require("../DataTypes/Vec2");
const Line_1 = require("../Nodes/Graphics/Line");
const Debug_1 = require("../Debug/Debug");
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
class CanvasRenderer extends RenderingManager_1.default {
    constructor() {
        super();
    }
    // @override
    setScene(scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    }
    // @override
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1.default(width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    }
    // @override
    render(visibleSet, tilemaps, uiLayers) {
        // Sort by depth, then by visible set by y-value
        visibleSet.sort((a, b) => {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return (a.boundary.bottom) - (b.boundary.bottom);
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        let tilemapIndex = 0;
        let tilemapLength = tilemaps.length;
        let visibleSetIndex = 0;
        let visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        let sortedUILayers = new Array();
        uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
        sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
        sortedUILayers.forEach(uiLayer => {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(node => {
                    if (node.visible) {
                        this.renderNode(node);
                    }
                });
        });
    }
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        let xScale = 1;
        let yScale = 1;
        if (node instanceof Sprite_1.default) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        let globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1.default) {
            Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1.default) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1.default) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    // @override
    renderSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world
                image draw start -> x, y
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderAnimatedSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        let animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world (given we moved)
                image draw start -> -w/2, -h/2
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1.default) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1.default) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    }
    // @override
    renderTilemap(tilemap) {
        if (tilemap instanceof OrthogonalTilemap_1.default) {
            this.tilemapRenderer.renderOrthogonalTilemap(tilemap);
        }
    }
    // @override
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1.default) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1.default) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1.default) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    }
    clear(clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
}
exports.default = CanvasRenderer;
},{"../DataTypes/Vec2":29,"../Debug/Debug":30,"../Nodes/Graphic":46,"../Nodes/Graphics/Line":48,"../Nodes/Graphics/Point":49,"../Nodes/Graphics/Rect":50,"../Nodes/Sprites/AnimatedSprite":51,"../Nodes/Sprites/Sprite":52,"../Nodes/Tilemaps/OrthogonalTilemap":54,"../Nodes/UIElement":55,"../Nodes/UIElements/Button":56,"../Nodes/UIElements/Label":57,"../Nodes/UIElements/Slider":58,"../Nodes/UIElements/TextInput":59,"./CanvasRendering/GraphicRenderer":75,"./CanvasRendering/TilemapRenderer":76,"./CanvasRendering/UIElementRenderer":77,"./RenderingManager":78}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
class GraphicRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    renderPoint(point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    }
    renderLine(line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    }
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    renderRect(rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    }
}
exports.default = GraphicRenderer;
},{"../../ResourceManager/ResourceManager":86}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
class TilemapRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    renderOrthogonalTilemap(tilemap) {
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        let origin = this.scene.getViewTranslation(tilemap);
        let size = this.scene.getViewport().getHalfSize();
        let zoom = this.scene.getViewScale();
        let bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            let minColRow = tilemap.getColRowAt(origin);
            let maxColRow = tilemap.getColRowAt(bottomRight);
            for (let x = minColRow.x; x <= maxColRow.x; x++) {
                for (let y = minColRow.y; y <= maxColRow.y; y++) {
                    // Get the tile at this position
                    let tile = tilemap.getTileAtRowCol(new Vec2_1.default(x, y));
                    // Extract the rot/flip parameters if there are any
                    const mask = (0xE << 28);
                    const rotFlip = ((mask & tile) >> 28) & 0xF;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (let tileset of tilemap.getTilesets()) {
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tileset, tile, x, y, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    renderTile(tileset, tileIndex, tilemapRow, tilemapCol, origin, scale, zoom, rotFlip) {
        let image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the true index
        let index = tileIndex - tileset.getStartIndex();
        // Get the row and col of the tile in image space
        let row = Math.floor(index / tileset.getNumCols());
        let col = index % tileset.getNumCols();
        let width = tileset.getTileSize().x;
        let height = tileset.getTileSize().y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor(tilemapRow * width * scale.x);
        let y = Math.floor(tilemapCol * height * scale.y);
        let worldX = Math.floor((x - origin.x) * zoom);
        let worldY = Math.floor((y - origin.y) * zoom);
        let worldWidth = Math.ceil(width * scale.x * zoom);
        let worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            let scaleX = 1;
            let scaleY = 1;
            let shearX = 0;
            let shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    }
}
exports.default = TilemapRenderer;
},{"../../DataTypes/Vec2":29,"../../ResourceManager/ResourceManager":86}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const MathUtils_1 = require("../../Utils/MathUtils");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
class UIElementRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a label
     * @param label The label to render
     */
    renderLabel(label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        let offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a button
     * @param button The button to render
     */
    renderButton(button) {
        this.renderLabel(button);
    }
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    renderSlider(slider) {
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        let sliderSize = new Vec2_1.default(slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    renderTextInput(textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    }
}
exports.default = UIElementRenderer;
},{"../../DataTypes/Vec2":29,"../../ResourceManager/ResourceManager":86,"../../Utils/MathUtils":105}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * An abstract framework to put all rendering in once place in the application
 */
class RenderingManager {
    constructor() {
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    setScene(scene) {
        this.scene = scene;
    }
}
exports.default = RenderingManager;
},{"../ResourceManager/ResourceManager":86}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const UIElement_1 = require("../Nodes/UIElement");
const Label_1 = require("../Nodes/UIElements/Label");
const ShaderRegistry_1 = require("../Registry/Registries/ShaderRegistry");
const RegistryManager_1 = require("../Registry/RegistryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const RenderingManager_1 = require("./RenderingManager");
class WebGLRenderer extends RenderingManager_1.default {
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1.default.ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        let textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    }
    render(visibleSet, tilemaps, uiLayers) {
        for (let node of visibleSet) {
            this.renderNode(node);
        }
        uiLayers.forEach(key => {
            if (!uiLayers.get(key).isHidden())
                uiLayers.get(key).getItems().forEach(node => this.renderNode(node));
        });
    }
    clear(color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1.default) {
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
    }
    renderSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderAnimatedSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    }
    renderTilemap(tilemap) {
        throw new Error("Method not implemented.");
    }
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
            let options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            let globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            let offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    renderCustom(node) {
        let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
        let options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    }
    addOptions(options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        let layer = node.getLayer();
        let parallax = new Vec2_1.default(1, 1);
        if (layer instanceof ParallaxLayer_1.default) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    }
}
exports.default = WebGLRenderer;
},{"../DataTypes/Vec2":29,"../Nodes/Graphic":46,"../Nodes/Graphics/Point":49,"../Nodes/Graphics/Rect":50,"../Nodes/Sprites/AnimatedSprite":51,"../Nodes/Sprites/Sprite":52,"../Nodes/UIElement":55,"../Nodes/UIElements/Label":57,"../Registry/Registries/ShaderRegistry":68,"../Registry/RegistryManager":69,"../ResourceManager/ResourceManager":86,"../Scene/Layers/ParallaxLayer":94,"./RenderingManager":78}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
class ShaderType {
    constructor(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    getOptions(node) { return {}; }
}
exports.default = ShaderType;
},{"../../ResourceManager/ResourceManager":86}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
class LabelShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const backgroundColor = options.backgroundColor.toWebGL();
        const borderColor = options.borderColor.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = LabelShaderType;
},{"../../../DataTypes/Mat4x4":17,"../../../DataTypes/Vec2":29,"../../../ResourceManager/ResourceManager":86,"./QuadShaderType":83}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RenderingUtils_1 = require("../../../Utils/RenderingUtils");
const ShaderType_1 = require("../ShaderType");
class PointShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
    }
    initBufferObject() {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
        let color = RenderingUtils_1.default.toWebGLColor(options.color);
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = position;
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    }
    getOptions(point) {
        let options = {
            position: point.position,
            color: point.color,
            pointSize: point.size,
        };
        return options;
    }
}
exports.default = PointShaderType;
},{"../../../Utils/RenderingUtils":106,"../ShaderType":80}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const ShaderType_1 = require("../ShaderType");
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
class QuadShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.scale = Mat4x4_1.default.IDENTITY;
        this.rotation = Mat4x4_1.default.IDENTITY;
        this.translation = Mat4x4_1.default.IDENTITY;
    }
}
exports.default = QuadShaderType;
},{"../../../DataTypes/Mat4x4":17,"../ShaderType":80}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
class RectShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const color = options.color.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /*
        So as it turns out, WebGL has an issue with non-square quads.
        It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
        To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
        A diagram of the solution follows.

        There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
        The offset in the vertical direction is therefore 0.5, as it is normally.
        However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
        All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.

        So now we have our rect, in a space scaled with respect to the largest dimension.
        Rotations work as you would expect, even for long rectangles.

                    0.5
            __ __ __ __ __ __ __
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
        -0.5|_ _|88888888888|_ _|0.5
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
            |___|88888888888|___|
                    -0.5

        The getVertices function below does as described, and converts the range
    */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = RectShaderType;
},{"../../../DataTypes/Mat4x4":17,"../../../DataTypes/Vec2":29,"../../../ResourceManager/ResourceManager":86,"./QuadShaderType":83}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const AnimatedSprite_1 = require("../../../Nodes/Sprites/AnimatedSprite");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** A shader for sprites and animated sprites */
class SpriteShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        const texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        const u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        const u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h, scale) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x, y, 0.0, 0.0,
            -x, -y, 0.0, 1.0,
            x, y, 1.0, 0.0,
            x, -y, 1.0, 1.0
        ]);
    }
    getOptions(sprite) {
        let texShift;
        let texScale;
        if (sprite instanceof AnimatedSprite_1.default) {
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
            texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        let options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift,
            texScale
        };
        return options;
    }
}
exports.default = SpriteShaderType;
},{"../../../DataTypes/Mat4x4":17,"../../../DataTypes/Vec2":29,"../../../Nodes/Sprites/AnimatedSprite":51,"../../../ResourceManager/ResourceManager":86,"./QuadShaderType":83}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Queue_1 = require("../DataTypes/Queue");
const StringUtils_1 = require("../Utils/StringUtils");
const AudioManager_1 = require("../Sound/AudioManager");
const WebGLProgramType_1 = require("../DataTypes/Rendering/WebGLProgramType");
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
class ResourceManager {
    constructor() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1.default();
        this.images = new Map_1.default();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
        this.spritesheets = new Map_1.default();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1.default();
        this.tilemaps = new Map_1.default();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1.default();
        this.audioBuffers = new Map_1.default();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1.default();
        this.jsonObjects = new Map_1.default();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
        this.gl_ShaderPrograms = new Map_1.default();
        this.gl_Textures = new Map_1.default();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1.default();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    ;
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    }
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    useWebGL(flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    }
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    image(key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepImage(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    getImage(key) {
        let image = this.images.get(key);
        if (image === undefined) {
            throw `There is no image associated with key "${key}"`;
        }
        return image;
    }
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    spritesheet(key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepSpritesheet(key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    }
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    getSpritesheet(key) {
        return this.spritesheets.get(key);
    }
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    audio(key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepAudio(key) {
        this.keepResource(key, ResourceType.AUDIO);
    }
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    getAudio(key) {
        return this.audioBuffers.get(key);
    }
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param path The path to the tilemap to load
     */
    tilemap(key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepTilemap(key) {
        this.keepResource(key, ResourceType.TILEMAP);
    }
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    getTilemap(key) {
        return this.tilemaps.get(key);
    }
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    object(key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepObject(key) {
        this.keepResource(key, ResourceType.JSON);
    }
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    getObject(key) {
        return this.jsonObjects.get(key);
    }
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    loadResourcesFromQueue(callback) {
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(() => {
            console.log("Loaded Tilemaps");
            this.loadSpritesheetsFromQueue(() => {
                console.log("Loaded Spritesheets");
                this.loadImagesFromQueue(() => {
                    console.log("Loaded Images");
                    this.loadAudioFromQueue(() => {
                        console.log("Loaded Audio");
                        this.loadObjectsFromQueue(() => {
                            console.log("Loaded Objects");
                            if (this.gl_WebGLActive) {
                                this.gl_LoadShadersFromQueue(() => {
                                    console.log("Loaded Shaders");
                                    this.finishLoading(callback);
                                });
                            }
                            else {
                                this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    }
    finishLoading(callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    }
    /* ######################################## UNLOAD FUNCTION ########################################*/
    keepResource(key, type) {
        console.log("Keep resource...");
        for (let i = 0; i < this.resourcesToUnload.length; i++) {
            let resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                let resourceToMove = this.resourcesToUnload.splice(i, 1);
                this.resourcesToKeep.push(...resourceToMove);
                return;
            }
        }
    }
    /**
     * Deletes references to all resources in the resource manager
     */
    unloadAllResources() {
        this.loading = false;
        this.justLoaded = false;
        for (let resource of this.resourcesToUnload) {
            // Unload the resource
            this.unloadResource(resource);
        }
    }
    unloadResource(resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images.delete(resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures.delete(resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps.delete(resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets.delete(resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers.delete(resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects.delete(resource.key);
                break;
            case ResourceType.SHADER:
                this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                this.gl_ShaderPrograms.delete(resource.key);
                break;
        }
        // Delete any dependencies
        for (let dependency of resource.dependencies) {
            this.unloadResource(dependency);
        }
    }
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    loadTilemapsFromQueue(onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
        this.loadTextFile(pathToTilemapJSON, (fileText) => {
            let tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.tilemaps.add(key, tilemapObject);
            let resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (let tileset of tilemapObject.tilesets) {
                if (tileset.image) {
                    let key = tileset.image;
                    let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                    this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (let tile of tileset.tiles) {
                        let key = tile.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingTilemap(callbackIfLast);
        });
    }
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    finishLoadingTilemap(callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    }
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    loadSpritesheetsFromQueue(onFinishLoading) {
        this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
        this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
            let spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.spritesheets.add(key, spritesheet);
            let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
            this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingSpritesheet(callbackIfLast);
        });
    }
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    finishLoadingSpritesheet(callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    }
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    loadImagesFromQueue(onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            let image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    }
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    loadImage(key, path, isDependency, callbackIfLast) {
        var image = new Image();
        image.onload = () => {
            // Add to loaded images
            this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (this.gl_WebGLActive) {
                this.createWebGLTexture(key, image);
            }
            // Finish image load
            this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    }
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    finishLoadingImage(callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    }
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    loadAudioFromQueue(onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            let audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    }
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    loadAudio(key, path, callbackIfLast) {
        let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
        let request = new XMLHttpRequest();
        request.open('GET', path, true);
        request.responseType = 'arraybuffer';
        request.onload = () => {
            audioCtx.decodeAudioData(request.response, (buffer) => {
                // Add to list of audio buffers
                this.audioBuffers.add(key, buffer);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                this.finishLoadingAudio(callbackIfLast);
            }, (error) => {
                throw "Error loading sound";
            });
        };
        request.send();
    }
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    finishLoadingAudio(callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    }
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    loadObjectsFromQueue(onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            let obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    loadObject(key, path, callbackIfLast) {
        this.loadTextFile(path, (fileText) => {
            let obj = JSON.parse(fileText);
            this.jsonObjects.add(key, obj);
            this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            this.finishLoadingObject(callbackIfLast);
        });
    }
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    finishLoadingObject(callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    }
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    getTexture(key) {
        return this.gl_Textures.get(key);
    }
    getShaderProgram(key) {
        return this.gl_ShaderPrograms.get(key).program;
    }
    getBuffer(key) {
        return this.gl_Buffers.get(key);
    }
    createWebGLTexture(imageKey, image) {
        // Get the texture ID
        const textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        const texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    }
    getTextureID(id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0: return this.gl.TEXTURE0;
            case 1: return this.gl.TEXTURE1;
            case 2: return this.gl.TEXTURE2;
            case 3: return this.gl.TEXTURE3;
            case 4: return this.gl.TEXTURE4;
            case 5: return this.gl.TEXTURE5;
            case 6: return this.gl.TEXTURE6;
            case 7: return this.gl.TEXTURE7;
            case 8: return this.gl.TEXTURE8;
            default: return this.gl.TEXTURE9;
        }
    }
    createBuffer(key) {
        if (this.gl_WebGLActive) {
            let buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    }
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    shader(key, vShaderFilepath, fShaderFilepath) {
        let splitPath = vShaderFilepath.split(".");
        let end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
        }
        let paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepShader(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    gl_LoadShadersFromQueue(onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    }
    gl_LoadShader(key, vpath, fpath, callbackIfLast) {
        this.loadTextFile(vpath, (vFileText) => {
            const vShader = vFileText;
            this.loadTextFile(fpath, (fFileText) => {
                const fShader = fFileText;
                // Extract the program and shaders
                const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                // Create a wrapper type
                const programWrapper = new WebGLProgramType_1.default();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                this.gl_ShaderPrograms.add(key, programWrapper);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    }
    gl_FinishLoadingShader(callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    }
    createShaderProgram(vShaderSource, fShaderSource) {
        const vertexShader = this.loadVertexShader(vShaderSource);
        const fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        const program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            const error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    }
    loadVertexShader(shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    }
    loadFragmentShader(shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    }
    loadShader(type, shaderSource) {
        const shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            const error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    }
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    loadTextFile(textFilePath, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', textFilePath, true);
        xobj.onreadystatechange = function () {
            if ((xobj.readyState == 4) && (xobj.status == 200)) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
    /* ########## LOADING BAR INFO ########## */
    getLoadPercent() {
        return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
            + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
            + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
            + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
            / this.loadonly_typesToLoad;
    }
    update(deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    }
}
exports.default = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
class ResourceReference {
    constructor(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    addDependency(resource) {
        this.dependencies.push(resource);
    }
}
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
class KeyPathPair {
    constructor() {
        this.isDependency = false;
    }
}
class KeyPath_Shader {
}
},{"../DataTypes/Map":16,"../DataTypes/Queue":20,"../DataTypes/Rendering/WebGLProgramType":21,"../Sound/AudioManager":99,"../Utils/StringUtils":107}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
class SceneGraph {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    addNode(node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    }
    ;
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    removeNode(node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    }
    ;
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    getNode(id) {
        return this.nodeMap[id];
    }
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    getNodesAt(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    }
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    getAllNodes() {
        let arr = new Array();
        for (let i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    }
}
exports.default = SceneGraph;
},{"../DataTypes/Vec2":29}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SceneGraph_1 = require("./SceneGraph");
const Stats_1 = require("../Debug/Stats");
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
class SceneGraphArray extends SceneGraph_1.default {
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        super(viewport, scene);
        this.nodeList = new Array();
    }
    // @override
    addNodeSpecific(node, id) {
        this.nodeList.push(node);
    }
    // @override
    removeNodeSpecific(node, id) {
        let index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    }
    // @override
    getNodesAtCoords(x, y) {
        let results = [];
        for (let node of this.nodeList) {
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    }
    // @override
    getNodesInRegion(boundary) {
        let t0 = performance.now();
        let results = [];
        for (let node of this.nodeList) {
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgquery", (t1 - t0));
        return results;
    }
    update(deltaT) {
        let t0 = performance.now();
        for (let node of this.nodeList) {
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgupdate", (t1 - t0));
    }
    render(ctx) { }
    // @override
    getVisibleSet() {
        let visibleSet = new Array();
        for (let node of this.nodeList) {
            if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    }
}
exports.default = SceneGraphArray;
},{"../Debug/Stats":31,"./SceneGraph":87}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const MathUtils_1 = require("../Utils/MathUtils");
const Queue_1 = require("../DataTypes/Queue");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Input_1 = require("../Input/Input");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const UILayer_1 = require("../Scene/Layers/UILayer");
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
class Viewport {
    constructor(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        this.view = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.lastPositions = new Queue_1.default();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1.default.ZERO;
        this.focus = Vec2_1.default.ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    enableZoom() {
        this.scrollZoomEnabled = true;
    }
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    getCenter() {
        return this.view.center;
    }
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    getOrigin() {
        return new Vec2_1.default(this.view.left, this.view.top);
    }
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    getView() {
        return this.view;
    }
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    setCenter(vecOrX, y = null) {
        let pos;
        if (vecOrX instanceof Vec2_1.default) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1.default(vecOrX, y);
        }
        this.view.center = pos;
    }
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    getHalfSize() {
        return this.view.getHalfSize();
    }
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    setSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
        }
    }
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    setHalfSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
        }
    }
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    setCanvasSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1.default(vecOrX, y);
        }
    }
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    setZoomLevel(zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    }
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    getZoomLevel() {
        return this.canvasSize.x / this.view.hw / 2;
    }
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    setSmoothingFactor(smoothingFactor) {
        if (smoothingFactor < 1)
            smoothingFactor = 1;
        this.smoothingFactor = smoothingFactor;
    }
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    setFocus(focus) {
        this.focus.copy(focus);
    }
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    includes(node) {
        let parallax = node.getLayer() instanceof ParallaxLayer_1.default || node.getLayer() instanceof UILayer_1.default ? node.getLayer().parallax : new Vec2_1.default(1, 1);
        let center = this.view.center.clone();
        this.view.center.mult(parallax);
        let overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    }
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    setBounds(lowerX, lowerY, upperX, upperY) {
        let hwidth = (upperX - lowerX) / 2;
        let hheight = (upperY - lowerY) / 2;
        let x = lowerX + hwidth;
        let y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    }
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    follow(node) {
        this.following = node;
    }
    updateView() {
        if (this.lastPositions.getSize() > this.smoothingFactor) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        let pos = Vec2_1.default.ZERO;
        this.lastPositions.forEach(position => pos.add(position));
        pos.scale(1 / this.lastPositions.getSize());
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    }
    update(deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1.default.didJustScroll()) {
                let currentSize = this.view.getHalfSize().clone();
                if (Input_1.default.getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    let factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    let factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    }
}
exports.default = Viewport;
},{"../DataTypes/Queue":20,"../DataTypes/Shapes/AABB":22,"../DataTypes/Vec2":29,"../Input/Input":37,"../Scene/Layers/ParallaxLayer":94,"../Scene/Layers/UILayer":95,"../Utils/MathUtils":105}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("../../Nodes/Sprites/Sprite");
const AnimatedSprite_1 = require("../../Nodes/Sprites/AnimatedSprite");
const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
const Point_1 = require("../../Nodes/Graphics/Point");
const Vec2_1 = require("../../DataTypes/Vec2");
const Button_1 = require("../../Nodes/UIElements/Button");
const Label_1 = require("../../Nodes/UIElements/Label");
const Slider_1 = require("../../Nodes/UIElements/Slider");
const TextInput_1 = require("../../Nodes/UIElements/TextInput");
const Rect_1 = require("../../Nodes/Graphics/Rect");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Line_1 = require("../../Nodes/Graphics/Line");
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class CanvasNodeFactory {
    constructor() {
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = this.buildTextInput(options);
                    break;
                default:
                    throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
            }
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let instance = new Sprite_1.default(key);
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let spritesheet = this.resourceManager.getSpritesheet(key);
            let instance = new AnimatedSprite_1.default(spritesheet);
            // Add instance fo scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = this.buildRect(options);
                    break;
                default:
                    throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
            }
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    init(scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /* ---------- BUILDERS ---------- */
    buildButton(options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1.default(options.position, options.text);
    }
    buildLabel(options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1.default(options.position, options.text);
    }
    buildSlider(options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
        let initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1.default(options.position, initValue);
    }
    buildTextInput(options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
        return new TextInput_1.default(options.position);
    }
    buildPoint(options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
        return new Point_1.default(options.position);
    }
    buildLine(options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
        return new Line_1.default(options.start, options.end);
    }
    buildRect(options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
        return new Rect_1.default(options.position, options.size);
    }
    /* ---------- ERROR HANDLING ---------- */
    checkIfPropExists(objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
        }
        else {
            // Check that the property has the correct type
            if ((typeof type) === "string") {
                if (!(typeof options[prop] === type)) {
                    throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
            else {
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
            }
        }
    }
}
exports.default = CanvasNodeFactory;
},{"../../DataTypes/Vec2":29,"../../Nodes/Graphics/GraphicTypes":47,"../../Nodes/Graphics/Line":48,"../../Nodes/Graphics/Point":49,"../../Nodes/Graphics/Rect":50,"../../Nodes/Sprites/AnimatedSprite":51,"../../Nodes/Sprites/Sprite":52,"../../Nodes/UIElements/Button":56,"../../Nodes/UIElements/Label":57,"../../Nodes/UIElements/Slider":58,"../../Nodes/UIElements/TextInput":59,"../../Nodes/UIElements/UIElementTypes":60,"../../ResourceManager/ResourceManager":86}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNodeFactory_1 = require("./CanvasNodeFactory");
const TilemapFactory_1 = require("./TilemapFactory");
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
class FactoryManager {
    constructor(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1.default();
        this.tilemapFactory = new TilemapFactory_1.default();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    uiElement(type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    }
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    sprite(key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    }
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    animatedSprite(key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(key, layerName);
    }
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    graphic(type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    }
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    tilemap(key, scale) {
        return this.tilemapFactory.add(key, scale);
    }
}
exports.default = FactoryManager;
},{"./CanvasNodeFactory":90,"./TilemapFactory":92}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const OrthogonalTilemap_1 = require("../../Nodes/Tilemaps/OrthogonalTilemap");
const Tileset_1 = require("../../DataTypes/Tilesets/Tileset");
const Vec2_1 = require("../../DataTypes/Vec2");
const PositionGraph_1 = require("../../DataTypes/Graphs/PositionGraph");
const Navmesh_1 = require("../../Pathfinding/Navmesh");
// @ignorePage
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class TilemapFactory {
    constructor() {
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = (key, scale = new Vec2_1.default(1, 1)) => {
            // Get Tilemap Data
            let tilemapData = this.resourceManager.getTilemap(key);
            // Set the constructor for this tilemap to either be orthographic or isometric
            let constr;
            if (tilemapData.orientation === "orthographic") {
                constr = OrthogonalTilemap_1.default;
            }
            else {
                // No isometric tilemap support right now, so Orthographic tilemap
                constr = OrthogonalTilemap_1.default;
            }
            // Initialize the return value array
            let sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            let tilesets = new Array();
            let collectionTiles = new Array();
            for (let tileset of tilemapData.tilesets) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1.default(tileset));
                }
                else {
                    tileset.tiles.forEach(tile => tile.id += tileset.firstgid);
                    collectionTiles.push(...tileset.tiles);
                }
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (let layer of tilemapData.layers) {
                let sceneLayer;
                let isParallaxLayer = false;
                let depth = 0;
                if (layer.properties) {
                    for (let prop of layer.properties) {
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                }
                else {
                    sceneLayer = this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    let tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = this.scene.generateId();
                    tilemap.setScene(this.scene);
                    // Add tilemap to scene
                    this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (let item of layer.properties) {
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    let isNavmeshPoints = false;
                    let navmeshName;
                    let edges;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        let g = new PositionGraph_1.default();
                        for (let obj of layer.objects) {
                            g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                        }
                        for (let edge of edges) {
                            g.addEdge(edge.from, edge.to);
                        }
                        this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (let obj of layer.objects) {
                        // Check if obj is collidable
                        let hasPhysics = false;
                        let isCollidable = false;
                        let isTrigger = false;
                        let onEnter = null;
                        let onExit = null;
                        let triggerGroup = null;
                        let group = "";
                        if (obj.properties) {
                            for (let prop of obj.properties) {
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        let sprite;
                        // Check if obj is a tile from a tileset
                        for (let tileset of tilesets) {
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                let imageKey = tileset.getImageKey();
                                let offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = this.scene.add.sprite(imageKey, layer.name);
                                let size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (let tile of collectionTiles) {
                                if (obj.gid === tile.id) {
                                    let imageKey = tile.image;
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    init(scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
}
exports.default = TilemapFactory;
},{"../../DataTypes/Graphs/PositionGraph":14,"../../DataTypes/Tilesets/Tileset":28,"../../DataTypes/Vec2":29,"../../Nodes/Tilemaps/OrthogonalTilemap":54,"../../Pathfinding/Navmesh":63,"../../ResourceManager/ResourceManager":86}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
class Layer {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    getName() {
        return this.name;
    }
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    setPaused(pauseValue) {
        this.paused = pauseValue;
    }
    /**
     * Returns whether or not the layer is paused
     */
    isPaused() {
        return this.paused;
    }
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    setAlpha(alpha) {
        this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
    }
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    setHidden(hidden) {
        this.hidden = hidden;
    }
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    isHidden() {
        return this.hidden;
    }
    /** Pauses this scene and hides it */
    disable() {
        this.paused = true;
        this.hidden = true;
    }
    /** Unpauses this layer and makes it visible */
    enable() {
        this.paused = false;
        this.hidden = false;
    }
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    setYSort(ySort) {
        this.ySort = ySort;
    }
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    getYSort() {
        return this.ySort;
    }
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    setDepth(depth) {
        this.depth = depth;
    }
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    getDepth() {
        return this.depth;
    }
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    addNode(node) {
        this.items.push(node);
        node.setLayer(this);
    }
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    removeNode(node) {
        // Find and remove the node
        let index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    }
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    getItems() {
        return this.items;
    }
}
exports.default = Layer;
},{"../Utils/MathUtils":105}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("../Layer");
/**
 * An extension of a Layer that has a parallax value.
 */
class ParallaxLayer extends Layer_1.default {
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    constructor(scene, name, parallax) {
        super(scene, name);
        this.parallax = parallax;
    }
}
exports.default = ParallaxLayer;
},{"../Layer":93}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ParallaxLayer_1 = require("./ParallaxLayer");
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
class UILayer extends ParallaxLayer_1.default {
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    constructor(scene, name) {
        super(scene, name, Vec2_1.default.ZERO);
    }
}
exports.default = UILayer;
},{"../../DataTypes/Vec2":29,"./ParallaxLayer":94}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("./Layer");
const Vec2_1 = require("../DataTypes/Vec2");
const BasicPhysicsManager_1 = require("../Physics/BasicPhysicsManager");
const SceneGraphArray_1 = require("../SceneGraph/SceneGraphArray");
const FactoryManager_1 = require("./Factories/FactoryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const NavigationManager_1 = require("../Pathfinding/NavigationManager");
const AIManager_1 = require("../AI/AIManager");
const Map_1 = require("../DataTypes/Map");
const ParallaxLayer_1 = require("./Layers/ParallaxLayer");
const UILayer_1 = require("./Layers/UILayer");
const CanvasNode_1 = require("../Nodes/CanvasNode");
const SceneOptions_1 = require("./SceneOptions");
const Debug_1 = require("../Debug/Debug");
const TimerManager_1 = require("../Timing/TimerManager");
const TweenManager_1 = require("../Rendering/Animations/TweenManager");
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
class Scene {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    constructor(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1.default(500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
        this.layers = new Map_1.default();
        this.uiLayers = new Map_1.default();
        this.parallaxLayers = new Map_1.default();
        this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
        this.navManager = new NavigationManager_1.default();
        this.aiManager = new AIManager_1.default();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1.default(this, this.tilemaps);
        this.load = ResourceManager_1.default.getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1.default.getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    initScene(init) { }
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    loadScene() { }
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    startScene() { }
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    updateScene(deltaT) { }
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    unloadScene() { }
    update(deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1.default.getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(tilemap => {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1.default.getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    }
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    render() {
        // Get the visible set of nodes
        let visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(key => {
            let pLayer = this.parallaxLayers.get(key);
            for (let node of pLayer.getItems()) {
                if (node instanceof CanvasNode_1.default) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        let nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
        Debug_1.default.setNodes(nodes);
    }
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    setRunning(running) {
        this.running = running;
    }
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    isRunning() {
        return this.running;
    }
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    remove(node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1.default) {
            this.sceneGraph.removeNode(node);
        }
    }
    /** Destroys this scene and all nodes in it */
    destroy() {
        for (let node of this.sceneGraph.getAllNodes()) {
            node.destroy();
        }
        for (let tilemap of this.tilemaps) {
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    }
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    addLayer(name, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new Layer_1.default(this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    addParallaxLayer(name, parallax, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new ParallaxLayer_1.default(this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    addUILayer(name) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new UILayer_1.default(this, name);
        this.uiLayers.add(name, layer);
        return layer;
    }
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    getLayer(name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw `Requested layer ${name} does not exist.`;
        }
    }
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    isParallaxLayer(name) {
        return this.parallaxLayers.has(name);
    }
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    isUILayer(name) {
        return this.uiLayers.has(name);
    }
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    getViewTranslation(node) {
        let layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    }
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
    */
    getViewScale() {
        return this.viewport.getZoomLevel();
    }
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    getViewport() {
        return this.viewport;
    }
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    getWorldSize() {
        return this.worldSize;
    }
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    getSceneGraph() {
        return this.sceneGraph;
    }
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    getPhysicsManager() {
        return this.physicsManager;
    }
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    getNavigationManager() {
        return this.navManager;
    }
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    getAIManager() {
        return this.aiManager;
    }
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    generateId() {
        return this.sceneManager.generateId();
    }
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    getTilemap(name) {
        for (let tilemap of this.tilemaps) {
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    }
}
exports.default = Scene;
},{"../AI/AIManager":9,"../DataTypes/Map":16,"../DataTypes/Vec2":29,"../Debug/Debug":30,"../Events/Emitter":32,"../Events/Receiver":36,"../Nodes/CanvasNode":44,"../Pathfinding/NavigationManager":61,"../Physics/BasicPhysicsManager":64,"../Rendering/Animations/TweenManager":73,"../ResourceManager/ResourceManager":86,"../SceneGraph/SceneGraphArray":88,"../Timing/TimerManager":101,"./Factories/FactoryManager":91,"./Layer":93,"./Layers/ParallaxLayer":94,"./Layers/UILayer":95,"./SceneOptions":98}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
class SceneManager {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    constructor(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    changeToScene(constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    }
    doSceneChange() {
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(() => {
            console.log("Starting Scene");
            this.currentScene.startScene();
            this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    }
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    generateId() {
        return this.idCounter++;
    }
    /**
     * Renders the current Scene
     */
    render() {
        if (this.currentScene) {
            this.currentScene.render();
        }
    }
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    update(deltaT) {
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    }
}
exports.default = SceneManager;
},{"../ResourceManager/ResourceManager":86}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
class SceneOptions {
    static parse(options) {
        let sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    }
}
exports.default = SceneOptions;
},{}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
const Map_1 = require("../DataTypes/Map");
const Receiver_1 = require("../Events/Receiver");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
class AudioManager {
    constructor() {
        this.initAudio();
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL
        ]);
        this.currentSounds = new Map_1.default();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    }
    /**
     * Initializes the webAudio context
     */
    initAudio() {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
            this.audioCtx = new AudioContext();
            console.log('Web Audio API successfully loaded');
        }
        catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    }
    initGainNodes() {
        for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    }
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    getAudioContext() {
        return this.audioCtx;
    }
    /*
        According to the MDN, create a new sound for every call:

        An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
        if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
        actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
        "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
        hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
        until sometime after the sound has finished playing.
    */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    createSound(key, holdReference, channel, options) {
        // Get audio buffer
        let buffer = ResourceManager_1.default.getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        const nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (let i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    }
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    playSound(key, loop, holdReference, channel, options) {
        let sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    }
    /**
     * Stop the sound specified by the key
     */
    stopSound(key) {
        let sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds.delete(key);
        }
    }
    muteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    }
    unmuteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    }
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    static setVolume(channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        const am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    }
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    getChannelGainNode(channel) {
        return this.gainNodes[channel];
    }
    update(deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === GameEventType_1.GameEventType.PLAY_SOUND || event.type === GameEventType_1.GameEventType.PLAY_MUSIC || event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                let soundKey = event.data.get("key");
                let loop = event.data.get("loop");
                let holdReference = event.data.get("holdReference");
                let channel = AudioChannelType.DEFAULT;
                if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event.data.has("channel")) {
                    channel = event.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event.data);
            }
            if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                let soundKey = event.data.get("key");
                this.stopSound(soundKey);
            }
            if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event.data.get("channel"));
            }
            if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event.data.get("channel"));
            }
        }
    }
}
exports.default = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;
},{"../DataTypes/Map":16,"../Events/GameEventType":35,"../Events/Receiver":36,"../ResourceManager/ResourceManager":86}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimerState = void 0;
const MathUtils_1 = require("../Utils/MathUtils");
const TimerManager_1 = require("./TimerManager");
class Timer {
    constructor(time, onEnd, loop = false) {
        // Register this timer
        TimerManager_1.default.getInstance().addTimer(this);
        this.totalTime = time;
        this.timeLeft = 0;
        this.onEnd = onEnd;
        this.loop = loop;
        this.state = TimerState.STOPPED;
        this.numRuns = 0;
    }
    isStopped() {
        return this.state === TimerState.STOPPED;
    }
    isPaused() {
        return this.state === TimerState.PAUSED;
    }
    /**
     * Returns whether or not this timer has been run before
     * @returns true if it has been run at least once (after the latest reset), and false otherwise
     */
    hasRun() {
        return this.numRuns > 0;
    }
    start(time) {
        if (time !== undefined) {
            this.totalTime = time;
        }
        this.state = TimerState.ACTIVE;
        this.timeLeft = this.totalTime;
    }
    /** Resets this timer. Sets the progress back to zero, and sets the number of runs back to zero */
    reset() {
        this.timeLeft = this.totalTime;
        this.numRuns = 0;
    }
    pause() {
        this.state = TimerState.PAUSED;
    }
    update(deltaT) {
        if (this.state === TimerState.ACTIVE) {
            this.timeLeft -= deltaT * 1000;
            if (this.timeLeft <= 0) {
                this.timeLeft = MathUtils_1.default.clampLow0(this.timeLeft);
                this.end();
            }
        }
    }
    end() {
        // Update the state
        this.state = TimerState.STOPPED;
        this.numRuns += 1;
        // Call the end function if there is one
        if (this.onEnd) {
            this.onEnd();
        }
        // Loop if we want to
        if (this.loop) {
            this.state = TimerState.ACTIVE;
            this.timeLeft = this.totalTime;
        }
    }
    toString() {
        return "Timer: " + this.state + " - Time Left: " + this.timeLeft + "ms of " + this.totalTime + "ms";
    }
}
exports.default = Timer;
var TimerState;
(function (TimerState) {
    TimerState["ACTIVE"] = "ACTIVE";
    TimerState["PAUSED"] = "PAUSED";
    TimerState["STOPPED"] = "STOPPED";
})(TimerState = exports.TimerState || (exports.TimerState = {}));
},{"../Utils/MathUtils":105,"./TimerManager":101}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TimerManager {
    constructor() {
        this.timers = new Array();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    }
    addTimer(timer) {
        this.timers.push(timer);
    }
    clearTimers() {
        this.timers = new Array();
    }
    update(deltaT) {
        this.timers.forEach(timer => timer.update(deltaT));
    }
}
exports.default = TimerManager;
},{}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
class Color {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Transparent color
     * @returns rgba(0, 0, 0, 0)
     */
    static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
    }
    /**
     * Red color
     * @returns rgb(255, 0, 0)
     */
    static get RED() {
        return new Color(255, 0, 0, 1);
    }
    /**
     * Green color
     * @returns rgb(0, 255, 0)
     */
    static get GREEN() {
        return new Color(0, 255, 0, 1);
    }
    /**
     * Blue color
     * @returns rgb(0, 0, 255)
     */
    static get BLUE() {
        return new Color(0, 0, 255, 1);
    }
    /**
     * Yellow color
     * @returns rgb(255, 255, 0)
     */
    static get YELLOW() {
        return new Color(255, 255, 0, 1);
    }
    /**
     * Magenta color
     * @returns rgb(255, 0, 255)
     */
    static get MAGENTA() {
        return new Color(255, 0, 255, 1);
    }
    /**
     * Cyan color
     * @returns rgb(0, 255, 255)
     */
    static get CYAN() {
        return new Color(0, 255, 255, 1);
    }
    /**
     * White color
     * @returns rgb(255, 255, 255)
     */
    static get WHITE() {
        return new Color(255, 255, 255, 1);
    }
    /**
     * Black color
     * @returns rgb(0, 0, 0)
     */
    static get BLACK() {
        return new Color(0, 0, 0, 1);
    }
    /**
     * Orange color
     * @returns rgb(255, 100, 0)
     */
    static get ORANGE() {
        return new Color(255, 100, 0, 1);
    }
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    set(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    lighten() {
        return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    darken() {
        return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    toString() {
        return "#" + MathUtils_1.default.toHex(this.r, 2) + MathUtils_1.default.toHex(this.g, 2) + MathUtils_1.default.toHex(this.b, 2);
    }
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    toStringRGB() {
        return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
    }
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    toStringRGBA() {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
    }
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    toWebGL() {
        return new Float32Array([
            this.r / 255,
            this.g / 255,
            this.b / 255,
            this.a
        ]);
    }
    static fromStringHex(str) {
        let i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
        let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
        let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    }
}
exports.default = Color;
},{"./MathUtils":105}],103:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseFunctionType = void 0;
class EaseFunctions {
    static easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }
    static easeOutInSine(x) {
        return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    }
    static easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    static easeInSine(x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    }
    static easeInOutQuint(x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    }
    static easeInOutQuad(x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    static easeOutInQuad(x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    }
    static easeOutIn_OutPow(x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    }
    static easeOutIn_InPow(x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    }
}
exports.default = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));
},{}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class to provides some utility functions for graphs */
class GraphUtils {
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    static djikstra(g, start) {
        let i; // Counter
        let p; // Pointer to edgenode
        let inTree = new Array(g.numVertices);
        let distance = new Array(g.numVertices);
        let parent = new Array(g.numVertices);
        let v; // Current vertex to process
        let w; // Candidate for next vertex
        let weight; // Edge weight
        let dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    }
}
exports.default = GraphUtils;
},{}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class containing some utility functions for math operations */
class MathUtils {
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    static sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    static between(a, b, x, exclusive) {
        if (exclusive) {
            return (a < x) && (x < b);
        }
        else {
            return (a <= x) && (x <= b);
        }
    }
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    static clamp(x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    }
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    static clamp01(x) {
        return MathUtils.clamp(x, 0, 1);
    }
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    static clampLow(x, min) {
        return x < min ? min : x;
    }
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    static clampLow0(x) {
        return MathUtils.clampLow(x, 0);
    }
    static clampMagnitude(v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    }
    static changeRange(x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    }
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    static lerp(a, b, t) {
        return a + t * (b - a);
    }
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    static invLerp(a, b, value) {
        return (value - a) / (b - a);
    }
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    static floorToPlace(num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        let factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    }
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    static fromHex(str) {
        return parseInt(str, 16);
    }
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    static toHex(num, minLength = null) {
        let factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        let hexStr = "";
        while (factor >= 1) {
            let digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    }
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    static toHexDigit(num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    }
}
exports.default = MathUtils;
},{}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
class RenderingUtils {
    static toWebGLCoords(point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
        ]);
    }
    static toWebGLScale(size, worldSize) {
        return new Float32Array([
            2 * size.x / worldSize.x,
            2 * size.y / worldSize.y,
        ]);
    }
    static toWebGLColor(color) {
        return new Float32Array([
            MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
            color.a
        ]);
    }
}
exports.default = RenderingUtils;
},{"./MathUtils":105}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Some utility functions for dealing with strings */
class StringUtils {
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    static getPathFromFilePath(filePath) {
        let splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    }
}
exports.default = StringUtils;
},{}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Game_1 = require("./Wolfie2D/Loop/Game");
const SplashScreen_1 = require("./Scenes/SplashScreen");
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    let options = {
        canvasSize: { x: 1280, y: 720 },
        clearColor: { r: 0, g: 0, b: 0 },
        inputs: [
            { name: "up", keys: ["w"] },
            { name: "down", keys: ["s"] },
            { name: "left", keys: ["a"] },
            { name: "right", keys: ["d"] },
            { name: "interact", keys: ["e"] },
            { name: "pause", keys: ["escape"] },
        ]
    };
    // Create a game with the options specified
    const game = new Game_1.default(options);
    // Start our game
    game.start(SplashScreen_1.default, {});
})();
function runTests() { }
;
},{"./Scenes/SplashScreen":8,"./Wolfie2D/Loop/Game":41}]},{},[108])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvQUkvQmF0QUkudHMiLCJzcmMvQUkvQmF0U3RhdGVzL0F0dGFjay50cyIsInNyYy9BSS9CYXRTdGF0ZXMvRW5lbXlTdGF0ZS50cyIsInNyYy9BSS9CYXRTdGF0ZXMvSWRsZS50cyIsInNyYy9BSS9QbGF5ZXJDb250cm9sbGVyLnRzIiwic3JjL1NjZW5lcy9HbHV0dG9ueUxldmVsLnRzIiwic3JjL1NjZW5lcy9NYWluTWVudS50cyIsInNyYy9TY2VuZXMvU3BsYXNoU2NyZWVuLnRzIiwic3JjL1dvbGZpZTJEL0FJL0FJTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9BSS9TdGF0ZU1hY2hpbmVBSS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvRnVuY3Rpb25zL051bGxGdW5jLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvRWRnZU5vZGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGgudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9NYXAudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL01hdDR4NC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUGh5c2ljcy9BcmVhQ29sbGlzaW9uLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9QaHlzaWNzL0hpdC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUXVldWUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1JlbmRlcmluZy9XZWJHTFByb2dyYW1UeXBlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQi50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0NpcmNsZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGFjay50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlTWFjaGluZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMi50cyIsInNyYy9Xb2xmaWUyRC9EZWJ1Zy9EZWJ1Zy50cyIsInNyYy9Xb2xmaWUyRC9EZWJ1Zy9TdGF0cy50cyIsInNyYy9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlci50cyIsInNyYy9Xb2xmaWUyRC9FdmVudHMvRXZlbnRRdWV1ZS50cyIsInNyYy9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50LnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRUeXBlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9SZWNlaXZlci50cyIsInNyYy9Xb2xmaWUyRC9JbnB1dC9JbnB1dC50cyIsInNyYy9Xb2xmaWUyRC9JbnB1dC9JbnB1dEhhbmRsZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9FbnZpcm9ubWVudEluaXRpYWxpemVyLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvRml4ZWRVcGRhdGVHYW1lTG9vcC50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWUudHMiLCJzcmMvV29sZmllMkQvTG9vcC9HYW1lTG9vcC50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVPcHRpb25zLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0NhbnZhc05vZGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR2FtZU5vZGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpYy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvTGluZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9Qb2ludC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9SZWN0LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9TcHJpdGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVGlsZW1hcC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnQudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9CdXR0b24udHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlci50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoLnRzIiwic3JjL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdm1lc2gudHMiLCJzcmMvV29sZmllMkQvUGh5c2ljcy9CYXNpY1BoeXNpY3NNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1BoeXNpY3MvUGh5c2ljc01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGxheWJhY2svUmVjb3JkZXIudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cmllcy9SZWdpc3RyeS50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1NoYWRlclJlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvblR5cGVzLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuQ29udHJvbGxlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2Vlbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvR3JhcGhpY1JlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvVGlsZW1hcFJlbmRlcmVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9DYW52YXNSZW5kZXJpbmcvVUlFbGVtZW50UmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL0xhYmVsU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUG9pbnRTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9RdWFkU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUmVjdFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1Nwcml0ZVNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1NjZW5lR3JhcGgudHMiLCJzcmMvV29sZmllMkQvU2NlbmVHcmFwaC9TY2VuZUdyYXBoQXJyYXkudHMiLCJzcmMvV29sZmllMkQvU2NlbmVHcmFwaC9WaWV3cG9ydC50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvQ2FudmFzTm9kZUZhY3RvcnkudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL0ZhY3RvcnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9UaWxlbWFwRmFjdG9yeS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9MYXllcnMvVUlMYXllci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvU2NlbmVPcHRpb25zLnRzIiwic3JjL1dvbGZpZTJEL1NvdW5kL0F1ZGlvTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9UaW1pbmcvVGltZXIudHMiLCJzcmMvV29sZmllMkQvVGltaW5nL1RpbWVyTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9Db2xvci50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9FYXNlRnVuY3Rpb25zLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0dyYXBoVXRpbHMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvTWF0aFV0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL1JlbmRlcmluZ1V0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL1N0cmlu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UUFDcEIsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUIsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFlBQVksQ0FBQyxLQUFXO1FBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxLQUFXO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxHQUFHLENBQUMsS0FBVztRQUNkLE9BQU8sSUFBSSxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxLQUFXO1FBQ3JCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUMxQyxJQUFJLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENB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QyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUM1QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUMsSUFBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFDO2dCQUM1QyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQy9CO1NBQ0o7UUFDRCxJQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUMzQixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDNUMsSUFBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFDO2dCQUMzQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQzlCO1NBQ0o7UUFDRCxJQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUM3QixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDaEQsSUFBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFDO2dCQUM3QyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ2hDO1NBQ0o7UUFDRCxJQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztZQUM1QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDOUMsSUFBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFDO2dCQUM1QyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQy9CO1NBQ0o7UUFFRCxJQUFJLENBQUMsYUFB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RyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDMUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFdEMsUUFBUTtZQUNSLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFOUMsU0FBUztZQUNULElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDMUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFdEMsT0FBTztZQUNQLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN0QixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7WUFFN0IsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLENBQUMsQ0FBQTtRQUVELHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsR0FBRyxVQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3pFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFD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O1FBRUQsMkNBQTJDO1FBQzNDLElBQUksR0FBRyxHQUFHLGNBQUksQ0FBQyxJQUFJLENBQUM7UUFDcEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDMUQsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRTFDLDBEQUEwRDtRQUMxRCxHQUFHLENBQUMsQ0FBQyxHQUFHLG1CQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0RyxHQUFHLENBQUMsQ0FBQyxHQUFHLG1CQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUV0RywyQ0FBMkM7UUFDM0MsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQixHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTFCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQWM7UUFDakIscUJBQXFCO1FBQ3JCLElBQUcsSUFBSSxD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LENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQVM7UUFDMUIsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDLENBQVM7UUFDeEIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFTO1FBQ3ZCLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLENBQVM7UUFDM0IsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVELE1BQU0s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QUUsQ0FBQyxRQUFRLENBQUMsRUFBQztTQUNwQztLQUNKLENBQUE7SUFFRCwyQ0FBMkM7SUFDM0MsTUFBTSxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFL0IsaUJBQWlCO0lBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsc0JBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNqQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBRUwsU0FBUyxRQUFRLEtBQUcsQ0FBQztBQUFBLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJpbXBvcnQgU3RhdGVNYWNoaW5lQUkgZnJvbSBcIi4vLi4vV29sZmllMkQvQUkvU3RhdGVNYWNoaW5lQUlcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBTdGF0ZSBmcm9tIFwiLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IEJhdHRsZXJBSSBmcm9tIFwiLi9CYXR0bGVyQUlcIjtcclxuaW1wb3J0IEF0dGFjayBmcm9tIFwiLi9CYXRTdGF0ZXMvQXR0YWNrXCI7XHJcbmltcG9ydCBJZGxlIGZyb20gXCIuL0JhdFN0YXRlcy9JZGxlXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5lbXlBSSBleHRlbmRzIFN0YXRlTWFjaGluZUFJIGltcGxlbWVudHMgQmF0dGxlckFJIHtcclxuICAgIC8qKiBUaGUgb3duZXIgb2YgdGhpcyBBSSAqL1xyXG4gICAgb3duZXI6IEFuaW1hdGVkU3ByaXRlO1xyXG5cclxuICAgIC8qKiBUaGUgYW1vdW50IG9mIGhlYWx0aCB0aGlzIGVudGl0eSBoYXMgKi9cclxuICAgIGhlYWx0aDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgZGVmYXVsdCBtb3ZlbWVudCBzcGVlZCBvZiB0aGlzIEFJICovXHJcbiAgICBzcGVlZDogbnVtYmVyID0gMjA7XHJcblxyXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXIgb2JqZWN0ICovXHJcbiAgICBwbGF5ZXI6IEdhbWVOb2RlO1xyXG5cclxuICAgIGluaXRpYWxpemVBSShvd25lcjogQW5pbWF0ZWRTcHJpdGUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkU3RhdGUoRW5lbXlTdGF0ZXMuSURMRSwgbmV3IElkbGUodGhpcywgb3duZXIpKTtcclxuICAgICAgICB0aGlzLmFkZFN0YXRlKEVuZW15U3RhdGVzLkFUVEFDS0lORywgbmV3IEF0dGFjayh0aGlzLCBvd25lcikpO1xyXG5cclxuICAgICAgICB0aGlzLmhlYWx0aCA9IG9wdGlvbnMuaGVhbHRoO1xyXG5cclxuICAgICAgICB0aGlzLnBsYXllciA9IG9wdGlvbnMucGxheWVyO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRvIHRoZSBkZWZhdWx0IHN0YXRlXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKEVuZW15U3RhdGVzLkRFRkFVTFQpO1xyXG5cclxuICAgICAgICB0aGlzLmdldFBsYXllclBvc2l0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIGRhbWFnZShkYW1hZ2U6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVG9vayBkYW1hZ2VcIik7XHJcbiAgICAgICAgdGhpcy5oZWFsdGggLT0gZGFtYWdlO1xyXG4gICAgXHJcbiAgICAgICAgaWYodGhpcy5oZWFsdGggPD0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIuc2V0QUlBY3RpdmUoZmFsc2UsIHt9KTtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5pc0NvbGxpZGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vd25lci52aXNpYmxlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZihNYXRoLnJhbmRvbSgpIDwgMC4yKXtcclxuICAgICAgICAgICAgICAgIC8vIFNwYXduIGEgaGVhbHRocGFja1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChcImhlYWx0aHBhY2tcIiwge3Bvc2l0aW9uOiB0aGlzLm93bmVyLnBvc2l0aW9ufSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UGxheWVyUG9zaXRpb24oKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucGxheWVyLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG5ldyBwbGF5ZXIgbG9jYXRpb25cclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLm93bmVyLnBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gcG9zLmNsb25lKCkuc3ViKHN0YXJ0KTtcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0aWxlbWFwIHJlZ2lvbiB1bnRpbCB3ZSBmaW5kIGEgY29sbGlzaW9uXHJcbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihzdGFydC54LCBwb3MueCk7XHJcbiAgICAgICAgbGV0IG1heFggPSBNYXRoLm1heChzdGFydC54LCBwb3MueCk7XHJcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBwb3MueSk7XHJcbiAgICAgICAgbGV0IG1heFkgPSBNYXRoLm1heChzdGFydC55LCBwb3MueSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgd2FsbCB0aWxlbWFwXHJcbiAgICAgICAgbGV0IHdhbGxzID0gPE9ydGhvZ29uYWxUaWxlbWFwPnRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXRMYXllcihcIldhbGxcIikuZ2V0SXRlbXMoKVswXTtcclxuXHJcbiAgICAgICAgbGV0IG1pbkluZGV4ID0gd2FsbHMuZ2V0Q29sUm93QXQobmV3IFZlYzIobWluWCwgbWluWSkpO1xyXG4gICAgICAgIGxldCBtYXhJbmRleCA9IHdhbGxzLmdldENvbFJvd0F0KG5ldyBWZWMyKG1heFgsIG1heFkpKTtcclxuXHJcbiAgICAgICAgbGV0IHRpbGVTaXplID0gd2FsbHMuZ2V0VGlsZVNpemUoKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xyXG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XHJcbiAgICAgICAgICAgICAgICBpZih3YWxscy5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZVBvcyA9IG5ldyBWZWMyKGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54LzIsIHJvdyAqIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55LzIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjb2xsaWRlciBmb3IgdGhpcyB0aWxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gY29sbGlkZXIuaW50ZXJzZWN0U2VnbWVudChzdGFydCwgZGVsdGEsIFZlYzIuWkVSTyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhpdCAhPT0gbnVsbCAmJiBzdGFydC5kaXN0YW5jZVNxVG8oaGl0LnBvcykgPCBzdGFydC5kaXN0YW5jZVNxVG8ocG9zKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhpdCBhIHdhbGwsIHdlIGNhbid0IHNlZSB0aGUgcGxheWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0ZSBtYWNoaW5lIGRlZmVycyB1cGRhdGVzIGFuZCBldmVudCBoYW5kbGluZyB0byBpdHMgY2hpbGRyZW5cclxuICAgIC8vIENoZWNrIHN1cGVyIGNsYXNzZXMgZm9yIGRldGFpbHNcclxufVxyXG5cclxuZXhwb3J0IGVudW0gRW5lbXlTdGF0ZXMge1xyXG4gICAgREVGQVVMVCA9IFwiZGVmYXVsdFwiLFxyXG4gICAgSURMRSA9IFwiaWRsZVwiLFxyXG4gICAgQVRUQUNLSU5HID0gXCJhdHRhY2tpbmdcIixcclxuICAgIFBSRVZJT1VTID0gXCJwcmV2aW91c1wiXHJcbn0iLCJpbXBvcnQgQUFCQiBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL1RpbWluZy9UaW1lclwiO1xyXG5pbXBvcnQgQmF0QUksIHsgRW5lbXlTdGF0ZXMgfSBmcm9tIFwiLi4vQmF0QUlcIjtcclxuaW1wb3J0IEVuZW15U3RhdGUgZnJvbSBcIi4vRW5lbXlTdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0YWNrIGV4dGVuZHMgRW5lbXlTdGF0ZSB7XHJcbiAgICAvLyBUaW1lcnMgZm9yIG1hbmFnaW5nIHRoaXMgc3RhdGVcclxuICAgIHBvbGxUaW1lcjogVGltZXI7XHJcbiAgICBleGl0VGltZXI6IFRpbWVyO1xyXG5cclxuICAgIC8vIFRoZSBjdXJyZW50IGtub3duIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXJcclxuICAgIHBsYXllclBvczogVmVjMjtcclxuXHJcbiAgICAvLyBUaGUgbGFzdCBrbm93biBwb3NpdGlvbiBvZiB0aGUgcGxheWVyXHJcbiAgICBsYXN0UGxheWVyUG9zOiBWZWMyO1xyXG5cclxuICAgIC8vIFRoZSByZXR1cm4gb2JqZWN0IGZvciB0aGlzIHN0YXRlXHJcbiAgICByZXRPYmo6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBCYXRBSSwgb3duZXI6IEdhbWVOb2RlKXtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIG93bmVyKTtcclxuXHJcbiAgICAgICAgLy8gUmVndWxhcmx5IHVwZGF0ZSB0aGUgcGxheWVyIGxvY2F0aW9uXHJcbiAgICAgICAgdGhpcy5wb2xsVGltZXIgPSBuZXcgVGltZXIoMTAwKTtcclxuXHJcbiAgICAgICAgdGhpcy5leGl0VGltZXIgPSBuZXcgVGltZXIoMTAwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sYXN0UGxheWVyUG9zID0gdGhpcy5wYXJlbnQuZ2V0UGxheWVyUG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIHJldHVybiBvYmplY3RcclxuICAgICAgICB0aGlzLnJldE9iaiA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHt9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5wb2xsVGltZXIuaXNTdG9wcGVkKCkpe1xyXG4gICAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lclxyXG4gICAgICAgICAgICB0aGlzLnBvbGxUaW1lci5zdGFydCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wbGF5ZXJQb3MgPSB0aGlzLnBhcmVudC5nZXRQbGF5ZXJQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5wbGF5ZXJQb3MgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2VlIGEgbmV3IHBsYXllciBwb3NpdGlvbiwgdXBkYXRlIHRoZSBsYXN0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RQbGF5ZXJQb3MgPSB0aGlzLnBsYXllclBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5wbGF5ZXJQb3MgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAvLyBQbGF5ZXIgaXMgdmlzaWJsZSwgcmVzdGFydCB0aGUgZXhpdFRpbWVyXHJcbiAgICAgICAgICAgIHRoaXMuZXhpdFRpbWVyLnN0YXJ0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGYWNlIHBsYXllclxyXG4gICAgICAgICAgICBsZXQgZGlyID0gdGhpcy5wbGF5ZXJQb3MuY2xvbmUoKS5zdWIodGhpcy5vd25lci5wb3NpdGlvbikubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIGRpci5yb3RhdGVDQ1coTWF0aC5QSSAvIDQgKiBNYXRoLnJhbmRvbSgpIC0gTWF0aC5QSS84KTtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5yb3RhdGlvbiA9IFZlYzIuVVAuYW5nbGVUb0NDVyhkaXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5leGl0VGltZXIuaXNTdG9wcGVkKCkpe1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlbid0IHNlZW4gdGhlIHBsYXllciBpbiBhIHdoaWxlLCBnbyBjaGVjayBvdXQgd2hlcmUgd2UgbGFzdCBzYXcgdGhlbSwgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgaWYodGhpcy5sYXN0UGxheWVyUG9zICE9PSBudWxsKXtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEVuZW15U3RhdGVzLklETEUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXRPYmo7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IFN0YXRlIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZVwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IEVuZW15QUkgZnJvbSBcIi4uL0JhdEFJXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBFbmVteVN0YXRlIGV4dGVuZHMgU3RhdGUge1xyXG4gICAgcHJvdGVjdGVkIHBhcmVudDogRW5lbXlBSTtcclxuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBFbmVteUFJLCBvd25lcjogR2FtZU5vZGUpe1xyXG4gICAgICBzdXBlcihwYXJlbnQpO1xyXG4gICAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5pbXBvcnQgQmF0QUksIHsgRW5lbXlTdGF0ZXMgfSBmcm9tIFwiLi4vQmF0QUlcIjtcclxuaW1wb3J0IEVuZW15U3RhdGUgZnJvbSBcIi4vRW5lbXlTdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWRsZSBleHRlbmRzIEVuZW15U3RhdGUge1xyXG4gICAgcHJpdmF0ZSBzdGFydFBvc2l0aW9uOiBWZWMyO1xyXG5cclxuICAgIHByaXZhdGUgYXdheUZyb21TdGFydFBvc2l0aW9uOiBib29sZWFuO1xyXG5cclxuICAgIHByaXZhdGUgcmV0T2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQ6IEJhdEFJLCBvd25lcjogR2FtZU5vZGUpe1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgb3duZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLnBhcmVudC5nZXRQbGF5ZXJQb3NpdGlvbigpICE9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5BVFRBQ0tJTkcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0T2JqO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBBSSBmcm9tIFwiLi4vV29sZmllMkQvRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsYXllckNvbnRyb2xsZXIgaW1wbGVtZW50cyBBSSB7XHJcbiAgICAvLyBmaWVsZHMgZnJvbSBCYXR0bGVyQUlcclxuICAgIGhlYWx0aDogbnVtYmVyO1xyXG5cclxuICAgIC8vIHBsYXllciBzcHJpdGVcclxuICAgIG93bmVyOiBBbmltYXRlZFNwcml0ZTtcclxuXHJcbiAgICAvLyBNb3ZlbWVudFxyXG4gICAgcHJpdmF0ZSBkaXJlY3Rpb246IFZlYzI7XHJcbiAgICBwcml2YXRlIGN1cnJfdmVsb2NpdHk6IFZlYzI7XHJcbiAgICBwcml2YXRlIHNwZWVkOiBudW1iZXI7XHJcblxyXG4gICAgLy8gQXR0YWNraW5nXHJcbiAgICBwcml2YXRlIGF0dGFja19kaXJlY3Rpb246IFZlYzI7XHJcblxyXG4gICAgLy8gdW5pcXVlIGxldmVsIGZ1bmN0aW9uYWxpdGllc1xyXG4gICAgcHJpdmF0ZSBzbGlwcGVyeTogYm9vbGVhbjtcclxuXHJcbiAgICBpbml0aWFsaXplQUkob3duZXI6IEFuaW1hdGVkU3ByaXRlLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyXHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5jdXJyX3ZlbG9jaXR5ID0gVmVjMi5aRVJPOyAgICAgICAgIC8vIGZvciB1c2Ugd2l0aCBzbGlwcGVyeSBtb3ZlbWVudFxyXG4gICAgICAgIHRoaXMuYXR0YWNrX2RpcmVjdGlvbiA9IFZlYzIuWkVSTztcclxuICAgICAgICB0aGlzLnNwZWVkID0gb3B0aW9ucy5zcGVlZDtcclxuICAgICAgICB0aGlzLmhlYWx0aCA9IDU7XHJcbiAgICAgICAgdGhpcy5zbGlwcGVyeSA9IG9wdGlvbnMuc2xpcHBlcnkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2xpcHBlcnkgOiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBhY3RpdmF0ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG5cclxuICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHt9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBtb3ZlbWVudCBkaXJlY3Rpb25cclxuICAgICAgICB0aGlzLmRpcmVjdGlvbi54ID0gKElucHV0LmlzUHJlc3NlZChcImxlZnRcIikgPyAtMSA6IDApICsgKElucHV0LmlzUHJlc3NlZChcInJpZ2h0XCIpID8gMSA6IDApO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uLnkgPSAoSW5wdXQuaXNQcmVzc2VkKFwidXBcIikgPyAtMSA6IDApICsgKElucHV0LmlzUHJlc3NlZChcImRvd25cIikgPyAxIDogMCk7XHJcblxyXG4gICAgICAgIGlmKCF0aGlzLmRpcmVjdGlvbi5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLnNsaXBwZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzbGlwcGVyeSBtb3ZlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kaXJlY3Rpb24ueCAhPT0gMCkge3RoaXMuY3Vycl92ZWxvY2l0eS54ICs9IHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS54IC8gMjA7fVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7dGhpcy5jdXJyX3ZlbG9jaXR5LnggLT0gdGhpcy5jdXJyX3ZlbG9jaXR5Lm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS54IC8gNDA7fVxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kaXJlY3Rpb24ueSAhPT0gMCkge3RoaXMuY3Vycl92ZWxvY2l0eS55ICs9IHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS55IC8gMjA7fVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7dGhpcy5jdXJyX3ZlbG9jaXR5LnkgLT0gdGhpcy5jdXJyX3ZlbG9jaXR5Lm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS55IC8gNDA7fVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMub3duZXIubW92ZSh0aGlzLmN1cnJfdmVsb2NpdHkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheUlmTm90QWxyZWFkeShcIldBTEtcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3JtYWwgbW92ZW1lbnRcclxuICAgICAgICAgICAgICAgIHRoaXMub3duZXIubW92ZSh0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemVkKCkuc2NhbGUodGhpcy5zcGVlZCAqIGRlbHRhVCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheUlmTm90QWxyZWFkeShcIldBTEtcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUGxheWVyIGlzIGlkbGVcclxuICAgICAgICAgICAgaWYodGhpcy5zbGlwcGVyeSAmJiAoTWF0aC5hYnModGhpcy5jdXJyX3ZlbG9jaXR5LngpID4gMCB8fCBNYXRoLmFicyh0aGlzLmN1cnJfdmVsb2NpdHkueSkgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2xpZGUgYSBiaXRcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic2xpZGUgY2FwIHVwXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuY3Vycl92ZWxvY2l0eS54IC09IHRoaXMuY3Vycl92ZWxvY2l0eS5ub3JtYWxpemVkKCkuc2NhbGUodGhpcy5zcGVlZCAqIGRlbHRhVCkueCAvIDQwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyX3ZlbG9jaXR5LnkgLT0gdGhpcy5jdXJyX3ZlbG9jaXR5Lm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS55IC8gNDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnModGhpcy5jdXJyX3ZlbG9jaXR5LngpIDwgLjA1KSB7dGhpcy5jdXJyX3ZlbG9jaXR5LnggPSAwO31cclxuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKHRoaXMuY3Vycl92ZWxvY2l0eS55KSA8IC4wNSkge3RoaXMuY3Vycl92ZWxvY2l0eS55ID0gMDt9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5tb3ZlKHRoaXMuY3Vycl92ZWxvY2l0eSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFwiV0FMS1wiLCB0cnVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXlJZk5vdEFscmVhZHkoXCJJRExFXCIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHVuaXQgdmVjdG9yIGluIHRoZSBhdHRhY2sgZGlyZWN0aW9uXHJcbiAgICAgICAgdGhpcy5hdHRhY2tfZGlyZWN0aW9uID0gdGhpcy5vd25lci5wb3NpdGlvbi5kaXJUbyhJbnB1dC5nZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCkpO1xyXG5cclxuICAgICAgICAvLyBwdW5jaCBhdHRhY2tcclxuICAgICAgICBpZihJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBpbXBsZW1lbnQgcHVuY2ggYXR0YWNrIGhlcmVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwdW5jaCBldmVudFwiKTtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheShcIkFUVEFDS1wiLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGhhdmUgcGxheWVyIGZhY2UgbGVmdCBvciByaWdodFxyXG4gICAgICAgIGxldCBtb3VzZV9wb3NpdGlvbiA9IElucHV0LmdldEdsb2JhbE1vdXNlUG9zaXRpb24oKTtcclxuICAgICAgICBpZihtb3VzZV9wb3NpdGlvbi54IDwgdGhpcy5vd25lci5wb3NpdGlvbi54KSB7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIuaW52ZXJ0WCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5pbnZlcnRYID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBkYW1hZ2UoZGFtYWdlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmhlYWx0aCAtPSBkYW1hZ2U7XHJcbiAgICAgICAgaWYodGhpcy5oZWFsdGggPD0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdhbWUgT3ZlclwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5vd25lcjtcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XHJcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuLi9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZtZXNoXCI7XHJcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4uL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL1dvbGZpZTJEL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBQbGF5ZXJDb250cm9sbGVyIGZyb20gXCIuLi9BSS9QbGF5ZXJDb250cm9sbGVyXCI7XHJcbmltcG9ydCBCYXRBSSBmcm9tIFwiLi4vQUkvQmF0QUlcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdsdXR0b255TGV2ZWwgZXh0ZW5kcyBTY2VuZSB7XHJcbiAgICBwcml2YXRlIHBsYXllcjogQW5pbWF0ZWRTcHJpdGU7ICAgICAgICAgLy8gdGhlIHBsYXllclxyXG4gICAgcHJpdmF0ZSBlbmVtaWVzOiBBcnJheTxBbmltYXRlZFNwcml0ZT4gIC8vIGxpc3Qgb2YgZW5lbWllc1xyXG4gICAgcHJpdmF0ZSB3YWxsczogT3J0aG9nb25hbFRpbGVtYXAgICAgICAgIC8vIHRoZSB3YWxsIGxheWVyXHJcblxyXG4gICAgLy8gdXNlIGluaXRTY2VuZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbGV2ZWwgc2VsZWN0IHN0YXJ0IGFuZCBnYW1lIGNvbnRpbnVlP1xyXG4gICAgXHJcbiAgICBsb2FkU2NlbmUoKSB7XHJcbiAgICAgICAgLy8gbG9hZCB0aGUgcGxheWVyIGFuZCBlbmVteSBzcHJpdGVzaGVldHNcclxuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJwbGF5ZXJcIiwgXCJnYW1lX2Fzc2V0cy9zcHJpdGVzaGVldHMvemFyYS5qc29uXCIpO1xyXG4gICAgICAgIC8vIFRPRE8gUFJPSkVDVCAtIGFkZCBlbmVteSBzcHJpdGVzaGVldHNcclxuICAgICAgICAvLyBMb2FkIGluIHRoZSBlbmVteSBpbmZvXHJcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiYmF0XCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlc2hlZXRzL2hlbGxiYXQuanNvblwiKTtcclxuICAgICAgICB0aGlzLmxvYWQub2JqZWN0KFwiZW5lbXlEYXRhXCIsIFwiZ2FtZV9hc3NldHMvZGF0YS9lbmVteS5qc29uXCIpO1xyXG4gICAgICAgIC8vIGxvYWQgdGhlIHRpbGVtYXBcclxuICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBzd2l0Y2ggd2l0aCBjb3JyZWN0IHRpbGVtYXBcclxuICAgICAgICB0aGlzLmxvYWQudGlsZW1hcChcImdsdXR0b255TGV2ZWxcIiwgXCJnYW1lX2Fzc2V0cy90aWxlbWFwcy9oZWxsc19mdXJ5Lmpzb25cIik7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRTY2VuZSgpIHtcclxuICAgICAgICAvLyBBZGQgaW4gdGhlIHRpbGVtYXBcclxuICAgICAgICBsZXQgdGlsZW1hcF9sYXllcnMgPSB0aGlzLmFkZC50aWxlbWFwKFwiZ2x1dHRvbnlMZXZlbFwiKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSB3YWxsIGxheWVyXHJcbiAgICAgICAgdGhpcy53YWxscyA9IDxPcnRob2dvbmFsVGlsZW1hcD50aWxlbWFwX2xheWVyc1sxXS5nZXRJdGVtcygpWzBdO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIHZpZXdwb3J0IGJvdW5kcyB0byB0aGUgdGlsZW1hcFxyXG4gICAgICAgIGxldCB0aWxlbWFwX3NpemU6IFZlYzIgPSB0aGlzLndhbGxzLnNpemU7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgdGlsZW1hcF9zaXplLngsIHRpbGVtYXBfc2l6ZS55KTtcclxuXHJcbiAgICAgICAgLy8gYWRkIHByaW1hcnkgbGF5ZXJcclxuICAgICAgICB0aGlzLmFkZExheWVyKFwicHJpbWFyeVwiLCAxMCk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVBsYXllcigpO1xyXG5cclxuICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSB3cml0ZSBpbml0aWFsaXplRW5lbWllcygpXHJcbiAgICAgICAgLy8gdGhpcy5pbml0aWFsaXplRW5lbWllcygpO1xyXG5cclxuICAgICAgICAvLyBzZXR1cCB2aWV3cG9ydFxyXG4gICAgICAgIHRoaXMudmlld3BvcnQuZm9sbG93KHRoaXMucGxheWVyKTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldFpvb21MZXZlbCgzKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETyBQUk9KRUNUIC0gcmVjZWl2ZXIgc3Vic2NyaWJlIHRvIGV2ZW50c1xyXG4gICAgICAgIC8vIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKEVWRU5UU1RSSU5HKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGluaXRpYWxpemVQbGF5ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBwbGF5ZXJcclxuICAgICAgICB0aGlzLnBsYXllciA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKFwicGxheWVyXCIsIFwicHJpbWFyeVwiKTtcclxuICAgICAgICB0aGlzLnBsYXllci5wb3NpdGlvbi5zZXQoMzAqMTYsIDYyKjE2KTtcclxuICAgICAgICB0aGlzLnBsYXllci5hZGRQaHlzaWNzKG5ldyBBQUJCKG5ldyBWZWMyKDAsIDE0KSwgbmV3IFZlYzIoOCwgMTApKSk7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIuYWRkQUkoUGxheWVyQ29udHJvbGxlcixcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3BlZWQ6IDE1MCxcclxuICAgICAgICAgICAgICAgIHNsaXBwZXJ5OiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucGxheWVyLmFuaW1hdGlvbi5wbGF5KFwiSURMRVwiLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0aWFsaXplRW5lbWllcygpe1xyXG4gICAgICAgIC8vIEdldCB0aGUgZW5lbXkgZGF0YVxyXG4gICAgICAgIGNvbnN0IGVuZW15RGF0YSA9IHRoaXMubG9hZC5nZXRPYmplY3QoXCJlbmVteURhdGFcIik7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhbiBlbmVtaWVzIGFycmF5XHJcbiAgICAgICAgdGhpcy5lbmVtaWVzID0gbmV3IEFycmF5KGVuZW15RGF0YS5udW1FbmVtaWVzKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZW5lbWllc1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbmVteURhdGEubnVtRW5lbWllczsgaSsrKXtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBlbmVteURhdGEuZW5lbWllc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBlbmVteVxyXG4gICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0gPSB0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShcImhlbGxiYXRcIiwgXCJwcmltYXJ5XCIpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0ucG9zaXRpb24uc2V0KGRhdGEucG9zaXRpb25bMF0sIGRhdGEucG9zaXRpb25bMV0pO1xyXG4gICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0uYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWN0aXZhdGUgcGh5c2ljc1xyXG4gICAgICAgICAgICAvL09ubHkgb25lIGVuZW15IGZvciBub3dcclxuICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig1LCA1KSkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGxldCBlbmVteU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICBoZWFsdGg6IGRhdGEuaGVhbHRoLFxyXG4gICAgICAgICAgICAgICAgcGxheWVyOiB0aGlzLnBsYXllcixcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldLmFkZEFJKEJhdEFJLCBlbmVteU9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBHbHV0dG9ueUxldmVsIGZyb20gXCIuL0dsdXR0b255TGV2ZWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5NZW51IGV4dGVuZHMgU2NlbmUge1xyXG4gICAgcHJpdmF0ZSBtYWluX21lbnU6IExheWVyO1xyXG4gICAgcHJpdmF0ZSBsZXZlbF9zZWxlY3Q6IExheWVyO1xyXG4gICAgcHJpdmF0ZSBoZWxwOiBMYXllcjtcclxuICAgIHByaXZhdGUgY29udHJvbHM6IExheWVyO1xyXG5cclxuICAgIGxvYWRTY2VuZSgpIHtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJtYWluTWVudUltYWdlXCIsIFwiZ2FtZV9hc3NldHMvaW1hZ2VzL21haW5fbWVudV9iYWNrZ3JvdW5kLnBuZ1wiKTtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJsZXZlbFNlbGVjdEltYWdlXCIsIFwiZ2FtZV9hc3NldHMvaW1hZ2VzL2xldmVsX3NlbGVjdF9iYWNrZ3JvdW5kLnBuZ1wiKTtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJoZWxwSW1hZ2VcIiwgXCJnYW1lX2Fzc2V0cy9pbWFnZXMvaGVscF9iYWNrZ3JvdW5kLnBuZ1wiKTtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJjb250cm9sc0ltYWdlXCIsIFwiZ2FtZV9hc3NldHMvaW1hZ2VzL2NvbnRyb2xzX2JhY2tncm91bmQucG5nXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0U2NlbmUoKSB7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGJ1dHRvbiBldmVudHNcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcIm5ld0dhbWVcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJsZXZlbFNlbGVjdFwiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImhlbHBcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJjb250cm9sc1wiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcIm1haW5NZW51XCIpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwibGV2ZWxHbHV0dG9ueVwiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImxldmVsTHVzdFwiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImxldmVsV3JhdGhcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJsZXZlbEdyZWVkXCIpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwibGV2ZWxTbG90aFwiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImxldmVsRW52eVwiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImxldmVsUHJpZGVcIik7XHJcblxyXG4gICAgICAgIC8qICMjIyMjIyMjIyMjIyMjIyMgTUFJTiBNRU5VICMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgICAgICAvLyBjcmVhdGUgbWFpbiBtZW51IGxheWVyXHJcbiAgICAgICAgdGhpcy5tYWluX21lbnUgPSB0aGlzLmFkZFVJTGF5ZXIoXCJtYWluTWVudVwiKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIG1haW4gbWVudSBiYWNrZ3JvdW5kIGltYWdlXHJcbiAgICAgICAgbGV0IG1tYiA9IHRoaXMuYWRkLnNwcml0ZShcIm1haW5NZW51SW1hZ2VcIiwgXCJtYWluTWVudVwiKTtcclxuICAgICAgICBtbWIucG9zaXRpb24uc2V0KG1tYi5zaXplLngvMiwgbW1iLnNpemUueS8yKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIG5ldyBnYW1lIGJ1dHRvbiwgYW5kIGdpdmUgaXQgYW4gZXZlbnQgdG8gZW1pdCBvbiBwcmVzc1xyXG4gICAgICAgIGNvbnN0IG5ld19nYW1lX2J1dHRvbiA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMTQsIGNlbnRlci55IC0gMTcwKSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIG5ld19nYW1lX2J1dHRvbi5zaXplLnNldCgzMzAsIDcwKTtcclxuICAgICAgICBuZXdfZ2FtZV9idXR0b24uYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIG5ld19nYW1lX2J1dHRvbi5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIG5ld19nYW1lX2J1dHRvbi5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBuZXdfZ2FtZV9idXR0b24ub25DbGlja0V2ZW50SWQgPSBcIm5ld0dhbWVcIjtcclxuXHJcbiAgICAgICAgLy8gQWRkIGxldmVsIHNlbGVjdCBidXR0b25cclxuICAgICAgICBjb25zdCBsZXZlbF9zZWxlY3RfYnV0dG9uID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcIm1haW5NZW51XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAxMywgY2VudGVyLnkgLSA2MCksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfYnV0dG9uLnNpemUuc2V0KDQyMCwgNzApO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9idXR0b24uYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9idXR0b24uYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfYnV0dG9uLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9idXR0b24ub25DbGlja0V2ZW50SWQgPSBcImxldmVsU2VsZWN0XCI7XHJcblxyXG4gICAgICAgIC8vIEFkZCBoZWxwIGJ1dHRvblxyXG4gICAgICAgIGNvbnN0IGhlbHBfYnV0dG9uID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcIm1haW5NZW51XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAyMSwgY2VudGVyLnkgKyA1NSksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBoZWxwX2J1dHRvbi5zaXplLnNldCgxNDUsIDc1KTtcclxuICAgICAgICBoZWxwX2J1dHRvbi5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgaGVscF9idXR0b24uYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBoZWxwX2J1dHRvbi5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBoZWxwX2J1dHRvbi5vbkNsaWNrRXZlbnRJZCA9IFwiaGVscFwiO1xyXG5cclxuICAgICAgICAvLyBBZGQgY29udHJvbHNcclxuICAgICAgICBjb25zdCBjb250cm9sc19idXR0b24gPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibWFpbk1lbnVcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDEzLCBjZW50ZXIueSArIDE1MCksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBjb250cm9sc19idXR0b24uc2l6ZS5zZXQoMjY4LCA3MCk7XHJcbiAgICAgICAgY29udHJvbHNfYnV0dG9uLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBjb250cm9sc19idXR0b24uYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBjb250cm9sc19idXR0b24uYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgY29udHJvbHNfYnV0dG9uLm9uQ2xpY2tFdmVudElkID0gXCJjb250cm9sc1wiO1xyXG5cclxuXHJcbiAgICAgICAgLyogIyMjIyMjIyMjIyMjIyMjIyBMRVZFTCBTRUxFQ1QgIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgICAgIC8vIGNyZWF0ZSBsZXZlbCBzZWxlY3QgbGF5ZXJcclxuICAgICAgICB0aGlzLmxldmVsX3NlbGVjdCA9IHRoaXMuYWRkVUlMYXllcihcImxldmVsU2VsZWN0XCIpO1xyXG4gICAgICAgIHRoaXMubGV2ZWxfc2VsZWN0LnNldEhpZGRlbih0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGxldmVsIHNlbGVjdCBiYWNrZ3JvdW5kIGltYWdlXHJcbiAgICAgICAgbGV0IGxzYiA9IHRoaXMuYWRkLnNwcml0ZShcImxldmVsU2VsZWN0SW1hZ2VcIiwgXCJsZXZlbFNlbGVjdFwiKTtcclxuICAgICAgICBsc2IucG9zaXRpb24uc2V0KGxzYi5zaXplLngvMiwgbHNiLnNpemUueS8yKTtcclxuXHJcbiAgICAgICAgY29uc3QgbGV2ZWxfc2VsZWN0X2JhY2sgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxTZWxlY3RcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCArIDUxOCwgY2VudGVyLnkgKyAzMDgpLCB0ZXh0OiBcIlwifSk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2JhY2suc2l6ZS5zZXQoMTY4LCA2NSk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2JhY2suYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9iYWNrLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2JhY2suYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2JhY2sub25DbGlja0V2ZW50SWQgPSBcIm1haW5NZW51XCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGxldmVsX3NlbGVjdF9nbHV0dG9ueSA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbFNlbGVjdFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMjAsIGNlbnRlci55IC0gMTk1KSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9nbHV0dG9ueS5zaXplLnNldCgyODUsIDc1KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZ2x1dHRvbnkuYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9nbHV0dG9ueS5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9nbHV0dG9ueS5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZ2x1dHRvbnkub25DbGlja0V2ZW50SWQgPSBcImxldmVsR2x1dHRvbnlcIjtcclxuXHJcbiAgICAgICAgY29uc3QgbGV2ZWxfc2VsZWN0X2x1c3QgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxTZWxlY3RcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDI3LCBjZW50ZXIueSAtIDk1KSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9sdXN0LnNpemUuc2V0KDE0MCwgNTgpO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9sdXN0LmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfbHVzdC5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9sdXN0LmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9sdXN0Lm9uQ2xpY2tFdmVudElkID0gXCJsZXZlbEx1c3RcIjtcclxuXHJcbiAgICAgICAgY29uc3QgbGV2ZWxfc2VsZWN0X3dyYXRoID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsU2VsZWN0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAyMSwgY2VudGVyLnkgKyAzKSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF93cmF0aC5zaXplLnNldCgxNjQsIDU0KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfd3JhdGguYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF93cmF0aC5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF93cmF0aC5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfd3JhdGgub25DbGlja0V2ZW50SWQgPSBcImxldmVsV3JhdGhcIjtcclxuXHJcbiAgICAgICAgY29uc3QgbGV2ZWxfc2VsZWN0X2dyZWVkID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsU2VsZWN0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAyMSwgY2VudGVyLnkgKyA4NSksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZ3JlZWQuc2l6ZS5zZXQoMTUwLCA1MCk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2dyZWVkLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZ3JlZWQuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZ3JlZWQuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2dyZWVkLm9uQ2xpY2tFdmVudElkID0gXCJsZXZlbEdyZWVkXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGxldmVsX3NlbGVjdF9zbG90aCA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbFNlbGVjdFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMTksIGNlbnRlci55ICsgMTYwKSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9zbG90aC5zaXplLnNldCgxMzUsIDUwKTtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfc2xvdGguYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9zbG90aC5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9zbG90aC5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfc2xvdGgub25DbGlja0V2ZW50SWQgPSBcImxldmVsU2xvdGhcIjtcclxuXHJcbiAgICAgICAgY29uc3QgbGV2ZWxfc2VsZWN0X2VudnkgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxTZWxlY3RcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDIwLCBjZW50ZXIueSArIDIzMCksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZW52eS5zaXplLnNldCgxMTQsIDUwKTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZW52eS5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2VudnkuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZW52eS5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZW52eS5vbkNsaWNrRXZlbnRJZCA9IFwibGV2ZWxFbnZ5XCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGxldmVsX3NlbGVjdF9wcmlkZSA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbFNlbGVjdFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMjIsIGNlbnRlci55ICsgMjk1KSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9wcmlkZS5zaXplLnNldCgxMDcsIDQ3KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfcHJpZGUuYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9wcmlkZS5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9wcmlkZS5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfcHJpZGUub25DbGlja0V2ZW50SWQgPSBcImxldmVsUHJpZGVcIjtcclxuXHJcbiAgICAgICAgLyogIyMjIyMjIyMjIyMjIyMjIyBIRUxQICMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgICAgICAvLyBjcmVhdGUgaGVscCBsYXllclxyXG4gICAgICAgIHRoaXMuaGVscCA9IHRoaXMuYWRkVUlMYXllcihcImhlbHBcIik7XHJcbiAgICAgICAgdGhpcy5oZWxwLnNldEhpZGRlbih0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGhlbHAgYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgICAgIGxldCBoYiA9IHRoaXMuYWRkLnNwcml0ZShcImhlbHBJbWFnZVwiLCBcImhlbHBcIik7XHJcbiAgICAgICAgaGIucG9zaXRpb24uc2V0KGhiLnNpemUueC8yLCBoYi5zaXplLnkvMik7XHJcblxyXG4gICAgICAgIGNvbnN0IGhlbHBfYmFjayA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJoZWxwXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggKyA1MTgsIGNlbnRlci55ICsgMzA4KSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGhlbHBfYmFjay5zaXplLnNldCgxNjgsIDY1KTtcclxuICAgICAgICBoZWxwX2JhY2suYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGhlbHBfYmFjay5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGhlbHBfYmFjay5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBoZWxwX2JhY2sub25DbGlja0V2ZW50SWQgPSBcIm1haW5NZW51XCI7XHJcblxyXG4gICAgICAgIC8qICMjIyMjIyMjIyMjIyMjIyMgQ09OVFJPTFMgIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgICAgIC8vIGNyZWF0ZSBjb250cm9scyBsYXllclxyXG4gICAgICAgIHRoaXMuY29udHJvbHMgPSB0aGlzLmFkZFVJTGF5ZXIoXCJjb250cm9sc1wiKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xzLnNldEhpZGRlbih0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gYWRkIGNvbnRyb2xzIGJhY2tncm91bmQgaW1hZ2VcclxuICAgICAgICBsZXQgY2IgPSB0aGlzLmFkZC5zcHJpdGUoXCJjb250cm9sc0ltYWdlXCIsIFwiY29udHJvbHNcIik7XHJcbiAgICAgICAgY2IucG9zaXRpb24uc2V0KGNiLnNpemUueC8yLCBjYi5zaXplLnkvMik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzX2JhY2sgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwiY29udHJvbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCArIDUxOCwgY2VudGVyLnkgKyAzMDgpLCB0ZXh0OiBcIlwifSk7XHJcbiAgICAgICAgY29udHJvbHNfYmFjay5zaXplLnNldCgxNjgsIDY1KTtcclxuICAgICAgICBjb250cm9sc19iYWNrLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBjb250cm9sc19iYWNrLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgY29udHJvbHNfYmFjay5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBjb250cm9sc19iYWNrLm9uQ2xpY2tFdmVudElkID0gXCJtYWluTWVudVwiO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVNjZW5lKCkge1xyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuICAgICAgICAgICAgLy8gbGV0IHNjZW5lX29wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIC8vICAgICBwaHlzaWNzOiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgZ3JvdXBOYW1lczogW1wiZ3JvdW5kXCIsIFwicGxheWVyXCJdLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIGNvbGxpc2lvbnM6IFtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgWzAsIDFdLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBbMSwgMF1cclxuICAgICAgICAgICAgLy8gICAgICAgICBdXHJcbiAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibmV3R2FtZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBzZXR1cCBuZXcgZ2FtZSBzY2VuZSBmcm9tIGhlcmUgKG1heWJlIGFkZCBvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJOZXcgR2FtZSBFdmVudCBubyBzY2VuZV9vcHRpb25zXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShHbHV0dG9ueUxldmVsLCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibWFpbk1lbnVcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYWluIE1lbnUgRXZlbnRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5fbWVudS5zZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbF9zZWxlY3Quc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwLnNldEhpZGRlbih0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImxldmVsU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTGV2ZWwgU2VsZWN0IEV2ZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluX21lbnUuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbF9zZWxlY3Quc2V0SGlkZGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJoZWxwXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSGVscCBFdmVudFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbl9tZW51LnNldEhpZGRlbih0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVscC5zZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImNvbnRyb2xzXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29udHJvbHMgRXZlbnRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5fbWVudS5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNldEhpZGRlbihmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibGV2ZWxHbHV0dG9ueVwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBnbyB0byBnbHV0dG9ueSBsZXZlbCAobGV2ZWwgMSlcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR2x1dHRvbnkgTGV2ZWxcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKEdsdXR0b255TGV2ZWwsIHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImxldmVsTHVzdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBnbyB0byBsdXN0IGxldmVsIChsZXZlbCAyKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMdXN0IExldmVsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibGV2ZWxXcmF0aFwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBnbyB0byB3cmF0aCBsZXZlbCAobGV2ZWwgMylcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV3JhdGggTGV2ZWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJsZXZlbEdyZWVkXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gUFJPSkVDVCAtIGdvIHRvIGdyZWVkIGxldmVsIChsZXZlbCA0KVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHcmVlZCBMZXZlbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImxldmVsU2xvdGhcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQUk9KRUNUIC0gZ28gdG8gc2xvdGggbGV2ZWwgKGxldmVsIDUpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNsb3RoIExldmVsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibGV2ZWxFbnZ5XCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gUFJPSkVDVCAtIGdvIHRvIGVudnkgbGV2ZWwgKGxldmVsIDYpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVudnkgTGV2ZWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJsZXZlbFByaWRlXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gUFJPSkVDVCAtIGdvIHRvIHByaWRlIGxldmVsIChsZXZlbCA3KVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcmlkZSBMZXZlbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9NYWluTWVudVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsYXNoU2NyZWVuIGV4dGVuZHMgU2NlbmUge1xyXG4gICAgcHJpdmF0ZSBzcGxhc2g6IExheWVyO1xyXG4gICAgcHJpdmF0ZSBzcGxhc2hfYmFja2dyb3VuZDogTGF5ZXI7XHJcblxyXG4gICAgbG9hZFNjZW5lKCkge1xyXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcInNwbGFzaEltYWdlXCIsIFwiZ2FtZV9hc3NldHMvaW1hZ2VzL3NwbGFzaF9zY3JlZW4ucG5nXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0U2NlbmUoKSB7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNwbGFzaCBzY3JlZW5cclxuICAgICAgICB0aGlzLnNwbGFzaCA9IHRoaXMuYWRkVUlMYXllcihcInNwbGFzaFNjcmVlblwiKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGEgYmFja2dyb3VuZCB0byB0aGUgc2NlbmVcclxuICAgICAgICB0aGlzLnNwbGFzaF9iYWNrZ3JvdW5kID0gdGhpcy5hZGRQYXJhbGxheExheWVyKFwic3BsYXNoX2JhY2tncm91bmRcIiwgbmV3IFZlYzIoMC41LCAxKSwgLTEpO1xyXG4gICAgICAgIGxldCBzYiA9IHRoaXMuYWRkLnNwcml0ZShcInNwbGFzaEltYWdlXCIsIFwic3BsYXNoX2JhY2tncm91bmRcIik7XHJcbiAgICAgICAgc2IucG9zaXRpb24uc2V0KHNiLnNpemUueC8yLCBzYi5zaXplLnkvMik7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0cmFuc3BhcmVudCBidXR0b25cclxuICAgICAgICBjb25zdCBjb25maXJtID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcInNwbGFzaFNjcmVlblwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBjb25maXJtLnNpemUuc2V0KDEyODAsIDcyMCk7XHJcbiAgICAgICAgY29uZmlybS5ib3JkZXJXaWR0aCA9IDA7XHJcbiAgICAgICAgY29uZmlybS5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGNvbmZpcm0uYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgY29uZmlybS5vbkNsaWNrRXZlbnRJZCA9IFwiY29uZmlybVwiO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgYnV0dG9uIGV2ZW50c1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiY29uZmlybVwiKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY2VuZSgpIHtcclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XHJcbiAgICAgICAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImNvbmZpcm1cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGxhc2hfYmFja2dyb3VuZC5kaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKE1haW5NZW51LCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCBBY3RvciBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcblxyXG4vKipcclxuICogQSBtYW5hZ2VyIGNsYXNzIGZvciBhbGwgb2YgdGhlIEFJIGluIGEgc2NlbmUuXHJcbiAqIEtlZXBzIGEgbGlzdCBvZiByZWdpc3RlcmVkIGFjdG9ycyBhbmQgaGFuZGxlcyBBSSBnZW5lcmF0aW9uIGZvciBhY3RvcnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBSU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHQvKiogVGhlIGFycmF5IG9mIHJlZ2lzdGVyZWQgYWN0b3JzICovXHJcblx0YWN0b3JzOiBBcnJheTxBY3Rvcj47XHJcblx0LyoqIE1hcHMgQUkgbmFtZXMgdG8gdGhlaXIgY29uc3RydWN0b3JzICovXHJcblx0cmVnaXN0ZXJlZEFJOiBNYXA8QUlDb25zdHJ1Y3Rvcj47XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLmFjdG9ycyA9IG5ldyBBcnJheSgpO1xyXG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkgPSBuZXcgTWFwKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgYW4gYWN0b3Igd2l0aCB0aGUgQUlNYW5hZ2VyXHJcblx0ICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byByZWdpc3RlclxyXG5cdCAqL1xyXG5cdHJlZ2lzdGVyQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcclxuXHR9XHJcblxyXG5cdHJlbW92ZUFjdG9yKGFjdG9yOiBBY3Rvcik6IHZvaWQge1xyXG5cdFx0bGV0IGluZGV4ID0gdGhpcy5hY3RvcnMuaW5kZXhPZihhY3Rvcik7XHJcblxyXG5cdFx0aWYoaW5kZXggIT09IC0xKXtcclxuXHRcdFx0dGhpcy5hY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhbiBBSSB3aXRoIHRoZSBBSU1hbmFnZXIgZm9yIHVzZSBsYXRlciBvblxyXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byByZWdpc3RlclxyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgQUlcclxuXHQgKi9cclxuXHRyZWdpc3RlckFJKG5hbWU6IHN0cmluZywgY29uc3RyOiBuZXcgPFQgZXh0ZW5kcyBBST4oKSA9PiBUICk6IHZvaWQge1xyXG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkuYWRkKG5hbWUsIGNvbnN0cik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYW4gQUkgaW5zdGFuY2UgZnJvbSBpdHMgbmFtZVxyXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byBhZGRcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBBSSBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlQUkobmFtZTogc3RyaW5nKTogQUkge1xyXG5cdFx0aWYodGhpcy5yZWdpc3RlcmVkQUkuaGFzKG5hbWUpKXtcclxuXHRcdFx0cmV0dXJuIG5ldyAodGhpcy5yZWdpc3RlcmVkQUkuZ2V0KG5hbWUpKSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhyb3cgYENhbm5vdCBjcmVhdGUgQUkgd2l0aCBuYW1lICR7bmFtZX0sIG5vIEFJIHdpdGggdGhhdCBuYW1lIGlzIHJlZ2lzdGVyZWRgO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBSdW4gdGhlIGFpIGZvciBldmVyeSBhY3RpdmUgYWN0b3JcclxuXHRcdHRoaXMuYWN0b3JzLmZvckVhY2goYWN0b3IgPT4geyBpZihhY3Rvci5haUFjdGl2ZSkgYWN0b3IuYWkudXBkYXRlKGRlbHRhVCkgfSk7XHJcblx0fVxyXG59XHJcblxyXG50eXBlIEFJQ29uc3RydWN0b3IgPSBuZXcgPFQgZXh0ZW5kcyBBST4oKSA9PiBUOyIsImltcG9ydCBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcclxuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1N0YXRlL1N0YXRlTWFjaGluZVwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcblxyXG4vKipcclxuICogQSB2ZXJzaW9uIG9mIGEgQHJlZmVyZW5jZVtTdGF0ZU1hY2hpbmVdIHRoYXQgaXMgY29uZmlndXJlZCB0byB3b3JrIGFzIGFuIEFJIGNvbnRyb2xsZXIgZm9yIGEgQHJlZmVyZW5jZVtHYW1lTm9kZV1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTWFjaGluZUFJIGV4dGVuZHMgU3RhdGVNYWNoaW5lIGltcGxlbWVudHMgQUkge1xyXG5cdC8qKlx0VGhlIEdhbWVOb2RlIHRoYXQgdXNlcyB0aGlzIFN0YXRlTWFjaGluZSBmb3IgaXRzIEFJICovXHJcblx0cHJvdGVjdGVkIG93bmVyOiBHYW1lTm9kZTtcclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0aW5pdGlhbGl6ZUFJKG93bmVyOiBHYW1lTm9kZSwgY29uZmlnOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRkZXN0cm95KCl7XHJcblx0XHQvLyBHZXQgcmlkIG9mIG91ciByZWZlcmVuY2UgdG8gdGhlIG93bmVyXHJcblx0XHRkZWxldGUgdGhpcy5vd25lcjtcclxuXHRcdHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0YWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cclxufSIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogQSBwbGFjZWhvbGRlciBmdW5jdGlvbiBmb3IgTm8gT3BlcmF0aW9uLiBEb2VzIG5vdGhpbmdcclxuICovXHJcbmNvbnN0IE51bGxGdW5jID0gKCkgPT4ge307XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOdWxsRnVuYzsiLCIvKipcclxuICogQSBsaW5rZWQtbGlzdCBmb3IgdGhlIGVkZ2VzIGluIGEgQHJlZmVyZW5jZVtHcmFwaF0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGdlTm9kZSB7XHJcbiAgICAvKiogVGhlIG5vZGUgaW4gdGhlIEdyYXBoIHRoaXMgZWRnZSBjb25uZWN0cyB0byAqL1xyXG4gICAgeTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSB3ZWlnaHQgb2YgdGhpcyBFZGdlTm9kZSAqL1xyXG5cdHdlaWdodDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBuZXh0IEVkZ2VOb2RlIGluIHRoZSBsaW5rZWQtbGlzdCAqL1xyXG4gICAgbmV4dDogRWRnZU5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEVkZ2VOb2RlXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRoaXMgZWRnZSBjb25uZWN0cyB0b1xyXG4gICAgICogQHBhcmFtIHdlaWdodCBUaGUgd2VpZ2h0IG9mIHRoaXMgZWRnZVxyXG4gICAgICovXHJcblx0Y29uc3RydWN0b3IoaW5kZXg6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKXtcclxuXHRcdHRoaXMueSA9IGluZGV4O1xyXG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcclxuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0ID8gd2VpZ2h0IDogMTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgRWRnZU5vZGUgZnJvbSBcIi4vRWRnZU5vZGVcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBNQVhfViA9IDEwMDtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIGdyYXBoIGRhdGEgc3RydWN0dXJlIHVzaW5nIGVkZ2UgbGlzdHMuIEluc3BpcmVkIGJ5IFRoZSBBbGdvcml0aG0gRGVzaWduIE1hbnVhbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIHtcclxuXHQvKiogQW4gYXJyYXkgb2YgZWRnZXMgYXQgdGhlIG5vZGUgc3BlY2lmaWVkIGJ5IHRoZSBpbmRleCAqL1xyXG5cdGVkZ2VzOiBBcnJheTxFZGdlTm9kZT47XHJcblx0LyoqIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgZGVncmVlIG9mIHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cclxuXHRkZWdyZWU6IEFycmF5PG51bWJlcj47XHJcblx0LyoqIFRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGdyYXBoICovXHJcblx0bnVtVmVydGljZXM6IG51bWJlcjtcclxuXHQvKiogVGhlIG51bWJlciBvZiBlZGdlcyBpbiB0aGUgZ3JhcGggKi9cclxuXHRudW1FZGdlczogbnVtYmVyO1xyXG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgZGlyZWN0ZWQgKi9cclxuXHRkaXJlY3RlZDogYm9vbGVhbjtcclxuXHQvKiogV2hldGhlciBvciBub3QgdGhlIGdyYXBoIGlzIHdlaWdodGVkICovXHJcblx0d2VpZ2h0ZWQ6IGJvb2xlYW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGhcclxuXHQgKiBAcGFyYW0gZGlyZWN0ZWQgV2hldGhlciBvciBub3QgdGhpcyBncmFwaCBpcyBkaXJlY3RlZFxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGVkOiBib29sZWFuID0gZmFsc2Upe1xyXG5cdFx0dGhpcy5kaXJlY3RlZCA9IGRpcmVjdGVkO1xyXG5cdFx0dGhpcy53ZWlnaHRlZCA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMubnVtVmVydGljZXMgPSAwO1xyXG5cdFx0dGhpcy5udW1FZGdlcyA9IDA7XHJcblxyXG5cdFx0dGhpcy5lZGdlcyA9IG5ldyBBcnJheShNQVhfVik7XHJcblx0XHR0aGlzLmRlZ3JlZSA9IG5ldyBBcnJheShNQVhfVik7XHJcblx0fVxyXG5cclxuXHQvKiogQWRkcyBhIG5vZGUgdG8gdGhpcyBncmFwaCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgaXRcclxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIG5ldyBub2RlXHJcblx0Ki9cclxuXHRhZGROb2RlKCk6IG51bWJlciB7XHJcblx0XHR0aGlzLm51bVZlcnRpY2VzKys7XHJcblx0XHRyZXR1cm4gdGhpcy5udW1WZXJ0aWNlcztcclxuXHR9XHJcblxyXG5cdC8qKiBBZGRzIGFuIGVkZ2UgYmV0d2VlbiBub2RlIHggYW5kIHksIHdpdGggYW4gb3B0aW9uYWwgd2VpZ2h0XHJcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBzdGFydCBvZiB0aGUgZWRnZVxyXG5cdCAqIEBwYXJhbSB5IFRoZSBpbmRleCBvZiB0aGUgZW5kIG9mIHRoZSBlZGdlXHJcblx0ICogQHBhcmFtIHdlaWdodCBUaGUgb3B0aW9uYWwgd2VpZ2h0IG9mIHRoZSBuZXcgZWRnZVxyXG5cdCovXHJcblx0YWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRsZXQgZWRnZSA9IG5ldyBFZGdlTm9kZSh5LCB3ZWlnaHQpO1xyXG5cclxuXHJcblxyXG5cdFx0aWYodGhpcy5lZGdlc1t4XSl7XHJcblx0XHRcdGVkZ2UubmV4dCA9IHRoaXMuZWRnZXNbeF07XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHRoaXMuZWRnZXNbeF0gPSBlZGdlO1xyXG5cclxuXHRcdGlmKCF0aGlzLmRpcmVjdGVkKXtcclxuXHRcdFx0ZWRnZSA9IG5ldyBFZGdlTm9kZSh4LCB3ZWlnaHQpO1xyXG5cclxuXHRcdFx0aWYodGhpcy5lZGdlc1t5XSl7XHJcblx0XHRcdFx0ZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t5XTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5lZGdlc1t5XSA9IGVkZ2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5udW1FZGdlcyArPSAxO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGFuIGVkZ2UgZXhpc3RzIGJldHdlZW4gdHdvIG5vZGVzLlxyXG5cdCAqIFRoaXMgY2hlY2sgaXMgZGlyZWN0aW9uYWwgaWYgdGhpcyBpcyBhIGRpcmVjdGVkIGdyYXBoLlxyXG5cdCAqIEBwYXJhbSB4IFRoZSBmaXJzdCBub2RlXHJcblx0ICogQHBhcmFtIHkgVGhlIHNlY29uZCBub2RlXHJcblx0ICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlZGdlIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0ZWRnZUV4aXN0cyh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW3hdO1xyXG5cclxuXHRcdHdoaWxlKGVkZ2UgIT09IG51bGwpe1xyXG5cdFx0XHRpZihlZGdlLnkgPT09IHkpe1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBlZGdlIGxpc3QgYXNzb2NpYXRlZCB3aXRoIG5vZGUgeFxyXG5cdCAqIEBwYXJhbSB4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBoZWFkIG9mIGEgbGlua2VkLWxpc3Qgb2YgZWRnZXNcclxuXHQgKi9cclxuXHRnZXRFZGdlcyh4OiBudW1iZXIpOiBFZGdlTm9kZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lZGdlc1t4XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGRlZ3JlZSBhc3NvY2lhdGVkIHdpdGggbm9kZSB4XHJcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXHJcblx0ICovXHJcblx0Z2V0RGVncmVlKHg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5kZWdyZWVbeF07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyB0aGUgc3BlY2lmZWQgbm9kZSBpbnRvIGEgc3RyaW5nXHJcblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBjb252ZXJ0IHRvIGEgc3RyaW5nXHJcblx0ICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZTogXCJOb2RlIHhcIlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBub2RlVG9TdHJpbmcoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCJOb2RlIFwiICsgaW5kZXg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyB0aGUgR3JhcGggaW50byBhIHN0cmluZyBmb3JtYXRcclxuXHQgKiBAcmV0dXJucyBUaGUgZ3JhcGggYXMgYSBzdHJpbmdcclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmVydGljZXM7IGkrKyl7XHJcblx0XHRcdGxldCBlZGdlID0gdGhpcy5lZGdlc1tpXTtcclxuXHRcdFx0bGV0IGVkZ2VTdHIgPSBcIlwiO1xyXG5cdFx0XHR3aGlsZShlZGdlICE9PSBudWxsKXtcclxuXHRcdFx0XHRlZGdlU3RyICs9IGVkZ2UueS50b1N0cmluZygpO1xyXG5cdFx0XHRcdGlmKHRoaXMud2VpZ2h0ZWQpe1xyXG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiAoXCIgKyBlZGdlLndlaWdodCArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihlZGdlLm5leHQgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiwgXCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRlZGdlID0gZWRnZS5uZXh0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR2YWwgKz0gdGhpcy5ub2RlVG9TdHJpbmcoaSkgKyBcIjogXCIgKyBlZGdlU3RyICsgXCJcXG5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmV0dmFsO1xyXG5cdH1cclxufSIsImltcG9ydCBHcmFwaCwgeyBNQVhfViB9IGZyb20gXCIuL0dyYXBoXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBEZWJ1Z1JlbmRlcmFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvRGVidWdSZW5kZXJhYmxlXCI7XHJcblxyXG4vKipcclxuICogQW4gZXh0ZW5zaW9uIG9mIEdyYXBoIHRoYXQgaGFzIG5vZGVzIHdpdGggcG9zaXRpb25zIGluIDJEIHNwYWNlLlxyXG4gKiBUaGlzIGlzIGEgd2VpZ2h0ZWQgZ3JhcGggKHRob3VnaCBub3QgaW5oZXJlbnRseSBkaXJlY3RkKVxyXG4qL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbkdyYXBoIGV4dGVuZHMgR3JhcGggaW1wbGVtZW50cyBEZWJ1Z1JlbmRlcmFibGUge1xyXG5cdC8qKiBBbiBhcnJheSBvZiB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBpbiB0aGlzIGdyYXBoICovXHJcblx0cG9zaXRpb25zOiBBcnJheTxWZWMyPjtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlZXMgYSBuZXcgUG9zaXRpb25HcmFwaFxyXG5cdCAqIEBwYXJhbSBkaXJlY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIGdyYXBoIGlzIGRpcmVjdGVkXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSl7XHJcblx0XHRzdXBlcihkaXJlY3RlZCk7XHJcblx0XHR0aGlzLnBvc2l0aW9ucyA9IG5ldyBBcnJheShNQVhfVik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgcG9zaXRpb25lZCBub2RlIHRvIHRoaXMgZ3JhcGhcclxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIHRvIGFkZFxyXG5cdCAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYWRkZWQgbm9kZVxyXG5cdCAqL1xyXG5cdGFkZFBvc2l0aW9uZWROb2RlKHBvc2l0aW9uOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdHRoaXMucG9zaXRpb25zW3RoaXMubnVtVmVydGljZXNdID0gcG9zaXRpb247XHJcblx0XHRyZXR1cm4gdGhpcy5hZGROb2RlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiBhIG5vZGUuXHJcblx0ICogQXV0b21hdGljYWxseSBhZGp1c3RzIHRoZSB3ZWlnaHRzIG9mIHRoZSBncmFwaCB0aWVkIHRvIHRoaXMgbm9kZS5cclxuXHQgKiBBcyBzdWNoLCBiZSB3YXJuZWQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBhbiBPKG4gKyBtKSBydW5uaW5nIHRpbWUsIGFuZCB1c2UgaXQgc3BhcmluZ2x5LlxyXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgbm9kZVxyXG5cdCAqL1xyXG5cdHNldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyLCBwb3NpdGlvbjogVmVjMik6IHZvaWQge1xyXG5cdFx0dGhpcy5wb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247XHJcblxyXG5cdFx0Ly8gUmVjYWxjdWxhdGUgYWxsIHdlaWdodHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5kZXhcclxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUVkZ2VzOyBpKyspe1xyXG5cclxuXHRcdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xyXG5cclxuXHRcdFx0d2hpbGUoZWRnZSAhPT0gbnVsbCl7XHJcblx0XHRcdFx0Ly8gSWYgdGhpcyBub2RlIGlzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBlZGdlLCByZWNhbGN1bGF0ZSB3ZWlnaHRcclxuXHRcdFx0XHRpZihpID09PSBpbmRleCB8fCBlZGdlLnkgPT09IGluZGV4KXtcclxuXHRcdFx0XHRcdGVkZ2Uud2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbaV0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1tlZGdlLnldKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZVxyXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuXHQgKiBAcmV0dXJucyBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGVcclxuXHQgKi9cclxuXHRnZXROb2RlUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMucG9zaXRpb25zW2luZGV4XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gZWRnZSB0byB0aGlzIGdyYXBoIGJldHdlZW4gbm9kZSB4IGFuZCB5LlxyXG5cdCAqIEF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlcyB0aGUgd2VpZ2h0IG9mIHRoZSBlZGdlIGFzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBub2Rlcy5cclxuXHQgKiBAcGFyYW0geCBUaGUgYmVnaW5uaW5nIG9mIHRoZSBlZGdlXHJcblx0ICogQHBhcmFtIHkgVGhlIGVuZCBvZiB0aGUgZWRnZVxyXG5cdCAqL1xyXG5cdGFkZEVkZ2UoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmKCF0aGlzLnBvc2l0aW9uc1t4XSB8fCAhdGhpcy5wb3NpdGlvbnNbeV0pe1xyXG5cdFx0XHR0aHJvdyBcIkNhbid0IGFkZCBlZGdlIHRvIHVuLXBvc2l0aW9uZWQgbm9kZSFcIjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXZWlnaHQgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vZGVzXHJcblx0XHRsZXQgd2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbeF0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1t5XSk7XHJcblxyXG5cdFx0c3VwZXIuYWRkRWRnZSh4LCB5LCB3ZWlnaHQpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIG5vZGVUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleCArIFwiIC0gXCIgKyB0aGlzLnBvc2l0aW9uc1tpbmRleF0udG9TdHJpbmcoKTtcclxuXHR9XHJcblxyXG5cdGRlYnVnUmVuZGVyID0gKCk6IHZvaWQgPT4ge1xyXG5cdFx0Ly8gZm9yKGxldCBwb2ludCBvZiB0aGlzLnBvc2l0aW9ucyl7XHJcblx0XHQvLyBcdGN0eC5maWxsUmVjdCgocG9pbnQueCAtIG9yaWdpbi54IC0gNCkqem9vbSwgKHBvaW50LnkgLSBvcmlnaW4ueSAtIDQpKnpvb20sIDgsIDgpO1xyXG5cdFx0Ly8gfVxyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xyXG5cclxuLyoqIEFuIG9iamVjdCB0aGF0IGlzIGEgcmVnaW9uLCB3aXRoIGEgc2l6ZSwgc2NhbGUsIGFuZCBib3VuZGFyeS4gKi9cclxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIFJlZ2lvbiB7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhpcyBvYmplY3QuICovXHJcbiAgICBzaXplOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgc2NhbGUgb2YgdGhpcyBvYmplY3QuICovXHJcbiAgICBzY2FsZTogVmVjMjtcclxuXHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG9iamVjdCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB6b29tIGFuZCBzY2FsZSAqL1xyXG4gICAgcmVhZG9ubHkgc2l6ZVdpdGhab29tOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgYm91bmRpbmcgYm94IG9mIHRoaXMgb2JqZWN0LiAqL1xyXG4gICAgYm91bmRhcnk6IEFBQkI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ2lvbihhcmc6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGFyZyAmJiBhcmcuc2l6ZSAmJiBhcmcuc2NhbGUgJiYgYXJnLmJvdW5kYXJ5O1xyXG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEFzc29jaWF0ZXMgc3RyaW5ncyB3aXRoIGVsZW1lbnRzIG9mIHR5cGUgVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XHJcblx0cHJpdmF0ZSBtYXA6IFJlY29yZDxzdHJpbmcsIFQ+O1xyXG5cclxuXHQvKiogQ3JlYXRlcyBhIG5ldyBtYXAgKi9cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5tYXAgPSB7fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSB2YWx1ZSBUIHN0b3JlZCBhdCBhIGtleS5cclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gYmUgc3RvcmVkXHJcblx0ICogQHBhcmFtIHZhbHVlIFRoZSBpdGVtIHRvIGJlIHN0b3JlZFxyXG5cdCAqL1xyXG5cdGFkZChrZXk6IHN0cmluZywgdmFsdWU6IFQpOiB2b2lkIHtcclxuXHRcdHRoaXMubWFwW2tleV0gPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEga2V5LlxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbVxyXG5cdCAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBrZXkgb3IgdW5kZWZpbmVkXHJcblx0ICovXHJcblx0Z2V0KGtleTogc3RyaW5nKTogVCB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGFsaWFzIG9mIGFkZC4gU2V0cyB0aGUgdmFsdWUgc3RvcmVkIGF0IGtleSB0byB0aGUgbmV3IHNwZWNpZmllZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBiZSBzdG9yZWRcclxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXHJcblx0ICovXHJcblx0c2V0KGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xyXG5cdFx0dGhpcy5hZGQoa2V5LCB2YWx1ZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYSB2YWx1ZSBzdG9yZWQgYXQgdGhlIHNwZWNpZmllZCBrZXksIGZhbHNlIG90aGVyd2lzZS5cclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gY2hlY2tcclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhlIGdpdmVuIGtleS5cclxuXHQgKi9cclxuXHRoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldICE9PSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUga2V5cyBpbiB0aGlzIG1hcC5cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCBrZXlzIGluIHRoZSBtYXAuXHJcblx0ICovXHJcblx0a2V5cygpOiBBcnJheTxzdHJpbmc+IHtcclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XHJcblx0fVxyXG5cdFxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGZvckVhY2goZnVuYzogKGtleTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLm1hcCkuZm9yRWFjaChrZXkgPT4gZnVuYyhrZXkpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlbGV0ZXMgYW4gaXRlbSBhc3NvY2lhdGVkIHdpdGggYSBrZXlcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgYXQgd2hpY2ggdG8gZGVsZXRlIGFuIGl0ZW1cclxuXHQgKi9cclxuXHRkZWxldGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGRlbGV0ZSB0aGlzLm1hcFtrZXldO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0Y2xlYXIoKTogdm9pZCB7XHJcblx0XHR0aGlzLmZvckVhY2goa2V5ID0+IGRlbGV0ZSB0aGlzLm1hcFtrZXldKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXAuXHJcblx0ICovXHJcblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGxldCBzdHIgPSBcIlwiO1xyXG5cclxuXHRcdHRoaXMuZm9yRWFjaCgoa2V5KSA9PiBzdHIgKz0ga2V5ICsgXCIgLT4gXCIgKyB0aGlzLmdldChrZXkpLnRvU3RyaW5nKCkgKyBcIlxcblwiKTtcclxuXHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuL1ZlYzJcIjtcclxuXHJcbi8qKiBBIDR4NCBtYXRyaXgwICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdDR4NCB7XHJcblx0cHJpdmF0ZSBtYXQ6IEZsb2F0MzJBcnJheTtcclxuXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMubWF0ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDBcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0Ly8gU3RhdGljIG1lbWJlcnNcclxuXHRzdGF0aWMgZ2V0IElERU5USVRZKCk6IE1hdDR4NCB7XHJcblx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLmlkZW50aXR5KCk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IFpFUk8oKTogTWF0NHg0IHtcclxuXHRcdHJldHVybiBuZXcgTWF0NHg0KCkuemVybygpO1xyXG5cdH1cclxuXHJcblx0Ly8gQWNjZXNzb3JzXHJcblx0c2V0IF8wMCh4OiBudW1iZXIpIHtcclxuXHRcdHRoaXMubWF0WzBdID0geDtcclxuXHR9XHJcblxyXG5cdHNldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0aWYoY29sIDwgMCB8fCBjb2wgPiAzIHx8IHJvdyA8IDAgfHwgcm93ID4gMyl7XHJcblx0XHRcdHRocm93IGBFcnJvciAtIGluZGV4ICgke2NvbH0sICR7cm93fSkgaXMgb3V0IG9mIGJvdW5kcyBmb3IgTWF0NHg0YFxyXG5cdFx0fVxyXG5cdFx0dGhpcy5tYXRbcm93KjQgKyBjb2xdID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRnZXQoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLm1hdFtyb3cqNCArIGNvbF07XHJcblx0fVxyXG5cclxuXHRzZXRBbGwoLi4uaXRlbXM6IEFycmF5PG51bWJlcj4pOiBNYXQ0eDQge1xyXG5cdFx0dGhpcy5tYXQuc2V0KGl0ZW1zKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0aWRlbnRpdHkoKTogTWF0NHg0IHtcclxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcclxuXHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cdFx0KVxyXG5cdH1cclxuXHJcblx0emVybygpOiBNYXQ0eDQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWFrZXMgdGhpcyBNYXQ0eDQgYSByb3RhdGlvbiBtYXRyaXggb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgcmFkaWFucyBjY3dcclxuXHQgKiBAcGFyYW0gelJhZGlhbnMgVGhlIG51bWJlciBvZiByYWRpYW5zIHRvIHJvdGF0ZVxyXG5cdCAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XHJcblx0ICovXHJcblx0cm90YXRlKHpSYWRpYW5zOiBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHRNYXRoLmNvcyh6UmFkaWFucyksIC1NYXRoLnNpbih6UmFkaWFucyksIFx0MCwgMCxcclxuXHRcdFx0TWF0aC5zaW4oelJhZGlhbnMpLCBNYXRoLmNvcyh6UmFkaWFucyksIFx0MCwgMCxcclxuXHRcdFx0MCwgXHRcdFx0XHRcdDAsIFx0XHRcdFx0XHRcdDEsIDAsXHJcblx0XHRcdDAsIFx0XHRcdFx0XHQwLCBcdFx0XHRcdFx0XHQwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVHVybnMgdGhpcyBNYXQ0eDQgaW50byBhIHRyYW5zbGF0aW9uIG1hdHJpeCBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zbGF0aW9uXHJcblx0ICogQHBhcmFtIHRyYW5zbGF0aW9uIFRoZSB0cmFuc2xhdGlvbiBpbiB4IGFuZCB5XHJcblx0ICogQHJldHVybnMgdGhpcyBNYXQ0eDRcclxuXHQgKi9cclxuXHR0cmFuc2xhdGUodHJhbnNsYXRpb246IFZlYzIgfCBGbG9hdDMyQXJyYXkpOiBNYXQ0eDQge1xyXG5cdFx0Ly8gSWYgdHJhbnNsYXRpb24gaXMgYSB2ZWMsIGdldCBpdHMgYXJyYXlcclxuXHRcdGlmKHRyYW5zbGF0aW9uIGluc3RhbmNlb2YgVmVjMil7XHJcblx0XHRcdHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb24udG9BcnJheSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcclxuXHRcdFx0MSwgMCwgMCwgdHJhbnNsYXRpb25bMF0sXHJcblx0XHRcdDAsIDEsIDAsIHRyYW5zbGF0aW9uWzFdLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0c2NhbGUoc2NhbGU6IFZlYzIgfCBGbG9hdDMyQXJyYXkgfCBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlIGlzIGEgZmxvYXQzMkFycmF5XHJcblx0XHRpZihzY2FsZSBpbnN0YW5jZW9mIFZlYzIpe1xyXG5cdFx0XHRzY2FsZSA9IHNjYWxlLnRvQXJyYXkoKTtcclxuXHRcdH0gZWxzZSBpZighKHNjYWxlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSl7XHJcblx0XHRcdHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbc2NhbGUsIHNjYWxlXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHRzY2FsZVswXSwgMCwgXHRcdDAsIDAsXHJcblx0XHRcdDAsIFx0XHQgIHNjYWxlWzFdLCAwLCAwLFxyXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQxLCAwLFxyXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG5ldyBNYXQ0eDQgdGhhdCByZXByZXNlbnRzIHRoZSByaWdodCBzaWRlIG11bHRpcGxpY2F0aW9uIFRISVMgeCBPVEhFUlxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgTWF0NHg0IHRvIG11bHRpcGx5IGJ5XHJcblx0ICogQHJldHVybnMgYSBuZXcgTWF0NHg0IGNvbnRhaW5pbmcgdGhlIHByb2R1Y3Qgb2YgdGhlc2UgdHdvIE1hdDR4NHNcclxuXHQgKi9cclxuXHRtdWx0KG90aGVyOiBNYXQ0eDQsIG91dD86IE1hdDR4NCk6IE1hdDR4NCB7XHJcblx0XHRsZXQgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspe1xyXG5cdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgNDsgaisrKXtcclxuXHRcdFx0XHRsZXQgdmFsdWUgPSAwO1xyXG5cdFx0XHRcdGZvcihsZXQgayA9IDA7IGsgPCA0OyBrKyspe1xyXG5cdFx0XHRcdFx0dmFsdWUgKz0gdGhpcy5nZXQoaywgaSkgKiBvdGhlci5nZXQoaiwgayk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRlbXBbaio0ICsgaV0gID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZihvdXQgIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdHJldHVybiBvdXQuc2V0QWxsKC4uLnRlbXApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBNYXQ0eDQoKS5zZXRBbGwoLi4udGVtcCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNdWx0aXBsaWVzIGFsbCBnaXZlbiBtYXRyaWNpZXMgaW4gb3JkZXIuIGUuZy4gTVVMVChBLCBCLCBDKSAtPiBBKkIqQ1xyXG5cdCAqIEBwYXJhbSBtYXRzIEEgbGlzdCBvZiBNYXQ0eDRzIHRvIG11bHRpcGx5IGluIG9yZGVyXHJcblx0ICogQHJldHVybnMgQSBuZXcgTWF0NHg0IGhvbGRpbmcgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXHJcblx0ICovXHJcblx0c3RhdGljIE1VTFQoLi4ubWF0czogQXJyYXk8TWF0NHg0Pik6IE1hdDR4NCB7XHJcblx0XHQvLyBDcmVhdGUgYSBuZXcgYXJyYXlcclxuXHRcdGxldCB0ZW1wID0gTWF0NHg0LklERU5USVRZO1xyXG5cclxuXHRcdC8vIE11bHRpcGx5IGJ5IGV2ZXJ5IGFycmF5IGluIG9yZGVyLCBpbiBwbGFjZVxyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IG1hdHMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHR0ZW1wLm11bHQobWF0c1tpXSwgdGVtcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRlbXA7XHJcblx0fVxyXG5cclxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXQ7XHJcblx0fVxyXG5cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICBgfCR7dGhpcy5tYXRbMF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbM10udG9GaXhlZCgyKX18XFxuYCArIFxyXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFs0XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs1XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs2XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs3XS50b0ZpeGVkKDIpfXxcXG5gICtcclxuXHRcdFx0XHRgfCR7dGhpcy5tYXRbOF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbOV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTBdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzExXS50b0ZpeGVkKDIpfXxcXG5gICtcclxuXHRcdFx0XHRgfCR7dGhpcy5tYXRbMTJdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzEzXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxNF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTVdLnRvRml4ZWQoMil9fGA7XHJcblx0fVxyXG59IiwiaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5pbXBvcnQgSGl0IGZyb20gXCIuL0hpdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyB0aGUgYXJlYSBvZiBvdmVybGFwIG9mIHR3byBjb2xsaWRpbmcgb2JqZWN0cyB0byBhbGxvdyBmb3Igc29ydGluZyBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmVhQ29sbGlzaW9uIHtcclxuICAgIC8qKiBUaGUgYXJlYSBvZiB0aGUgb3ZlcmxhcCBmb3IgdGhlIGNvbGxpZGluZyBvYmplY3RzICovXHJcbiAgICBhcmVhOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBBQUJCIG9mIHRoZSBvdGhlciBjb2xsaWRlciBpbiB0aGlzIGNvbGxpc2lvbiAqL1xyXG4gICAgY29sbGlkZXI6IEFBQkI7XHJcblxyXG4gICAgLyoqIFR5cGUgb2YgdGhlIGNvbGxpc2lvbiAqL1xyXG4gICAgdHlwZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBUaGVyIG90aGVyIG9iamVjdCBpbiB0aGUgY29sbGlzaW9uICovXHJcbiAgICBvdGhlcjogUGh5c2ljYWw7XHJcblxyXG4gICAgLyoqIFRoZSB0aWxlLCBpZiB0aGlzIHdhcyBhIHRpbGVtYXAgY29sbGlzaW9uICovXHJcbiAgICB0aWxlOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgcGh5c2ljcyBoaXQgZm9yIHRoaXMgb2JqZWN0ICovXHJcbiAgICBoaXQ6IEhpdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgQXJlYUNvbGxpc2lvbiBvYmplY3RcclxuICAgICAqIEBwYXJhbSBhcmVhIFRoZSBhcmVhIG9mIHRoZSBjb2xsaXNpb25cclxuICAgICAqIEBwYXJhbSBjb2xsaWRlciBUaGUgb3RoZXIgY29sbGlkZXJcclxuICAgICAqL1xyXG5cdGNvbnN0cnVjdG9yKGFyZWE6IG51bWJlciwgY29sbGlkZXI6IEFBQkIsIG90aGVyOiBQaHlzaWNhbCwgdHlwZTogc3RyaW5nLCB0aWxlOiBWZWMyKXtcclxuXHRcdHRoaXMuYXJlYSA9IGFyZWE7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IGNvbGxpZGVyO1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudGlsZSA9IHRpbGU7XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRhIGNvbGxlY3RlZCBmcm9tIGEgcGh5c2ljcyBoaXQgYmV0d2VlbiB0d28gZ2VvbWV0cmljIG9iamVjdHMuXHJcbiAqIEluc3BpcmVkIGJ5IHRoZSBoZWxwZnVsIGNvbGxpc2lvbiBkb2N1bWVudGF0aW9uIEBsaW5rKGhlcmUpKGh0dHBzOi8vbm9vbmF0LmdpdGh1Yi5pby9pbnRlcnNlY3QvKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpdCB7XHJcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGNvbGxpc2lvbi4gT25seSBudW1iZXJzIDAgdGhyb3VnaCAxIGhhcHBlbiBpbiB0aGlzIGZyYW1lLiAqL1xyXG4gICAgdGltZTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBuZWFyIHRpbWVzIG9mIHRoZSBjb2xsaXNpb24gKi9cclxuICAgIG5lYXJUaW1lczogVmVjMiA9IFZlYzIuWkVSTztcclxuICAgIC8qKiBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbGxpc2lvbiAqL1xyXG4gICAgcG9zOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gICAgLyoqIFRoZSBvdmVybGFwIGRpc3RhbmNlIG9mIHRoZSBoaXQgKi9cclxuICAgIGRlbHRhOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gICAgLyoqIFRoZSBub3JtYWwgdmVjdG9yIG9mIHRoZSBoaXQgKi9cclxuICAgIG5vcm1hbDogVmVjMiA9IFZlYzIuWkVSTztcclxufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBBIEZJRk8gcXVldWUgd2l0aCBlbGVtZW50cyBvZiB0eXBlIFRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XHJcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBRdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBNQVhfRUxFTUVOVFM6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSBxOiBBcnJheTxUPjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBoZWFkIG9mIHRoZSBxdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSBoZWFkOiBudW1iZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgdGFpbCBvZiB0aGUgcXVldWUgKi9cclxuICAgIHByaXZhdGUgdGFpbDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgY3VycmVudCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHF1ZXVlICovXHJcbiAgICBwcml2YXRlIHNpemU6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcXVldWVcclxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKXtcclxuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMucSA9IG5ldyBBcnJheSh0aGlzLk1BWF9FTEVNRU5UUyk7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gMDtcclxuICAgICAgICB0aGlzLnRhaWwgPSAwO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXHJcbiAgICAgKi9cclxuICAgIGVucXVldWUoaXRlbTogVCk6IHZvaWR7XHJcbiAgICAgICAgaWYoKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFMgPT09IHRoaXMuaGVhZCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNpemUgKz0gMTtcclxuICAgICAgICB0aGlzLnFbdGhpcy50YWlsXSA9IGl0ZW07XHJcbiAgICAgICAgdGhpcy50YWlsID0gKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgICAqL1xyXG4gICAgZGVxdWV1ZSgpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IHJlbW92ZSBlbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRoaXMuc2l6ZSAtPSAxO1xyXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5xW3RoaXMuaGVhZF07XHJcbiAgICAgICAgLy8gTm93IGRlbGV0ZSB0aGUgaXRlbVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnFbdGhpcy5oZWFkXTtcclxuICAgICAgICB0aGlzLmhlYWQgPSAodGhpcy5oZWFkICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZSwgYnV0IGRvZXMgbm90IHJlbW92ZSBpdFxyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxyXG4gICAgICovXHJcbiAgICBwZWVrTmV4dCgpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XHJcbiAgICAgICAgICAgIHRocm93IFwiUXVldWUgZW1wdHkgLSBjYW5ub3QgZ2V0IGVsZW1lbnRcIlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVldWUgaGFzIGl0ZW1zIGluIGl0LCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBxdWV1ZSBoYXMgaXRlbXNcclxuICAgICAqL1xyXG4gICAgaGFzSXRlbXMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCAhPT0gdGhpcy50YWlsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBxdWV1ZVxyXG4gICAgICovXHJcbiAgICBnZXRTaXplKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnFbaW5kZXhdKTtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgd2hpbGUoaSAhPT0gdGhpcy50YWlsKXtcclxuICAgICAgICAgICAgZnVuYyh0aGlzLnFbaV0sIGkpO1xyXG4gICAgICAgICAgICBpID0gKGkgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgcXVldWUgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHF1ZXVlXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgaWYoaW5kZXggIT09IDApe1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dmFsID0gc3RyICsgcmV0dmFsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XHJcbiAgICB9XHJcbn0iLCIvKiogQSBjb250YWluZXIgZm9yIGluZm8gYWJvdXQgYSB3ZWJHTCBzaGFkZXIgcHJvZ3JhbSAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFByb2dyYW1UeXBlIHtcclxuXHQvKiogQSB3ZWJHTCBwcm9ncmFtICovXHJcblx0cHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG5cdFxyXG5cdC8qKiBBIHZlcnRleCBzaGFkZXIgKi9cclxuXHR2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xyXG5cclxuXHQvKiogQSBmcmFnbWVudCBzaGFkZXIgKi9cclxuXHRmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlbGV0ZXMgdGhpcyBzaGFkZXIgcHJvZ3JhbVxyXG5cdCAqL1xyXG5cdGRlbGV0ZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XHJcblx0XHQvLyBDbGVhbiB1cCBhbGwgYXNwZWN0cyBvZiB0aGlzIHByb2dyYW1cclxuXHRcdGlmKHRoaXMucHJvZ3JhbSl7XHJcblx0XHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuXHRcdH1cclxuXHRcdFx0XHJcblx0XHRpZih0aGlzLnZlcnRleFNoYWRlcil7XHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5mcmFnbWVudFNoYWRlcil7XHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4vQ2lyY2xlXCI7XHJcbmltcG9ydCBIaXQgZnJvbSBcIi4uL1BoeXNpY3MvSGl0XCI7XHJcblxyXG4vKipcclxuICogQW4gQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveC4gSW4gb3RoZXIgd29yZHMsIGEgcmVjdGFuZ2xlIHRoYXQgaXMgYWx3YXlzIGFsaWduZWQgdG8gdGhlIHgteSBncmlkLlxyXG4gKiBJbnNwaXJlZCBieSB0aGUgaGVscGZ1bCBjb2xsaXNpb24gZG9jdW1lbnRhdGlvbiBAbGluayhoZXJlKShodHRwczovL25vb25hdC5naXRodWIuaW8vaW50ZXJzZWN0LykuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBQUJCIGV4dGVuZHMgU2hhcGUge1xyXG4gICAgY2VudGVyOiBWZWMyO1xyXG4gICAgaGFsZlNpemU6IFZlYzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFBQkJcclxuICAgICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgQUFCQlxyXG4gICAgICogQHBhcmFtIGhhbGZTaXplIFRoZSBoYWxmIHNpemUgb2YgdGhlIEFBQkIgLSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHRvIGFuIGVkZ2UgaW4geCBhbmQgeVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjZW50ZXI/OiBWZWMyLCBoYWxmU2l6ZT86IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBjZW50ZXIgPyBjZW50ZXIgOiBuZXcgVmVjMigwLCAwKTtcclxuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemUgPyBoYWxmU2l6ZSA6IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICAgIGdldCB0b3BMZWZ0KCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMudG9wKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXHJcbiAgICBnZXQgdG9wUmlnaHQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMudG9wKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICAgIGdldCBib3R0b21MZWZ0KCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXHJcbiAgICBnZXQgYm90dG9tUmlnaHQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCk6IEFBQkIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xyXG4gICAgICAgIGxldCByID0gTWF0aC5tYXgodGhpcy5odywgdGhpcy5oaClcclxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLmNlbnRlci5jbG9uZSgpLCByKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgZ2V0SGFsZlNpemUoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgIHNldEhhbGZTaXplKGhhbGZTaXplOiBWZWMyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5oYWxmU2l6ZSA9IGhhbGZTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gLSBtb3ZlIHRoZXNlIGFsbCB0byB0aGUgU2hhcGUgY2xhc3NcclxuICAgIC8qKlxyXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBwb2ludC54ID49IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XHJcbiAgICAgICAgICAgICYmIHBvaW50LnkgPj0gdGhpcy55IC0gdGhpcy5oaCAmJiBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3RQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBkeCA9IHBvaW50LnggLSB0aGlzLng7XHJcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyAtIE1hdGguYWJzKGR4KTtcclxuICAgICAgICBcclxuICAgICAgICBpZihweCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGR5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoIC0gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgICAgICBpZihweSA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludCB3aXRoIHNvZnQgbGVmdCBhbmQgdG9wIGJvdW5kYXJpZXMuXHJcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgaWYgdGhlIHRvcCBsZWZ0IGlzICgwLCAwKSwgdGhlIHBvaW50ICgwLCAwKSBpcyBub3QgaW4gdGhlIEFBQkJcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBjb250YWluc1BvaW50U29mdChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBwb2ludC54ID4gdGhpcy54IC0gdGhpcy5odyAmJiBwb2ludC54IDw9IHRoaXMueCArIHRoaXMuaHdcclxuICAgICAgICAgICAgJiYgcG9pbnQueSA+IHRoaXMueSAtIHRoaXMuaGggJiYgcG9pbnQueSA8PSB0aGlzLnkgKyB0aGlzLmhoXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBmcm9tIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBBQUJCIHdpdGggYSBsaW5lIHNlZ21lbnQgZnJvbSBhIHBvaW50IGluIGEgZGlyZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRoYXQgdGhlIGxpbmUgc2VnbWVudCBzdGFydHMgZnJvbVxyXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgKiBAcGFyYW0gcGFkZGluZyBQYWRzIHRoZSBBQUJCIHRvIG1ha2UgaXQgd2lkZXIgZm9yIHRoZSBpbnRlcnNlY3Rpb24gdGVzdFxyXG4gICAgICogQHJldHVybnMgVGhlIEhpdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24sIG9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIGludGVyc2VjdGlvblxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3RTZWdtZW50KHBvaW50OiBWZWMyLCBkZWx0YTogVmVjMiwgcGFkZGluZz86IFZlYzIpOiBIaXQge1xyXG4gICAgICAgIGxldCBwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nLnggOiAwO1xyXG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nLnkgOiAwO1xyXG5cclxuICAgICAgICBsZXQgc2NhbGVYID0gMS9kZWx0YS54O1xyXG4gICAgICAgIGxldCBzY2FsZVkgPSAxL2RlbHRhLnk7XHJcblxyXG4gICAgICAgIGxldCBzaWduWCA9IE1hdGhVdGlscy5zaWduKHNjYWxlWCk7XHJcbiAgICAgICAgbGV0IHNpZ25ZID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVZKTtcclxuXHJcbiAgICAgICAgbGV0IHRuZWFyeCA9IHNjYWxlWCoodGhpcy54IC0gc2lnblgqKHRoaXMuaHcgKyBwYWRkaW5nWCkgLSBwb2ludC54KTtcclxuICAgICAgICBsZXQgdG5lYXJ5ID0gc2NhbGVZKih0aGlzLnkgLSBzaWduWSoodGhpcy5oaCArIHBhZGRpbmdZKSAtIHBvaW50LnkpO1xyXG4gICAgICAgIGxldCB0ZmFyeCA9IHNjYWxlWCoodGhpcy54ICsgc2lnblgqKHRoaXMuaHcgKyBwYWRkaW5nWCkgLSBwb2ludC54KTtcclxuICAgICAgICBsZXQgdGZhcnkgPSBzY2FsZVkqKHRoaXMueSArIHNpZ25ZKih0aGlzLmhoICsgcGFkZGluZ1kpIC0gcG9pbnQueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodG5lYXJ4ID4gdGZhcnkgfHwgdG5lYXJ5ID4gdGZhcngpe1xyXG4gICAgICAgICAgICAvLyBXZSBhcmVuJ3QgY29sbGlkaW5nIC0gd2UgY2xlYXIgb25lIGF4aXMgYmVmb3JlIGludGVyc2VjdGluZyBhbm90aGVyXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRuZWFyID0gTWF0aC5tYXgodG5lYXJ4LCB0bmVhcnkpO1xyXG5cclxuICAgICAgICAvLyBEb3VibGUgY2hlY2sgZm9yIE5hTnNcclxuICAgICAgICBpZih0bmVhcnggIT09IHRuZWFyeCl7XHJcbiAgICAgICAgICAgIHRuZWFyID0gdG5lYXJ5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodG5lYXJ5ICE9PSB0bmVhcnkpe1xyXG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB0ZmFyID0gTWF0aC5taW4odGZhcngsIHRmYXJ5KTtcclxuXHJcbiAgICAgICAgaWYodG5lYXIgPT09IC1JbmZpbml0eSl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodG5lYXIgPj0gMSB8fCB0ZmFyIDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGFyZSBjb2xsaWRpbmdcclxuICAgICAgICBsZXQgaGl0ID0gbmV3IEhpdCgpO1xyXG4gICAgICAgIGhpdC50aW1lID0gTWF0aFV0aWxzLmNsYW1wMDEodG5lYXIpO1xyXG4gICAgICAgIGhpdC5uZWFyVGltZXMueCA9IHRuZWFyeDtcclxuICAgICAgICBoaXQubmVhclRpbWVzLnkgPSB0bmVhcnk7XHJcblxyXG4gICAgICAgIGlmKHRuZWFyeCA+IHRuZWFyeSl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgbGVmdCBvciByaWdodCBzaXplXHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gMDtcclxuICAgICAgICB9IGVsc2UgaWYoTWF0aC5hYnModG5lYXJ4IC0gdG5lYXJ5KSA8IDAuMDAwMSl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgY29ybmVyXHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gLXNpZ25ZO1xyXG4gICAgICAgICAgICBoaXQubm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgdG9wIG9yIGJvdHRvbVxyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAwO1xyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoaXQuZGVsdGEueCA9ICgxLjAgLSBoaXQudGltZSkgKiAtZGVsdGEueDtcclxuICAgICAgICBoaXQuZGVsdGEueSA9ICgxLjAgLSBoaXQudGltZSkgKiAtZGVsdGEueTtcclxuICAgICAgICBoaXQucG9zLnggPSBwb2ludC54ICsgZGVsdGEueCAqIGhpdC50aW1lO1xyXG4gICAgICAgIGhpdC5wb3MueSA9IHBvaW50LnkgKyBkZWx0YS55ICogaGl0LnRpbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBoaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuIHtcclxuICAgICAgICBpZihvdGhlciBpbnN0YW5jZW9mIEFBQkIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwc0FBQkIob3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBcIk92ZXJsYXAgbm90IGRlZmluZWQgYmV0d2VlbiB0aGVzZSBzaGFwZXMuXCJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgb3ZlcmxhcHMgYW5vdGhlclxyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrIGFnYWluc3RcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBBQUJCIG92ZXJsYXBzIHRoZSBvdGhlciwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvdmVybGFwc0FBQkIob3RoZXI6IEFBQkIpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgZHggPSBvdGhlci54IC0gdGhpcy54O1xyXG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcclxuICAgICAgICBcclxuICAgICAgICBpZihweCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcclxuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XHJcblxyXG4gICAgICAgIGlmKHB5IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGVzZSBBQUJCcyBhcmUgSlVTVCB0b3VjaGluZyAtIG5vdCBvdmVybGFwcGluZy5cclxuICAgICAqIFZlYzIueCBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgdG8gdGhlIGxlZnQsIDEgaWYgdG8gdGhlIHJpZ2h0LlxyXG4gICAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQiB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgVGhlIGNvbGxpc2lvbiBzaWRlcyBzdG9yZWQgaW4gYSBWZWMyIGlmIHRoZSBBQUJCcyBhcmUgdG91Y2hpbmcsIG51bGwgb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHRvdWNoZXNBQUJCKG90aGVyOiBBQUJCKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcclxuICAgICAgICBsZXQgcHggPSB0aGlzLmh3ICsgb3RoZXIuaHcgLSBNYXRoLmFicyhkeCk7XHJcblxyXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XHJcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgICAgICAvLyBJZiBvbmUgYXhpcyBpcyBqdXN0IHRvdWNoaW5nIGFuZCB0aGUgb3RoZXIgaXMgb3ZlcmxhcHBpbmcsIHRydWVcclxuICAgICAgICBpZigocHggPT09IDAgJiYgcHkgPj0gMCkgfHwgKHB5ID09PSAwICYmIHB4ID49IDApKXtcclxuICAgICAgICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XHJcblxyXG4gICAgICAgICAgICBpZihweCA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHB5ID09PSAwKXtcclxuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlc2UgQUFCQnMgYXJlIEpVU1QgdG91Y2hpbmcgLSBub3Qgb3ZlcmxhcHBpbmcuXHJcbiAgICAgKiBBbHNvLCBpZiB0aGV5IGFyZSBvbmx5IHRvdWNoaW5nIGNvcm5lcnMsIHRoZXkgYXJlIGNvbnNpZGVyZWQgbm90IHRvdWNoaW5nLlxyXG4gICAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXHJcbiAgICAgKiBMaWtld2lzZSwgVmVjMi55IGlzIC0xIGlmIHRoZSBvdGhlciBpcyBvbiB0b3AsIDEgaWYgb24gYm90dG9tLlxyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lkZSBvZiB0aGUgdG91Y2gsIHN0b3JlZCBhcyBhIFZlYzIsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gdG91Y2hcclxuICAgICAqL1xyXG4gICAgdG91Y2hlc0FBQkJXaXRob3V0Q29ybmVycyhvdGhlcjogQUFCQik6IFZlYzIge1xyXG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XHJcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xyXG5cclxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xyXG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcclxuXHJcbiAgICAgICAgLy8gSWYgb25lIGF4aXMgaXMgdG91Y2hpbmcsIGFuZCB0aGUgb3RoZXIgaXMgc3RyaWN0bHkgb3ZlcmxhcHBpbmdcclxuICAgICAgICBpZigocHggPT09IDAgJiYgcHkgPiAwKSB8fCAocHkgPT09IDAgJiYgcHggPiAwKSl7XHJcbiAgICAgICAgICAgIGxldCByZXQgPSBuZXcgVmVjMigpO1xyXG5cclxuICAgICAgICAgICAgaWYocHggPT09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0LnggPSBvdGhlci54IDwgdGhpcy54ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0LnkgPSBvdGhlci55IDwgdGhpcy55ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhpcyBBQUJCIGFuZCBhbm90aGVyXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkJcclxuICAgICAqIEByZXR1cm5zIFRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhlIEFBQkJzXHJcbiAgICAgKi9cclxuICAgIG92ZXJsYXBBcmVhKG90aGVyOiBBQUJCKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgbGVmdHggPSBNYXRoLm1heCh0aGlzLnggLSB0aGlzLmh3LCBvdGhlci54IC0gb3RoZXIuaHcpO1xyXG4gICAgICAgIGxldCByaWdodHggPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLmh3LCBvdGhlci54ICsgb3RoZXIuaHcpO1xyXG4gICAgICAgIGxldCBkeCA9IHJpZ2h0eCAtIGxlZnR4O1xyXG5cclxuICAgICAgICBsZXQgbGVmdHkgPSBNYXRoLm1heCh0aGlzLnkgLSB0aGlzLmhoLCBvdGhlci55IC0gb3RoZXIuaGgpO1xyXG4gICAgICAgIGxldCByaWdodHkgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhoLCBvdGhlci55ICsgb3RoZXIuaGgpO1xyXG4gICAgICAgIGxldCBkeSA9IHJpZ2h0eSAtIGxlZnR5O1xyXG5cclxuICAgICAgICBpZihkeCA8IDAgfHwgZHkgPCAwKSByZXR1cm4gMDtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gZHgqZHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBhbmQgcmVzaXplcyB0aGlzIHJlY3QgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiB0byB0aGUgcG9zaXRpb24gc3BlY2lmaWVkXHJcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIG1vdmVtZW50IG9mIHRoZSByZWN0IGZyb20gaXRzIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIEEgcG9zaXRpb24gc3BlY2lmaWVkIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBvZiBzd2VlcGluZ1xyXG4gICAgICogQHBhcmFtIGhhbGZTaXplIFRoZSBoYWxmU2l6ZSBvZiB0aGUgc3dlZXBpbmcgcmVjdCBcclxuICAgICAqL1xyXG4gICAgc3dlZXAodmVsb2NpdHk6IFZlYzIsIGZyb21Qb3NpdGlvbj86IFZlYzIsIGhhbGZTaXplPzogVmVjMik6IHZvaWQge1xyXG4gICAgICAgIGlmKCFmcm9tUG9zaXRpb24pe1xyXG4gICAgICAgICAgICBmcm9tUG9zaXRpb24gPSB0aGlzLmNlbnRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFoYWxmU2l6ZSl7XHJcbiAgICAgICAgICAgIGhhbGZTaXplID0gdGhpcy5oYWxmU2l6ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjZW50ZXJYID0gZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54LzI7XHJcbiAgICAgICAgbGV0IGNlbnRlclkgPSBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkvMjtcclxuXHJcbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihmcm9tUG9zaXRpb24ueCAtIGhhbGZTaXplLngsIGZyb21Qb3NpdGlvbi54ICsgdmVsb2NpdHkueCAtIGhhbGZTaXplLngpO1xyXG4gICAgICAgIGxldCBtaW5ZID0gTWF0aC5taW4oZnJvbVBvc2l0aW9uLnkgLSBoYWxmU2l6ZS55LCBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkgLSBoYWxmU2l6ZS55KTtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXIuc2V0KGNlbnRlclgsIGNlbnRlclkpO1xyXG4gICAgICAgIHRoaXMuaGFsZlNpemUuc2V0KGNlbnRlclggLSBtaW5YLCBjZW50ZXJZIC0gbWluWSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgY2xvbmUoKTogQUFCQiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBQUJCKHRoaXMuY2VudGVyLmNsb25lKCksIHRoaXMuaGFsZlNpemUuY2xvbmUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIEFBQkIgdG8gYSBzdHJpbmcgZm9ybWF0XHJcbiAgICAgKiBAcmV0dXJucyAoY2VudGVyOiAoeCwgeSksIGhhbGZTaXplOiAoeCwgeSkpXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiKGNlbnRlcjogXCIgKyB0aGlzLmNlbnRlci50b1N0cmluZygpICsgXCIsIGhhbGYtc2l6ZTogXCIgKyB0aGlzLmhhbGZTaXplLnRvU3RyaW5nKCkgKyBcIilcIlxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIENpcmNsZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2hhcGUge1xyXG5cdHByaXZhdGUgX2NlbnRlcjogVmVjMjtcclxuXHRyYWRpdXM6IG51bWJlcjtcclxuXHRcclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IENpcmNsZVxyXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihjZW50ZXI6IFZlYzIsIHJhZGl1czogbnVtYmVyKSB7XHJcblx0XHRzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzID8gcmFkaXVzIDogMDtcclxuXHR9XHJcblxyXG5cdGdldCBjZW50ZXIoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2VudGVyO1xyXG5cdH1cclxuXHJcblx0c2V0IGNlbnRlcihjZW50ZXI6IFZlYzIpIHtcclxuXHRcdHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcclxuXHR9XHJcblxyXG5cdGdldCBoYWxmU2l6ZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHIoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnJhZGl1cztcclxuXHR9XHJcblxyXG5cdHNldCByKHJhZGl1czogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdC8qKlxyXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci5kaXN0YW5jZVNxVG8ocG9pbnQpIDw9IHRoaXMucmFkaXVzKnRoaXMucmFkaXVzO1xyXG4gICAgfVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRnZXRCb3VuZGluZ1JlY3QoKTogQUFCQiB7XHJcblx0XHRyZXR1cm4gbmV3IEFBQkIodGhpcy5fY2VudGVyLmNsb25lKCksIG5ldyBWZWMyKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cykpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0Z2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0Y2xvbmUoKTogQ2lyY2xlIHtcclxuXHRcdHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuX2NlbnRlci5jbG9uZSgpLCB0aGlzLnJhZGl1cyk7XHJcblx0fVxyXG5cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiKGNlbnRlcjogXCIgKyB0aGlzLmNlbnRlci50b1N0cmluZygpICsgXCIsIHJhZGl1czogXCIgKyB0aGlzLnJhZGl1cyArIFwiKVwiO1xyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuL0FBQkJcIjtcclxuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBTaGFwZSBjbGFzcyB0aGF0IGFjdHMgYXMgYW4gaW50ZXJmYWNlIGZvciBiZXR0ZXIgaW50ZXJhY3Rpb25zIHdpdGggc3ViY2xhc3Nlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNoYXBlIHtcclxuICAgIGFic3RyYWN0IGdldCBjZW50ZXIoKTogVmVjMjtcclxuXHJcbiAgICBhYnN0cmFjdCBzZXQgY2VudGVyKGNlbnRlcjogVmVjMik7XHJcblxyXG4gICAgYWJzdHJhY3QgZ2V0IGhhbGZTaXplKCk6IFZlYzI7XHJcblxyXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIueDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci55O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBodygpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLng7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGhoKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemUueTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdG9wKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueSAtIHRoaXMuaGg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGJvdHRvbSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhoO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBsZWZ0KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAtIHRoaXMuaHc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHJpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMuaHc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgYm91bmRpbmcgcmVjdGFuZ2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXHJcbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRoZSBib3VuZGluZyBjaXJjbGUgb2YgYW4gQUFCQiBpcyBpdHNlbGYuIFVzZSBjbG9uZSgpIGlmIHlvdSBuZWVkIGEgbmV3IHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgQW4gQUFCQiB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGJvdW5kaW5nIGNpcmNsZSBmb3IgdGhpcyBzaGFwZS4gV2FybmluZyAtIG1heSBiZSB0aGUgc2FtZSBhcyB0aGlzIFNoYXBlLlxyXG4gICAgICogRm9yIGluc3RhbmNlLCB0aGUgYm91bmRpbmcgY2lyY2xlIG9mIGEgQ2lyY2xlIGlzIGl0c2VsZi4gVXNlIGNsb25lKCkgaWYgeW91IG5lZWQgYSBuZXcgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBBIENpcmNsZSB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgU2hhcGVcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGNvcHkgb2YgdGhpcyBzaGFwZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjbG9uZSgpOiBTaGFwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGlzIHNoYXBlIG92ZXJsYXBzIGFub3RoZXJcclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgc2hhcGUgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMgYSBib29sZWFuIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgU2hhcGUgb3ZlcmxhcHMgdGhlIG90aGVyIG9uZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuO1xyXG5cclxuICAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW47XHJcblxyXG4gICAgc3RhdGljIGdldFRpbWVPZkNvbGxpc2lvbihBOiBTaGFwZSwgdmVsQTogVmVjMiwgQjogU2hhcGUsIHZlbEI6IFZlYzIpOiBbVmVjMiwgVmVjMiwgYm9vbGVhbiwgYm9vbGVhbl0ge1xyXG5cdFx0aWYoQSBpbnN0YW5jZW9mIEFBQkIgJiYgQiBpbnN0YW5jZW9mIEFBQkIpe1xyXG5cdFx0XHRyZXR1cm4gU2hhcGUuZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBLCB2ZWxBLCBCLCB2ZWxCKTtcclxuXHRcdH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBOiBBQUJCLCB2ZWxBOiBWZWMyLCBCOiBTaGFwZSwgdmVsQjogVmVjMik6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XHJcbiAgICAgICAgbGV0IHBvc1NtYWxsZXIgPSBBLmNlbnRlcjtcclxuICAgICAgICBsZXQgcG9zTGFyZ2VyID0gQi5jZW50ZXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHNpemVTbWFsbGVyID0gQS5oYWxmU2l6ZTtcclxuICAgICAgICBsZXQgc2l6ZUxhcmdlciA9IEIuaGFsZlNpemU7XHJcbiAgICBcclxuICAgICAgICBsZXQgZmlyc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XHJcbiAgICAgICAgbGV0IGxhc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XHJcbiAgICBcclxuICAgICAgICBsZXQgY29sbGlkaW5nWCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjb2xsaWRpbmdZID0gZmFsc2U7XHJcbiAgICBcclxuICAgICAgICAvLyBTb3J0IGJ5IHBvc2l0aW9uXHJcbiAgICAgICAgaWYocG9zTGFyZ2VyLnggPCBwb3NTbWFsbGVyLngpe1xyXG4gICAgICAgICAgICAvLyBTd2FwLCBiZWNhdXNlIHNtYWxsZXIgaXMgZnVydGhlciByaWdodCB0aGFuIGxhcmdlclxyXG4gICAgICAgICAgICBsZXQgdGVtcDogVmVjMjtcclxuICAgICAgICAgICAgdGVtcCA9IHNpemVTbWFsbGVyO1xyXG4gICAgICAgICAgICBzaXplU21hbGxlciA9IHNpemVMYXJnZXI7XHJcbiAgICAgICAgICAgIHNpemVMYXJnZXIgPSB0ZW1wO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xyXG4gICAgICAgICAgICBwb3NTbWFsbGVyID0gcG9zTGFyZ2VyO1xyXG4gICAgICAgICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRlbXAgPSB2ZWxBO1xyXG4gICAgICAgICAgICB2ZWxBID0gdmVsQjtcclxuICAgICAgICAgICAgdmVsQiA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gQSBpcyBsZWZ0LCBCIGlzIHJpZ2h0XHJcbiAgICAgICAgZmlyc3RDb250YWN0LnggPSBJbmZpbml0eTtcclxuICAgICAgICBsYXN0Q29udGFjdC54ID0gSW5maW5pdHk7XHJcbiAgICBcclxuICAgICAgICBpZiAocG9zTGFyZ2VyLnggLSBzaXplTGFyZ2VyLnggPj0gcG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCl7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXHJcbiAgICAgICAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnggLSB2ZWxCLng7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihyZWxWZWwgPiAwKXtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgICAgIGZpcnN0Q29udGFjdC54ID0gKChwb3NMYXJnZXIueCAtIHNpemVMYXJnZXIueCkgLSAocG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCkpLyhyZWxWZWwpO1xyXG4gICAgICAgICAgICAgICAgbGFzdENvbnRhY3QueCA9ICgocG9zTGFyZ2VyLnggKyBzaXplTGFyZ2VyLngpIC0gKHBvc1NtYWxsZXIueCAtIHNpemVTbWFsbGVyLngpKS8ocmVsVmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGluZ1ggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGlmKHBvc0xhcmdlci55IDwgcG9zU21hbGxlci55KXtcclxuICAgICAgICAgICAgLy8gU3dhcCwgYmVjYXVzZSBzbWFsbGVyIGlzIGZ1cnRoZXIgdXAgdGhhbiBsYXJnZXJcclxuICAgICAgICAgICAgbGV0IHRlbXA6IFZlYzI7XHJcbiAgICAgICAgICAgIHRlbXAgPSBzaXplU21hbGxlcjtcclxuICAgICAgICAgICAgc2l6ZVNtYWxsZXIgPSBzaXplTGFyZ2VyO1xyXG4gICAgICAgICAgICBzaXplTGFyZ2VyID0gdGVtcDtcclxuICAgIFxyXG4gICAgICAgICAgICB0ZW1wID0gcG9zU21hbGxlcjtcclxuICAgICAgICAgICAgcG9zU21hbGxlciA9IHBvc0xhcmdlcjtcclxuICAgICAgICAgICAgcG9zTGFyZ2VyID0gdGVtcDtcclxuICAgIFxyXG4gICAgICAgICAgICB0ZW1wID0gdmVsQTtcclxuICAgICAgICAgICAgdmVsQSA9IHZlbEI7XHJcbiAgICAgICAgICAgIHZlbEIgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIEEgaXMgdG9wLCBCIGlzIGJvdHRvbVxyXG4gICAgICAgIGZpcnN0Q29udGFjdC55ID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGFzdENvbnRhY3QueSA9IEluZmluaXR5O1xyXG4gICAgXHJcbiAgICAgICAgaWYgKHBvc0xhcmdlci55IC0gc2l6ZUxhcmdlci55ID49IHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpe1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgY3VycmVudGx5IGNvbGxpZGluZ1xyXG4gICAgICAgICAgICBsZXQgcmVsVmVsID0gdmVsQS55IC0gdmVsQi55O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYocmVsVmVsID4gMCl7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBtb3ZpbmcgdG93YXJkcyBlYWNoIG90aGVyXHJcbiAgICAgICAgICAgICAgICBmaXJzdENvbnRhY3QueSA9ICgocG9zTGFyZ2VyLnkgLSBzaXplTGFyZ2VyLnkpIC0gKHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpKS8ocmVsVmVsKTtcclxuICAgICAgICAgICAgICAgIGxhc3RDb250YWN0LnkgPSAoKHBvc0xhcmdlci55ICsgc2l6ZUxhcmdlci55KSAtIChwb3NTbWFsbGVyLnkgLSBzaXplU21hbGxlci55KSkvKHJlbFZlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xsaWRpbmdZID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gW2ZpcnN0Q29udGFjdCwgbGFzdENvbnRhY3QsIGNvbGxpZGluZ1gsIGNvbGxpZGluZ1ldO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgTElGTyBzdGFjayB3aXRoIGl0ZW1zIG9mIHR5cGUgVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhY2s8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcclxuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIFN0YWNrICovXHJcbiAgICBwcml2YXRlIE1BWF9FTEVNRU5UUzogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGFjayAqL1xyXG4gICAgcHJpdmF0ZSBzdGFjazogQXJyYXk8VD47XHJcbiAgICBcclxuICAgIC8qKiBUaGUgaGVhZCBvZiB0aGUgc3RhY2sgKi9cclxuXHRwcml2YXRlIGhlYWQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgc3RhY2tcclxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKXtcclxuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgQXJyYXk8VD4odGhpcy5NQVhfRUxFTUVOVFMpO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IC0xO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIG5ldyBpdGVtIHRvIGFkZCB0byB0aGUgc3RhY2tcclxuICAgICAqL1xyXG4gICAgcHVzaChpdGVtOiBUKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5oZWFkICsgMSA9PT0gdGhpcy5NQVhfRUxFTUVOVFMpe1xyXG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWFkICs9IDE7XHJcbiAgICAgICAgdGhpcy5zdGFja1t0aGlzLmhlYWRdID0gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBwb3AoKTogVCB7XHJcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSAtMSl7XHJcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZW1wdHkgLSBjYW5ub3QgcmVtb3ZlIGVsZW1lbnRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWFkIC09IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5oZWFkICsgMV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAqL1xyXG4gICAgcGVlaygpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IC0xKXtcclxuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCBnZXQgZWxlbWVudFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzdGFjayBpcyBlbXB0eVxyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RhY2sgaXMgZW1wdHlcclxuICAgICovXHJcbiAgICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgPT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gZGVsZXRlIHRoaXMuc3RhY2tbaW5kZXhdKTtcclxuICAgICAgICB0aGlzLmhlYWQgPSAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBpdGVtcyBjdXJyZW50bHkgaW4gdGhlIHN0YWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBzaXplKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGltcGxlbWVudGVkXHJcbiAgICBmb3JFYWNoKGZ1bmM6IChpdGVtOiBULCBpbmRleD86IG51bWJlcikgPT4gdm9pZCk6IHZvaWR7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlKGkgPD0gdGhpcy5oZWFkKXtcclxuICAgICAgICAgICAgZnVuYyh0aGlzLnN0YWNrW2ldLCBpKTtcclxuICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgc3RhY2sgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHN0YWNrXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgaWYoaW5kZXggIT09IDApe1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dmFsID0gc3RyICsgcmV0dmFsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBTdGF0ZU1hY2hpbmUgZnJvbSBcIi4vU3RhdGVNYWNoaW5lXCI7XHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3QgaW1wbGVtZW50YXRpb24gb2YgYSBzdGF0ZSBmb3IgYSBAcmVmZXJlbmNlW1N0YXRlTWFjaGluZV0uXHJcbiAqIFRoaXMgY2xhc3Mgc2hvdWxkIGJlIGV4dGVuZGVkIHRvIGFsbG93IGZvciBjdXN0b20gc3RhdGUgYmVoYXZpb3JzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU3RhdGUgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuICAgIC8qKiBUaGUgU3RhdGVNYWNoaW5lIHRoYXQgdXNlcyB0aGlzIFN0YXRlICovXHJcbiAgICBwcm90ZWN0ZWQgcGFyZW50OiBTdGF0ZU1hY2hpbmU7XHJcblxyXG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cclxuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBTdGF0ZVxyXG4gICAgICogQHBhcmFtIHBhcmVudCBUaGUgcGFyZW50IFN0YXRlTWFjaGluZSBvZiB0aGlzIHN0YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogU3RhdGVNYWNoaW5lKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhpcyBzdGF0ZSBpcyBlbnRlcmVkLiBVc2UgdGhpcyB0byBpbml0aWFsaXplIGFueSB2YXJpYWJsZXMgYmVmb3JlIHVwZGF0ZXMgb2NjdXIuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJbmZvcm1hdGlvbiB0byBwYXNzIHRvIHRoaXMgc3RhdGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgb25FbnRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCB0aGF0IGhhbmRsZXMgYW4gaW5wdXQgZXZlbnQsIHN1Y2ggYXMgdGFraW5nIGRhbWFnZS5cclxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgR2FtZUV2ZW50IHRvIHByb2Nlc3NcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQ7XHJcblxyXG4gICAgLy8gQGltcGxlbWVudGVkXHJcbiAgICBhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHN0YXRlIG1hY2hpbmUgdGhhdCB0aGlzIHN0YXRlIGhhcyBlbmRlZCwgYW5kIG1ha2VzIGl0IHRyYW5zaXRpb24gdG8gdGhlIG5ldyBzdGF0ZSBzcGVjaWZpZWRcclxuICAgICAqIEBwYXJhbSBzdGF0ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGZpbmlzaGVkKHN0YXRlTmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hhbmdlU3RhdGUoc3RhdGVOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaXMgZW5kaW5nLlxyXG4gICAgICogQHJldHVybnMgaW5mbyB0byBwYXNzIHRvIHRoZSBuZXh0IHN0YXRlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG59IiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9TdGFja1wiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4vU3RhdGVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vTWFwXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi8uLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIFB1c2ggRG93biBBdXRvbWF0YSBTdGF0ZSBtYWNoaW5lLiBTdGF0ZXMgY2FuIGFsc28gYmUgaGllcmFyY2hpY2FsXHJcbiAqIGZvciBtb3JlIGZsZXhpYmlsaXR5LCBhcyBkZXNjcmliZWQgaW4gQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vc3RhdGUuaHRtbCkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZU1hY2hpbmUgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuICAgIC8qKiBBIHN0YWNrIG9mIHRoZSBjdXJyZW50IHN0YXRlcyAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YWNrOiBTdGFjazxTdGF0ZT47XHJcbiAgICAvKiogQSBtYXBlIG9mIHN0YXRlIGtleXMgdG8gYWN0dWFsIHN0YXRlIGluc3RhbmNlcyAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRlTWFwOiBNYXA8U3RhdGU+O1xyXG4gICAgLyoqIFRoZSBjdXJyZW50IHN0YXRlICovXHJcbiAgICBwcm90ZWN0ZWQgY3VycmVudFN0YXRlOiBTdGF0ZTtcclxuICAgIC8qKiBBbiBldmVudCByZWNlaXZlciAqL1xyXG4gICAgcHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcclxuICAgIC8qKiBBbiBldmVudCBlbWl0dGVyICovXHJcbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuICAgIC8qKiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgU3RhdGVNYWNoaW5lIGlzIGN1cnJlbnRseSBhY3RpdmUgKi9cclxuICAgIHByb3RlY3RlZCBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICAvKiogQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIFN0YXRlTWFjaGluZSBzaG91bGQgZW1pdCBhbiBldmVudCBvbiBzdGF0ZSBjaGFuZ2UgKi9cclxuICAgIHByb3RlY3RlZCBlbWl0RXZlbnRPblN0YXRlQ2hhbmdlOiBib29sZWFuO1xyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBlbWl0dGVkIG9uIHN0YXRlIGNoYW5nZSAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRlQ2hhbmdlRXZlbnROYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0YXRlTWFjaGluZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgU3RhY2soKTtcclxuICAgICAgICB0aGlzLnN0YXRlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYWN0aXZpdHkgc3RhdGUgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lXHJcbiAgICAgKiBAcGFyYW0gZmxhZyBUcnVlIGlmIHlvdSB3YW50IHRvIHNldCB0aGlzIG1hY2hpbmUgcnVubmluZywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHNldEFjdGl2ZShmbGFnOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmbGFnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgdGhpcyBzdGF0ZSBtYWNoaW5lIGVtaXQgYW4gZXZlbnQgYW55IHRpbWUgaXRzIHN0YXRlIGNoYW5nZXNcclxuICAgICAqIEBwYXJhbSBzdGF0ZUNoYW5nZUV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdFxyXG4gICAgICovXHJcbiAgICBzZXRFbWl0RXZlbnRPblN0YXRlQ2hhbmdlKHN0YXRlQ2hhbmdlRXZlbnROYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmVtaXRFdmVudE9uU3RhdGVDaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFdmVudE5hbWUgPSBzdGF0ZUNoYW5nZUV2ZW50TmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoaXMgc3RhdGUgbWFjaGluZSBmcm9tIGVtaXR0aW5nIGV2ZW50cyBvbiBzdGF0ZSBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbEVtaXRFdmVudE9uU3RhdGVDaGFuZ2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhpcyBzdGF0ZSBtYWNoaW5lIHdpdGggYW4gaW5pdGlhbCBzdGF0ZSBhbmQgc2V0cyBpdCBydW5uaW5nXHJcbiAgICAgKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBuYW1lIG9mIGluaXRpYWwgc3RhdGUgb2YgdGhlIHN0YXRlIG1hY2hpbmVcclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZShpbml0aWFsU3RhdGU6IHN0cmluZywgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGVNYXAuZ2V0KGluaXRpYWxTdGF0ZSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnNldEFjdGl2ZSh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzdGF0ZSB0byB0aGlzIHN0YXRlIG1hY2hpbmVcclxuICAgICAqIEBwYXJhbSBzdGF0ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGFkZFxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0byBhZGRcclxuICAgICAqL1xyXG4gICAgYWRkU3RhdGUoc3RhdGVOYW1lOiBzdHJpbmcsIHN0YXRlOiBTdGF0ZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc3RhdGVNYXAuYWRkKHN0YXRlTmFtZSwgc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgc3RhdGUgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lIHRvIHRoZSBwcm92aWRlZCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RyaW5nIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGNoYW5nZSB0b1xyXG4gICAgICovXHJcbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRXhpdCB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5jdXJyZW50U3RhdGUub25FeGl0KCk7XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29ycmVjdCBzdGF0ZSBpcyBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICAgIGlmKHN0YXRlID09PSBcInByZXZpb3VzXCIpe1xyXG4gICAgICAgICAgICAvLyBQb3AgdGhlIGN1cnJlbnQgc3RhdGUgb2ZmIHRoZSBzdGFja1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBuZXcgc3RhdGUgZnJvbSB0aGUgc3RhdGVtYXAgYW5kIHB1dCBpdCBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZU1hcC5nZXQoc3RhdGUpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJldHJlaXZlIHRoZSBuZXcgc3RhdGUgZnJvbSB0aGUgc3RhY2tcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhY2sucGVlaygpO1xyXG5cclxuICAgICAgICAvLyBFbWl0IGFuIGV2ZW50IGlmIHR1cm5lZCBvblxyXG4gICAgICAgIGlmKHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSl7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSwge3N0YXRlOiB0aGlzLmN1cnJlbnRTdGF0ZX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRW50ZXIgdGhlIG5ldyBzdGF0ZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLm9uRW50ZXIob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGlucHV0LiBUaGlzIGhhcHBlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoaXMgc3RhdGUgbWFjaGluZSdzIHVwZGF0ZSBjeWNsZS5cclxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZ2FtZSBldmVudCB0byBwcm9jZXNzXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLmFjdGl2ZSl7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmhhbmRsZUlucHV0KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGltcGxlbWVudGVkXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICAvLyBEaXN0cmlidXRlIGV2ZW50c1xyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlbGVnYXRlIHRoZSB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS51cGRhdGUoZGVsdGFUKTtcclxuICAgIH1cclxufSIsImltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IHsgVGlsZWRUaWxlc2V0RGF0YSB9IGZyb20gXCIuL1RpbGVkRGF0YVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkYXRhIHJlcHJlc2VudGF0aW9uIG9mIGEgVGlsZXNldCBmb3IgdGhlIGdhbWUgZW5naW5lLiBUaGlzIHJlcHJlc2VudHMgb25lIGltYWdlLFxyXG4gKiB3aXRoIGEgc3RhcnRJbmRleCBpZiByZXF1aXJlZCAoYXMgaXQgaXMgd2l0aCBUaWxlZCB1c2luZyB0d28gaW1hZ2VzIGluIG9uZSB0aWxzZXQpLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZXNldCB7XHJcbiAgICAvKiogVGhlIGtleSBvZiB0aGUgaW1hZ2UgdXNlZCBieSB0aGlzIHRpbGVzZXQgKi9cclxuICAgIHByb3RlY3RlZCBpbWFnZUtleTogc3RyaW5nO1xyXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlc2V0IGltYWdlICovXHJcbiAgICBwcm90ZWN0ZWQgaW1hZ2VTaXplOiBWZWMyO1xyXG4gICAgLyoqIFRoZSBpbmRleCBvZiAwdGggaW1hZ2Ugb2YgdGhpcyB0aWxlc2V0ICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhcnRJbmRleDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBpbWFnZSBvZiB0aGlzIHRpbHNldCAqL1xyXG4gICAgcHJvdGVjdGVkIGVuZEluZGV4OiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIHRpbGVzIGluIHRoaXMgdGlsZXNldCAqL1xyXG4gICAgcHJvdGVjdGVkIHRpbGVTaXplOiBWZWMyO1xyXG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGlzIHRpbGVzZXQgKi9cclxuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoaXMgdGlsZXNldCAqL1xyXG4gICAgcHJvdGVjdGVkIG51bUNvbHM6IG51bWJlcjtcclxuXHJcbiAgICAvLyBUT0RPOiBDaGFuZ2UgdGhpcyB0byBiZSBtb3JlIGdlbmVyYWwgYW5kIHdvcmsgd2l0aCBvdGhlciB0aWxlc2V0IGZvcm1hdHNcclxuICAgIGNvbnN0cnVjdG9yKHRpbGVzZXREYXRhOiBUaWxlZFRpbGVzZXREYXRhKXtcclxuICAgICAgICAvLyBEZWZlciBoYW5kbGluZyBvZiB0aGUgZGF0YSB0byBhIGhlbHBlciBjbGFzc1xyXG4gICAgICAgIHRoaXMuaW5pdEZyb21UaWxlZERhdGEodGlsZXNldERhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgdGlsZXNldCBmcm9tIHRoZSBkYXRhIGZyb20gYSBUaWxlZCBqc29uIGZpbGVcclxuICAgICAqIEBwYXJhbSB0aWxlZERhdGEgVGhlIHBhcnNlZCBvYmplY3QgZnJvbSBhIFRpbGVkIGpzb24gZmlsZVxyXG4gICAgICovXHJcbiAgICBpbml0RnJvbVRpbGVkRGF0YSh0aWxlZERhdGE6IFRpbGVkVGlsZXNldERhdGEpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm51bVJvd3MgPSB0aWxlZERhdGEudGlsZWNvdW50L3RpbGVkRGF0YS5jb2x1bW5zO1xyXG4gICAgICAgIHRoaXMubnVtQ29scyA9IHRpbGVkRGF0YS5jb2x1bW5zO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHRpbGVkRGF0YS5maXJzdGdpZDtcclxuICAgICAgICB0aGlzLmVuZEluZGV4ID0gdGhpcy5zdGFydEluZGV4ICsgdGlsZWREYXRhLnRpbGVjb3VudCAtIDE7XHJcbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IG5ldyBWZWMyKHRpbGVkRGF0YS50aWxld2lkdGgsIHRpbGVkRGF0YS50aWxld2lkdGgpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VLZXkgPSB0aWxlZERhdGEuaW1hZ2U7XHJcbiAgICAgICAgdGhpcy5pbWFnZVNpemUgPSBuZXcgVmVjMih0aWxlZERhdGEuaW1hZ2V3aWR0aCwgdGlsZWREYXRhLmltYWdlaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogXHJcbiAgICAgKiBHZXRzIHRoZSBpbWFnZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGlsZW1hcFxyXG4gICAgICogQHJldHVybnMgVGhlIGltYWdlIGtleSBvZiB0aGlzIHRpbGVtYXBcclxuICAgICAqL1xyXG4gICAgZ2V0SW1hZ2VLZXkoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUtleTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBWZWMyIGNvbnRhaW5pbmcgdGhlIGxlZnQgYW5kIHRvcCBvZmZzZXQgZnJvbSB0aGUgaW1hZ2Ugb3JpZ2luIGZvciB0aGlzIHRpbGUuXHJcbiAgICAgKiBAcGFyYW0gdGlsZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBmcm9tIHN0YXJ0SW5kZXggdG8gZW5kSW5kZXggb2YgdGhpcyB0aWxlc2V0XHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgb2Zmc2V0IGZvciB0aGUgc3BlY2lmaWVkIHRpbGUuXHJcbiAgICAgKi9cclxuICAgIGdldEltYWdlT2Zmc2V0Rm9yVGlsZSh0aWxlSW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxyXG4gICAgICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRoaXMuc3RhcnRJbmRleDtcclxuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMubnVtQ29scyk7XHJcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudGlsZVNpemUueDtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy50aWxlU2l6ZS55O1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxyXG4gICAgICAgIGxldCBsZWZ0ID0gY29sICogd2lkdGg7XHJcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKGxlZnQsIHRvcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzdGFydCBpbmRleFxyXG4gICAgICogQHJldHVybnMgVGhlIHN0YXJ0IGluZGV4XHJcbiAgICAgKi9cclxuICAgIGdldFN0YXJ0SW5kZXgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydEluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdGlsZSBzZXRcclxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSB0aWxlIHNpemVcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZVNpemUoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZXNldFxyXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiByb3dzXHJcbiAgICAgKi9cclxuICAgIGdldE51bVJvd3MoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1Sb3dzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbHNldFxyXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjb2x1bW5zXHJcbiAgICAgKi9cclxuICAgIGdldE51bUNvbHMoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1Db2xzO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRpbGVDb3VudCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZEluZGV4IC0gdGhpcy5zdGFydEluZGV4ICsgMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCBjb250YWlucyB0aGUgc3BlY2lmaWVkIHRpbGUgaW5kZXguIFRoaXMgaXMgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyB0aWxzZXQgdXNlcyB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGhhc1RpbGUodGlsZUluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGlsZUluZGV4ID49IHRoaXMuc3RhcnRJbmRleCAmJiB0aWxlSW5kZXggPD0gdGhpcy5lbmRJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlciBhIHNpbmd1bGFyIHRpbGUgd2l0aCBpbmRleCB0aWxlSW5kZXggZnJvbSB0aGUgdGlsZXNldCBsb2NhdGVkIGF0IHBvc2l0aW9uIGRhdGFJbmRleFxyXG4gICAgICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIHZhbHVlIG9mIHRoZSB0aWxlIHRvIHJlbmRlclxyXG4gICAgICogQHBhcmFtIGRhdGFJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIGRhdGEgYXJyYXlcclxuICAgICAqIEBwYXJhbSB3b3JsZFNpemUgVGhlIHNpemUgb2YgdGhlIHdvcmxkXHJcbiAgICAgKiBAcGFyYW0gb3JpZ2luIFRoZSB2aWV3cG9ydCBvcmlnaW4gaW4gdGhlIGN1cnJlbnQgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBzY2FsZSBUaGUgc2NhbGUgb2YgdGhlIHRpbGVtYXBcclxuICAgICAqL1xyXG4gICAgcmVuZGVyVGlsZShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgdGlsZUluZGV4OiBudW1iZXIsIGRhdGFJbmRleDogbnVtYmVyLCBtYXhDb2xzOiBudW1iZXIsIG9yaWdpbjogVmVjMiwgc2NhbGU6IFZlYzIsIHpvb206IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBpbWFnZSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEltYWdlKHRoaXMuaW1hZ2VLZXkpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHRydWUgaW5kZXhcclxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xyXG4gICAgICAgIGxldCBjb2wgPSBpbmRleCAlIHRoaXMubnVtQ29scztcclxuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudGlsZVNpemUueTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcclxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xyXG4gICAgICAgIGxldCB0b3AgPSByb3cgKiBoZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHdvcmxkIHRvIHJlbmRlciB0aGUgdGlsZVxyXG4gICAgICAgIGxldCB4ID0gTWF0aC5mbG9vcigoZGF0YUluZGV4ICUgbWF4Q29scykgKiB3aWR0aCAqIHNjYWxlLngpO1xyXG4gICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcihNYXRoLmZsb29yKGRhdGFJbmRleCAvIG1heENvbHMpICogaGVpZ2h0ICogc2NhbGUueSk7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCBNYXRoLmZsb29yKCh4IC0gb3JpZ2luLngpKnpvb20pLCBNYXRoLmZsb29yKCh5IC0gb3JpZ2luLnkpKnpvb20pLCBNYXRoLmNlaWwod2lkdGggKiBzY2FsZS54ICogem9vbSksIE1hdGguY2VpbChoZWlnaHQgKiBzY2FsZS55ICogem9vbSkpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcblxyXG4vKipcclxuICogQSB0d28tZGltZW5zaW9uYWwgdmVjdG9yICh4LCB5KVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjMiB7XHJcblxyXG5cdC8vIFN0b3JlIHggYW5kIHkgaW4gYW4gYXJyYXlcclxuXHQvKiogVGhlIGFycmF5IHRoYXQgc3RvcmVzIHRoZSBhY3R1YWwgdmVjdG9yIHZhbHVlcyB4IGFuZCB5ICovXHJcblx0cHJpdmF0ZSB2ZWM6IEZsb2F0MzJBcnJheTtcclxuXHJcblx0LyoqXHRcclxuXHQgKiBXaGVuIHRoaXMgdmVjdG9yIGNoYW5nZXMgaXRzIHZhbHVlLCBkbyBzb21ldGhpbmdcclxuXHQgKi9cclxuXHRwcml2YXRlIG9uQ2hhbmdlOiBGdW5jdGlvbiA9ICgpID0+IHt9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IFZlYzJcclxuXHQgKiBAcGFyYW0geCBUaGUgeCB2YWx1ZSBvZiB0aGUgdmVjdG9yXHJcblx0ICogQHBhcmFtIHkgVGhlIHkgdmFsdWUgb2YgdGhlIHZlY3RvclxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHg6IG51bWJlciA9IDAsIHk6IG51bWJlciA9IDApIHtcclxuXHRcdHRoaXMudmVjID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcclxuXHRcdHRoaXMudmVjWzBdID0geDtcclxuXHRcdHRoaXMudmVjWzFdID0geTtcclxuXHR9XHJcblxyXG5cdC8vIEV4cG9zZSB4IGFuZCB5IHdpdGggZ2V0dGVycyBhbmQgc2V0dGVyc1xyXG5cdGdldCB4KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudmVjWzBdO1xyXG5cdH1cclxuXHJcblx0c2V0IHgoeDogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnZlY1swXSA9IHg7XHJcblxyXG5cdFx0aWYodGhpcy5vbkNoYW5nZSl7XHJcblx0XHRcdHRoaXMub25DaGFuZ2UoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGdldCB5KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudmVjWzFdO1xyXG5cdH1cclxuXHJcblx0c2V0IHkoeTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnZlY1sxXSA9IHk7XHJcblxyXG5cdFx0aWYodGhpcy5vbkNoYW5nZSl7XHJcblx0XHRcdHRoaXMub25DaGFuZ2UoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXQgWkVSTygpIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMigwLCAwKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyByZWFkb25seSBaRVJPX1NUQVRJQyA9IG5ldyBWZWMyKDAsIDApO1xyXG5cclxuXHRzdGF0aWMgZ2V0IElORigpIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMihJbmZpbml0eSwgSW5maW5pdHkpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldCBVUCgpIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMigwLCAtMSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IERPV04oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoMCwgMSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IExFRlQoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoLTEsIDApO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldCBSSUdIVCgpIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMigxLCAwKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBzcXVhcmVkIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLiBUaGlzIHRlbmRzIHRvIGJlIGZhc3Rlciwgc28gdXNlIGl0IGluIHNpdHVhdGlvbnMgd2hlcmUgdGFraW5nIHRoZVxyXG5cdCAqIHNxdWFyZSByb290IGRvZXNuJ3QgbWF0dGVyLCBsaWtlIGZvciBjb21wYXJpbmcgZGlzdGFuY2VzLlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzcXVhcmVkIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yXHJcblx0ICovXHJcblx0bWFnU3EoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLngqdGhpcy54ICsgdGhpcy55KnRoaXMueTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cclxuXHQgKiBAcmV0dXJucyBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXHJcblx0ICovXHJcblx0bWFnKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMubWFnU3EoKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXZkZXMgeCBhbmQgeSBieSB0aGUgbWFnbml0dWRlIHRvIG9idGFpbiB0aGUgdW5pdCB2ZWN0b3IgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGlzIHZlY3Rvci5cclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHVuaXQgdmVjdG9yLlxyXG5cdCAqL1xyXG5cdG5vcm1hbGl6ZSgpOiBWZWMyIHtcclxuXHRcdGlmKHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDApIHJldHVybiB0aGlzO1xyXG5cdFx0bGV0IG1hZyA9IHRoaXMubWFnKCk7XHJcblx0XHR0aGlzLnggLz0gbWFnO1xyXG5cdFx0dGhpcy55IC89IG1hZztcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogV29ya3MgbGlrZSBub3JtYWxpemUoKSwgYnV0IHJldHVybnMgYSBuZXcgVmVjMlxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB0aGF0IGlzIHRoZSB1bml0IHZlY3RvciBmb3IgdGhpcyBvbmVcclxuXHQgKi9cclxuXHRub3JtYWxpemVkKCk6IFZlYzIge1xyXG5cdFx0aWYodGhpcy5pc1plcm8oKSl7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRsZXQgbWFnID0gdGhpcy5tYWcoKTtcclxuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLngvbWFnLCB0aGlzLnkvbWFnKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHggYW5kIHkgZWxlbWVudHMgb2YgdGhpcyB2ZWN0b3IgdG8gemVyby5cclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3Rvciwgd2l0aCB4IGFuZCB5IHNldCB0byB6ZXJvLlxyXG5cdCAqL1xyXG5cdHplcm8oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXQoMCwgMCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSB2ZWN0b3IncyB4IGFuZCB5IGJhc2VkIG9uIHRoZSBhbmdsZSBwcm92aWRlZC4gR29lcyBjb3VudGVyIGNsb2Nrd2lzZS5cclxuXHQgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvciBhdCB0aGUgc3BlY2lmaWVkIGFuZ2xlXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IuXHJcblx0ICovXHJcblx0c2V0VG9BbmdsZShhbmdsZTogbnVtYmVyLCByYWRpdXM6IG51bWJlciA9IDEpOiBWZWMyIHtcclxuXHRcdHRoaXMueCA9IE1hdGhVdGlscy5mbG9vclRvUGxhY2UoTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgNSk7XHJcblx0XHR0aGlzLnkgPSBNYXRoVXRpbHMuZmxvb3JUb1BsYWNlKC1NYXRoLnNpbihhbmdsZSkqcmFkaXVzLCA1KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHZlY3RvciB0aGF0IHBvaW50IGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlciBvbmVcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBwb2ludCB0b1xyXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgdGhhdCBwb2ludHMgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb25lIHByb3ZpZGVkXHJcblx0ICovXHJcblx0dmVjVG8ob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMihvdGhlci54IC0gdGhpcy54LCBvdGhlci55IC0gdGhpcy55KTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHZlY3RvciBjb250YWluaW5nIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gcG9pbnQgdG9cclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHRoYXQgcG9pbnRzIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG9uZSBwcm92aWRlZC4gVGhpcyBuZXcgVmVjMiB3aWxsIGJlIGEgdW5pdCB2ZWN0b3IuXHJcblx0ICovXHJcblx0ZGlyVG8ob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLnZlY1RvKG90aGVyKS5ub3JtYWxpemUoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEtlZXBzIHRoZSB2ZWN0b3IncyBkaXJlY3Rpb24sIGJ1dCBzZXRzIGl0cyBtYWduaXR1ZGUgdG8gYmUgdGhlIHByb3ZpZGVkIG1hZ25pdHVkZVxyXG5cdCAqIEBwYXJhbSBtYWduaXR1ZGUgVGhlIG1hZ25pdHVkZSB0aGUgdmVjdG9yIHNob3VsZCBiZVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIHdpdGggaXRzIG1hZ25pdHVkZSBzZXQgdG8gdGhlIG5ldyBtYWduaXR1ZGVcclxuXHQgKi9cclxuXHRzY2FsZVRvKG1hZ25pdHVkZTogbnVtYmVyKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5zY2FsZShtYWduaXR1ZGUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2NhbGVzIHggYW5kIHkgYnkgdGhlIG51bWJlciBwcm92aWRlZCwgb3IgaWYgdHdvIG51bWJlciBhcmUgcHJvdmlkZWQsIHNjYWxlcyB0aGVtIGluZGl2aWR1YWxseS5cclxuXHQgKiBAcGFyYW0gZmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHZlY3Rvciwgb3IgZm9yIG9ubHkgdGhlIHgtY29tcG9uZW50IGlmIHlGYWN0b3IgaXMgcHJvdmlkZWRcclxuXHQgKiBAcGFyYW0geUZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB5LWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgc2NhbGluZ1xyXG5cdCAqL1xyXG5cdHNjYWxlKGZhY3RvcjogbnVtYmVyLCB5RmFjdG9yOiBudW1iZXIgPSBudWxsKTogVmVjMiB7XHJcblx0XHRpZih5RmFjdG9yICE9PSBudWxsKXtcclxuXHRcdFx0dGhpcy54ICo9IGZhY3RvcjtcclxuXHRcdFx0dGhpcy55ICo9IHlGYWN0b3I7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy54ICo9IGZhY3RvcjtcclxuXHRcdHRoaXMueSAqPSBmYWN0b3I7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzY2FsZWQgdmVyc2lvbiBvZiB0aGlzIHZlY3RvciB3aXRob3V0IG1vZGlmeWluZyBpdC5cclxuXHQgKiBAcGFyYW0gZmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHZlY3Rvciwgb3IgZm9yIG9ubHkgdGhlIHgtY29tcG9uZW50IGlmIHlGYWN0b3IgaXMgcHJvdmlkZWRcclxuXHQgKiBAcGFyYW0geUZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB5LWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXHJcblx0ICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHRoYXQgaGFzIHRoZSB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3IgYWZ0ZXIgc2NhbGluZ1xyXG5cdCAqL1xyXG5cdHNjYWxlZChmYWN0b3I6IG51bWJlciwgeUZhY3RvcjogbnVtYmVyID0gbnVsbCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5zY2FsZShmYWN0b3IsIHlGYWN0b3IpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUm90YXRlcyB0aGUgdmVjdG9yIGNvdW50ZXItY2xvY2t3aXNlIGJ5IHRoZSBhbmdsZSBhbW91bnQgc3BlY2lmaWVkXHJcblx0ICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSB0byByb3RhdGUgYnkgaW4gcmFkaWFuc1xyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIHJvdGF0aW9uLlxyXG5cdCAqL1xyXG5cdHJvdGF0ZUNDVyhhbmdsZTogbnVtYmVyKTogVmVjMiB7XHJcblx0XHRsZXQgY3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcblx0XHRsZXQgc24gPSBNYXRoLnNpbihhbmdsZSk7XHJcblx0XHRsZXQgdGVtcFggPSB0aGlzLngqY3MgLSB0aGlzLnkqc247XHJcblx0XHRsZXQgdGVtcFkgPSB0aGlzLngqc24gKyB0aGlzLnkqY3M7XHJcblx0XHR0aGlzLnggPSB0ZW1wWDtcclxuXHRcdHRoaXMueSA9IHRlbXBZO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSB2ZWN0b3JzIGNvb3JkaW5hdGVzIHRvIGJlIHRoZSBvbmVzIHByb3ZpZGVkXHJcblx0ICogQHBhcmFtIHggVGhlIG5ldyB4IHZhbHVlIGZvciB0aGlzIHZlY3RvclxyXG5cdCAqIEBwYXJhbSB5IFRoZSBuZXcgeSB2YWx1ZSBmb3IgdGhpcyB2ZWN0b3JcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvclxyXG5cdCAqL1xyXG5cdHNldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBvdGhlciBWZWMyIGludG8gdGhpcyBvbmUuXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIGNvcHlcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciB3aXRoIGl0cyB2YWx1ZXMgc2V0IHRvIHRoZSB2ZWN0b3IgcHJvdmlkZWRcclxuXHQgKi9cclxuXHRjb3B5KG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXQob3RoZXIueCwgb3RoZXIueSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIHRoaXMgdmVjdG9yIHRoZSBhbm90aGVyIHZlY3RvclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBhZGQgdG8gdGhpcyBvbmVcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBhZGRpbmcgdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdGFkZChvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0dGhpcy54ICs9IG90aGVyLng7XHJcblx0XHR0aGlzLnkgKz0gb3RoZXIueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5jcmVtZW50cyB0aGUgZmllbGRzIG9mIHRoaXMgdmVjdG9yLiBCb3RoIGFyZSBpbmNyZW1lbnRlZCB3aXRoIGEsIGlmIG9ubHkgYSBpcyBwcm92aWRlZC5cclxuXHQgKiBAcGFyYW0gYSBUaGUgZmlyc3QgbnVtYmVyIHRvIGluY3JlbWVudCBieVxyXG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGluY3JlbWVudCBieVxyXG5cdCAqIEByZXR1cm5zcyBUaGlzIHZlY3RvciBhZnRlciBpbmNyZW1lbnRpbmdcclxuXHQgKi9cclxuXHRpbmMoYTogbnVtYmVyLCBiPzogbnVtYmVyKTogVmVjMiB7XHJcblx0XHRpZihiID09PSB1bmRlZmluZWQpe1xyXG5cdFx0XHR0aGlzLnggKz0gYTtcclxuXHRcdFx0dGhpcy55ICs9IGE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnggKz0gYTtcclxuXHRcdFx0dGhpcy55ICs9IGI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFN1YnRyYWN0cyBhbm90aGVyIHZlY3RvciBmcm9tIHRoaXMgdmVjdG9yXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIHN1YnRyYWN0IGZyb20gdGhpcyBvbmVcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBzdWJ0cmFjdGluZyB0aGUgb25lIHByb3ZpZGVkXHJcblx0ICovXHJcblx0c3ViKG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHR0aGlzLnggLT0gb3RoZXIueDtcclxuXHRcdHRoaXMueSAtPSBvdGhlci55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgZWxlbWVudC13aXNlLiBJbiBvdGhlciB3b3JkcywgdGhpcy54ICo9IG90aGVyLnggYW5kIHRoaXMueSAqPSBvdGhlci55XHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIG11bHRpcGx5IHRoaXMgb25lIGJ5XHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgbXVsdGlwbHlpbmcgaXRzIGNvbXBvbmVudHMgYnkgdGhpcyBvbmVcclxuXHQgKi9cclxuXHRtdWx0KG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHR0aGlzLnggKj0gb3RoZXIueDtcclxuXHRcdHRoaXMueSAqPSBvdGhlci55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXZpZGVzIHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlciB2ZWN0b3IgZWxlbWVudC13aXNlLiBJbiBvdGhlciB3b3JkcywgdGhpcy54IC89IG90aGVyLnggYW5kIHRoaXMueSAvPSBvdGhlci55XHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gZGl2aWRlIHRoaXMgb25lIGJ5XHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgZGl2aXNpb25cclxuXHQgKi9cclxuXHRkaXYob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdGlmKG90aGVyLnggPT09IDAgfHwgb3RoZXIueSA9PT0gMCkgdGhyb3cgXCJEaXZpZGUgYnkgemVybyBlcnJvclwiO1xyXG5cdFx0dGhpcy54IC89IG90aGVyLng7XHJcblx0XHR0aGlzLnkgLz0gb3RoZXIueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRG9lcyBhbiBlbGVtZW50IHdpc2UgcmVtYWluZGVyIG9wZXJhdGlvbiBvbiB0aGlzIHZlY3Rvci4gdGhpcy54ICU9IG90aGVyLnggYW5kIHRoaXMueSAlPSBvdGhlci55XHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciB2ZWN0b3JcclxuXHQgKiBAcmV0dXJucyB0aGlzIHZlY3RvclxyXG5cdCAqL1xyXG5cdHJlbWFpbmRlcihvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0dGhpcy54ID0gdGhpcy54ICUgb3RoZXIueDtcclxuXHRcdHRoaXMueSA9IHRoaXMueSAlIG90aGVyLnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIGRpc3RhbmNlIHNxdWFyZWQgdG9cclxuXHQgKiBAcmV0dXJucyBUaGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXHJcblx0ICovXHJcblx0ZGlzdGFuY2VTcVRvKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAodGhpcy54IC0gb3RoZXIueCkqKHRoaXMueCAtIG90aGVyLngpICsgKHRoaXMueSAtIG90aGVyLnkpKih0aGlzLnkgLSBvdGhlci55KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSBkaXN0YW5jZSB0b1xyXG5cdCAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkXHJcblx0ICovXHJcblx0ZGlzdGFuY2VUbyhvdGhlcjogVmVjMik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvKG90aGVyKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IHdpdGhcclxuXHQgKiBAcmV0dXJucyBUaGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWQuXHJcblx0ICovXHJcblx0ZG90KG90aGVyOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLngqb3RoZXIueCArIHRoaXMueSpvdGhlci55O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYW5nbGUgY291bnRlci1jbG9ja3dpc2UgaW4gcmFkaWFucyBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXIgdmVjdG9yXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgYW5nbGUgdG9cclxuXHQgKiBAcmV0dXJucyBUaGUgYW5nbGUsIHJvdGF0aW5nIENDVywgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb3RoZXIgdmVjdG9yXHJcblx0ICovXHJcblx0YW5nbGVUb0NDVyhvdGhlcjogVmVjMik6IG51bWJlciB7XHJcblx0XHRsZXQgZG90ID0gdGhpcy5kb3Qob3RoZXIpO1xyXG5cdFx0bGV0IGRldCA9IHRoaXMueCpvdGhlci55IC0gdGhpcy55Km90aGVyLng7XHJcblx0XHRsZXQgYW5nbGUgPSAtTWF0aC5hdGFuMihkZXQsIGRvdCk7XHJcblxyXG5cdFx0aWYoYW5nbGUgPCAwKXtcclxuXHRcdFx0YW5nbGUgKz0gMipNYXRoLlBJO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhbmdsZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byAxIGRlY2ltYWwgcG9pbnRcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHN0cmluZ1xyXG5cdCAqL1xyXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy50b0ZpeGVkKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHNcclxuXHQgKiBAcGFyYW0gbnVtRGVjaW1hbFBvaW50cyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIGNyZWF0ZSBhIHN0cmluZyB0b1xyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFzIGEgc3RyaW5nXHJcblx0ICovXHJcblx0dG9GaXhlZChudW1EZWNpbWFsUG9pbnRzOiBudW1iZXIgPSAxKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIihcIiArIHRoaXMueC50b0ZpeGVkKG51bURlY2ltYWxQb2ludHMpICsgXCIsIFwiICsgdGhpcy55LnRvRml4ZWQobnVtRGVjaW1hbFBvaW50cykgKyBcIilcIjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBuZXcgdmVjdG9yIHdpdGggdGhlIHNhbWUgY29vcmRpbmF0ZXMgYXMgdGhpcyBvbmUuXHJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZVxyXG5cdCAqL1xyXG5cdGNsb25lKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueCwgdGhpcy55KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZlY3RvciBhbmQgb3RoZXIgaGF2ZSB0aGUgRVhBQ1Qgc2FtZSB4IGFuZCB5IChub3QgYXNzdXJlZCB0byBiZSBzYWZlIGZvciBmbG9hdHMpXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY2hlY2sgYWdhaW5zdFxyXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoZSB0d28gdmVjdG9yc1xyXG5cdCAqL1xyXG5cdHN0cmljdEVxdWFscyhvdGhlcjogVmVjMik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJiB0aGlzLnkgPT09IG90aGVyLnk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgYW5kIG90aGVyIGhhdmUgdGhlIHNhbWUgeCBhbmQgeVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNoZWNrIGFnYWluc3RcclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGUgdHdvIHZlY3RvcnNcclxuXHQgKi9cclxuXHRlcXVhbHMob3RoZXI6IFZlYzIpOiBib29sZWFuIHtcclxuXHRcdGxldCB4RXEgPSBNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IDAuMDAwMDAwMTtcclxuXHRcdGxldCB5RXEgPSBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8IDAuMDAwMDAwMTtcclxuXHJcblx0XHRyZXR1cm4geEVxICYmIHlFcTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZlY3RvciBpcyB0aGUgemVybyB2ZWN0b3IgZXhhY3RseSAobm90IGFzc3VyZWQgdG8gYmUgc2FmZSBmb3IgZmxvYXRzKS5cclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIHplcm8gdmVjdG9yXHJcblx0ICovXHJcblx0c3RyaWN0SXNaZXJvKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB4IGFuZCB5IGZvciB0aGlzIHZlY3RvciBhcmUgYm90aCB6ZXJvLlxyXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgemVybyB2ZWN0b3JcclxuXHQgKi9cclxuXHRpc1plcm8oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy54KSA8IDAuMDAwMDAwMSAmJiBNYXRoLmFicyh0aGlzLnkpIDwgMC4wMDAwMDAxO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciB0aGlzIHZlY3RvciBpcyBjaGFuZ2VkLlxyXG5cdCAqIEBwYXJhbSBmIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuXHQgKi9cclxuXHRzZXRPbkNoYW5nZShmOiBGdW5jdGlvbik6IHZvaWQge1xyXG5cdFx0dGhpcy5vbkNoYW5nZSA9IGY7XHJcblx0fVxyXG5cclxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gdGhpcy52ZWM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWN0b3JzXHJcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3RvclxyXG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yXHJcblx0ICogQHBhcmFtIHQgVGhlIHRpbWUgb2YgdGhlIGxlcnAsIHdpdGggMCBiZWluZyB2ZWN0b3IgQSwgYW5kIDEgYmVpbmcgdmVjdG9yIEJcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgbGVycCBiZXR3ZWVuIHZlY3RvciBhIGFuZCBiLlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBsZXJwKGE6IFZlYzIsIGI6IFZlYzIsIHQ6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKE1hdGhVdGlscy5sZXJwKGEueCwgYi54LCB0KSwgTWF0aFV0aWxzLmxlcnAoYS55LCBiLnksIHQpKTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHV0aWwgY2xhc3MgZm9yIHJlbmRlcmluZyBEZWJ1ZyBtZXNzYWdlcyB0byB0aGUgY2FudmFzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVidWcge1xyXG5cclxuXHQvKiogQSBtYXAgb2YgbG9nIG1lc3NhZ2VzIHRvIGRpc3BsYXkgb24gdGhlIHNjcmVlbiAqLyBcclxuXHRwcml2YXRlIHN0YXRpYyBsb2dNZXNzYWdlczogTWFwPHN0cmluZz4gPSBuZXcgTWFwKCk7XHJcblxyXG5cdC8qKiBBbiBhcnJheSBvZiBnYW1lIG5vZGVzIHRvIHJlbmRlciBkZWJ1ZyBpbmZvIGZvciAqL1xyXG5cdHByaXZhdGUgc3RhdGljIG5vZGVzOiBBcnJheTxHYW1lTm9kZT47XHJcblxyXG5cdC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIGFueSBkZWJ1ZyBtZXNzYWdlcyAqL1xyXG5cdHByaXZhdGUgc3RhdGljIGRlYnVnUmVuZGVyaW5nQ29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuXHQvKipcdFRoZSBzaXplIG9mIHRoZSBkZWJ1ZyBjYW52YXMgKi9cclxuXHRwcml2YXRlIHN0YXRpYyBkZWJ1Z0NhbnZhc1NpemU6IFZlYzI7XHJcblxyXG5cdC8qKiBUaGUgcmVuZGVyaW5nIGNvbG9yIGZvciB0ZXh0ICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgZGVmYXVsdFRleHRDb2xvcjogQ29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGEgbWVzc2FnZSB0byBkaXNwbGF5IG9uIHRoZSBkZWJ1ZyBzY3JlZW5cclxuXHQgKiBAcGFyYW0gaWQgQSB1bmlxdWUgSUQgZm9yIHRoaXMgbWVzc2FnZVxyXG5cdCAqIEBwYXJhbSBtZXNzYWdlcyBUaGUgbWVzc2FnZXMgdG8gcHJpbnQgdG8gdGhlIGRlYnVnIHNjcmVlblxyXG5cdCAqL1xyXG5cdHN0YXRpYyBsb2coaWQ6IHN0cmluZywgLi4ubWVzc2FnZXM6IGFueSk6IHZvaWQge1xyXG5cdFx0Ly8gbGV0IG1lc3NhZ2UgPSBcIlwiO1xyXG5cdFx0Ly8gZm9yKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKXtcclxuXHRcdC8vIFx0bWVzc2FnZSArPSBtZXNzYWdlc1tpXS50b1N0cmluZygpO1xyXG5cdFx0Ly8gfVxyXG5cdFx0Ly8gSm9pbiBhbGwgbWVzc2FnZXMgd2l0aCBzcGFjZXNcclxuXHRcdGxldCBtZXNzYWdlID0gbWVzc2FnZXMubWFwKChtOiBhbnkpID0+IG0udG9TdHJpbmcoKSkuam9pbihcIiBcIik7XHJcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmFkZChpZCwgbWVzc2FnZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZWxldGVzIGEgYSBrZXkgZnJvbSB0aGUgbG9nIGFuZCBzdG9wcyBpdCBmcm9tIGtlZXBpbmcgdXAgc3BhY2Ugb24gdGhlIHNjcmVlblxyXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIGxvZyBpdGVtIHRvIGNsZWFyXHJcblx0ICovXHJcblx0c3RhdGljIGNsZWFyTG9nSXRlbShpZDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmRlbGV0ZShpZCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBsaXN0IG9mIG5vZGVzIHRvIHJlbmRlciB3aXRoIHRoZSBkZWJ1Z2dlclxyXG5cdCAqIEBwYXJhbSBub2RlcyBUaGUgbmV3IGxpc3Qgb2Ygbm9kZXNcclxuXHQgKi9cclxuXHRzdGF0aWMgc2V0Tm9kZXMobm9kZXM6IEFycmF5PEdhbWVOb2RlPik6IHZvaWQge1xyXG5cdFx0dGhpcy5ub2RlcyA9IG5vZGVzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgYSBib3ggYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgYm94XHJcblx0ICogQHBhcmFtIGhhbGZTaXplIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3hcclxuXHQgKiBAcGFyYW0gZmlsbGVkIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdGhlIGJveCBpcyBmaWxsZWRcclxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBib3ggdG8gZHJhd1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBkcmF3Qm94KGNlbnRlcjogVmVjMiwgaGFsZlNpemU6IFZlYzIsIGZpbGxlZDogYm9vbGVhbiwgY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHRsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gY29sb3IuYTtcclxuXHJcblx0XHRpZihmaWxsZWQpe1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsUmVjdChjZW50ZXIueCAtIGhhbGZTaXplLngsIGNlbnRlci55IC0gaGFsZlNpemUueSwgaGFsZlNpemUueCoyLCBoYWxmU2l6ZS55KjIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGxpbmVXaWR0aCA9IDI7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VSZWN0KGNlbnRlci54IC0gaGFsZlNpemUueCwgY2VudGVyLnkgLSBoYWxmU2l6ZS55LCBoYWxmU2l6ZS54KjIsIGhhbGZTaXplLnkqMik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIGEgY2lyY2xlIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG5cdCAqIEBwYXJhbSByYWRpdXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJveFxyXG5cdCAqIEBwYXJhbSBmaWxsZWQgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgY2lyY2xlIGlzIGZpbGxlZFxyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGNpcmNsZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBkcmF3Q2lyY2xlKGNlbnRlcjogVmVjMiwgcmFkaXVzOiBudW1iZXIsIGZpbGxlZDogYm9vbGVhbiwgY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHRsZXQgYWxwaGEgPSB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYTtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gY29sb3IuYTtcclxuXHJcblx0XHRpZihmaWxsZWQpe1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYXJjKGNlbnRlci54LCBjZW50ZXIueSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgbGluZVdpZHRoID0gMjtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5hcmMoY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyBhIHJheSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIGZyb20gVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSByYXlcclxuXHQgKiBAcGFyYW0gdG8gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiB0aGUgcmF5XHJcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgcmF5XHJcblx0ICovXHJcblx0c3RhdGljIGRyYXdSYXkoZnJvbTogVmVjMiwgdG86IFZlYzIsIGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gMjtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lm1vdmVUbyhmcm9tLngsIGZyb20ueSk7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lVG8odG8ueCwgdG8ueSk7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgYSBwb2ludCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gb2YgdGhlIHBvaW50XHJcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgcG9pbnRcclxuXHQgKi9cclxuXHRzdGF0aWMgZHJhd1BvaW50KHBvczogVmVjMiwgY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHRsZXQgcG9pbnRTaXplID0gNjtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsUmVjdChwb3MueCAtIHBvaW50U2l6ZS8yLCBwb3MueSAtIHBvaW50U2l6ZS8yLCBwb2ludFNpemUsIHBvaW50U2l6ZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCBmb3IgdGhlIGRlYnVnZ2VyXHJcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciB0byByZW5kZXIgdGhlIHRleHRcclxuXHQgKi9cclxuXHRzdGF0aWMgc2V0RGVmYXVsdFRleHRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuZGVmYXVsdFRleHRDb2xvciA9IGNvbG9yO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgYW55IG5lY2Vzc2FyeSBzZXR1cCBvcGVyYXRpb25zIG9uIHRoZSBEZWJ1ZyBjYW52YXNcclxuXHQgKiBAcGFyYW0gY2FudmFzIFRoZSBkZWJ1ZyBjYW52YXNcclxuXHQgKiBAcGFyYW0gd2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIGNhbnZhc1xyXG5cdCAqIEBwYXJhbSBoZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBjYW52YXNcclxuXHQgKiBAcmV0dXJucyBUaGUgcmVuZGVyaW5nIGNvbnRleHQgZXh0cmFjdGVkIGZyb20gdGhlIGNhbnZhc1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBpbml0aWFsaXplRGVidWdDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdFxyXG5cdFx0dGhpcy5kZWJ1Z0NhbnZhc1NpemUgPSBuZXcgVmVjMih3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQ7XHJcblx0fVxyXG5cclxuXHQvKiogQ2xlYXJzIHRoZSBkZWJ1ZyBjYW52YXMgKi9cclxuXHRzdGF0aWMgY2xlYXJDYW52YXMoKTogdm9pZCB7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5kZWJ1Z0NhbnZhc1NpemUueCwgdGhpcy5kZWJ1Z0NhbnZhc1NpemUueSk7XHJcblx0fVxyXG5cclxuXHQvKiogUmVuZGVycyB0aGUgdGV4dCBhbmQgbm9kZXMgc2VudCB0byB0aGUgRGVidWcgc3lzdGVtICovXHJcblx0c3RhdGljIHJlbmRlcigpOiB2b2lkIHtcclxuXHRcdHRoaXMucmVuZGVyVGV4dCgpO1xyXG5cdFx0dGhpcy5yZW5kZXJOb2RlcygpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlbmRlcnMgdGhlIHRleHQgc2VudCB0byB0aGUgRGVidWcgY2FudmFzICovXHJcblx0c3RhdGljIHJlbmRlclRleHQoKTogdm9pZCB7XHJcblx0XHRsZXQgeSA9IDIwO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZm9udCA9IFwiMjBweCBBcmlhbFwiO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5kZWZhdWx0VGV4dENvbG9yLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0Ly8gRHJhdyBhbGwgb2YgdGhlIHRleHRcclxuXHRcdHRoaXMubG9nTWVzc2FnZXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFRleHQodGhpcy5sb2dNZXNzYWdlcy5nZXQoa2V5KSwgMTAsIHkpXHJcblx0XHRcdHkgKz0gMzA7XHRcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlbmRlcnMgdGhlIG5vZGVzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZGVidWcgY2FudmFzICovXHJcblx0c3RhdGljIHJlbmRlck5vZGVzKCk6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5ub2Rlcyl7XHJcblx0XHRcdHRoaXMubm9kZXMuZm9yRWFjaChub2RlID0+IHtcclxuXHRcdFx0XHRub2RlLmRlYnVnUmVuZGVyKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRzIGV4dGVuZHMgT2JqZWN0IHtcclxuICAgIC8vIFRoZSBmcHMgb2YgdGhlIGdhbWUuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2ZnBzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgTlVNX1BPSU5UUzogbnVtYmVyID0gNjA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuICAgIHByaXZhdGUgc3RhdGljIENBTlZBU19XSURUSDogbnVtYmVyID0gMzAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgQ0FOVkFTX0hFSUdIVDogbnVtYmVyID0gMzAwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc3RhdHNEaXY6IEhUTUxEaXZFbGVtZW50O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3JhcGhDaG9pY2VzOiBIVE1MU2VsZWN0RWxlbWVudDtcclxuXHJcbiAgICAvLyBRdWFkdHJlZSBzdGF0c1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldkNsZWFyVGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBTR0NsZWFyVGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR0NsZWFyVGltZTogbnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByZXZGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBTR0ZpbGxUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHRmlsbFRpbWU6IG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2VXBkYXRlVGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBTR1VwZGF0ZVRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dVcGRhdGVUaW1lOiBudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldlF1ZXJ5VGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBTR1F1ZXJ5VGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR1F1ZXJ5VGltZTogbnVtYmVyO1xyXG5cclxuICAgIHN0YXRpYyBpbml0U3RhdHMoKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGNhbnZhcyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzLWNhbnZhc1wiKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLkNBTlZBU19XSURUSDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5DQU5WQVNfSEVJR0hUO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0c0RpdiA9IDxIVE1MRGl2RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzLWRpc3BsYXlcIik7XHJcblxyXG4gICAgICAgIHRoaXMucHJldmZwcyA9IG5ldyBBcnJheSgpO1xyXG5cclxuICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5TR0NsZWFyVGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLmF2Z1NHQ2xlYXJUaW1lID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wcmV2RmlsbFRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuYXZnU0dGaWxsVGltZSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5hdmdTR1VwZGF0ZVRpbWUgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gMDtcclxuXHJcbiAgICAgICAgbGV0IGNsZWFyVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIGNsZWFyVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnY2xlYXJcIik7XHJcbiAgICAgICAgbGV0IGZpbGxUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgZmlsbFRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ2ZpbGxcIik7XHJcbiAgICAgICAgbGV0IHVwZGF0ZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICB1cGRhdGVUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2d1cGRhdGVcIik7XHJcbiAgICAgICAgbGV0IHF1ZXJ5VGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIHF1ZXJ5VGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNncXVlcnlcIik7XHJcbiAgICAgICAgbGV0IGJyMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcclxuICAgICAgICBsZXQgYnIyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xyXG4gICAgICAgIGxldCBicjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdHNEaXYuYXBwZW5kKGNsZWFyVGltZSwgYnIxLCBmaWxsVGltZSwgYnIyLCB1cGRhdGVUaW1lLCBicjMsIHF1ZXJ5VGltZSk7XHJcblxyXG4gICAgICAgIHRoaXMuZ3JhcGhDaG9pY2VzID0gPEhUTUxTZWxlY3RFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hhcnQtb3B0aW9uXCIpO1xyXG4gICAgICAgIGxldCBvcHRpb24xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb24xLnZhbHVlID0gXCJwcmV2ZnBzXCI7XHJcbiAgICAgICAgb3B0aW9uMS5sYWJlbCA9IFwiRlBTXCI7XHJcbiAgICAgICAgbGV0IG9wdGlvbjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgICAgIG9wdGlvbjIudmFsdWUgPSBcInByZXZDbGVhclRpbWVzXCI7XHJcbiAgICAgICAgb3B0aW9uMi5sYWJlbCA9IFwiQ2xlYXIgVGltZVwiO1xyXG4gICAgICAgIGxldCBvcHRpb24zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb24zLnZhbHVlID0gXCJwcmV2RmlsbFRpbWVzXCI7XHJcbiAgICAgICAgb3B0aW9uMy5sYWJlbCA9IFwiRmlsbCB0aW1lXCI7XHJcbiAgICAgICAgbGV0IG9wdGlvbjQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgICAgIG9wdGlvbjQudmFsdWUgPSBcInByZXZVcGRhdGVUaW1lc1wiO1xyXG4gICAgICAgIG9wdGlvbjQubGFiZWwgPSBcIlVwZGF0ZSB0aW1lXCI7XHJcbiAgICAgICAgbGV0IG9wdGlvbjUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgICAgIG9wdGlvbjUudmFsdWUgPSBcInByZXZRdWVyeVRpbWVzXCI7XHJcbiAgICAgICAgb3B0aW9uNS5sYWJlbCA9IFwiUXVlcnkgVGltZVwiO1xyXG4gICAgICAgIGxldCBvcHRpb25BbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgICAgIG9wdGlvbkFsbC52YWx1ZSA9IFwiYWxsXCI7XHJcbiAgICAgICAgb3B0aW9uQWxsLmxhYmVsID0gXCJBbGxcIjtcclxuICAgICAgICB0aGlzLmdyYXBoQ2hvaWNlcy5hcHBlbmQob3B0aW9uMSwgb3B0aW9uMiwgb3B0aW9uMywgb3B0aW9uNCwgb3B0aW9uNSwgb3B0aW9uQWxsKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgdXBkYXRlRlBTKGZwczogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wcmV2ZnBzLnB1c2goZnBzKTtcclxuICAgICAgICBpZih0aGlzLnByZXZmcHMubGVuZ3RoID4gU3RhdHMuTlVNX1BPSU5UUyl7XHJcbiAgICAgICAgICAgIHRoaXMucHJldmZwcy5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMucHVzaCh0aGlzLmF2Z1NHQ2xlYXJUaW1lKTtcclxuICAgICAgICAgICAgaWYodGhpcy5wcmV2Q2xlYXJUaW1lcy5sZW5ndGggPiB0aGlzLk5VTV9QT0lOVFMpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMucHJldkZpbGxUaW1lcy5wdXNoKHRoaXMuYXZnU0dGaWxsVGltZSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJldkZpbGxUaW1lcy5sZW5ndGggPiB0aGlzLk5VTV9QT0lOVFMpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2RmlsbFRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcy5wdXNoKHRoaXMuYXZnU0dVcGRhdGVUaW1lKTtcclxuICAgICAgICAgICAgaWYodGhpcy5wcmV2VXBkYXRlVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMucHVzaCh0aGlzLmF2Z1NHUXVlcnlUaW1lKTtcclxuICAgICAgICAgICAgaWYodGhpcy5wcmV2UXVlcnlUaW1lcy5sZW5ndGggPiB0aGlzLk5VTV9QT0lOVFMpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVNHU3RhdHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgbG9nKGtleTogc3RyaW5nLCBkYXRhOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBpZihrZXkgPT09IFwic2djbGVhclwiKXtcclxuICAgICAgICAgICAgdGhpcy5TR0NsZWFyVGltZXMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgaWYodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMTAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuU0dDbGVhclRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNnZmlsbFwiKXtcclxuICAgICAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICBpZih0aGlzLlNHRmlsbFRpbWVzLmxlbmd0aCA+IDEwMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlNHRmlsbFRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNndXBkYXRlXCIpe1xyXG4gICAgICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgaWYodGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aCA+IDEwMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZihrZXkgPT09IFwic2dxdWVyeVwiKXtcclxuICAgICAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMTAwMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcmVuZGVyKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIERpc3BsYXkgc3RhdHNcclxuICAgICAgICB0aGlzLmRyYXdDaGFydHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZHJhd0NoYXJ0cygpe1xyXG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLkNBTlZBU19XSURUSCwgdGhpcy5DQU5WQVNfSEVJR0hUKTtcclxuXHJcbiAgICAgICAgbGV0IHBhcmFtU3RyaW5nID0gdGhpcy5ncmFwaENob2ljZXMudmFsdWU7XHJcblxyXG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZmcHNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldmZwcztcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuQkxVRS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2Q2xlYXJUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2Q2xlYXJUaW1lcztcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuUkVELnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZGaWxsVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldkZpbGxUaW1lcztcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuR1JFRU4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldlVwZGF0ZVRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xyXG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZVcGRhdGVUaW1lcztcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuQ1lBTi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2UXVlcnlUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2UXVlcnlUaW1lcztcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gQ29sb3IuT1JBTkdFLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkcmF3Q2hhcnQocGFyYW06IEFycmF5PG51bWJlcj4sIGNvbG9yOiBzdHJpbmcpe1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gQ29sb3IuQkxBQ0sudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMTAsIDEwKTtcclxuICAgICAgICB0aGlzLmN0eC5saW5lVG8oMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcclxuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcclxuICAgICAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5DQU5WQVNfV0lEVEggLSAxMCwgdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTApO1xyXG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICBsZXQgbWF4ID0gTWF0aC5tYXgoLi4ucGFyYW0pO1xyXG4gICAgICAgIGxldCBwcmV2WCA9IDEwO1xyXG4gICAgICAgIGxldCBwcmV2WSA9IHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwIC0gcGFyYW1bMF0vbWF4Kih0aGlzLkNBTlZBU19IRUlHSFQtMjApO1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBwYXJhbS5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCBmcHMgPSBwYXJhbVtpXTtcclxuICAgICAgICAgICAgbGV0IHggPSAxMCArIGkqKHRoaXMuQ0FOVkFTX1dJRFRIIC0gMjApL3RoaXMuTlVNX1BPSU5UUztcclxuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCAtIGZwcy9tYXgqKHRoaXMuQ0FOVkFTX0hFSUdIVC0yMClcclxuICAgICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhwcmV2WCwgcHJldlkpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgICAgIHByZXZYID0geDtcclxuICAgICAgICAgICAgcHJldlkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgdXBkYXRlU0dTdGF0cygpe1xyXG4gICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLmF2Z1NHQ2xlYXJUaW1lID0gdGhpcy5TR0NsZWFyVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLlNHRmlsbFRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLmF2Z1NHRmlsbFRpbWUgPSB0aGlzLlNHRmlsbFRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgdGhpcy5hdmdTR1VwZGF0ZVRpbWUgPSB0aGlzLlNHVXBkYXRlVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuYXZnU0dRdWVyeVRpbWUgPSB0aGlzLlNHUXVlcnlUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2djbGVhclwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyBjbGVhciB0aW1lOiBcIiArIHRoaXMuYXZnU0dDbGVhclRpbWU7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ2ZpbGxcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgZmlsbCB0aW1lOiBcIiArIHRoaXMuYXZnU0dGaWxsVGltZTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNndXBkYXRlXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIHVwZGF0ZSB0aW1lOiBcIiArIHRoaXMuYXZnU0dVcGRhdGVUaW1lO1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2dxdWVyeVwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyBxdWVyeSB0aW1lOiBcIiArIHRoaXMuYXZnU0dRdWVyeVRpbWU7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBldmVudCBlbWl0dGVyIG9iamVjdCBvdGhlciBzeXN0ZW1zIGNhbiB1c2UgdG8gaG9vayBpbnRvIHRoZSBFdmVudFF1ZXVlLlxyXG4gKiBQcm92aWRlcyBhbiBlYXN5IGludGVyZmFjZSBmb3IgZmlyaW5nIG9mZiBldmVudHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbWl0dGVyIHtcclxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIEV2ZW50UXVldWUgKi9cclxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcblxyXG5cdC8qKiBDcmVhdGVzIGEgbmV3IEVtaXR0ZXIgKi9cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRW1pdCBhbmQgZXZlbnQgb2YgdHlwZSBldmVudFR5cGUgd2l0aCB0aGUgZGF0YSBwYWNrZXQgZGF0YVxyXG5cdCAqIEBwYXJhbSBldmVudFR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgb2ZmXHJcblx0ICogQHBhcmFtIGRhdGEgQSBAcmVmZXJlbmNlW01hcF0gb3IgcmVjb3JkIGNvbnRhaW5pbmcgYW55IGRhdGEgYWJvdXQgdGhlIGV2ZW50XHJcblx0ICovXHJcblx0ZmlyZUV2ZW50KGV2ZW50VHlwZTogc3RyaW5nLCBkYXRhOiBNYXA8YW55PiB8IFJlY29yZDxzdHJpbmcsIGFueT4gPSBudWxsKTogdm9pZCB7XHJcblx0XHR0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQobmV3IEdhbWVFdmVudChldmVudFR5cGUsIGRhdGEpKTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi9SZWNlaXZlclwiO1xyXG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4vR2FtZUV2ZW50VHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtYWluIGV2ZW50IHN5c3RlbSBvZiB0aGUgZ2FtZSBlbmdpbmUuXHJcbiAqIEV2ZW50cyBhcmUgc2VudCB0byB0aGUgRXZlbnRRdWV1ZSwgd2hpY2ggaGFuZGxlcyBkaXN0cmlidXRpb24gdG8gYW55IHN5c3RlbXMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciB0aG9zZSBldmVudHMuXHJcbiAqIFRoaXMgYWxsb3dzIGZvciBoYW5kbGluZyBvZiBpbnB1dCB3aXRob3V0IGhhdmluZyBjbGFzc2VzIGRpcmVjdGx5IGhvb2sgaW50byBqYXZhc2NyaXB0IGV2ZW50IGhhbmRsZXMsIFxyXG4gKiBhbmQgYWxsb3dzIG90aGVyd2lzZSBzZXBhcmF0ZSBjbGFzc2VzIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlciBjbGVhbmx5LCBzdWNoIGFzIGEgUGxheWVyIG9iamVjdCBcclxuICogcmVxdWVzdGluZyBhIHNvdW5kIGJlIHBsYXllZCBieSB0aGUgYXVkaW8gc3lzdGVtLlxyXG4gKiBcclxuICogVGhlIGRpc3RyaWJ1dGlvbiBvZiBAcmVmZXJlbmNlW0dhbWVFdmVudF1zIGhhcHBlbnMgYXMgZm9sbG93czpcclxuICogXHJcbiAqIEV2ZW50cyBhcmUgcmVjaWV2ZWQgdGhyb3VnaG91dCBhIGZyYW1lIGFuZCBhcmUgcXVldWVkIHVwIGJ5IHRoZSBFdmVudFF1ZXVlLlxyXG4gKiBBdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGZyYW1lLCBldmVudHMgYXJlIHNlbnQgb3V0IHRvIGFueSByZWNlaXZlcnMgdGhhdCBhcmUgaG9va2VkIGludG8gdGhlIGV2ZW50IHR5cGUuXHJcbiAqIEByZWZlcmVuY2VbUmVjZWl2ZXJdcyBhcmUgdGhlbiBmcmVlIHRvIHByb2Nlc3MgZXZlbnRzIGFzIHRoZXkgc2VlIGZpdC5cclxuICogXHJcbiAqIE92ZXJhbGwsIHRoZSBFdmVudFF1ZXVlIGNhbiBiZSBjb25zaWRlcmVkIGFzIHNvbWV0aGluZyBzaW1pbGFyIHRvIGFuIGVtYWlsIHNlcnZlcixcclxuICogYW5kIHRoZSBAcmVmZXJlbmNlW1JlY2VpdmVyXXMgY2FuIGJlIGNvbnNpZGVyZWQgYXMgdGhlIGNsaWVudCBpbmJveGVzLlxyXG4gKiBcclxuICogU2VlIEBsaW5rKEdhbWUgUHJvZ3JhbW1pbmcgUGF0dGVybnMpKGh0dHBzOi8vZ2FtZXByb2dyYW1taW5ncGF0dGVybnMuY29tL2V2ZW50LXF1ZXVlLmh0bWwpIGZvciBtb3JlIGRpc2N1c3Npb24gb24gRXZlbnRRdWV1ZXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50UXVldWUge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEV2ZW50UXVldWUgPSBudWxsO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyB2aXNpYmxlICovXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IE1BWF9TSVpFOiBudW1iZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgYWN0dWFsIHF1ZXVlIG9mIGV2ZW50cyAqL1xyXG4gICAgcHJpdmF0ZSBxOiBRdWV1ZTxHYW1lRXZlbnQ+O1xyXG4gICAgXHJcbiAgICAvKiogVGhlIG1hcCBvZiByZWNlaXZlcnMgcmVnaXN0ZXJlZCBmb3IgYW4gZXZlbnQgbmFtZSAqL1xyXG5cdHByaXZhdGUgcmVjZWl2ZXJzOiBNYXA8QXJyYXk8UmVjZWl2ZXI+PjtcclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5NQVhfU0laRSA9IDEwMDtcclxuICAgICAgICB0aGlzLnEgPSBuZXcgUXVldWU8R2FtZUV2ZW50Pih0aGlzLk1BWF9TSVpFKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVycyA9IG5ldyBNYXA8QXJyYXk8UmVjZWl2ZXI+PigpO1xyXG5cdH1cclxuICAgIFxyXG4gICAgLyoqIFJldHJpZXZlcyB0aGUgaW5zdGFuY2Ugb2YgdGhlIFNpbmdsZXRvbiBFdmVudFF1ZXVlICovXHJcblx0c3RhdGljIGdldEluc3RhbmNlKCk6IEV2ZW50UXVldWUge1xyXG5cdFx0aWYodGhpcy5pbnN0YW5jZSA9PT0gbnVsbCl7XHJcblx0XHRcdHRoaXMuaW5zdGFuY2UgPSBuZXcgRXZlbnRRdWV1ZSgpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuXHR9XHJcblxyXG4gICAgLyoqIEFkZHMgYW4gZXZlbnQgdG8gdGhlIEV2ZW50UXVldWUuXHJcbiAgICAgKiBUaGlzIGlzIGV4cG9zZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIGdhbWUgZW5naW5lIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRW1pdHRlcl0gY2xhc3MgKi9cclxuICAgIGFkZEV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnEuZW5xdWV1ZShldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBc3NvY2lhdGVzIGEgcmVjZWl2ZXIgd2l0aCBhIHR5cGUgb2YgZXZlbnQuIEV2ZXJ5IHRpbWUgdGhpcyBldmVudCBhcHBlYXJzIGluIHRoZSBmdXR1cmUsXHJcbiAgICAgKiBpdCB3aWxsIGJlIGdpdmVuIHRvIHRoZSByZWNlaXZlciAoYW5kIGFueSBvdGhlcnMgd2F0Y2hpbmcgdGhhdCB0eXBlKS5cclxuICAgICAqIFRoaXMgaXMgZXhwb3NlZCB0byB0aGUgcmVzdCBvZiB0aGUgZ2FtZSBlbmdpbmUgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtSZWNlaXZlcl0gY2xhc3NcclxuICAgICAqIEBwYXJhbSByZWNlaXZlciBUaGUgZXZlbnQgcmVjZWl2ZXJcclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9yIHR5cGVzIG9mIGV2ZW50cyB0byBzdWJzY3JpYmUgdG9cclxuICAgICAqL1xyXG4gICAgc3Vic2NyaWJlKHJlY2VpdmVyOiBSZWNlaXZlciwgdHlwZTogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG4gICAgICAgIGlmKHR5cGUgaW5zdGFuY2VvZiBBcnJheSl7XHJcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFuIGFycmF5LCBzdWJzY3JpYmUgdG8gYWxsIGV2ZW50IHR5cGVzXHJcbiAgICAgICAgICAgIGZvcihsZXQgdCBvZiB0eXBlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGlzdGVuZXIocmVjZWl2ZXIsIHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihyZWNlaXZlciwgdHlwZSk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlcyB0aGUgc3BlY2lmaWVkIHJlY2VpdmVyIGZyb20gYWxsIGV2ZW50cywgb3IgZnJvbSB3aGF0ZXZlciBldmVudHMgYXJlIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXIgVGhlIHJlY2VpdmVyIHRvIHVuc3Vic2NyaWJlXHJcbiAgICAgKiBAcGFyYW0ga2V5cyBUaGUgZXZlbnRzIHRvIHVuc3Vic2NyaWJlIGZyb20uIElmIG5vbmUgYXJlIHByb3ZpZGVkLCB1bnN1YnNjcmliZSBmcm9tIGFsbFxyXG4gICAgICovXHJcbiAgICB1bnN1YnNjcmliZShyZWNlaXZlcjogUmVjZWl2ZXIsIC4uLmV2ZW50czogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXJzLmZvckVhY2goZXZlbnROYW1lID0+IHtcclxuICAgICAgICAgICAgLy8gSWYga2V5cyB3ZXJlIHByb3ZpZGVkLCBvbmx5IGNvbnRpbnVlIGlmIHRoaXMga2V5IGlzIG9uZSBvZiB0aGVtXHJcbiAgICAgICAgICAgIGlmKGV2ZW50cy5sZW5ndGggPiAwICYmIGV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgPT09IC0xKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiBvdXIgcmVjZWl2ZXIgZm9yIHRoaXMga2V5XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMucmVjZWl2ZXJzLmdldChldmVudE5hbWUpLmluZGV4T2YocmVjZWl2ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgYW4gaW5kZXggd2FzIGZvdW5kLCByZW1vdmUgdGhlIHJlY2VpdmVyXHJcbiAgICAgICAgICAgIGlmKGluZGV4ICE9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmVycy5nZXQoZXZlbnROYW1lKS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXNzb2NpYXRlIHRoZSByZWNlaXZlciBhbmQgdGhlIHR5cGVcclxuXHRwcml2YXRlIGFkZExpc3RlbmVyKHJlY2VpdmVyOiBSZWNlaXZlciwgdHlwZTogc3RyaW5nKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLnJlY2VpdmVycy5oYXModHlwZSkpe1xyXG5cdFx0XHR0aGlzLnJlY2VpdmVycy5nZXQodHlwZSkucHVzaChyZWNlaXZlcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnJlY2VpdmVycy5hZGQodHlwZSwgW3JlY2VpdmVyXSk7XHJcblx0XHR9XHJcblx0fVxyXG4gICAgXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB3aGlsZSh0aGlzLnEuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIC8vIFJldHJpZXZlIGVhY2ggZXZlbnRcclxuXHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5xLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElmIGEgcmVjZWl2ZXIgaGFzIHRoaXMgZXZlbnQgdHlwZSwgc2VuZCBpdCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgaWYodGhpcy5yZWNlaXZlcnMuaGFzKGV2ZW50LnR5cGUpKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcmVjZWl2ZXIgb2YgdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50LnR5cGUpKXtcclxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5yZWNlaXZlKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHRcdFx0fVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSWYgYSByZWNlaXZlciBpcyBzdWJzY3JpYmVkIHRvIGFsbCBldmVudHMsIHNlbmQgaXQgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgIGlmKHRoaXMucmVjZWl2ZXJzLmhhcyhHYW1lRXZlbnRUeXBlLkFMTCkpe1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCByZWNlaXZlciBvZiB0aGlzLnJlY2VpdmVycy5nZXQoR2FtZUV2ZW50VHlwZS5BTEwpKXtcclxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5yZWNlaXZlKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIlxyXG5cclxuLyoqXHJcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW4tZ2FtZSBldmVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoZSBldmVudCAqL1xyXG4gICAgcHVibGljIHR5cGU6IHN0cmluZztcclxuICAgIC8qKiBUaGUgZGF0YSBjb250YWluZWQgYnkgdGhlIGV2ZW50ICovXHJcbiAgICBwdWJsaWMgZGF0YTogTWFwPGFueT47XHJcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIG1zICovXHJcblx0cHVibGljIHRpbWU6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgR2FtZUV2ZW50LlxyXG4gICAgICogVGhpcyBpcyBoYW5kbGVkIGltcGxpY2l0bHkgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFbWl0dGVyXSBjbGFzc1xyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIEdhbWVFdmVudFxyXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBHYW1lRXZlbnRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodHlwZTogc3RyaW5nLCBkYXRhOiBNYXA8YW55PiB8IFJlY29yZDxzdHJpbmcsIGFueT4gPSBudWxsKSB7XHJcbiAgICAgICAgLy8gUGFyc2UgdGhlIGdhbWUgZXZlbnQgZGF0YVxyXG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXA8YW55PigpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIShkYXRhIGluc3RhbmNlb2YgTWFwKSl7XHJcbiAgICAgICAgICAgIC8vIGRhdGEgaXMgYSByYXcgb2JqZWN0LCB1bnBhY2tcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcDxhbnk+KCk7XHJcbiAgICAgICAgICAgIGZvcihsZXQga2V5IGluIGRhdGEpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLmFkZChrZXksIGRhdGFba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRoZSB0eXBlIG9mIHRoZSBHYW1lRXZlbnRcclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBHYW1lRXZlbnQgaXMgdGhlIHNwZWNpZmllZCB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzVHlwZSh0eXBlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIEdhbWVFdmVudCBhcyBhIHN0cmluZ1xyXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgR2FtZUV2ZW50XHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArIFwiOiBAXCIgKyB0aGlzLnRpbWU7XHJcbiAgICB9XHJcbn0iLCIvLyBAaWdub3JlUGFnZVxyXG5cclxuZXhwb3J0IGVudW0gR2FtZUV2ZW50VHlwZSB7XHJcblx0LyoqXHJcblx0ICogTW91c2UgRG93biBldmVudC4gSGFzIGRhdGE6IHtwb3NpdGlvbjogVmVjMiAtIE1vdXNlIFBvc2l0aW9ufVxyXG5cdCAqL1xyXG5cdE1PVVNFX0RPV04gPSBcIm1vdXNlX2Rvd25cIixcclxuXHQvKipcclxuXHQgKiBNb3VzZSBVcCBldmVudC4gSGFzIGRhdGE6IHtwb3NpdGlvbjogVmVjMiAtIE1vdXNlIFBvc2l0aW9ufVxyXG5cdCAqL1xyXG5cdE1PVVNFX1VQID0gXCJtb3VzZV91cFwiLFxyXG5cdC8qKlxyXG5cdCAqIE1vdXNlIE1vdmUgZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cclxuXHQgKi9cclxuXHRNT1VTRV9NT1ZFID0gXCJtb3VzZV9tb3ZlXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEtleSBEb3duIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nIC0gVGhlIGtleSB0aGF0IGlzIGRvd259XHJcblx0ICovXHJcblx0S0VZX0RPV04gPSBcImtleV9kb3duXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEtleSBVcCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZyAtIFRoZSBrZXkgdGhhdCBpcyB1cH1cclxuXHQgKi9cclxuXHRLRVlfVVAgPSBcImtleV91cFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBDYW52YXMgQmx1ciBldmVudC4gSGFzIGRhdGE6IHt9XHJcblx0ICovXHJcblx0Q0FOVkFTX0JMVVIgPSBcImNhbnZhc19ibHVyXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1vdXNlIHdoZWVsIHVwIGV2ZW50LiBIYXMgZGF0YToge31cclxuXHQgKi9cclxuXHRXSEVFTF9VUCA9IFwid2hlZWxfdXBcIixcclxuXHJcblx0LyoqXHJcblx0ICogTW91c2Ugd2hlZWwgZG93biBldmVudC4gSGFzIGRhdGE6IHt9XHJcblx0ICovXHJcblx0V0hFRUxfRE9XTiA9IFwid2hlZWxfZG93blwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBTdGFydCBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdFNUQVJUX1JFQ09SRElORyA9IFwic3RhcnRfcmVjb3JkaW5nXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFN0b3AgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cclxuXHQgKi9cclxuXHRTVE9QX1JFQ09SRElORyA9IFwic3RvcF9yZWNvcmRpbmdcIixcclxuXHRcclxuXHQvKipcclxuXHQgKiBQbGF5IFJlY29yZGluZyBldmVudC4gSGFzIGRhdGE6IHt9XHJcblx0ICovXHJcblx0UExBWV9SRUNPUkRJTkcgPSBcInBsYXlfcmVjb3JkaW5nXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4gfVxyXG5cdCAqL1xyXG5cdFBMQVlfU09VTkQgPSBcInBsYXlfc291bmRcIixcclxuXHJcblx0LyoqXHJcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZ31cclxuXHQgKi9cclxuXHRTVE9QX1NPVU5EID0gXCJzdG9wX3NvdW5kXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4sIGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUgfVxyXG5cdCAqL1xyXG4gXHRQTEFZX1NGWCA9IFwicGxheV9zZnhcIixcclxuXHJcbiBcdC8qKlxyXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4sIGhvbGRSZWZlcmVuY2U6IGJvb2xlYW4gfVxyXG5cdCAqL1xyXG4gIFx0UExBWV9NVVNJQyA9IFwicGxheV9tdXNpY1wiLFxyXG5cclxuXHQvKipcclxuXHQgKiBNdXRlIGF1ZGlvIGNoYW5uZWwgZXZlbnQuIEhhcyBkYXRhOiB7Y2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZX1cclxuXHQgKi9cclxuXHRNVVRFX0NIQU5ORUwgPSBcIm11dGVfY2hhbm5lbFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBVbm11dGUgYXVkaW8gY2hhbm5lbCBldmVudC4gSGFzIGRhdGE6IHtjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlfVxyXG5cdCAqL1xyXG5cdFVOTVVURV9DSEFOTkVMID0gXCJ1bm11dGVfY2hhbm5lbFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBFbmNvbXBhc3NlcyBhbGwgZXZlbnQgdHlwZXMuIFVzZWQgZm9yIHJlY2VpdmVycyBvbmx5LlxyXG5cdCAqL1xyXG5cdEFMTCA9IFwiYWxsXCIsXHJcbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xyXG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XHJcblxyXG4vKipcclxuICogUmVjZWl2ZXMgc3Vic2NyaWJlZCBldmVudHMgZnJvbSB0aGUgRXZlbnRRdWV1ZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY2VpdmVyIHtcclxuXHQvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50cyB0aGlzIFJlY2VpdmVyIGNhbiBob2xkIGF0IG9uZSB0aW1lICovXHJcblx0cmVhZG9ubHkgTUFYX1NJWkU6IG51bWJlcjtcclxuXHJcblx0LyoqIFRoZSBpbmJveCBvZiB0aGUgUmVjZWl2ZXIgKi9cclxuXHRwcml2YXRlIHE6IFF1ZXVlPEdhbWVFdmVudD47XHJcblxyXG5cdC8qKiBDcmVhdGVzIGEgbmV3IFJlY2VpdmVyICovXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMuTUFYX1NJWkUgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5xID0gbmV3IFF1ZXVlKHRoaXMuTUFYX1NJWkUpO1xyXG5cdH1cclxuXHJcblx0ZGVzdHJveSgpe1xyXG5cdFx0RXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpLnVuc3Vic2NyaWJlKHRoaXMpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBBZGRzIHRoZXNlIHR5cGVzIG9mIGV2ZW50cyB0byB0aGlzIHJlY2VpdmVyJ3MgcXVldWUgZXZlcnkgdXBkYXRlLlxyXG5cdCAqIEBwYXJhbSBldmVudFR5cGVzIFRoZSB0eXBlcyBvZiBldmVudHMgdGhpcyByZWNlaXZlciB3aWxsIGJlIHN1YnNjcmliZWQgdG9cclxuXHQgKi9cclxuXHRzdWJzY3JpYmUoZXZlbnRUeXBlczogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG5cdFx0RXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpLnN1YnNjcmliZSh0aGlzLCBldmVudFR5cGVzKTtcclxuXHRcdHRoaXMucS5jbGVhcigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhbiBldmVudCB0byB0aGUgcXVldWUgb2YgdGhpcyByZWNpZXZlci4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdIHRvIGRpc3RyaWJ1dGUgZXZlbnRzXHJcblx0ICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byByZWNlaXZlXHJcblx0ICovXHJcblx0cmVjZWl2ZShldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XHJcblx0XHR0cnl7XHJcblx0XHR0aGlzLnEuZW5xdWV1ZShldmVudCk7XHJcblx0XHR9IGNhdGNoKGUpe1xyXG5cdFx0XHRjb25zb2xlLndhcm4oXCJSZWNlaXZlciBvdmVyZmxvdyBmb3IgZXZlbnQgXCIgKyBldmVudC50b1N0cmluZygpKTtcclxuXHRcdFx0dGhyb3cgZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHJpZXZlcyB0aGUgbmV4dCBldmVudCBmcm9tIHRoZSByZWNlaXZlcidzIHF1ZXVlXHJcblx0ICogQHJldHVybnMgVGhlIG5leHQgR2FtZUV2ZW50XHJcblx0ICovXHJcblx0Z2V0TmV4dEV2ZW50KCk6IEdhbWVFdmVudCB7XHJcblx0XHRyZXR1cm4gdGhpcy5xLmRlcXVldWUoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIExvb2tzIGF0IHRoZSBuZXh0IGV2ZW50IGluIHRoZSByZWNlaXZlcidzIHF1ZXVlLCBidXQgZG9lc24ndCByZW1vdmUgaXQgZnJvbSB0aGUgcXVldWVcclxuXHQgKiBAcmV0dXJucyBUaGUgbmV4dCBHYW1lRXZlbnRcclxuXHQgKi9cclxuXHRwZWVrTmV4dEV2ZW50KCk6IEdhbWVFdmVudCB7XHJcblx0XHRyZXR1cm4gdGhpcy5xLnBlZWtOZXh0KClcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVjZWl2ZXIgaGFzIGFueSBldmVudHMgaW4gaXRzIHF1ZXVlXHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcmVjZWl2ZXIgaGFzIGFub3RoZXIgZXZlbnQsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdGhhc05leHRFdmVudCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnEuaGFzSXRlbXMoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIElnbm9yZSBhbGwgZXZlbnRzIHRoaXMgZnJhbWVcclxuXHQgKi9cclxuXHRpZ25vcmVFdmVudHMoKTogdm9pZCB7XHJcblx0XHR0aGlzLnEuY2xlYXIoKTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIFJlY2VpdmVzIGlucHV0IGV2ZW50cyBmcm9tIHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdIGFuZCBhbGxvd3MgZm9yIGVhc3kgYWNjZXNzIG9mIGluZm9ybWF0aW9uIGFib3V0IGlucHV0IGJ5IG90aGVyIHN5c3RlbXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0IHtcclxuXHRwcml2YXRlIHN0YXRpYyBtb3VzZVByZXNzZWQ6IGJvb2xlYW47XHJcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VKdXN0UHJlc3NlZDogYm9vbGVhbjtcclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMga2V5SnVzdFByZXNzZWQ6IE1hcDxib29sZWFuPjtcclxuXHRwcml2YXRlIHN0YXRpYyBrZXlQcmVzc2VkOiBNYXA8Ym9vbGVhbj47XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIG1vdXNlUG9zaXRpb246IFZlYzI7XHJcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQcmVzc1Bvc2l0aW9uOiBWZWMyO1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBzY3JvbGxEaXJlY3Rpb246IG51bWJlcjtcclxuXHRwcml2YXRlIHN0YXRpYyBqdXN0U2Nyb2xsZWQ6IGJvb2xlYW47XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcblx0cHJpdmF0ZSBzdGF0aWMgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cdHByaXZhdGUgc3RhdGljIHZpZXdwb3J0OiBWaWV3cG9ydDtcclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMga2V5TWFwOiBNYXA8QXJyYXk8c3RyaW5nPj47XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGtleXNEaXNhYmxlZDogYm9vbGVhbjtcclxuXHRwcml2YXRlIHN0YXRpYyBtb3VzZURpc2FibGVkOiBib29sZWFuO1xyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyB0aGUgSW5wdXQgb2JqZWN0XHJcblx0ICogQHBhcmFtIHZpZXdwb3J0IEEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCBvZiB0aGUgZ2FtZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBpbml0aWFsaXplKHZpZXdwb3J0OiBWaWV3cG9ydCwga2V5TWFwOiBBcnJheTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pil7XHJcblx0XHRJbnB1dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xyXG5cdFx0SW5wdXQubW91c2VQcmVzc2VkID0gZmFsc2U7XHJcblx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gZmFsc2U7XHJcblx0XHRJbnB1dC5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQgPSBuZXcgTWFwPGJvb2xlYW4+KCk7XHJcblx0XHRJbnB1dC5rZXlQcmVzc2VkID0gbmV3IE1hcDxib29sZWFuPigpO1xyXG5cdFx0SW5wdXQubW91c2VQb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xyXG5cdFx0SW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uID0gbmV3IFZlYzIoMCwgMCk7XHJcblx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAwO1xyXG5cdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gZmFsc2U7XHJcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdElucHV0Lm1vdXNlRGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBJbml0aWFsaXplIHRoZSBrZXltYXBcclxuXHRcdElucHV0LmtleU1hcCA9IG5ldyBNYXAoKTtcclxuXHJcblx0XHQvLyBBZGQgYWxsIGtleXMgdG8gdGhlIGtleW1hcFxyXG5cdFx0Zm9yKGxldCBlbnRyeSBpbiBrZXlNYXApe1xyXG5cdFx0XHRsZXQgbmFtZSA9IGtleU1hcFtlbnRyeV0ubmFtZTtcclxuXHRcdFx0bGV0IGtleXMgPSBrZXlNYXBbZW50cnldLmtleXM7XHJcblx0XHRcdElucHV0LmtleU1hcC5hZGQobmFtZSwga2V5cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0SW5wdXQuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuXHRcdC8vIFN1YnNjcmliZSB0byBhbGwgaW5wdXQgZXZlbnRzXHJcblx0XHRJbnB1dC5ldmVudFF1ZXVlLnN1YnNjcmliZShJbnB1dC5yZWNlaXZlciwgW0dhbWVFdmVudFR5cGUuTU9VU0VfRE9XTiwgR2FtZUV2ZW50VHlwZS5NT1VTRV9VUCwgR2FtZUV2ZW50VHlwZS5NT1VTRV9NT1ZFLFxyXG5cdFx0XHQgR2FtZUV2ZW50VHlwZS5LRVlfRE9XTiwgR2FtZUV2ZW50VHlwZS5LRVlfVVAsIEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIsIEdhbWVFdmVudFR5cGUuV0hFRUxfVVAsIEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTl0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Ly8gUmVzZXQgdGhlIGp1c3RQcmVzc2VkIHZhbHVlcyB0byBmYWxzZVxyXG5cdFx0SW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IGZhbHNlO1xyXG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XHJcblx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSBmYWxzZTtcclxuXHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IDA7XHJcblxyXG5cdFx0d2hpbGUoSW5wdXQucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1x0XHRcdFxyXG5cdFx0XHRsZXQgZXZlbnQgPSBJbnB1dC5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIEhhbmRsZSBlYWNoIGV2ZW50IHR5cGVcclxuXHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOKXtcclxuXHRcdFx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gdHJ1ZTtcclxuXHRcdFx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbiA9IGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIik7XHRcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NT1VTRV9VUCl7XHJcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc2VkID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSl7XHJcblx0XHRcdFx0SW5wdXQubW91c2VQb3NpdGlvbiA9IGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25cIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuS0VZX0RPV04pe1xyXG5cdFx0XHRcdGxldCBrZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcclxuXHRcdFx0XHQvLyBIYW5kbGUgc3BhY2UgYmFyXHJcblx0XHRcdFx0aWYoa2V5ID09PSBcIiBcIil7XHJcblx0XHRcdFx0XHRrZXkgPSBcInNwYWNlXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCFJbnB1dC5rZXlQcmVzc2VkLmdldChrZXkpKXtcclxuXHRcdFx0XHRcdElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIHRydWUpO1xyXG5cdFx0XHRcdFx0SW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuS0VZX1VQKXtcclxuXHRcdFx0XHRsZXQga2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XHJcblx0XHRcdFx0Ly8gSGFuZGxlIHNwYWNlIGJhclxyXG5cdFx0XHRcdGlmKGtleSA9PT0gXCIgXCIpe1xyXG5cdFx0XHRcdFx0a2V5ID0gXCJzcGFjZVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5DQU5WQVNfQkxVUil7XHJcblx0XHRcdFx0SW5wdXQuY2xlYXJLZXlQcmVzc2VzKClcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5XSEVFTF9VUCl7XHJcblx0XHRcdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gLTE7XHJcblx0XHRcdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gdHJ1ZTtcclxuXHRcdFx0fSBlbHNlIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTil7XHJcblx0XHRcdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMTtcclxuXHRcdFx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBjbGVhcktleVByZXNzZXMoKTogdm9pZCB7XHJcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgZmFsc2UpKTtcclxuXHRcdElucHV0LmtleVByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgZmFsc2UpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYSBrZXkgd2FzIG5ld2x5IHByZXNzZWQgSW5wdXQgZnJhbWUuXHJcblx0ICogSWYgdGhlIGtleSBpcyBzdGlsbCBwcmVzc2VkIGZyb20gbGFzdCBmcmFtZSBhbmQgd2Fzbid0IHJlLXByZXNzZWQsIElucHV0IHdpbGwgcmV0dXJuIGZhbHNlLlxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleVxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtleSB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNLZXlKdXN0UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0aWYoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYoSW5wdXQua2V5SnVzdFByZXNzZWQuaGFzKGtleSkpe1xyXG5cdFx0XHRyZXR1cm4gSW5wdXQua2V5SnVzdFByZXNzZWQuZ2V0KGtleSlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBrZXlzIHRoYXQgYXJlIG5ld2x5IHByZXNzZWQgSW5wdXQgZnJhbWUuXHJcblx0ICogSWYgYSBrZXkgaXMgc3RpbGwgcHJlc3NlZCBmcm9tIGxhc3QgZnJhbWUgYW5kIHdhc24ndCByZS1wcmVzc2VkLCBpdCB3aWxsIG5vdCBiZSBpbiBJbnB1dCBsaXN0LlxyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBvZiB0aGUgbmV3bHkgcHJlc3NlZCBrZXlzLlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRLZXlzSnVzdFByZXNzZWQoKTogQXJyYXk8c3RyaW5nPiB7XHJcblx0XHRpZihJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBbXTtcclxuXHJcblx0XHRsZXQga2V5cyA9IEFycmF5PHN0cmluZz4oKTtcclxuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0aWYoSW5wdXQua2V5SnVzdFByZXNzZWQuZ2V0KGtleSkpe1xyXG5cdFx0XHRcdGtleXMucHVzaChrZXkpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBrZXlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGtleSBpcyBiZWluZyBwcmVzc2VkLlxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleVxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGtleSBpcyBjdXJyZW50bHkgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0c3RhdGljIGlzS2V5UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0aWYoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYoSW5wdXQua2V5UHJlc3NlZC5oYXMoa2V5KSl7XHJcblx0XHRcdHJldHVybiBJbnB1dC5rZXlQcmVzc2VkLmdldChrZXkpXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGFuZ2VzIHRoZSBiaW5kaW5nIG9mIGFuIGlucHV0IG5hbWUgdG8ga2V5c1xyXG5cdCAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XHJcblx0ICogQHBhcmFtIGtleXMgVGhlIGNvcnJlc3BvbmRpbmcga2V5c1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBjaGFuZ2VLZXlCaW5kaW5nKGlucHV0TmFtZTogc3RyaW5nLCBrZXlzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcblx0XHRJbnB1dC5rZXlNYXAuc2V0KGlucHV0TmFtZSwga2V5cyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhcnMgYWxsIGtleSBiaW5kaW5nc1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBjbGVhckFsbEtleUJpbmRpbmdzKCk6IHZvaWQge1xyXG5cdFx0SW5wdXQua2V5TWFwLmNsZWFyKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGlucHV0IHdhcyBqdXN0IHByZXNzZWQgdGhpcyBmcmFtZVxyXG5cdCAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0c3RhdGljIGlzSnVzdFByZXNzZWQoaW5wdXROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdGlmKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGlmKElucHV0LmtleU1hcC5oYXMoaW5wdXROYW1lKSl7XHJcblx0XHRcdGNvbnN0IGtleXMgPSBJbnB1dC5rZXlNYXAuZ2V0KGlucHV0TmFtZSk7XHJcblx0XHRcdGxldCBqdXN0UHJlc3NlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yKGxldCBrZXkgb2Yga2V5cyl7XHJcblx0XHRcdFx0anVzdFByZXNzZWQgPSBqdXN0UHJlc3NlZCB8fCBJbnB1dC5pc0tleUp1c3RQcmVzc2VkKGtleSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBqdXN0UHJlc3NlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cdFxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBpbnB1dCBpcyBjdXJyZW50bHkgcHJlc3NlZFxyXG5cdCAqIEBwYXJhbSBpbnB1dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGlucHV0XHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgaW5wdXQgaXMgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0c3RhdGljIGlzUHJlc3NlZChpbnB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0aWYoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYoSW5wdXQua2V5TWFwLmhhcyhpbnB1dE5hbWUpKXtcclxuXHRcdFx0Y29uc3Qga2V5cyA9IElucHV0LmtleU1hcC5nZXQoaW5wdXROYW1lKTtcclxuXHRcdFx0bGV0IHByZXNzZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdGZvcihsZXQga2V5IG9mIGtleXMpe1xyXG5cdFx0XHRcdHByZXNzZWQgPSBwcmVzc2VkIHx8IElucHV0LmlzS2V5UHJlc3NlZChrZXkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJlc3NlZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lXHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbW91c2Ugd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0c3RhdGljIGlzTW91c2VKdXN0UHJlc3NlZCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBJbnB1dC5tb3VzZUp1c3RQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbW91c2UgaXMgY3VycmVudGx5IHByZXNzZWRcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0c3RhdGljIGlzTW91c2VQcmVzc2VkKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGUgdXNlciBzY3JvbGxlZCBvciBub3RcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB1c2VyIGp1c3Qgc2Nyb2xsZWQgSW5wdXQgZnJhbWUsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBkaWRKdXN0U2Nyb2xsKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIElucHV0Lmp1c3RTY3JvbGxlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsXHJcblx0ICogQHJldHVybnMgLTEgaWYgdGhlIHVzZXIgc2Nyb2xsZWQgdXAsIDEgaWYgdGhleSBzY3JvbGxlZCBkb3duXHJcblx0ICovXHJcblx0c3RhdGljIGdldFNjcm9sbERpcmVjdGlvbigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIElucHV0LnNjcm9sbERpcmVjdGlvbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXIncyBtb3VzZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXHJcblx0ICovXHJcblx0c3RhdGljIGdldE1vdXNlUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQb3NpdGlvbi5zY2FsZWQoMS90aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXIncyBtb3VzZSBpbiB0aGUgZ2FtZSB3b3JsZCxcclxuXHQgKiB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHZpZXdwb3J0XHJcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0R2xvYmFsTW91c2VQb3NpdGlvbigpOiBWZWMyIHtcclxuXHRcdHJldHVybiBJbnB1dC5tb3VzZVBvc2l0aW9uLmNsb25lKCkuc2NhbGUoMS90aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpKS5hZGQoSW5wdXQudmlld3BvcnQuZ2V0T3JpZ2luKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgbW91c2UgcHJlc3NcclxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgbW91c2UgcHJlc3MgaW4gdGhlIGdhbWUgd29ybGQsXHJcblx0ICogdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgc2Nyb2xsaW5nIG9mIHRoZSB2aWV3cG9ydFxyXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXHJcblx0ICovXHJcblx0c3RhdGljIGdldEdsb2JhbE1vdXNlUHJlc3NQb3NpdGlvbigpOiBWZWMyIHtcclxuXHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzUG9zaXRpb24uY2xvbmUoKS5hZGQoSW5wdXQudmlld3BvcnQuZ2V0T3JpZ2luKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGlzYWJsZXMgYWxsIGtleXByZXNzIGFuZCBtb3VzZSBjbGljayBpbnB1dHNcclxuXHQgKi9cclxuXHRzdGF0aWMgZGlzYWJsZUlucHV0KCk6IHZvaWQge1xyXG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gdHJ1ZTtcclxuXHRcdElucHV0Lm1vdXNlRGlzYWJsZWQgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRW5hYmxlcyBhbGwga2V5cHJlc3MgYW5kIG1vdXNlIGNsaWNrIGlucHV0c1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBlbmFibGVJbnB1dCgpOiB2b2lkIHtcclxuXHRcdElucHV0LmtleXNEaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0SW5wdXQubW91c2VEaXNhYmxlZCA9IGZhbHNlO1xyXG5cdH1cclxufSIsImltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XHJcblxyXG4vKipcclxuICogSGFuZGxlcyBjb21tdW5pY2F0aW9uIHdpdGggdGhlIHdlYiBicm93c2VyIHRvIHJlY2VpdmUgYXN5bmNocm9ub3VzIGV2ZW50cyBhbmQgc2VuZCB0aGVtIHRvIHRoZSBAcmVmZXJlbmNlW0V2ZW50UXVldWVdXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dEhhbmRsZXIge1xyXG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuICAgICBcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbnB1dEhhbmRsZXJcclxuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGdhbWUgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpe1xyXG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xyXG5cdFx0XHJcbiAgICAgICAgY2FudmFzLm9ubW91c2Vkb3duID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlRG93bihldmVudCwgY2FudmFzKTtcclxuICAgICAgICBjYW52YXMub25tb3VzZXVwID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlVXAoZXZlbnQsIGNhbnZhcyk7XHJcbiAgICAgICAgY2FudmFzLm9uY29udGV4dG1lbnUgPSB0aGlzLmhhbmRsZUNvbnRleHRNZW51O1xyXG4gICAgICAgIGNhbnZhcy5vbm1vdXNlbW92ZSA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZU1vdmUoZXZlbnQsIGNhbnZhcyk7XHJcbiAgICAgICAgZG9jdW1lbnQub25rZXlkb3duID0gdGhpcy5oYW5kbGVLZXlEb3duO1xyXG4gICAgICAgIGRvY3VtZW50Lm9ua2V5dXAgPSB0aGlzLmhhbmRsZUtleVVwO1xyXG4gICAgICAgIGRvY3VtZW50Lm9uYmx1ciA9IHRoaXMuaGFuZGxlQmx1cjtcclxuICAgICAgICBkb2N1bWVudC5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVCbHVyO1xyXG4gICAgICAgIGRvY3VtZW50Lm9ud2hlZWwgPSB0aGlzLmhhbmRsZVdoZWVsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VEb3duID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XHJcblx0XHRsZXQgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfRE9XTiwge3Bvc2l0aW9uOiBwb3N9KTtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZU1vdXNlVXAgPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBsZXQgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfVVAsIHtwb3NpdGlvbjogcG9zfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBsZXQgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSwge3Bvc2l0aW9uOiBwb3N9KTtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZUtleURvd24gPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBsZXQga2V5ID0gdGhpcy5nZXRLZXkoZXZlbnQpO1xyXG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuS0VZX0RPV04sIHtrZXk6IGtleX0pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlS2V5VXAgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBsZXQga2V5ID0gdGhpcy5nZXRLZXkoZXZlbnQpO1xyXG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuS0VZX1VQLCB7a2V5OiBrZXl9KTtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZUJsdXIgPSAoZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5DQU5WQVNfQkxVUiwge30pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlQ29udGV4dE1lbnUgPSAoZXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZVdoZWVsID0gKGV2ZW50OiBXaGVlbEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50OiBHYW1lRXZlbnQ7XHJcbiAgICAgICAgaWYoZXZlbnQuZGVsdGFZIDwgMCl7XHJcbiAgICAgICAgICAgIGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5XSEVFTF9VUCwge30pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5XSEVFTF9ET1dOLCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0S2V5KGtleUV2ZW50OiBLZXlib2FyZEV2ZW50KXtcclxuICAgICAgICByZXR1cm4ga2V5RXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRNb3VzZVBvc2l0aW9uKG1vdXNlRXZlbnQ6IE1vdXNlRXZlbnQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiBWZWMyIHtcclxuICAgICAgICBsZXQgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBsZXQgeCA9IG1vdXNlRXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcclxuICAgICAgICBsZXQgeSA9IG1vdXNlRXZlbnQuY2xpZW50WSAtIHJlY3QudG9wO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTtcclxuICAgIH1cclxufSIsImltcG9ydCB7fSBmcm9tIFwiLi4vLi4vaW5kZXhcIjsgIC8vIFRoaXMgaW1wb3J0IGFsbG93cyB1cyB0byBtb2RpZnkgdGhlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB0byBhZGQgZXh0cmEgZnVuY3Rpb25hbGl0eVxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuLyoqXHJcbiAqIFNldHMgdXAgdGhlIGVudmlyb25tZW50IG9mIHRoZSBnYW1lIGVuZ2luZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW52aXJvbm1lbnRJbml0aWFsaXplciB7XHJcbiAgICBzdGF0aWMgc2V0dXAoKXtcclxuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeDogbnVtYmVyLCB5OiBudW1iZXIsIHc6IG51bWJlciwgaDogbnVtYmVyLCByOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICAgICAgLy8gQ2xhbXAgdGhlIHJhZGl1cyBiZXR3ZWVuIDAgYW5kIHRoZSBtaW4gb2YgdGhlIHdpZHRoIG9yIGhlaWdodFxyXG4gICAgICAgICAgICBpZihyIDwgMCkgciA9IDA7XHJcbiAgICAgICAgICAgIGlmKHIgPiBNYXRoLm1pbih3LCBoKSkgciA9IE1hdGgubWluKHcsIGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSByb3VuZGVkIHJlY3RcclxuICAgICAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gVG9wXHJcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcclxuICAgICAgICAgICAgdGhpcy5saW5lVG8oeCArIHcgLSByLCB5KTtcclxuICAgICAgICAgICAgdGhpcy5hcmNUbyh4ICsgdywgeSwgeCArIHcsIHkgKyByLCByKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmlnaHRcclxuICAgICAgICAgICAgdGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCArIHcsIHkgKyBoLCB4ICsgdyAtIHIsIHkgKyBoLCByKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gQm90dG9tXHJcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyByLCB5ICsgaCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gciwgcik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIExlZnRcclxuICAgICAgICAgICAgdGhpcy5saW5lVG8oeCwgeSArIHIpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY1RvKHgsIHksIHggKyByLCB5LCByKVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLnN0cm9rZVJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcil7XHJcbiAgICAgICAgICAgIHRoaXMucm91bmRlZFJlY3QoeCwgeSwgdywgaCwgcik7XHJcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbFJvdW5kZWRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcil7XHJcbiAgICAgICAgICAgIHRoaXMucm91bmRlZFJlY3QoeCwgeSwgdywgaCwgcik7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBHYW1lTG9vcCBmcm9tIFwiLi9HYW1lTG9vcFwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGdhbWUgbG9vcCB3aXRoIGEgZml4ZWQgdXBkYXRlIHRpbWUgYW5kIGEgdmFyaWFibGUgcmVuZGVyIHRpbWUuXHJcbiAqIEV2ZXJ5IGZyYW1lLCB0aGUgZ2FtZSB1cGRhdGVzIHVudGlsIGFsbCB0aW1lIHNpbmNlIHRoZSBsYXN0IGZyYW1lIGhhcyBiZWVuIHByb2Nlc3NlZC5cclxuICogSWYgdG9vIG11Y2ggdGltZSBoYXMgcGFzc2VkLCBzdWNoIGFzIGlmIHRoZSBsYXN0IHVwZGF0ZSB3YXMgdG9vIHNsb3csIFxyXG4gKiBvciBpZiB0aGUgYnJvd3NlciB3YXMgcHV0IGludG8gdGhlIGJhY2tncm91bmQsIHRoZSBsb29wIHdpbGwgcGFuaWMgYW5kIGRpc2NhcmQgdGltZS5cclxuICogQSByZW5kZXIgaGFwcGVucyBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGZyYW1lLiBUaGlzIGhhcHBlbnMgYXMgZmFzdCBhcyBwb3NzaWJsZSB1bmxlc3Mgc3BlY2lmaWVkLlxyXG4gKiBBIGxvb3Agb2YgdGhpcyB0eXBlIGFsbG93cyBmb3IgZGV0ZXJtaW5pc3RpYyBiZWhhdmlvciAtIE5vIG1hdHRlciB3aGF0IHRoZSBmcmFtZSByYXRlIGlzLCB0aGUgdXBkYXRlIHNob3VsZCBiZWhhdmUgdGhlIHNhbWUsIFxyXG4gKiBhcyBpdCBpcyBvY2N1cmluZyBpbiBhIGZpeGVkIGludGVydmFsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRml4ZWRVcGRhdGVHYW1lTG9vcCBleHRlbmRzIEdhbWVMb29wIHtcclxuXHJcblx0LyoqIFRoZSBtYXggYWxsb3dlZCB1cGRhdGUgZnBzLiovXHJcbiAgICBwcml2YXRlIG1heFVwZGF0ZUZQUzogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIHRpbWVzdGVwIGZvciBlYWNoIHVwZGF0ZS4gVGhpcyBpcyB0aGUgZGVsdGFUIHBhc3NlZCB0byB1cGRhdGUgY2FsbHMuICovXHJcblx0cHJpdmF0ZSB1cGRhdGVUaW1lc3RlcDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgd2UgYXJlIHlldCB0byBzaW11bGF0ZS4gKi9cclxuICAgIHByaXZhdGUgZnJhbWVEZWx0YTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgdGltZSB3aGVuIHRoZSBsYXN0IGZyYW1lIHdhcyBkcmF3bi4gKi9cclxuICAgIHByaXZhdGUgbGFzdEZyYW1lVGltZTogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIG1pbmltdW0gdGltZSB3ZSB3YW50IHRvIHdhaXQgYmV0d2VlbiBnYW1lIGZyYW1lcy4gKi9cclxuICAgIHByaXZhdGUgbWluRnJhbWVEZWxheTogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGdhbWUuICovXHJcblx0cHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIGFjdHVhbCBmcHMgb2YgdGhlIGdhbWUuICovXHJcbiAgICBwcml2YXRlIGZwczogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIHRpbWUgYmV0d2VlbiBmcHMgbWVhc3VyZW1lbnQgdXBkYXRlcy4gKi9cclxuICAgIHByaXZhdGUgZnBzVXBkYXRlSW50ZXJ2YWw6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGxhc3QgZnBzIHVwZGF0ZS4gKi9cclxuICAgIHByaXZhdGUgbGFzdEZwc1VwZGF0ZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGZyYW1lcyBzaW5jZSB0aGUgbGFzdCBmcHMgdXBkYXRlIHdhcyBkb25lLiAqL1xyXG4gICAgcHJpdmF0ZSBmcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGU6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGhhcyBzdGFydGVkLiAqL1xyXG4gICAgcHJpdmF0ZSBzdGFydGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaXMgcGF1c2VkICovXHJcbiAgICBwcml2YXRlIHBhdXNlZDogYm9vbGVhbjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBpcyBjdXJyZW50bHkgcnVubmluZy4gKi9cclxuICAgIHByaXZhdGUgcnVubmluZzogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIG51bWJlciBvZiB1cGRhdGUgc3RlcHMgdGhpcyBpdGVyYXRpb24gb2YgdGhlIGdhbWUgbG9vcC4gKi9cclxuICAgIHByaXZhdGUgbnVtVXBkYXRlU3RlcHM6IG51bWJlcjtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubWF4VXBkYXRlRlBTID0gNjA7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lc3RlcCA9IE1hdGguZmxvb3IoMTAwMC90aGlzLm1heFVwZGF0ZUZQUyk7XHJcbiAgICAgICAgdGhpcy5mcmFtZURlbHRhID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcHMgPSB0aGlzLm1heFVwZGF0ZUZQUzsgICAvLyBJbml0aWFsaXplIHRoZSBmcHMgdG8gdGhlIG1heCBhbGxvd2VkIGZwc1xyXG4gICAgICAgIHRoaXMuZnBzVXBkYXRlSW50ZXJ2YWwgPSAxMDAwO1xyXG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XHJcblx0fVxyXG5cclxuXHRnZXRGUFMoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBmcmFtZSBjb3VudCBhbmQgc3VtIG9mIHRpbWUgZm9yIHRoZSBmcmFtZXJhdGUgb2YgdGhlIGdhbWVcclxuICAgICAqIEBwYXJhbSB0aW1lc3RlcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCB1cGRhdGVGUFModGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZwcyA9IDAuOSAqIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlICogMTAwMCAvICh0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcHNVcGRhdGUpICsoMSAtIDAuOSkgKiB0aGlzLmZwcztcclxuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgPSAwO1xyXG5cclxuICAgICAgICBEZWJ1Zy5sb2coXCJmcHNcIiwgXCJGUFM6IFwiICsgdGhpcy5mcHMudG9GaXhlZCgxKSk7XHJcbiAgICAgICAgU3RhdHMudXBkYXRlRlBTKHRoaXMuZnBzKTtcclxuICAgIH1cclxuXHJcblx0ICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgbWF4aW11bSBhbGxvd2VkIHBoeXNpY3MgZnJhbWVyYXRlIG9mIHRoZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gaW5pdE1heCBUaGUgbWF4IGZyYW1lcmF0ZVxyXG4gICAgICovXHJcbiAgICBzZXRNYXhVcGRhdGVGUFMoaW5pdE1heDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5tYXhVcGRhdGVGUFMgPSBpbml0TWF4O1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZXN0ZXAgPSBNYXRoLmZsb29yKDEwMDAvdGhpcy5tYXhVcGRhdGVGUFMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWF4aW11bSByZW5kZXJpbmcgZnJhbWVyYXRlXHJcbiAgICAgKiBAcGFyYW0gbWF4RlBTIFRoZSBtYXggZnJhbWVyYXRlXHJcbiAgICAgKi9cclxuICAgIHNldE1heEZQUyhtYXhGUFM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubWluRnJhbWVEZWxheSA9IDEwMDAvbWF4RlBTO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBnYW1lIGxvb3AgcGFuaWNzLCBpLmUuIGl0IHRyaWVzIHRvIHByb2Nlc3MgdG9vIG11Y2ggdGltZSBpbiBhbiBlbnRpcmUgZnJhbWUuXHJcblx0ICogVGhpcyB3aWxsIHJlc2V0IHRoZSBhbW91bnQgb2YgdGltZSBiYWNrIHRvIHplcm8uXHJcblx0ICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB0aW1lIHdlIGFyZSBkaXNjYXJkaW5nIGZyb20gcHJvY2Vzc2luZy5cclxuXHQgKi9cclxuXHRyZXNldEZyYW1lRGVsdGEoKSA6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IG9sZEZyYW1lRGVsdGEgPSB0aGlzLmZyYW1lRGVsdGE7XHJcbiAgICAgICAgdGhpcy5mcmFtZURlbHRhID0gMDtcclxuICAgICAgICByZXR1cm4gb2xkRnJhbWVEZWx0YTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBTdGFydHMgdXAgdGhlIGdhbWUgbG9vcCBhbmQgY2FsbHMgdGhlIGZpcnN0IHJlcXVlc3RBbmltYXRpb25GcmFtZVxyXG4gICAgICovXHJcblx0c3RhcnQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYoIXRoaXMuc3RhcnRlZCl7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0aW1lc3RhbXApID0+IHRoaXMuZG9GaXJzdEZyYW1lKHRpbWVzdGFtcCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwYXVzZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzdW1lKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG5cdC8qKlxyXG4gICAgICogVGhlIGZpcnN0IGdhbWUgZnJhbWUgLSBpbml0aWFsaXplcyB0aGUgZmlyc3QgZnJhbWUgdGltZSBhbmQgYmVnaW5zIHRoZSByZW5kZXJcclxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZG9GaXJzdEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCAge1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuX2RvUmVuZGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcclxuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgPSAwO1xyXG5cclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0KSA9PiB0aGlzLmRvRnJhbWUodCkpO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuXHQgKiBIYW5kbGVzIGFueSBwcm9jZXNzaW5nIHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGZyYW1lXHJcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZSBvZiB0aGUgZnJhbWUgaW4gbXNcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgc3RhcnRGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Ly8gVXBkYXRlIHRoZSBhbW91bnQgb2YgdGltZSB3ZSBuZWVkIG91ciB1cGRhdGUgdG8gcHJvY2Vzc1xyXG5cdFx0dGhpcy5mcmFtZURlbHRhICs9IHRpbWVzdGFtcCAtIHRoaXMubGFzdEZyYW1lVGltZTtcclxuXHJcblx0XHQvLyBTZXQgdGhlIG5ldyB0aW1lIG9mIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gdGltZXN0YW1wO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGVzdGltYXRlIG9mIHRoZSBmcmFtZXJhdGVcclxuICAgICAgICBpZih0aW1lc3RhbXAgPiB0aGlzLmxhc3RGcHNVcGRhdGUgKyB0aGlzLmZwc1VwZGF0ZUludGVydmFsKXtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVGUFModGltZXN0YW1wKTtcclxuICAgICAgICB9XHJcblxyXG5cdFx0Ly8gSW5jcmVtZW50IHRoZSBudW1iZXIgb2YgZnJhbWVzXHJcbiAgICAgICAgdGhpcy5mcmFtZSsrO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlKys7XHJcblx0fVxyXG5cclxuXHQvKipcclxuICAgICAqIFRoZSBtYWluIGxvb3Agb2YgdGhlIGdhbWUuIFVwZGF0ZXMgdW50aWwgdGhlIGN1cnJlbnQgdGltZSBpcyByZWFjaGVkLiBSZW5kZXJzIG9uY2VcclxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZG9GcmFtZSA9ICh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gICAgICAgIC8vIElmIGEgcGF1c2Ugd2FzIGV4ZWN1dGVkLCBzdG9wIGRvaW5nIHRoZSBsb29wLlxyXG4gICAgICAgIGlmKHRoaXMucGF1c2VkKXsgXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIHRvIHByZXBhcmUgZm9yIGFub3RoZXIgdXBkYXRlIG9yIHJlbmRlclxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHQpID0+IHRoaXMuZG9GcmFtZSh0KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHdlIGFyZSB0cnlpbmcgdG8gcmVuZGVyIHRvbyBzb29uLCBkbyBub3RoaW5nLlxyXG4gICAgICAgIGlmKHRpbWVzdGFtcCA8IHRoaXMubGFzdEZyYW1lVGltZSArIHRoaXMubWluRnJhbWVEZWxheSl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gQSBmcmFtZSBpcyBhY3R1YWxseSBoYXBwZW5pbmdcclxuXHRcdHRoaXMuc3RhcnRGcmFtZSh0aW1lc3RhbXApO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSB3aGlsZSB0aGVyZSBpcyBzdGlsbCB0aW1lIHRvIG1ha2UgdXAuIElmIHdlIGRvIHRvbyBtYW55IHVwZGF0ZSBzdGVwcywgcGFuaWMgYW5kIGV4aXQgdGhlIGxvb3AuXHJcblx0XHR0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcclxuXHRcdGxldCBwYW5pYyA9IGZhbHNlO1xyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmZyYW1lRGVsdGEgPj0gdGhpcy51cGRhdGVUaW1lc3RlcCl7XHJcblx0XHRcdC8vIERvIGFuIHVwZGF0ZVxyXG5cdFx0XHR0aGlzLl9kb1VwZGF0ZSh0aGlzLnVwZGF0ZVRpbWVzdGVwLzEwMDApO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSB1cGRhdGUgc3RlcCB0aW1lIGZyb20gdGhlIHRpbWUgd2UgaGF2ZSB0byBwcm9jZXNzXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVEZWx0YSAtPSB0aGlzLnVwZGF0ZVRpbWVzdGVwO1xyXG5cclxuXHRcdFx0Ly8gSW5jcmVtZW50IHN0ZXBzIGFuZCBjaGVjayBpZiB3ZSd2ZSBkb25lIHRvbyBtYW55XHJcbiAgICAgICAgICAgIHRoaXMubnVtVXBkYXRlU3RlcHMrKztcclxuICAgICAgICAgICAgaWYodGhpcy5udW1VcGRhdGVTdGVwcyA+IDEwMCl7XHJcbiAgICAgICAgICAgICAgICBwYW5pYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlcyBhcmUgZG9uZSwgcmVuZGVyXHJcbiAgICAgICAgdGhpcy5fZG9SZW5kZXIoKTtcclxuXHJcbiAgICAgICAgLy8gV3JhcCB1cCB0aGUgZnJhbWVcclxuICAgICAgICB0aGlzLmZpbmlzaEZyYW1lKHBhbmljKTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcblx0ICogV3JhcHMgdXAgdGhlIGZyYW1lIGFuZCBoYW5kbGVzIHRoZSBwYW5pYyBzdGF0ZSBpZiB0aGVyZSBpcyBvbmVcclxuXHQgKiBAcGFyYW0gcGFuaWMgV2hldGhlciBvciBub3QgdGhlIGxvb3AgcGFuaWNrZWRcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZmluaXNoRnJhbWUocGFuaWM6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGlmKHBhbmljKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXNjYXJkZWRUaW1lID0gTWF0aC5yb3VuZCh0aGlzLnJlc2V0RnJhbWVEZWx0YSgpKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWluIGxvb3AgcGFuaWNrZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIGJyb3dzZXIgdGFiIHdhcyBwdXQgaW4gdGhlIGJhY2tncm91bmQuIERpc2NhcmRpbmcgJyArIGRpc2NhcmRlZFRpbWUgKyAnbXMnKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxufSIsImltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBJbnB1dEhhbmRsZXIgZnJvbSBcIi4uL0lucHV0L0lucHV0SGFuZGxlclwiO1xyXG5pbXBvcnQgUmVjb3JkZXIgZnJvbSBcIi4uL1BsYXliYWNrL1JlY29yZGVyXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcclxuaW1wb3J0IFNjZW5lTWFuYWdlciBmcm9tIFwiLi4vU2NlbmUvU2NlbmVNYW5hZ2VyXCI7XHJcbmltcG9ydCBBdWRpb01hbmFnZXIgZnJvbSBcIi4uL1NvdW5kL0F1ZGlvTWFuYWdlclwiO1xyXG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgQ2FudmFzUmVuZGVyZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9DYW52YXNSZW5kZXJlclwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBHYW1lT3B0aW9ucyBmcm9tIFwiLi9HYW1lT3B0aW9uc1wiO1xyXG5pbXBvcnQgR2FtZUxvb3AgZnJvbSBcIi4vR2FtZUxvb3BcIjtcclxuaW1wb3J0IEZpeGVkVXBkYXRlR2FtZUxvb3AgZnJvbSBcIi4vRml4ZWRVcGRhdGVHYW1lTG9vcFwiO1xyXG5pbXBvcnQgRW52aXJvbm1lbnRJbml0aWFsaXplciBmcm9tIFwiLi9FbnZpcm9ubWVudEluaXRpYWxpemVyXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXJcIjtcclxuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmVyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFpbiBsb29wIG9mIHRoZSBnYW1lIGVuZ2luZS5cclxuICogSGFuZGxlcyB0aGUgdXBkYXRlIG9yZGVyLCBhbmQgaW5pdGlhbGl6ZXMgYWxsIHN1YnN5c3RlbXMuXHJcbiAqIFRoZSBHYW1lIG1hbmFnZXMgdGhlIHVwZGF0ZSBjeWNsZSwgYW5kIHJlcXVlc3RzIGFuaW1hdGlvbiBmcmFtZXMgdG8gcmVuZGVyIHRvIHRoZSBicm93c2VyLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZSB7XHJcbiAgICBnYW1lT3B0aW9uczogR2FtZU9wdGlvbnM7XHJcbiAgICBwcml2YXRlIHNob3dEZWJ1ZzogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgc2hvd1N0YXRzOiBib29sZWFuO1xyXG5cclxuICAgIC8vIFRoZSBnYW1lIGxvb3BcclxuICAgIHByaXZhdGUgbG9vcDogR2FtZUxvb3A7XHJcblxyXG4gICAgLy8gR2FtZSBjYW52YXMgYW5kIGl0cyB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgICByZWFkb25seSBHQU1FX0NBTlZBUzogSFRNTENhbnZhc0VsZW1lbnQ7XHJcbiAgICByZWFkb25seSBERUJVR19DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xyXG5cdHJlYWRvbmx5IFdJRFRIOiBudW1iZXI7XHJcbiAgICByZWFkb25seSBIRUlHSFQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgdmlld3BvcnQ6IFZpZXdwb3J0O1xyXG4gICAgcHJpdmF0ZSBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcclxuICAgIHByaXZhdGUgY2xlYXJDb2xvcjogQ29sb3I7XHJcbiAgICBcclxuICAgIC8vIEFsbCBvZiB0aGUgbmVjZXNzYXJ5IHN1YnN5c3RlbXMgdGhhdCBuZWVkIHRvIHJ1biBoZXJlXHJcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xyXG5cdHByaXZhdGUgaW5wdXRIYW5kbGVyOiBJbnB1dEhhbmRsZXI7XHJcblx0cHJpdmF0ZSByZWNvcmRlcjogUmVjb3JkZXI7XHJcbiAgICBwcml2YXRlIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG4gICAgcHJpdmF0ZSBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlcjtcclxuICAgIHByaXZhdGUgYXVkaW9NYW5hZ2VyOiBBdWRpb01hbmFnZXI7XHJcbiAgICBwcml2YXRlIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBHYW1lIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcclxuICAgICAgICAvLyBCZWZvcmUgYW55dGhpbmcgZWxzZSwgYnVpbGQgdGhlIGVudmlyb25tZW50XHJcbiAgICAgICAgRW52aXJvbm1lbnRJbml0aWFsaXplci5zZXR1cCgpO1xyXG5cclxuICAgICAgICAvLyBUeXBlY2FzdCB0aGUgY29uZmlnIG9iamVjdCB0byBhIEdhbWVDb25maWcgb2JqZWN0XHJcbiAgICAgICAgdGhpcy5nYW1lT3B0aW9ucyA9IEdhbWVPcHRpb25zLnBhcnNlKG9wdGlvbnMpO1xyXG5cclxuICAgICAgICB0aGlzLnNob3dEZWJ1ZyA9IHRoaXMuZ2FtZU9wdGlvbnMuc2hvd0RlYnVnO1xyXG4gICAgICAgIHRoaXMuc2hvd1N0YXRzID0gdGhpcy5nYW1lT3B0aW9ucy5zaG93U3RhdHM7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhIGdhbWUgbG9vcFxyXG4gICAgICAgIHRoaXMubG9vcCA9IG5ldyBGaXhlZFVwZGF0ZUdhbWVMb29wKCk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgZ2FtZSBjYW52YXMgYW5kIGdpdmUgaXQgYSBiYWNrZ3JvdW5kIGNvbG9yXHJcbiAgICAgICAgdGhpcy5HQU1FX0NBTlZBUyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbWUtY2FudmFzXCIpO1xyXG4gICAgICAgIHRoaXMuREVCVUdfQ0FOVkFTID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVidWctY2FudmFzXCIpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gR2l2ZSB0aGUgY2FudmFzIGEgc2l6ZSBhbmQgZ2V0IHRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgIHRoaXMuV0lEVEggPSB0aGlzLmdhbWVPcHRpb25zLmNhbnZhc1NpemUueDtcclxuICAgICAgICB0aGlzLkhFSUdIVCA9IHRoaXMuZ2FtZU9wdGlvbnMuY2FudmFzU2l6ZS55O1xyXG5cclxuICAgICAgICAvLyBUaGlzIHN0ZXAgTVVTVCBoYXBwZW4gYmVmb3JlIHRoZSByZXNvdXJjZSBtYW5hZ2VyIGRvZXMgYW55dGhpbmdcclxuICAgICAgICBpZih0aGlzLmdhbWVPcHRpb25zLnVzZVdlYkdMKXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gbmV3IFdlYkdMUmVuZGVyZXIoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplR2FtZVdpbmRvdygpO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLmluaXRpYWxpemVDYW52YXModGhpcy5HQU1FX0NBTlZBUywgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xyXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IG5ldyBDb2xvcih0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuciwgdGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLmcsIHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5iKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkZWJ1Z2dpbmcgYW5kIHN0YXRzXHJcbiAgICAgICAgRGVidWcuaW5pdGlhbGl6ZURlYnVnQ2FudmFzKHRoaXMuREVCVUdfQ0FOVkFTLCB0aGlzLldJRFRILCB0aGlzLkhFSUdIVCk7XHJcbiAgICAgICAgU3RhdHMuaW5pdFN0YXRzKCk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZ2FtZU9wdGlvbnMuc2hvd1N0YXRzKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0YXRzIG91dHB1dCBhbmQgbWFrZSBpdCBubyBsb25nZXIgaGlkZGVuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHNcIikuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTaXplIHRoZSB2aWV3cG9ydCB0byB0aGUgZ2FtZSBjYW52YXNcclxuICAgICAgICBjb25zdCBjYW52YXNTaXplID0gbmV3IFZlYzIodGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBuZXcgVmlld3BvcnQoY2FudmFzU2l6ZSwgdGhpcy5nYW1lT3B0aW9ucy56b29tTGV2ZWwpO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIGFsbCBuZWNlc3NhcnkgZ2FtZSBzdWJzeXN0ZW1zXHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyID0gbmV3IElucHV0SGFuZGxlcih0aGlzLkdBTUVfQ0FOVkFTKTtcclxuICAgICAgICBJbnB1dC5pbml0aWFsaXplKHRoaXMudmlld3BvcnQsIHRoaXMuZ2FtZU9wdGlvbnMuaW5wdXRzKTtcclxuICAgICAgICB0aGlzLnJlY29yZGVyID0gbmV3IFJlY29yZGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlciA9IG5ldyBTY2VuZU1hbmFnZXIodGhpcy52aWV3cG9ydCwgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyKTtcclxuICAgICAgICB0aGlzLmF1ZGlvTWFuYWdlciA9IEF1ZGlvTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHVwIHRoZSBnYW1lIHdpbmRvdyB0aGF0IGhvbGRzIHRoZSBjYW52YXNlc1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGluaXRpYWxpemVHYW1lV2luZG93KCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGdhbWVXaW5kb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbWUtd2luZG93XCIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBnYW1lIHdpbmRvd1xyXG4gICAgICAgIGdhbWVXaW5kb3cuc3R5bGUud2lkdGggPSB0aGlzLldJRFRIICsgXCJweFwiO1xyXG4gICAgICAgIGdhbWVXaW5kb3cuc3R5bGUuaGVpZ2h0ID0gdGhpcy5IRUlHSFQgKyBcInB4XCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyZWl2ZXMgdGhlIFNjZW5lTWFuYWdlciBmcm9tIHRoZSBHYW1lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgU2NlbmVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGdldFNjZW5lTWFuYWdlcigpOiBTY2VuZU1hbmFnZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lTWFuYWdlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgZ2FtZVxyXG4gICAgICovXHJcbiAgICBzdGFydChJbml0aWFsU2NlbmU6IG5ldyAoLi4uYXJnczogYW55KSA9PiBTY2VuZSwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIC8vIFNldCB0aGUgdXBkYXRlIGZ1bmN0aW9uIG9mIHRoZSBsb29wXHJcbiAgICAgICAgdGhpcy5sb29wLmRvVXBkYXRlID0gKGRlbHRhVDogbnVtYmVyKSA9PiB0aGlzLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiB0aGUgbG9vcFxyXG4gICAgICAgIHRoaXMubG9vcC5kb1JlbmRlciA9ICgpID0+IHRoaXMucmVuZGVyKCk7XHJcblxyXG4gICAgICAgIC8vIFByZWxvYWQgcmVnaXN0cnkgaXRlbXNcclxuICAgICAgICBSZWdpc3RyeU1hbmFnZXIucHJlbG9hZCgpO1xyXG5cclxuICAgICAgICAvLyBMb2FkIHRoZSBpdGVtcyB3aXRoIHRoZSByZXNvdXJjZSBtYW5hZ2VyXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIubG9hZFJlc291cmNlc0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgZG9uZSBsb2FkaW5nLCBzdGFydCB0aGUgbG9vcFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZpbmlzaGVkIFByZWxvYWQgLSBsb2FkaW5nIGZpcnN0IHNjZW5lXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKEluaXRpYWxTY2VuZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcC5zdGFydCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBhbGwgbmVjZXNzYXJ5IHN1YnN5c3RlbXMgb2YgdGhlIGdhbWUuIERlZmVycyBzY2VuZSB1cGRhdGVzIHRvIHRoZSBzY2VuZU1hbmFnZXJcclxuICAgICAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWUgc2luZSB0aGUgbGFzdCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAvLyBIYW5kbGUgYWxsIGV2ZW50cyB0aGF0IGhhcHBlbmVkIHNpbmNlIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBsb29wXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRRdWV1ZS51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgZGF0YSBzdHJ1Y3R1cmVzIHNvIGdhbWUgb2JqZWN0cyBjYW4gc2VlIHRoZSBpbnB1dFxyXG4gICAgICAgICAgICBJbnB1dC51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVjb3JkaW5nIG9mIHRoZSBnYW1lXHJcbiAgICAgICAgICAgIHRoaXMucmVjb3JkZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHNjZW5lc1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgc291bmRzXHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTG9hZCBvciB1bmxvYWQgYW55IHJlc291cmNlcyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIudXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICAgICAgdGhpcy5sb29wLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuY2F1Z2h0IEVycm9yIGluIFVwZGF0ZSAtIENyYXNoaW5nIGdyYWNlZnVsbHlcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjYW52YXMgYW5kIGRlZmVycyBzY2VuZSByZW5kZXJpbmcgdG8gdGhlIHNjZW5lTWFuYWdlci4gUmVuZGVycyB0aGUgZGVidWcgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcigpOiB2b2lkIHtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYW52YXNlc1xyXG4gICAgICAgICAgICBEZWJ1Zy5jbGVhckNhbnZhcygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLmNsZWFyKHRoaXMuY2xlYXJDb2xvcik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhY2t5IGRlYnVnIG1vZGVcclxuICAgICAgICAgICAgaWYoSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcImdcIikpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RGVidWcgPSAhdGhpcy5zaG93RGVidWc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERlYnVnIHJlbmRlclxyXG4gICAgICAgICAgICBpZih0aGlzLnNob3dEZWJ1Zyl7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5zaG93U3RhdHMpe1xyXG4gICAgICAgICAgICAgICAgU3RhdHMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AucGF1c2UoKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgRXJyb3IgaW4gUmVuZGVyIC0gQ3Jhc2hpbmcgZ3JhY2VmdWxseVwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTnVsbEZ1bmMgZnJvbSBcIi4uL0RhdGFUeXBlcy9GdW5jdGlvbnMvTnVsbEZ1bmNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFpbiBnYW1lIGxvb3Agb2YgdGhlIGdhbWUuIEtlZXBzIHRyYWNrIG9mIGZwcyBhbmQgaGFuZGxlcyBzY2hlZHVsaW5nIG9mIHVwZGF0ZXMgYW5kIHJlbmRlcmluZy5cclxuICogVGhpcyBjbGFzcyBpcyBsZWZ0IGFic3RyYWN0LCBzbyB0aGF0IGEgc3ViY2xhc3MgY2FuIGhhbmRsZSBleGFjdGx5IGhvdyB0aGUgbG9vcCBpcyBzY2hlZHVsZWQuXHJcbiAqIEZvciBhbiBleGFtcGxlIG9mIGRpZmZlcmVudCB0eXBlcyBvZiBnYW1lIGxvb3Agc2NoZWR1bGluZywgY2hlY2sgb3V0IEBsaW5rKEdhbWUgUHJvZ3JhbW1pbmcgUGF0dGVybnMpKGh0dHBzOi8vZ2FtZXByb2dyYW1taW5ncGF0dGVybnMuY29tL2dhbWUtbG9vcC5odG1sKVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR2FtZUxvb3Age1xyXG5cclxuXHQvKiogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhbiB1cGRhdGUgb2NjdXJzICovXHJcblx0cHJvdGVjdGVkIF9kb1VwZGF0ZTogRnVuY3Rpb24gPSBOdWxsRnVuYztcclxuXHJcblx0c2V0IGRvVXBkYXRlKHVwZGF0ZTogRnVuY3Rpb24pe1xyXG5cdFx0dGhpcy5fZG9VcGRhdGUgPSB1cGRhdGU7XHJcblx0fVxyXG5cclxuXHQvKiogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIHJlbmRlciBvY2N1cnMgKi9cclxuXHRwcm90ZWN0ZWQgX2RvUmVuZGVyOiBGdW5jdGlvbiA9IE51bGxGdW5jO1xyXG5cclxuXHJcblx0c2V0IGRvUmVuZGVyKHJlbmRlcjogRnVuY3Rpb24pe1xyXG5cdFx0dGhpcy5fZG9SZW5kZXIgPSByZW5kZXI7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBGUFMgb2YgdGhlIGdhbWVcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBnZXRGUFMoKTogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuICAgICAqIFN0YXJ0cyB1cCB0aGUgZ2FtZSBsb29wXHJcbiAgICAgKi9cclxuXHRhYnN0cmFjdCBzdGFydCgpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBQYXVzZXMgdGhlIGdhbWUgbG9vcCwgdXN1YWxseSBmb3IgYW4gZXJyb3IgY29uZGl0aW9uLlxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IHBhdXNlKCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc3VtZXMgdGhlIGdhbWUgbG9vcC5cclxuXHQgKi9cclxuXHRhYnN0cmFjdCByZXN1bWUoKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUnVucyB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGdhbWUuIE5vIHVwZGF0ZSBvY2N1cnMgaGVyZSwgb25seSBhIHJlbmRlci5cclxuXHQgKiBUaGlzIGlzIG5lZWRlZCB0byBpbml0aWFsaXplIGRlbHRhIHRpbWUgdmFsdWVzXHJcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJ1biBiZWZvcmUgYW55IHVwZGF0ZXMgb3IgdGhlIHJlbmRlciBvZiBhIGZyYW1lLlxyXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBzdGFydEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGNvcmUgb2YgdGhlIGZyYW1lLCB3aGVyZSBhbnkgbmVjZXNzYXJ5IHVwZGF0ZXMgb2NjdXIsIGFuZCB3aGVyZSBhIHJlbmRlciBoYXBwZW5zXHJcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGRvRnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBXcmFwcyB1cCB0aGUgZnJhbWVcclxuXHQgKiBAcGFyYW0gcGFuaWMgV2hldGhlciBvciBub3QgdGhlIHVwZGF0ZSBjeWNsZSBwYW5pY2tlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdG9vIG1hbnkgdXBkYXRlcyB0cnkgdG8gaGFwcGVuIGluIGEgc2luZ2xlIGZyYW1lXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGZpbmlzaEZyYW1lKHBhbmljOiBib29sZWFuKTogdm9pZDtcclxufSIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKiogVGhlIG9wdGlvbnMgZm9yIGluaXRpYWxpemluZyB0aGUgQHJlZmVyZW5jZVtHYW1lTG9vcF0gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZU9wdGlvbnMge1xyXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCAqL1xyXG4gICAgY2FudmFzU2l6ZToge3g6IG51bWJlciwgeTogbnVtYmVyfTtcclxuXHJcbiAgICAvKiBUaGUgZGVmYXVsdCBsZXZlbCBvZiB6b29tICovXHJcbiAgICB6b29tTGV2ZWw6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGNvbG9yIHRvIGNsZWFyIHRoZSBjYW52YXMgdG8gZWFjaCBmcmFtZSAqL1xyXG4gICAgY2xlYXJDb2xvcjoge3I6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXJ9XHJcblxyXG4gICAgLyogQSBsaXN0IG9mIGlucHV0IGJpbmRpbmdzICovXHJcbiAgICBpbnB1dHM6IEFycmF5PHtuYW1lOiBzdHJpbmcsIGtleXM6IEFycmF5PHN0cmluZz59PjtcclxuXHJcbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0aGUgZGVidWcgcmVuZGVyaW5nIHNob3VsZCBvY2N1ciAqL1xyXG4gICAgc2hvd0RlYnVnOiBib29sZWFuO1xyXG5cclxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRoZSBzdGF0cyByZW5kZXJpbmcgc2hvdWxkIG9jY3VyICovXHJcbiAgICBzaG93U3RhdHM6IGJvb2xlYW47XHJcblxyXG4gICAgLyogV2hldGhlciBvciBub3QgdG8gdXNlIHdlYkdMICovXHJcbiAgICB1c2VXZWJHTDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyB0aGUgZGF0YSBpbiB0aGUgcmF3IG9wdGlvbnMgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZ2FtZSBvcHRpb25zIGFzIGEgUmVjb3JkXHJcbiAgICAgKiBAcmV0dXJucyBBIHZlcnNpb24gb2YgdGhlIG9wdGlvbnMgY29udmVydGVkIHRvIGEgR2FtZU9wdGlvbnMgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwYXJzZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR2FtZU9wdGlvbnMge1xyXG4gICAgICAgIGxldCBnT3B0ID0gbmV3IEdhbWVPcHRpb25zKCk7XHJcblxyXG4gICAgICAgIGdPcHQuY2FudmFzU2l6ZSA9IG9wdGlvbnMuY2FudmFzU2l6ZSA/IG9wdGlvbnMuY2FudmFzU2l6ZSA6IHt4OiA4MDAsIHk6IDYwMH07XHJcbiAgICAgICAgZ09wdC56b29tTGV2ZWwgPSBvcHRpb25zLnpvb21MZXZlbCA/IG9wdGlvbnMuem9vbUxldmVsIDogMTtcclxuICAgICAgICBnT3B0LmNsZWFyQ29sb3IgPSBvcHRpb25zLmNsZWFyQ29sb3IgPyBvcHRpb25zLmNsZWFyQ29sb3IgOiB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NX07XHJcbiAgICAgICAgZ09wdC5pbnB1dHMgPSBvcHRpb25zLmlucHV0cyA/IG9wdGlvbnMuaW5wdXRzIDogW107XHJcbiAgICAgICAgZ09wdC5zaG93RGVidWcgPSAhIW9wdGlvbnMuc2hvd0RlYnVnO1xyXG4gICAgICAgIGdPcHQuc2hvd1N0YXRzID0gISFvcHRpb25zLnNob3dTdGF0cztcclxuICAgICAgICBnT3B0LnVzZVdlYkdMID0gISFvcHRpb25zLnVzZVdlYkdMO1xyXG5cclxuICAgICAgICByZXR1cm4gZ09wdDtcclxuICAgIH1cclxufSIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFJlZ2lvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbiB0aGUgZ2FtZSB3b3JsZCB0aGF0IGNhbiBiZSBkcmF3biB0byB0aGUgc2NyZWVuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDYW52YXNOb2RlIGV4dGVuZHMgR2FtZU5vZGUgaW1wbGVtZW50cyBSZWdpb24ge1xyXG5cdHByaXZhdGUgX3NpemU6IFZlYzI7XHJcblx0cHJpdmF0ZSBfc2NhbGU6IFZlYzI7XHJcblx0cHJpdmF0ZSBfYm91bmRhcnk6IEFBQkI7XHJcblx0cHJpdmF0ZSBfaGFzQ3VzdG9tU2hhZGVyOiBib29sZWFuO1xyXG5cdHByaXZhdGUgX2N1c3RvbVNoYWRlcktleTogc3RyaW5nO1xyXG5cdHByaXZhdGUgX2FscGhhOiBudW1iZXI7XHJcblxyXG5cdC8qKiBBIGZsYWcgZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBDYW52YXNOb2RlIGlzIHZpc2libGUgKi9cclxuXHR2aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcclxuXHRcclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuX3NpemUgPSBuZXcgVmVjMigwLCAwKTtcclxuXHRcdHRoaXMuX3NpemUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zaXplQ2hhbmdlZCgpKTtcclxuXHRcdHRoaXMuX3NjYWxlID0gbmV3IFZlYzIoMSwgMSk7XHJcblx0XHR0aGlzLl9zY2FsZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNjYWxlQ2hhbmdlZCgpKTtcclxuXHRcdHRoaXMuX2JvdW5kYXJ5ID0gbmV3IEFBQkIoKTtcclxuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcclxuXHJcblx0XHR0aGlzLl9oYXNDdXN0b21TaGFkZXIgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGdldCBhbHBoYSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2FscGhhO1xyXG5cdH1cclxuXHJcblx0c2V0IGFscGhhKGE6IG51bWJlcikge1xyXG5cdFx0dGhpcy5fYWxwaGEgPSBhO1xyXG5cdH1cclxuXHJcblx0Z2V0IHNpemUoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcclxuXHR9XHJcblxyXG5cdHNldCBzaXplKHNpemU6IFZlYzIpe1xyXG5cdFx0dGhpcy5fc2l6ZSA9IHNpemU7XHJcblx0XHQvLyBFbnRlciBhcyBhIGxhbWJkYSB0byBiaW5kIFwidGhpc1wiXHJcblx0XHR0aGlzLl9zaXplLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2l6ZUNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnNpemVDaGFuZ2VkKCk7XHJcblx0fVxyXG5cclxuXHRnZXQgc2NhbGUoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGU7XHJcblx0fVxyXG5cclxuXHRzZXQgc2NhbGUoc2NhbGU6IFZlYzIpe1xyXG5cdFx0dGhpcy5fc2NhbGUgPSBzY2FsZTtcclxuXHRcdC8vIEVudGVyIGFzIGEgbGFtYmRhIHRvIGJpbmQgXCJ0aGlzXCJcclxuXHRcdHRoaXMuX3NjYWxlLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2NhbGVDaGFuZ2VkKCkpO1xyXG5cdFx0dGhpcy5zY2FsZUNoYW5nZWQoKTtcclxuXHR9XHJcblxyXG5cdHNldCBzY2FsZVgodmFsdWU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5zY2FsZS54ID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRzZXQgc2NhbGVZKHZhbHVlOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuc2NhbGUueSA9IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0Z2V0IGhhc0N1c3RvbVNoYWRlcigpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl9oYXNDdXN0b21TaGFkZXI7XHJcblx0fVxyXG5cclxuXHRnZXQgY3VzdG9tU2hhZGVyS2V5KCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3VzdG9tU2hhZGVyS2V5O1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIHBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcclxuXHRcdHN1cGVyLnBvc2l0aW9uQ2hhbmdlZCgpO1xyXG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xyXG5cdH1cclxuXHJcblx0LyoqIENhbGxlZCBpZiB0aGUgc2l6ZSB2ZWN0b3IgaXMgY2hhbmdlZCBvciByZXBsYWNlZC4gKi9cclxuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XHJcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XHJcblx0fVxyXG5cclxuXHQvKiogQ2FsbGVkIGlmIHRoZSBzY2FsZSB2ZWN0b3IgaXMgY2hhbmdlZCBvciByZXBsYWNlZCAqL1xyXG5cdHByb3RlY3RlZCBzY2FsZUNoYW5nZWQoKTogdm9pZCB7XHJcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XHJcblx0fVxyXG5cclxuXHQvLyBAZG9jSWdub3JlXHJcblx0LyoqIENhbGxlZCBpZiB0aGUgcG9zaXRpb24sIHNpemUsIG9yIHNjYWxlIG9mIHRoZSBDYW52YXNOb2RlIGlzIGNoYW5nZWQuIFVwZGF0ZXMgdGhlIGJvdW5kYXJ5LiAqL1xyXG5cdHByaXZhdGUgdXBkYXRlQm91bmRhcnkoKTogdm9pZCB7XHJcblx0XHR0aGlzLl9ib3VuZGFyeS5jZW50ZXIuc2V0KHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55KTtcclxuXHRcdHRoaXMuX2JvdW5kYXJ5LmhhbGZTaXplLnNldCh0aGlzLnNpemUueCp0aGlzLnNjYWxlLngvMiwgdGhpcy5zaXplLnkqdGhpcy5zY2FsZS55LzIpO1xyXG5cdH1cclxuXHJcblx0Z2V0IGJvdW5kYXJ5KCk6IEFBQkIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kYXJ5O1xyXG5cdH1cclxuXHJcblx0Z2V0IHNpemVXaXRoWm9vbSgpOiBWZWMyIHtcclxuXHRcdGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ib3VuZGFyeS5oYWxmU2l6ZS5jbG9uZSgpLnNjYWxlZCh6b29tLCB6b29tKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBjdXN0b20gc2hhZGVyIHRvIHRoaXMgQ2FudmFzTm9kZVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIHJlZ2lzdHJ5IGtleSBvZiB0aGUgU2hhZGVyVHlwZVxyXG5cdCAqL1xyXG5cdHVzZUN1c3RvbVNoYWRlcihrZXk6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy5faGFzQ3VzdG9tU2hhZGVyID0gdHJ1ZTtcclxuXHRcdHRoaXMuX2N1c3RvbVNoYWRlcktleSA9IGtleTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgKHgsIHkpIGlzIGluc2lkZSBvZiB0aGlzIGNhbnZhcyBvYmplY3RcclxuXHQgKiBAcGFyYW0geCBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcclxuXHQgKiBAcGFyYW0geSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcclxuXHQgKiBAcmV0dXJucyBBIGZsYWcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBjb250YWlucyB0aGUgcG9pbnQuXHJcblx0ICovXHJcblx0Y29udGFpbnMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZGFyeS5jb250YWluc1BvaW50KG5ldyBWZWMyKHgsIHkpKTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGRlYnVnUmVuZGVyKCk6IHZvaWQge1xyXG5cdFx0RGVidWcuZHJhd0JveCh0aGlzLnJlbGF0aXZlUG9zaXRpb24sIHRoaXMuc2l6ZVdpdGhab29tLCBmYWxzZSwgQ29sb3IuQkxVRSk7XHJcblx0XHRzdXBlci5kZWJ1Z1JlbmRlcigpO1xyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVyXCI7XHJcbmltcG9ydCBBSSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQUlcIjtcclxuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xyXG5pbXBvcnQgUG9zaXRpb25lZCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUG9zaXRpb25lZFwiO1xyXG5pbXBvcnQgeyBpc1JlZ2lvbiB9IGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb25cIjtcclxuaW1wb3J0IFVuaXF1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVW5pcXVlXCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBEZWJ1Z1JlbmRlcmFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0RlYnVnUmVuZGVyYWJsZVwiO1xyXG5pbXBvcnQgQWN0b3IgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FjdG9yXCI7XHJcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9TaGFwZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi4vUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGhcIjtcclxuaW1wb3J0IFR3ZWVuQ29udHJvbGxlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0NpcmNsZVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW4gdGhlIGdhbWUgd29ybGQuXHJcbiAqIFRvIGNvbnN0cnVjdCBHYW1lTm9kZXMsIHNlZSB0aGUgQHJlZmVyZW5jZVtTY2VuZV0gZG9jdW1lbnRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEdhbWVOb2RlIGltcGxlbWVudHMgUG9zaXRpb25lZCwgVW5pcXVlLCBVcGRhdGVhYmxlLCBQaHlzaWNhbCwgQWN0b3IsIERlYnVnUmVuZGVyYWJsZSB7XHJcblx0LyotLS0tLS0tLS0tIFBPU0lUSU9ORUQgLS0tLS0tLS0tLSovXHJcblx0cHJpdmF0ZSBfcG9zaXRpb246IFZlYzI7XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBVTklRVUUgLS0tLS0tLS0tLSovXHJcblx0cHJpdmF0ZSBfaWQ6IG51bWJlcjtcclxuXHJcblx0LyotLS0tLS0tLS0tIFBIWVNJQ0FMIC0tLS0tLS0tLS0qL1xyXG5cdGhhc1BoeXNpY3M6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRtb3Zpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRmcm96ZW46IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRvbkdyb3VuZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdG9uV2FsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdG9uQ2VpbGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdGNvbGxpc2lvblNoYXBlOiBTaGFwZTtcclxuXHRjb2xsaWRlck9mZnNldDogVmVjMjtcclxuXHRpc1N0YXRpYzogYm9vbGVhbjtcclxuXHRpc0NvbGxpZGFibGU6IGJvb2xlYW47XHJcblx0aXNUcmlnZ2VyOiBib29sZWFuO1xyXG5cdHRyaWdnZXJNYXNrOiBudW1iZXI7XHJcblx0dHJpZ2dlckVudGVyczogQXJyYXk8c3RyaW5nPjtcclxuXHR0cmlnZ2VyRXhpdHM6IEFycmF5PHN0cmluZz47XHJcblx0X3ZlbG9jaXR5OiBWZWMyO1xyXG5cdHN3ZXB0UmVjdDogQUFCQjtcclxuXHRjb2xsaWRlZFdpdGhUaWxlbWFwOiBib29sZWFuO1xyXG5cdGdyb3VwOiBudW1iZXI7XHJcblx0aXNQbGF5ZXI6IGJvb2xlYW47XHJcblx0aXNDb2xsaWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyotLS0tLS0tLS0tIEFDVE9SIC0tLS0tLS0tLS0qL1xyXG5cdF9haTogQUk7XHJcblx0YWlBY3RpdmU6IGJvb2xlYW47XHJcblx0cGF0aDogTmF2aWdhdGlvblBhdGg7XHJcblx0cGF0aGZpbmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyotLS0tLS0tLS0tIEdFTkVSQUwgLS0tLS0tLS0tLSovXHJcblx0LyoqIEFuIGV2ZW50IHJlY2VpdmVyLiAqL1xyXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblx0LyoqIEFuIGV2ZW50IGVtaXR0ZXIuICovXHJcblx0cHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBzY2VuZSB0aGlzIEdhbWVOb2RlIGlzIGEgcGFydCBvZi4gKi9cclxuXHRwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG5cdC8qKiBUaGUgdmlzdWFsIGxheWVyIHRoaXMgR2FtZU5vZGUgcmVzaWRlcyBpbi4gKi9cclxuXHRwcm90ZWN0ZWQgbGF5ZXI6IExheWVyO1xyXG5cdC8qKiBBIHV0aWxpdHkgdGhhdCBhbGxvd3MgdGhlIHVzZSBvZiB0d2VlbnMgb24gdGhpcyBHYW1lTm9kZSAqL1xyXG5cdHR3ZWVuczogVHdlZW5Db250cm9sbGVyO1xyXG5cdC8qKiBBIHR3ZWVuYWJsZSBwcm9wZXJ0eSBmb3Igcm90YXRpb24uIERvZXMgbm90IGFmZmVjdCB0aGUgYm91bmRpbmcgYm94IG9mIHRoaXMgR2FtZU5vZGUgLSBPbmx5IHJlbmRlcmluZy4gKi9cclxuXHRyb3RhdGlvbjogbnVtYmVyO1xyXG5cdC8qKiBUaGUgb3BhY2l0eSB2YWx1ZSBvZiB0aGlzIEdhbWVOb2RlICovXHJcblx0YWJzdHJhY3Qgc2V0IGFscGhhKGE6IG51bWJlcik7XHJcblxyXG5cdGFic3RyYWN0IGdldCBhbHBoYSgpOiBudW1iZXI7XHJcblxyXG5cdC8vIENvbnN0cnVjdG9yIGRvY3MgYXJlIGlnbm9yZWQsIGFzIHRoZSB1c2VyIHNob3VsZCBOT1QgY3JlYXRlIG5ldyBHYW1lTm9kZXMgd2l0aCBhIHJhdyBjb25zdHJ1Y3RvclxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xyXG5cdFx0dGhpcy5fcG9zaXRpb24uc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cdFx0dGhpcy50d2VlbnMgPSBuZXcgVHdlZW5Db250cm9sbGVyKHRoaXMpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XHJcblx0fVxyXG5cclxuXHRkZXN0cm95KCl7XHJcblx0XHR0aGlzLnR3ZWVucy5kZXN0cm95KCk7XHJcblx0XHR0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcclxuXHJcblx0XHRpZih0aGlzLmhhc1BoeXNpY3Mpe1xyXG5cdFx0XHR0aGlzLnJlbW92ZVBoeXNpY3MoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLl9haSl7XHJcblx0XHRcdHRoaXMuX2FpLmRlc3Ryb3koKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2FpO1xyXG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlbW92ZUFjdG9yKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTm9kZSh0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBQT1NJVElPTkVEIC0tLS0tLS0tLS0qL1xyXG5cdGdldCBwb3NpdGlvbigpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3NpdGlvbjtcclxuXHR9XHJcblxyXG5cdHNldCBwb3NpdGlvbihwb3M6IFZlYzIpIHtcclxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gcG9zO1xyXG5cdFx0dGhpcy5fcG9zaXRpb24uc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBhIHBvaW50IHRvIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB6b29tIGFuZCBvcmlnaW4gb2YgdGhpcyBub2RlXHJcblx0ICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjb252ZXJcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcclxuXHQgKi9cclxuXHRpblJlbGF0aXZlQ29vcmRpbmF0ZXMocG9pbnQ6IFZlYzIpOiBWZWMyIHtcclxuXHRcdGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aGlzKTtcclxuXHRcdGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuXHRcdHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihvcmlnaW4pLnNjYWxlKHpvb20pO1xyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cclxuXHRnZXQgaWQoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9pZDtcclxuXHR9XHJcblxyXG5cdHNldCBpZChpZDogbnVtYmVyKSB7XHJcblx0XHQvLyBpZCBjYW4gb25seSBiZSBzZXQgb25jZVxyXG5cdFx0aWYodGhpcy5faWQgPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdHRoaXMuX2lkID0gaWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBcIkF0dGVtcHRlZCB0byBhc3NpZ24gaWQgdG8gb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgaWQuXCJcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBQSFlTSUNBTCAtLS0tLS0tLS0tKi9cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgdmVsb2NpdHkgd2l0aCB3aGljaCB0byBtb3ZlIHRoZSBvYmplY3QuXHJcbiAgICAgKi9cclxuXHRtb3ZlKHZlbG9jaXR5OiBWZWMyKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLmZyb3plbikgcmV0dXJuO1xyXG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcclxuXHR9O1xyXG5cclxuXHRtb3ZlT25QYXRoKHNwZWVkOiBudW1iZXIsIHBhdGg6IE5hdmlnYXRpb25QYXRoKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLmZyb3plbikgcmV0dXJuO1xyXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHRcdGxldCBkaXIgPSBwYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcyk7XHJcblx0XHR0aGlzLm1vdmluZyA9IHRydWU7XHJcblx0XHR0aGlzLnBhdGhmaW5kaW5nID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gZGlyLnNjYWxlKHNwZWVkKTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdGhlIG9iamVjdCB3aWxsIG1vdmUuXHJcbiAgICAgKi9cclxuXHRmaW5pc2hNb3ZlKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMucG9zaXRpb24uYWRkKHRoaXMuX3ZlbG9jaXR5KTtcclxuXHRcdGlmKHRoaXMucGF0aGZpbmRpbmcpe1xyXG5cdFx0XHR0aGlzLnBhdGguaGFuZGxlUGF0aFByb2dyZXNzKHRoaXMpO1xyXG5cdFx0XHR0aGlzLnBhdGggPSBudWxsO1xyXG5cdFx0XHR0aGlzLnBhdGhmaW5kaW5nID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuXHQgKiBAcGFyYW0gY29sbGlzaW9uU2hhcGUgVGhlIGNvbGxpZGVyIGZvciB0aGlzIG9iamVjdC4gSWYgdGhpcyBoYXMgYSByZWdpb24gKGltcGxlbWVudHMgUmVnaW9uKSxcclxuXHQgKiBpdCB3aWxsIGJlIHVzZWQgd2hlbiBubyBjb2xsaXNpb24gc2hhcGUgaXMgc3BlY2lmaWVkIChvciBpZiBjb2xsaXNpb24gc2hhcGUgaXMgbnVsbCkuXHJcblx0ICogQHBhcmFtIGlzQ29sbGlkYWJsZSBXaGV0aGVyIHRoaXMgaXMgY29sbGlkYWJsZSBvciBub3QuIFRydWUgYnkgZGVmYXVsdC5cclxuXHQgKiBAcGFyYW0gaXNTdGF0aWMgV2hldGhlciB0aGlzIGlzIHN0YXRpYyBvciBub3QuIEZhbHNlIGJ5IGRlZmF1bHRcclxuXHQgKi9cclxuXHRhZGRQaHlzaWNzKGNvbGxpc2lvblNoYXBlPzogU2hhcGUsIGNvbGxpZGVyT2Zmc2V0PzogVmVjMiwgaXNDb2xsaWRhYmxlOiBib29sZWFuID0gdHJ1ZSwgaXNTdGF0aWM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgcGh5c2ljcyB2YXJpYWJsZXNcclxuXHRcdHRoaXMuaGFzUGh5c2ljcyA9IHRydWU7XHJcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbldhbGwgPSBmYWxzZTtcclxuXHRcdHRoaXMub25DZWlsaW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0XHR0aGlzLmlzQ29sbGlkYWJsZSA9IGlzQ29sbGlkYWJsZTtcclxuXHRcdHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcclxuXHRcdHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XHJcblx0XHR0aGlzLnRyaWdnZXJNYXNrID0gMDtcclxuXHRcdHRoaXMudHJpZ2dlckVudGVycyA9IG5ldyBBcnJheSgzMik7XHJcblx0XHR0aGlzLnRyaWdnZXJFeGl0cyA9IG5ldyBBcnJheSgzMik7XHJcblx0XHR0aGlzLl92ZWxvY2l0eSA9IFZlYzIuWkVSTztcclxuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbmV3IEFBQkIoKTtcclxuXHRcdHRoaXMuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5ncm91cCA9IC0xO1x0XHRcdFx0XHQvLyBUaGUgZGVmYXVsdCBncm91cCwgY29sbGlkZXMgd2l0aCBldmVyeXRoaW5nXHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBjb2xsaXNpb24gc2hhcGUgaWYgcHJvdmlkZWQsIG9yIHNpbXBseSB1c2UgdGhlIHRoZSByZWdpb24gaWYgdGhlcmUgaXMgb25lLlxyXG5cdFx0aWYoY29sbGlzaW9uU2hhcGUpe1xyXG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlzaW9uU2hhcGU7XHJcblx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbjtcclxuXHRcdH0gZWxzZSBpZiAoaXNSZWdpb24odGhpcykpIHtcclxuXHRcdFx0Ly8gSWYgdGhlIGdhbWVub2RlIGhhcyBhIHJlZ2lvbiBhbmQgbm8gb3RoZXIgaXMgc3BlY2lmaWVkLCB1c2UgdGhhdFxyXG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gKDxhbnk+dGhpcykuYm91bmRhcnkuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRocm93IFwiTm8gY29sbGlzaW9uIHNoYXBlIHNwZWNpZmllZCBmb3IgcGh5c2ljcyBvYmplY3QuXCJcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB3ZSB3ZXJlIHByb3ZpZGVkIHdpdGggYSBjb2xsaWRlciBvZmZzZXQsIHNldCBpdC4gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIG9mZnNldCwgc28gdXNlIHRoZSB6ZXJvIHZlY3RvclxyXG5cdFx0aWYoY29sbGlkZXJPZmZzZXQpe1xyXG5cdFx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gY29sbGlkZXJPZmZzZXQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gVmVjMi5aRVJPO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN3ZXB0IHJlY3RcclxuXHRcdHRoaXMuc3dlcHRSZWN0ID0gdGhpcy5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHJcblx0XHQvLyBSZWdpc3RlciB0aGUgb2JqZWN0IHdpdGggcGh5c2ljc1xyXG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLnJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlbW92ZXMgdGhpcyBvYmplY3QgZnJvbSB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cclxuICAgIHJlbW92ZVBoeXNpY3MoKTogdm9pZCB7XHJcblx0XHQvLyBSZW1vdmUgdGhpcyBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJcclxuXHRcdHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5kZXJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xyXG5cclxuXHRcdC8vIE51bGxpZnkgYWxsIHBoeXNpY3MgZmllbGRzXHJcblx0XHR0aGlzLmhhc1BoeXNpY3MgPSBmYWxzZTtcclxuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLm9uR3JvdW5kID0gZmFsc2U7XHJcblx0XHR0aGlzLm9uV2FsbCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbkNlaWxpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHR0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcclxuXHRcdHRoaXMudHJpZ2dlck1hc2sgPSAwO1xyXG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzID0gbnVsbDtcclxuXHRcdHRoaXMudHJpZ2dlckV4aXRzID0gbnVsbDtcclxuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gVmVjMi5aRVJPO1xyXG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBudWxsO1xyXG5cdFx0dGhpcy5jb2xsaWRlZFdpdGhUaWxlbWFwID0gZmFsc2U7XHJcblx0XHR0aGlzLmdyb3VwID0gLTE7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gbnVsbDtcclxuXHRcdHRoaXMuY29sbGlkZXJPZmZzZXQgPSBWZWMyLlpFUk87XHJcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKiogRGlzYWJsZXMgcGh5c2ljcyBtb3ZlbWVudCBmb3IgdGhpcyBub2RlICovXHJcblx0ZnJlZXplKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5mcm96ZW4gPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlZW5hYmxlcyBwaHlzaWNzIG1vdmVtZW50IGZvciB0aGlzIG5vZGUgKi9cclxuXHR1bmZyZWV6ZSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuZnJvemVuID0gZmFsc2U7XHJcblx0fVxyXG5cclxuICAgIC8qKiBQcmV2ZW50cyB0aGlzIG9iamVjdCBmcm9tIHBhcnRpY2lwYXRpbmcgaW4gYWxsIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBJdCBjYW4gc3RpbGwgbW92ZS4gKi9cclxuICAgIGRpc2FibGVQaHlzaWNzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHR9XHJcblxyXG4gICAgLyoqIEVuYWJsZXMgdGhpcyBvYmplY3QgdG8gcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucyBhbmQgdHJpZ2dlcnMuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgZGlzYWJsZVBoeXNpY3Mgd2FzIGNhbGxlZCAqL1xyXG4gICAgZW5hYmxlUGh5c2ljcygpOiB2b2lkIHtcclxuXHRcdHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGNvbGxpZGVyIGZvciB0aGlzIEdhbWVOb2RlXHJcblx0ICogQHBhcmFtIGNvbGxpZGVyIFRoZSBuZXcgY29sbGlkZXIgdG8gdXNlXHJcblx0ICovXHJcblx0c2V0Q29sbGlzaW9uU2hhcGUoY29sbGlkZXI6IFNoYXBlKTogdm9pZCB7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlkZXI7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlci5jb3B5KHRoaXMucG9zaXRpb24pO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0LyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgb2JqZWN0IHRvIGJlIGEgdHJpZ2dlciBmb3IgYSBzcGVjaWZpYyBncm91cFxyXG4gICAgICogQHBhcmFtIGdyb3VwIFRoZSBuYW1lIG9mIHRoZSBncm91cCB0aGF0IGFjdGl2YXRlcyB0aGUgdHJpZ2dlclxyXG4gICAgICogQHBhcmFtIG9uRW50ZXIgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIHRyaWdnZXIgaXMgYWN0aXZhdGVkXHJcbiAgICAgKiBAcGFyYW0gb25FeGl0IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIHdoZW4gdGhpcyB0cmlnZ2VyIHN0b3BzIGJlaW5nIGFjdGl2YXRlZFxyXG4gICAgICovXHJcbiAgICBzZXRUcmlnZ2VyKGdyb3VwOiBzdHJpbmcsIG9uRW50ZXI6IHN0cmluZywgb25FeGl0OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdC8vIE1ha2UgdGhpcyBvYmplY3QgYSB0cmlnZ2VyXHJcblx0XHR0aGlzLmlzVHJpZ2dlciA9IHRydWU7XHJcblxyXG5cdFx0Ly8gR2V0IHRoZSBudW1iZXIgb2YgdGhlIHBoeXNpY3MgbGF5ZXJcclxuXHRcdGxldCBsYXllck51bWJlciA9IHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5nZXRHcm91cE51bWJlcihncm91cCk7XHJcblxyXG5cdFx0aWYobGF5ZXJOdW1iZXIgPT09IDApe1xyXG5cdFx0XHRjb25zb2xlLndhcm4oYFRyaWdnZXIgZm9yIEdhbWVOb2RlICR7dGhpcy5pZH0gbm90IHNldCAtIGdyb3VwIFwiJHtncm91cH1cIiB3YXMgbm90IHJlY29nbml6ZWQgYnkgdGhlIHBoeXNpY3MgbWFuYWdlci5gKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCB0aGlzIHRvIHRoZSB0cmlnZ2VyIG1hc2tcclxuXHRcdHRoaXMudHJpZ2dlck1hc2sgfD0gbGF5ZXJOdW1iZXI7XHJcblxyXG5cdFx0Ly8gTGF5ZXIgbnVtYmVycyBhcmUgYml0cywgc28gZ2V0IHdoaWNoIGJpdCBpdCBpc1xyXG5cdFx0bGV0IGluZGV4ID0gTWF0aC5sb2cyKGxheWVyTnVtYmVyKTtcclxuXHJcblx0XHQvLyBTZXQgdGhlIGV2ZW50IG5hbWVzXHJcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnNbaW5kZXhdID0gb25FbnRlcjtcclxuXHRcdHRoaXMudHJpZ2dlckV4aXRzW2luZGV4XSA9IG9uRXhpdDtcclxuXHR9O1xyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIHBoeXNpY3MgZ3JvdXAgdGhpcyBub2RlIHNob3VsZCBiZWxvbmcgdG9cclxuXHQgKi9cclxuXHRzZXRHcm91cChncm91cDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuc2V0R3JvdXAodGhpcywgZ3JvdXApO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVuZWRcclxuXHRnZXRMYXN0VmVsb2NpdHkoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdmVsb2NpdHk7XHJcblx0fVxyXG5cclxuXHQvKi0tLS0tLS0tLS0gQUNUT1IgLS0tLS0tLS0tLSovXHJcblx0Z2V0IGFpKCk6IEFJIHtcclxuXHRcdHJldHVybiB0aGlzLl9haTtcclxuXHR9XHJcblxyXG5cdHNldCBhaShhaTogQUkpIHtcclxuXHRcdGlmKCF0aGlzLl9haSl7XHJcblx0XHRcdC8vIElmIHdlIGhhdmVuJ3QgYmVlbiBwcmV2aW91c2x5IGhhZCBhbiBhaSwgcmVnaXN0ZXIgdXMgd2l0aCB0aGUgYWkgbWFuYWdlclxyXG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlZ2lzdGVyQWN0b3IodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWkgPSBhaTtcclxuXHRcdHRoaXMuYWlBY3RpdmUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0YWRkQUk8VCBleHRlbmRzIEFJPihhaTogc3RyaW5nIHwgKG5ldyAoKSA9PiBUKSwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuXHRcdGlmKCF0aGlzLl9haSl7XHJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVnaXN0ZXJBY3Rvcih0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0eXBlb2YgYWkgPT09IFwic3RyaW5nXCIpe1xyXG5cdFx0XHR0aGlzLl9haSA9IHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkuZ2VuZXJhdGVBSShhaSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9haSA9IG5ldyBhaSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FpLmluaXRpYWxpemVBSSh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLmFpQWN0aXZlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdHNldEFJQWN0aXZlKGFjdGl2ZTogYm9vbGVhbiwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG5cdFx0dGhpcy5haUFjdGl2ZSA9IGFjdGl2ZTtcclxuXHRcdGlmKHRoaXMuYWlBY3RpdmUpe1xyXG5cdFx0XHR0aGlzLmFpLmFjdGl2YXRlKG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tIFRXRUVOQUJMRSBQUk9QRVJUSUVTIC0tLS0tLS0tLS0qL1xyXG5cdHNldCBwb3NpdGlvblgodmFsdWU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5wb3NpdGlvbi54ID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRzZXQgcG9zaXRpb25ZKHZhbHVlOiBudW1iZXIpIHtcclxuXHRcdHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0YWJzdHJhY3Qgc2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKTtcclxuXHJcblx0YWJzdHJhY3Qgc2V0IHNjYWxlWSh2YWx1ZTogbnVtYmVyKTtcclxuXHJcblx0LyotLS0tLS0tLS0tIEdBTUUgTk9ERSAtLS0tLS0tLS0tKi9cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBzY2VuZSBmb3IgdGhpcyBvYmplY3QuXHJcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvLlxyXG5cdCAqL1xyXG5cdHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgc2NlbmUgdGhpcyBvYmplY3QgaXMgaW4uIFxyXG5cdCAqIEByZXR1cm5zIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvXHJcblx0Ki9cclxuXHRnZXRTY2VuZSgpOiBTY2VuZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zY2VuZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGxheWVyIG9mIHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIgdGhpcyBvYmplY3Qgd2lsbCBiZSBvbi5cclxuXHQgKi9cclxuXHRzZXRMYXllcihsYXllcjogTGF5ZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbGF5ZXIgdGhpcyBvYmplY3QgaXMgb24uXHJcblx0Ki9cclxuXHRnZXRMYXllcigpOiBMYXllciB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllcjtcclxuXHR9XHJcblxyXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHBvc2l0aW9uIHZlY3RvciBpcyBtb2RpZmllZCBvciByZXBsYWNlZCAqL1xyXG5cdHByb3RlY3RlZCBwb3NpdGlvbkNoYW5nZWQoKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcclxuXHRcdFx0aWYodGhpcy5jb2xsaWRlck9mZnNldCl7XHJcblx0XHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIgPSB0aGlzLnBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMuY29sbGlkZXJPZmZzZXQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBHYW1lTm9kZVxyXG5cdCAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWVzdGVwIG9mIHRoZSB1cGRhdGUuXHJcblx0ICovXHJcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBEZWZlciBldmVudCBoYW5kbGluZyB0byBBSS5cclxuXHRcdHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG5cdFx0XHR0aGlzLl9haS5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGRlYnVnUmVuZGVyKCk6IHZvaWQge1xyXG5cdFx0Ly8gRHJhdyB0aGUgcG9zaXRpb24gb2YgdGhpcyBHYW1lTm9kZVxyXG5cdFx0RGVidWcuZHJhd1BvaW50KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgQ29sb3IuQkxVRSk7XHJcblxyXG5cdFx0Ly8gSWYgdmVsb2NpdHkgaXMgbm90IHplcm8sIGRyYXcgYSB2ZWN0b3IgZm9yIGl0XHJcblx0XHRpZih0aGlzLl92ZWxvY2l0eSAmJiAhdGhpcy5fdmVsb2NpdHkuaXNaZXJvKCkpe1xyXG5cdFx0XHREZWJ1Zy5kcmF3UmF5KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgdGhpcy5fdmVsb2NpdHkuY2xvbmUoKS5zY2FsZVRvKDIwKS5hZGQodGhpcy5yZWxhdGl2ZVBvc2l0aW9uKSwgQ29sb3IuQkxVRSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgdGhpcyBoYXMgYSBjb2xsaWRlciwgZHJhdyBpdFxyXG5cdFx0aWYodGhpcy5jb2xsaXNpb25TaGFwZSl7XHJcblx0XHRcdGxldCBjb2xvciA9IHRoaXMuaXNDb2xsaWRpbmcgPyBDb2xvci5SRUQgOiBDb2xvci5HUkVFTjtcclxuXHJcblx0XHRcdGlmKHRoaXMuaXNUcmlnZ2VyKXtcclxuXHRcdFx0XHRjb2xvciA9IENvbG9yLk1BR0VOVEE7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGNvbG9yLmEgPSAwLjI7XHJcblxyXG5cdFx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlIGluc3RhbmNlb2YgQUFCQil7XHJcblx0XHRcdFx0RGVidWcuZHJhd0JveCh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyh0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciksIHRoaXMuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUuc2NhbGVkKHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCkpLCB0cnVlLCBjb2xvcik7XHJcblx0XHRcdH0gZWxzZSBpZih0aGlzLmNvbGxpc2lvblNoYXBlIGluc3RhbmNlb2YgQ2lyY2xlKXtcclxuXHRcdFx0XHREZWJ1Zy5kcmF3Q2lyY2xlKHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyKSwgdGhpcy5jb2xsaXNpb25TaGFwZS5odyp0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpLCB0cnVlLCBjb2xvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIFR3ZWVuYWJsZVByb3BlcnRpZXN7XHJcblx0cG9zWCA9IFwicG9zaXRpb25YXCIsXHJcblx0cG9zWSA9IFwicG9zaXRpb25ZXCIsXHJcblx0c2NhbGVYID0gXCJzY2FsZVhcIixcclxuXHRzY2FsZVkgPSBcInNjYWxlWVwiLFxyXG5cdHJvdGF0aW9uID0gXCJyb3RhdGlvblwiLFxyXG5cdGFscGhhID0gXCJhbHBoYVwiXHJcbn0iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBnYW1lIG9iamVjdCB0aGF0IGRvZXNuJ3QgcmVseSBvbiBhbnkgcmVzb3VyY2VzIHRvIHJlbmRlciAtIGl0IGlzIGRyYXduIHRvIHRoZSBzY3JlZW4gYnkgdGhlIGNhbnZhc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR3JhcGhpYyBleHRlbmRzIENhbnZhc05vZGUge1xyXG4gICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgR3JhcGhpYyAqL1xyXG4gICAgY29sb3I6IENvbG9yO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuUkVEO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBhbHBoYSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29sb3IuYTtcclxuXHR9XHJcblxyXG5cdHNldCBhbHBoYShhOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuY29sb3IuYSA9IGE7XHJcblx0fVxyXG5cclxuICAgIC8vIEBkZXByZWNhdGVkXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoZSBHcmFwaGljLiBERVBSRUNBVEVEXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgVGhlIG5ldyBjb2xvciBvZiB0aGUgR3JhcGhpYy5cclxuICAgICAqL1xyXG4gICAgc2V0Q29sb3IoY29sb3I6IENvbG9yKXtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZW51bSBHcmFwaGljVHlwZSB7XHJcblx0UE9JTlQgPSBcIlBPSU5UXCIsXHJcblx0UkVDVCA9IFwiUkVDVFwiLFxyXG5cdExJTkUgPSBcIkxJTkVcIixcclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZSBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgcHJvdGVjdGVkIF9lbmQ6IFZlYzI7XHJcbiAgICB0aGlja25lc3M6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydDogVmVjMiwgZW5kOiBWZWMyKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IDI7XHJcblxyXG4gICAgICAgIC8vIERvZXMgdGhpcyByZWFsbHkgaGF2ZSBhIG1lYW5pbmcgZm9yIGxpbmVzP1xyXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoNSwgNSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHN0YXJ0KHBvczogVmVjMil7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvcztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc3RhcnQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGVuZChwb3M6IFZlYzIpe1xyXG4gICAgICAgIHRoaXMuX2VuZCA9IHBvcztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZW5kKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbmQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKiBBIGJhc2ljIHBvaW50IHRvIGJlIGRyYXduIG9uIHRoZSBzY3JlZW4uICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50IGV4dGVuZHMgR3JhcGhpYyB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoNSwgNSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xyXG5cclxuLyoqIEEgYmFzaWMgcmVjdGFuZ2xlIHRvIGJlIGRyYXduIG9uIHRoZSBzY3JlZW4uICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3QgZXh0ZW5kcyBHcmFwaGljIHtcclxuXHJcbiAgICAvKiogVGhlIGJvcmRlciBjb2xvciBvZiB0aGUgUmVjdCAqL1xyXG4gICAgYm9yZGVyQ29sb3I6IENvbG9yO1xyXG5cclxuICAgIC8qKiBUaGUgd2lkdGggb2YgdGhlIGJvcmRlciAqL1xyXG4gICAgYm9yZGVyV2lkdGg6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgc2l6ZTogVmVjMil7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBib3JkZXIgY29sb3Igb2YgdGhpcyByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgYm9yZGVyIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHNldEJvcmRlckNvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBjb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgZ2V0Qm9yZGVyQ29sb3IoKTogQ29sb3Ige1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvcmRlckNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIHdpZHRoIG9mIHRoaXMgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIHNldEJvcmRlcldpZHRoKHdpZHRoOiBudW1iZXIpe1xyXG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSB3aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRCb3JkZXJXaWR0aCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvcmRlcldpZHRoO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi9TcHJpdGVcIjtcclxuaW1wb3J0IEFuaW1hdGlvbk1hbmFnZXIgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvbk1hbmFnZXJcIjtcclxuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG4vKiogQW4gc3ByaXRlIHdpdGggc3BlY2lmaWVkIGFuaW1hdGlvbiBmcmFtZXMuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhpcyBzcHJpdGUgc2hlZXQgKi9cclxuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XHJcblxyXG4gICAgZ2V0IGNvbHMoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1Db2xzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhpcyBzcHJpdGUgc2hlZXQgKi9cclxuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XHJcblxyXG4gICAgZ2V0IHJvd3MoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1Sb3dzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgYW5pbWF0aW9uTWFuYWdlciBmb3IgdGhpcyBzcHJpdGUgKi9cclxuICAgIGFuaW1hdGlvbjogQW5pbWF0aW9uTWFuYWdlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGVzaGVldDogU3ByaXRlc2hlZXQpe1xyXG4gICAgICAgIHN1cGVyKHNwcml0ZXNoZWV0Lm5hbWUpO1xyXG4gICAgICAgIHRoaXMubnVtQ29scyA9IHNwcml0ZXNoZWV0LmNvbHVtbnM7XHJcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gc3ByaXRlc2hlZXQucm93cztcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSBzcHJpdGUgdG8gdGhlIHNwcml0ZSBzaXplIHNwZWNpZmllZCBieSB0aGUgc3ByaXRlc2hlZXRcclxuICAgICAgICB0aGlzLnNpemUuc2V0KHNwcml0ZXNoZWV0LnNwcml0ZVdpZHRoLCBzcHJpdGVzaGVldC5zcHJpdGVIZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb25NYW5hZ2VyKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIGFuaW1hdGlvbnMgdG8gdGhlIGFuaW1hdGVkIHNwcml0ZVxyXG4gICAgICAgIGZvcihsZXQgYW5pbWF0aW9uIG9mIHNwcml0ZXNoZWV0LmFuaW1hdGlvbnMpe1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoYW5pbWF0aW9uLm5hbWUsIGFuaW1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaW1hZ2Ugb2Zmc2V0IGZvciB0aGUgY3VycmVudCBpbmRleCBvZiBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2UncmUgYXQgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIGltYWdlIG9mZnNldFxyXG4gICAgICovXHJcbiAgICBnZXRBbmltYXRpb25PZmZzZXQoaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMigoaW5kZXggJSB0aGlzLm51bUNvbHMpICogdGhpcy5zaXplLngsIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpICogdGhpcy5zaXplLnkpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBzcHJpdGUgLSBhbiBpbi1nYW1lIGltYWdlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGUgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuICAgIC8qKiBUaGUgaWQgb2YgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlTWFuYWdlciAqL1xyXG4gICAgaW1hZ2VJZDogc3RyaW5nO1xyXG4gICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBpbiBhbiBhdGxhcyBpbWFnZSAqL1xyXG4gICAgaW1hZ2VPZmZzZXQ6IFZlYzI7XHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHgtYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXHJcbiAgICBpbnZlcnRYOiBib29sZWFuO1xyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB5LWF4aXMgc2hvdWxkIGJlIGludmVydGVkIG9uIHJlbmRlciAqL1xyXG4gICAgaW52ZXJ0WTogYm9vbGVhbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZUlkOiBzdHJpbmcpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbWFnZUlkID0gaW1hZ2VJZDtcclxuICAgICAgICBsZXQgaW1hZ2UgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRJbWFnZSh0aGlzLmltYWdlSWQpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBWZWMyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5pbnZlcnRYID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnZlcnRZID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBmcm9tICgwLCAwKSBpbiB0aGUgaW1hZ2UncyBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgZnJvbSAoMCwgMCkgaW4gaW1hZ2UgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgc2V0SW1hZ2VPZmZzZXQob2Zmc2V0OiBWZWMyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5pbWFnZU9mZnNldCA9IG9mZnNldDtcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgVGlsZXNldCBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVzZXRcIjtcclxuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiXHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IFBoeXNpY3NNYW5hZ2VyIGZyb20gXCIuLi9QaHlzaWNzL1BoeXNpY3NNYW5hZ2VyXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgdGlsZW1hcCAtIHRoaXMgY2FuIGNvbnNpc3Qgb2YgYSBjb21iaW5hdGlvbiBvZiB0aWxlc2V0cyBpbiBvbmUgbGF5ZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFRpbGVtYXAgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgdGhhdCB0aGlzIHRpbGVtYXAgdXNlcyAqL1xyXG4gICAgcHJvdGVjdGVkIHRpbGVzZXRzOiBBcnJheTxUaWxlc2V0PjtcclxuXHJcbiAgICAvKiogVGhlIHNpemUgb2YgYSB0aWxlIGluIHRoaXMgdGlsZW1hcCAqL1xyXG4gICAgcHJvdGVjdGVkIHRpbGVTaXplOiBWZWMyO1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aWxlIGRhdGEgKi9cclxuICAgIHByb3RlY3RlZCBkYXRhOiBBcnJheTxudW1iZXI+O1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aWxlIGNvbGxpc2lvbiBkYXRhICovXHJcbiAgICBwcm90ZWN0ZWQgY29sbGlzaW9uTWFwOiBBcnJheTxib29sZWFuPjtcclxuXHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIHRpbGVtYXAgKi9cclxuICAgIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgbm8gbG9uZ2VyIGJlIHNwZWNpZmljIHRvIFRpbGVkXHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhLCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD4sIHNjYWxlOiBWZWMyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRpbGVzZXRzID0gdGlsZXNldHM7XHJcbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGxheWVyLm5hbWU7XHJcblxyXG4gICAgICAgIGxldCB0aWxlY291bnQgPSAwO1xyXG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlc2V0cyl7XHJcbiAgICAgICAgICAgIHRpbGVjb3VudCArPSB0aWxlc2V0LmdldFRpbGVDb3VudCgpICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uTWFwID0gbmV3IEFycmF5KHRpbGVjb3VudCk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY29sbGlzaW9uTWFwLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmVyIHBhcnNpbmcgb2YgdGhlIGRhdGEgdG8gY2hpbGQgY2xhc3NlcyAtIHRoaXMgYWxsb3dzIGZvciBpc29tZXRyaWMgdnMuIG9ydGhvZ3JhcGhpYyB0aWxlbWFwcyBhbmQgaGFuZGxpbmcgb2YgVGlsZWQgZGF0YSBvciBvdGhlciBkYXRhXHJcbiAgICAgICAgdGhpcy5wYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhLCBsYXllcik7XHJcbiAgICAgICAgdGhpcy5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSB0aWxlc2V0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyB0aWxlbWFwXHJcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgb2YgdGhlIHRpbGVzZXRzIGFzc29jYWl0ZWQgd2l0aCB0aGlzIHRpbGVtYXAuXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVzZXRzKCk6IFRpbGVzZXRbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZXNldHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nXHJcbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciBjb250YWluaW5nIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZS5zY2FsZWQodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdGlsZSBzaXplIHRha2luZyB6b29tIGludG8gYWNjb3VudFxyXG4gICAgICogQHJldHVybnMgVGhlIHRpbGUgc2l6ZSB3aXRoIHpvb21cclxuICAgICovXHJcbiAgICBnZXRUaWxlU2l6ZVdpdGhab29tKCk6IFZlYzIge1xyXG4gICAgICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVNpemUoKS5zY2FsZSh6b29tKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhpcyB0aWxlbWFwIHRvIHRoZSBwaHlzaWNzIHN5c3RlbVxyXG4gICAgKi9cclxuICAgIGFkZFBoeXNpY3MoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5yZWdpc3RlclRpbGVtYXAodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIHBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcmV0dXJucyBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCB3b3JsZCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0VGlsZUF0V29ybGRQb3NpdGlvbih3b3JsZENvb3JkczogVmVjMik6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFRpbGVXb3JsZFBvc2l0aW9uKGluZGV4OiBudW1iZXIpOiBWZWMyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0VGlsZShpbmRleDogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgbmV3IGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc2V0VGlsZShpbmRleDogbnVtYmVyLCB0eXBlOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IHVzZSB0aWxlZCBkYXRhIHNwZWNpZmljYWxseSAtIGl0IHNob3VsZCBiZSBtb3JlIGdlbmVyYWxcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCB0aGUgdGlsZXNldCB1c2luZyB0aGUgZGF0YSBsb2FkZWQgZnJvbSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcERhdGEgVGhlIHRpbGVtYXAgZGF0YSBmcm9tIGZpbGVcclxuICAgICAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIgZGF0YSBmcm9tIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQ7XHJcbn0iLCJpbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vVGlsZW1hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb3J0aG9nb25hbCB0aWxlbWFwIC0gaS5lLiBhIHRvcCBkb3duIG9yIHBsYXRmb3JtZXIgdGlsZW1hcFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3J0aG9nb25hbFRpbGVtYXAgZXh0ZW5kcyBUaWxlbWFwIHtcclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbGVtYXAgKi9cclxuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSB0aWxlbWFwICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcHJvdGVjdGVkIHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQge1xyXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSB0aWxlbWFwIGluIGxvY2FsIHNwYWNlXHJcbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGlsZW1hcERhdGEud2lkdGg7XHJcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZW1hcERhdGEuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aWxlc1xyXG4gICAgICAgIHRoaXMudGlsZVNpemUuc2V0KHRpbGVtYXBEYXRhLnRpbGV3aWR0aCwgdGlsZW1hcERhdGEudGlsZWhlaWdodCk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSB0aWxlbWFwIG9uIHRoZSBjYW52YXNcclxuICAgICAgICB0aGlzLnNpemUuc2V0KHRoaXMubnVtQ29scyAqIHRoaXMudGlsZVNpemUueCwgdGhpcy5udW1Sb3dzICogdGhpcy50aWxlU2l6ZS55KTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBsYXllci5kYXRhO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGxheWVyLnZpc2libGU7XHJcblxyXG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIHRpbGVtYXAgaXMgY29sbGlkYWJsZSBvciBub3RcclxuICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGl0ZW0gb2YgbGF5ZXIucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGl0ZW0udmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhbGwgdGlsZXMgYmVzaWRlcyBcImVtcHR5OiAwXCIgdG8gYmUgY29sbGlkYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCB0aGlzLmNvbGxpc2lvbk1hcC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWFwW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYW5kIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZW1hcC5cclxuICAgICAqL1xyXG4gICAgZ2V0RGltZW5zaW9ucygpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5udW1Db2xzLCB0aGlzLm51bVJvd3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHdvcmxkIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIGNvb3JkaW5hdGVzIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlQXRXb3JsZFBvc2l0aW9uKHdvcmxkQ29vcmRzOiBWZWMyKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgbG9jYWxDb29yZHMgPSB0aGlzLmdldENvbFJvd0F0KHdvcmxkQ29vcmRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlQXRSb3dDb2wobG9jYWxDb29yZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW5cclxuICAgICAqIEBwYXJhbSByb3dDb2wgVGhlIGNvb3JkaW5hdGVzIGluIHRpbGVtYXAgc3BhY2VcclxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVBdFJvd0NvbChyb3dDb2w6IFZlYzIpOiBudW1iZXIge1xyXG4gICAgICAgIGlmKHJvd0NvbC54IDwgMCB8fCByb3dDb2wueCA+PSB0aGlzLm51bUNvbHMgfHwgcm93Q29sLnkgPCAwIHx8IHJvd0NvbC55ID49IHRoaXMubnVtUm93cyl7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbcm93Q29sLnkgKiB0aGlzLm51bUNvbHMgKyByb3dDb2wueF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZVdvcmxkUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIC8vIEdldCB0aGUgbG9jYWwgcG9zaXRpb25cclxuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIHBvc2l0aW9uXHJcbiAgICAgICAgbGV0IHggPSBjb2wgKiB0aGlzLnRpbGVTaXplLng7XHJcbiAgICAgICAgbGV0IHkgPSByb3cgKiB0aGlzLnRpbGVTaXplLnk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZShpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHNldFRpbGUoaW5kZXg6IG51bWJlciwgdHlwZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kYXRhW2luZGV4XSA9IHR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW5cclxuICAgICAqIEBwYXJhbSByb3dDb2wgVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWxlIGluIHRpbGVtYXAgc3BhY2VcclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSBuZXcgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxyXG4gICAgICovXHJcbiAgICBzZXRUaWxlQXRSb3dDb2wocm93Q29sOiBWZWMyLCB0eXBlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaW5kZXggPSByb3dDb2wueSAqIHRoaXMubnVtQ29scyArIHJvd0NvbC54O1xyXG4gICAgICAgIHRoaXMuc2V0VGlsZShpbmRleCwgdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtbiBvZiB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhPckNvbCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgb3IgdGhlIGNvbHVtbiBpdCBpcyBpblxyXG4gICAgICogQHBhcmFtIHJvdyBUaGUgcm93IHRoZSB0aWxlIGlzIGluXHJcbiAgICAgKiBAcmV0dXJucyBBIGZsYWcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSB0aWxlIGlzIGNvbGxpZGFibGUuXHJcbiAgICAgKi9cclxuICAgIGlzVGlsZUNvbGxpZGFibGUoaW5kZXhPckNvbDogbnVtYmVyLCByb3c/OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICAvLyBUaGUgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAgICBsZXQgdGlsZSA9IDA7XHJcblxyXG4gICAgICAgIGlmKHJvdyl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBjb2x1bW4gYW5kIGEgcm93XHJcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGVBdFJvd0NvbChuZXcgVmVjMihpbmRleE9yQ29sLCByb3cpKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHRpbGUgPCAwKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKGluZGV4T3JDb2wgPCAwIHx8IGluZGV4T3JDb2wgPj0gdGhpcy5kYXRhLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAvLyBUaWxlcyB0aGF0IGRvbid0IGV4aXN0IGFyZW4ndCBjb2xsaWRhYmxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBpbmRleFxyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy5nZXRUaWxlKGluZGV4T3JDb2wpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uTWFwW3RpbGVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgaW4gd29ybGQgY29vcmRpbmF0ZXMgYW5kIHJldHVybnMgdGhlIHJvdyBhbmQgY29sdW1uIG9mIHRoZSB0aWxlIGF0IHRoYXQgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB3b3JsZENvb3JkcyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvdGVudGlhbCB0aWxlIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvdGVudGlhbCB0aWxlIGluIHRpbGVtYXAgc3BhY2VcclxuICAgICAqL1xyXG4gICAgZ2V0Q29sUm93QXQod29ybGRDb29yZHM6IFZlYzIpOiBWZWMyIHtcclxuICAgICAgICBsZXQgY29sID0gTWF0aC5mbG9vcih3b3JsZENvb3Jkcy54IC8gdGhpcy50aWxlU2l6ZS54IC8gdGhpcy5zY2FsZS54KTtcclxuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcih3b3JsZENvb3Jkcy55IC8gdGhpcy50aWxlU2l6ZS55IC8gdGhpcy5zY2FsZS55KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKGNvbCwgcm93KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIGRlYnVnUmVuZGVyKCl7XHJcbiAgICAgICAgLy8gSGFsZiBvZiB0aGUgdGlsZSBzaXplXHJcbiAgICAgICAgbGV0IHpvb21lZEhhbGZUaWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemVXaXRoWm9vbSgpLnNjYWxlZCgwLjUpO1xyXG4gICAgICAgIGxldCBoYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGVkKDAuNSk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBjZW50ZXIgb2YgdGhlIHRvcCBsZWZ0IHRpbGVcclxuICAgICAgICBsZXQgdG9wTGVmdCA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5zdWIodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBBIHZlYyB0byBzdG9yZSB0aGUgY2VudGVyXHJcbiAgICAgICAgbGV0IGNlbnRlciA9IFZlYzIuWkVSTztcclxuXHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLm51bUNvbHM7IGNvbCsrKXtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB4LXBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNlbnRlci54ID0gdG9wTGVmdC54ICsgY29sKjIqaGFsZlRpbGVTaXplLnggKyBoYWxmVGlsZVNpemUueDtcclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5udW1Sb3dzOyByb3crKyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzQ29sbGlkYWJsZSAmJiB0aGlzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHktcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIueSA9IHRvcExlZnQueSArIHJvdyoyKmhhbGZUaWxlU2l6ZS55ICsgaGFsZlRpbGVTaXplLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERyYXcgYSBib3ggZm9yIHRoaXMgdGlsZVxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLmRyYXdCb3godGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXMoY2VudGVyKSwgem9vbWVkSGFsZlRpbGVTaXplLCBmYWxzZSwgQ29sb3IuQkxVRSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vSW5wdXQvSW5wdXRcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBVSUVsZW1lbnQgLSB0aGUgcGFyZW50IGNsYXNzIG9mIHRoaW5ncyBsaWtlIGJ1dHRvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFVJRWxlbWVudCBleHRlbmRzIENhbnZhc05vZGUge1xyXG5cdC8vIFN0eWxlIGF0dHJpYnV0ZXMgLSBUT0RPIC0gYWJzdHJhY3QgdGhpcyBpbnRvIGEgc3R5bGUgb2JqZWN0L2ludGVyZmFjZVxyXG5cdC8qKiBUaGUgYmFja2dvdW5kIGNvbG9yICovXHJcblx0YmFja2dyb3VuZENvbG9yOiBDb2xvcjtcclxuXHQvKiogVGhlIGJvcmRlciBjb2xvciAqL1xyXG5cdGJvcmRlckNvbG9yOiBDb2xvcjtcclxuXHQvKiogVGhlIGJvcmRlciByYWRpdXMgKi9cclxuXHRib3JkZXJSYWRpdXM6IG51bWJlcjtcclxuXHQvKiogVGhlIGJvcmRlciB3aWR0aCAqL1xyXG5cdGJvcmRlcldpZHRoOiBudW1iZXI7XHJcblx0LyoqIFRoZSBwYWRkaW5nICovXHJcblx0cGFkZGluZzogVmVjMjtcclxuXHJcblx0Ly8gRXZlbnRBdHRyaWJ1dGVzXHJcblx0LyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCBvbiBhIGNsaWNrICovXHJcblx0b25DbGljazogRnVuY3Rpb247XHJcblx0LyoqIFRoZSBldmVudCBwcm9wYWdhdGVkIG9uIGNsaWNrICovXHJcblx0b25DbGlja0V2ZW50SWQ6IHN0cmluZztcclxuXHQvKiogVGhlIHJlYWN0aW9uIHRvIHRoZSByZWxlYXNlIG9mIGEgY2xpY2sgKi9cclxuXHRvblJlbGVhc2U6IEZ1bmN0aW9uO1xyXG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXHJcblx0b25SZWxlYXNlRXZlbnRJZDogc3RyaW5nO1xyXG5cdC8qKiBUaGUgcmVhY3Rpb24gd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdG9uRW50ZXI6IEZ1bmN0aW9uO1xyXG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCB3aGVuIGEgbW91c2UgZW50ZXJzIHRoaXMgVUlFbGVtZW50ICovXHJcblx0b25FbnRlckV2ZW50SWQ6IHN0cmluZztcclxuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHRvbkxlYXZlOiBGdW5jdGlvbjtcclxuXHQvKiogVGhlIGV2ZW50IHByb3BvZ2F0ZWQgd2hlbiBhIG1vdXNlIGxlYXZlcyB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdG9uTGVhdmVFdmVudElkOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFVJRWxlbWVudCBpcyBjdXJyZW50bHkgY2xpY2tlZCBvbiAqL1xyXG5cdHByb3RlY3RlZCBpc0NsaWNrZWQ6IGJvb2xlYW47XHJcblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgVUlFbGVtZW50IGlzIGN1cnJlbnRseSBob3ZlcmVkIG92ZXIgKi9cclxuXHRwcm90ZWN0ZWQgaXNFbnRlcmVkOiBib29sZWFuO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cdFx0XHJcblx0XHR0aGlzLmJhY2tncm91bmRDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcclxuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XHJcblx0XHR0aGlzLmJvcmRlclJhZGl1cyA9IDU7XHJcblx0XHR0aGlzLmJvcmRlcldpZHRoID0gMTtcclxuXHRcdHRoaXMucGFkZGluZyA9IFZlYzIuWkVSTztcclxuXHJcblx0XHR0aGlzLm9uQ2xpY2sgPSBudWxsO1xyXG5cdFx0dGhpcy5vbkNsaWNrRXZlbnRJZCA9IG51bGw7XHJcblx0XHR0aGlzLm9uUmVsZWFzZSA9IG51bGw7XHJcblx0XHR0aGlzLm9uUmVsZWFzZUV2ZW50SWQgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMub25FbnRlciA9IG51bGw7XHJcblx0XHR0aGlzLm9uRW50ZXJFdmVudElkID0gbnVsbDtcclxuXHRcdHRoaXMub25MZWF2ZSA9IG51bGw7XHJcblx0XHR0aGlzLm9uTGVhdmVFdmVudElkID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc0VudGVyZWQgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8vIEBkZXByZWNhdGVkXHJcblx0c2V0QmFja2dyb3VuZENvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcclxuXHR9XHJcblxyXG5cdC8vIEBkZXByZWNhdGVkXHJcblx0c2V0UGFkZGluZyhwYWRkaW5nOiBWZWMyKTogdm9pZCB7XHJcblx0XHR0aGlzLnBhZGRpbmcuY29weShwYWRkaW5nKTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0c3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG5cdFx0Ly8gU2VlIG9mIHRoaXMgb2JqZWN0IHdhcyBqdXN0IGNsaWNrZWRcclxuXHRcdGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcclxuXHRcdFx0bGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XHJcblx0XHRcdGlmKHRoaXMuY29udGFpbnMoY2xpY2tQb3MueCwgY2xpY2tQb3MueSkgJiYgdGhpcy52aXNpYmxlICYmICF0aGlzLmxheWVyLmlzSGlkZGVuKCkpe1xyXG5cdFx0XHRcdHRoaXMuaXNDbGlja2VkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0aWYodGhpcy5vbkNsaWNrICE9PSBudWxsKXtcclxuXHRcdFx0XHRcdHRoaXMub25DbGljaygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih0aGlzLm9uQ2xpY2tFdmVudElkICE9PSBudWxsKXtcclxuXHRcdFx0XHRcdGxldCBkYXRhID0ge307XHJcblx0XHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25DbGlja0V2ZW50SWQsIGRhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHRoZSBtb3VzZSB3YXNuJ3QganVzdCBwcmVzc2VkLCB0aGVuIHdlIGRlZmluaXRlbHkgd2VyZW4ndCBjbGlja2VkXHJcblx0XHRpZighSW5wdXQuaXNNb3VzZVByZXNzZWQoKSl7XHJcblx0XHRcdGlmKHRoaXMuaXNDbGlja2VkKXtcclxuXHRcdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG1vdXNlIGlzIGhvdmVyaW5nIG92ZXIgdGhpcyBlbGVtZW50XHJcblx0XHRsZXQgbW91c2VQb3MgPSBJbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCk7XHJcblx0XHRpZihtb3VzZVBvcyAmJiB0aGlzLmNvbnRhaW5zKG1vdXNlUG9zLngsIG1vdXNlUG9zLnkpKXtcclxuXHRcdFx0dGhpcy5pc0VudGVyZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYodGhpcy5vbkVudGVyICE9PSBudWxsKXtcclxuXHRcdFx0XHR0aGlzLm9uRW50ZXIoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0aGlzLm9uRW50ZXJFdmVudElkICE9PSBudWxsKXtcclxuXHRcdFx0XHRsZXQgZGF0YSA9IHt9O1xyXG5cdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkVudGVyRXZlbnRJZCwgZGF0YSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYodGhpcy5pc0VudGVyZWQpIHtcclxuXHRcdFx0dGhpcy5pc0VudGVyZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmKHRoaXMub25MZWF2ZSAhPT0gbnVsbCl7XHJcblx0XHRcdFx0dGhpcy5vbkxlYXZlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5vbkxlYXZlRXZlbnRJZCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcclxuXHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25MZWF2ZUV2ZW50SWQsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYodGhpcy5pc0NsaWNrZWQpIHtcclxuXHRcdFx0Ly8gSWYgbW91c2UgaXMgZHJhZ2dlZCBvZmYgb2YgZWxlbWVudCB3aGlsZSBkb3duLCBpdCBpcyBub3QgY2xpY2tlZCBhbnltb3JlXHJcblx0XHRcdHRoaXMuaXNDbGlja2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVycmlkYWJsZSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIGJhY2tncm91bmQgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xyXG5cdCAqIEByZXR1cm5zIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBib3JkZXIgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xyXG5cdCAqIEByZXR1cm5zIFRoZSBib3JkZXIgY29sb3Igb2YgdGhlIFVJRWxlbWVudFxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZUJvcmRlckNvbG9yKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiB0aGlzLmJvcmRlckNvbG9yO1xyXG5cdH1cclxufSIsImltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuLyoqIEEgY2xpY2thYmxlIGJ1dHRvbiBVSUVsZW1lbnQgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uIGV4dGVuZHMgTGFiZWwge1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgdGV4dDogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHBvc2l0aW9uLCB0ZXh0KTtcclxuXHRcdFxyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMTUwLCA3NSwgMjAzKTtcclxuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBuZXcgQ29sb3IoNDEsIDQ2LCAzMCk7XHJcblx0XHR0aGlzLnRleHRDb2xvciA9IG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1KTtcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdGNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpOiBDb2xvciB7XHJcblx0XHQvLyBDaGFuZ2UgdGhlIGJhY2tncm91bmQgY29sb3IgaWYgY2xpY2tlZCBvciBob3ZlcmVkXHJcblx0XHRpZih0aGlzLmlzRW50ZXJlZCAmJiAhdGhpcy5pc0NsaWNrZWQpe1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3IubGlnaHRlbigpO1xyXG5cdFx0fSBlbHNlIGlmKHRoaXMuaXNDbGlja2VkKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmRhcmtlbigpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL1VJRWxlbWVudFwiO1xyXG5cclxuLyoqIEEgYmFzaWMgdGV4dC1jb250YWluaW5nIGxhYmVsICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsIGV4dGVuZHMgVUlFbGVtZW50e1xyXG5cdC8qKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgb2YgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHR0ZXh0Q29sb3I6IENvbG9yO1xyXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhlIHRleHQgb2YgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHR0ZXh0OiBzdHJpbmc7XHJcblx0LyoqIFRoZSBuYW1lIG9mIHRoZSBmb250ICovXHJcblx0Zm9udDogc3RyaW5nO1xyXG5cdC8qKiBUaGUgc2l6ZSBvZiB0aGUgZm9udCAqL1xyXG5cdGZvbnRTaXplOiBudW1iZXI7XHJcblx0LyoqIFRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGUgdGV4dCB3aXRoaW4gdGhlIGxhYmVsICovXHJcblx0cHJvdGVjdGVkIGhBbGlnbjogc3RyaW5nO1xyXG5cdC8qKiBUaGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xyXG5cdHByb3RlY3RlZCB2QWxpZ246IHN0cmluZztcclxuXHJcblx0LyoqIEEgZmxhZyBmb3IgaWYgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGhhcyBiZWVuIG1lYXN1cmVkIG9uIHRoZSBjYW52YXMgZm9yIGF1dG8gd2lkdGggYXNzaWdubWVudCAqL1xyXG5cdHByb3RlY3RlZCBzaXplQXNzaWduZWQ6IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCB0ZXh0OiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIocG9zaXRpb24pO1xyXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcclxuXHRcdHRoaXMudGV4dENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xyXG5cdFx0dGhpcy5mb250ID0gXCJBcmlhbFwiO1xyXG5cdFx0dGhpcy5mb250U2l6ZSA9IDMwO1xyXG5cdFx0dGhpcy5oQWxpZ24gPSBcImNlbnRlclwiO1xyXG5cdFx0dGhpcy52QWxpZ24gPSBcImNlbnRlclwiO1xyXG5cclxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBAZGVwcmVjYXRlZFxyXG5cdHNldFRleHQodGV4dDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xyXG5cdH1cclxuXHJcblx0Ly8gQGRlcHJlY2F0ZWRcclxuXHRzZXRUZXh0Q29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLnRleHRDb2xvciA9IGNvbG9yO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBhIHN0cmluZyBjb250YWluZyB0aGUgZm9udCBkZXRhaWxzIGZvciByZW5kZXJpbmdcclxuXHQgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBmb250IGRldGFpbHNcclxuXHQgKi9cclxuXHRnZXRGb250U3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVycmlkYWJsZSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIHRleHQgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xyXG5cdCAqIEByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5nIHRoZSB0ZXh0IGNvbG9yXHJcblx0ICovXHJcblx0Y2FsY3VsYXRlVGV4dENvbG9yKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0Q29sb3IudG9TdHJpbmdSR0JBKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVc2VzIHRoZSBjYW52YXMgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICogQHJldHVybnMgQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSByZW5kZXJlZCB0ZXh0IHdpZHRoXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGNhbGN1bGF0ZVRleHRXaWR0aChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IG51bWJlciB7XHJcblx0XHRjdHguZm9udCA9IHRoaXMuZm9udFNpemUgKyBcInB4IFwiICsgdGhpcy5mb250O1xyXG5cdFx0cmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xyXG5cdH1cclxuXHJcblx0c2V0SEFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdHRoaXMuaEFsaWduID0gYWxpZ247XHJcblx0fVxyXG5cclxuXHRzZXRWQWxpZ24oYWxpZ246IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy52QWxpZ24gPSBhbGlnbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSB0ZXh0IC0gdGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcgdGV4dCB3aXRoIGRpZmZlcmVudCBhbGlnbm1lbnRzXHJcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKiBAcmV0dXJucyBUaGUgb2Zmc2V0IG9mIHRoZSB0ZXh0IGluIGEgVmVjMlxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZVRleHRPZmZzZXQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBWZWMyIHtcclxuXHRcdGxldCB0ZXh0V2lkdGggPSB0aGlzLmNhbGN1bGF0ZVRleHRXaWR0aChjdHgpO1xyXG5cclxuXHRcdGxldCBvZmZzZXQgPSBuZXcgVmVjMigwLCAwKTtcclxuXHJcblx0XHRsZXQgaERpZmYgPSB0aGlzLnNpemUueCAtIHRleHRXaWR0aDtcclxuXHRcdGlmKHRoaXMuaEFsaWduID09PSBIQWxpZ24uQ0VOVEVSKXtcclxuXHRcdFx0b2Zmc2V0LnggPSBoRGlmZi8yO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLmhBbGlnbiA9PT0gSEFsaWduLlJJR0hUKXtcclxuXHRcdFx0b2Zmc2V0LnggPSBoRGlmZjtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLnZBbGlnbiA9PT0gVkFsaWduLlRPUCl7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xyXG5cdFx0XHRvZmZzZXQueSA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMudkFsaWduID09PSBWQWxpZ24uQk9UVE9NKXtcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XHJcblx0XHRcdG9mZnNldC55ID0gdGhpcy5zaXplLnk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuXHRcdFx0b2Zmc2V0LnkgPSB0aGlzLnNpemUueS8yO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvZmZzZXQ7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XHJcblx0XHRzdXBlci5zaXplQ2hhbmdlZCgpO1xyXG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQXV0b21hdGljYWxseSBzaXplcyB0aGUgZWxlbWVudCB0byB0aGUgdGV4dCB3aXRoaW4gaXRcclxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhdXRvU2l6ZShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge1xyXG5cdFx0bGV0IHdpZHRoID0gdGhpcy5jYWxjdWxhdGVUZXh0V2lkdGgoY3R4KTtcclxuXHRcdGxldCBoZWlnaHQgPSB0aGlzLmZvbnRTaXplO1xyXG5cdFx0dGhpcy5zaXplLnNldCh3aWR0aCArIHRoaXMucGFkZGluZy54KjIsIGhlaWdodCArIHRoaXMucGFkZGluZy55KjIpO1xyXG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGx5IGFzc2lnbnMgYSBzaXplIHRvIHRoZSBVSUVsZW1lbnQgaWYgbm9uZSBpcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICovXHJcblx0aGFuZGxlSW5pdGlhbFNpemluZyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge1xyXG5cdFx0aWYoIXRoaXMuc2l6ZUFzc2lnbmVkKXtcclxuXHRcdFx0dGhpcy5hdXRvU2l6ZShjdHgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqIE9uIHRoZSBuZXh0IHJlbmRlciwgc2l6ZSB0aGlzIGVsZW1lbnQgdG8gaXQncyBjdXJyZW50IHRleHQgdXNpbmcgaXRzIGN1cnJlbnQgZm9udCBzaXplICovXHJcblx0c2l6ZVRvVGV4dCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gZmFsc2U7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBWQWxpZ24ge1xyXG5cdFRPUCA9IFwidG9wXCIsXHJcblx0Q0VOVEVSID0gXCJjZW50ZXJcIixcclxuXHRCT1RUT00gPSBcImJvdHRvbVwiXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEhBbGlnbiB7XHJcblx0TEVGVCA9IFwibGVmdFwiLFxyXG5cdENFTlRFUiA9IFwiY2VudGVyXCIsXHJcblx0UklHSFQgPSBcInJpZ2h0XCJcclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL1VJRWxlbWVudFwiO1xyXG5cclxuLyoqIEEgc2xpZGVyIFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXIgZXh0ZW5kcyBVSUVsZW1lbnQge1xyXG4gICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyIGZyb20gWzAsIDFdICovXHJcbiAgICBwcm90ZWN0ZWQgdmFsdWU6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIHNsaWRlciBuaWIgKi9cclxuICAgIHB1YmxpYyBuaWJDb2xvcjogQ29sb3I7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG5pYiAqL1xyXG4gICAgcHVibGljIG5pYlNpemU6IFZlYzI7XHJcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgdHJhY2sgKi9cclxuICAgIHB1YmxpYyBzbGlkZXJDb2xvcjogQ29sb3I7XHJcbiAgICAvKiogVGhlIHJlYWN0aW9uIG9mIHRoaXMgVUlFbGVtZW50IHRvIGEgdmFsdWUgY2hhbmdlICovXHJcbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZTogRnVuY3Rpb247XHJcbiAgICAvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgYnkgdGhpcyBVSUVsZW1lbnQgd2hlbiB2YWx1ZSBjaGFuZ2VzICovXHJcbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZUV2ZW50SWQ6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgaW5pdFZhbHVlOiBudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGluaXRWYWx1ZTtcclxuICAgICAgICB0aGlzLm5pYkNvbG9yID0gQ29sb3IuUkVEO1xyXG4gICAgICAgIHRoaXMuc2xpZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICB0aGlzLm5pYlNpemUgPSBuZXcgVmVjMigxMCwgMjApO1xyXG5cclxuICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IHNpemVcclxuICAgICAgICB0aGlzLnNpemUuc2V0KDIwMCwgMjApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHNsaWRlclxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBIG1ldGhvZCBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gdGhlIHZhbHVlIGNoYW5naW5nICovXHJcbiAgICBwcm90ZWN0ZWQgdmFsdWVDaGFuZ2VkKCk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZSl7XHJcbiAgICAgICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZUV2ZW50SWQpe1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25WYWx1ZUNoYW5nZUV2ZW50SWQsIHt0YXJnZXQ6IHRoaXMsIHZhbHVlOiB0aGlzLnZhbHVlfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICBpZih0aGlzLmlzQ2xpY2tlZCl7XHJcbiAgICAgICAgICAgIGxldCB2YWwgPSBNYXRoVXRpbHMuaW52TGVycCh0aGlzLnBvc2l0aW9uLnggLSB0aGlzLnNpemUueC8yLCB0aGlzLnBvc2l0aW9uLnggKyB0aGlzLnNpemUueC8yLCBJbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCkueCk7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoVXRpbHMuY2xhbXAwMSh2YWwpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XHJcblxyXG4vKiogQSB0ZXh0IGlucHV0IFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgICAvKiogQSBmbGFnIHRoZSByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHVzZXIgY2FuIHR5cGUgaW4gdGhpcyBUZXh0SW5wdXQgKi9cclxuICAgIGZvY3VzZWQ6IGJvb2xlYW47XHJcbiAgICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgaW4gdGhpcyBUZXh0SW5wdXQgKi9cclxuICAgIGN1cnNvckNvdW50ZXI6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XHJcbiAgICAgICAgc3VwZXIocG9zaXRpb24sIFwiXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1cnNvckNvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAvLyBHaXZlIGEgZGVmYXVsdCBzaXplIHRvIHRoZSB4IG9ubHlcclxuICAgICAgICB0aGlzLnNpemUuc2V0KDIwMCwgdGhpcy5mb250U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5oQWxpZ24gPSBcImxlZnRcIjtcclxuXHJcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcclxuXHRcdFx0bGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XHJcblx0XHRcdGlmKHRoaXMuY29udGFpbnMoY2xpY2tQb3MueCwgY2xpY2tQb3MueSkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yQ291bnRlciA9IDMwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZm9jdXNlZCl7XHJcbiAgICAgICAgICAgIGxldCBrZXlzID0gSW5wdXQuZ2V0S2V5c0p1c3RQcmVzc2VkKCk7XHJcbiAgICAgICAgICAgIGxldCBudW1zID0gXCIxMjM0NTY3ODkwXCI7XHJcbiAgICAgICAgICAgIGxldCBzcGVjaWFsQ2hhcnMgPSBcImB+IUAjJCVeJiooKS1fPStbe119XFxcXHw7OidcXFwiLDwuPi8/XCI7XHJcbiAgICAgICAgICAgIGxldCBsZXR0ZXJzID0gXCJxd2VydHl1aW9wYXNkZmdoamtsenhjdmJubVwiO1xyXG4gICAgICAgICAgICBsZXQgbWFzayA9IG51bXMgKyBzcGVjaWFsQ2hhcnMgKyBsZXR0ZXJzO1xyXG4gICAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+IG1hc2suaW5jbHVkZXMoa2V5KSk7XHJcbiAgICAgICAgICAgIGxldCBzaGlmdFByZXNzZWQgPSBJbnB1dC5pc0tleVByZXNzZWQoXCJzaGlmdFwiKTtcclxuICAgICAgICAgICAgbGV0IGJhY2tzcGFjZVByZXNzZWQgPSBJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiYmFja3NwYWNlXCIpO1xyXG4gICAgICAgICAgICBsZXQgc3BhY2VQcmVzc2VkID0gSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcInNwYWNlXCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoYmFja3NwYWNlUHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIHRoaXMudGV4dC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHNwYWNlUHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmKHNoaWZ0UHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGtleXNbMF0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGtleXNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZW51bSBVSUVsZW1lbnRUeXBlIHtcclxuXHRCVVRUT04gPSBcIkJVVFRPTlwiLFxyXG5cdExBQkVMID0gXCJMQUJFTFwiLFxyXG5cdFNMSURFUiA9IFwiU0xJREVSXCIsXHJcblx0VEVYVF9JTlBVVCA9IFwiVEVYVElOUFVUXCJcclxufSIsImltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL05hdmlnYWJsZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFuYWdlciBjbGFzcyBmb3IgbmF2aWdhdGlvbi5cclxuICogSGFuZGxlcyBhbGwgbmF2aWdhYmxlIGVudGl0aWVzLCBzdWNoIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBhY2Nlc3NlZCBieSBvdXRzaWRlIHN5c3RlbXMgYnkgcmVxdWVzdGluZyBhIHBhdGhcclxuICogZnJvbSBvbmUgcG9zaXRpb24gdG8gYW5vdGhlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25NYW5hZ2VyIHtcclxuXHQvKiogVGhlIGxpc3Qgb2YgYWxsIG5hdmlnYWJsZSBlbnRpdGllcyAqL1xyXG5cdHByb3RlY3RlZCBuYXZpZ2FibGVFbnRpdGllczogTWFwPE5hdmlnYWJsZT47XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzID0gbmV3IE1hcCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIG5hdmlnYWJsZSBlbnRpdHkgdG8gdGhlIE5hdmlnYXRpb25NYW5hZ2VyXHJcblx0ICogQHBhcmFtIG5hdk5hbWUgVGhlIG5hbWUgb2YgdGhlIG5hdmlnYWJsZSBlbnRpdHJ5XHJcblx0ICogQHBhcmFtIG5hdiBUaGUgYWN0dWFsIE5hdmlnYWJsZSBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdGFkZE5hdmlnYWJsZUVudGl0eShuYXZOYW1lOiBzdHJpbmcsIG5hdjogTmF2aWdhYmxlKTogdm9pZCB7XHJcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmFkZChuYXZOYW1lLCBuYXYpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBhIHBhdGggZnJvbWUgb25lIHBvaW50IHRvIGFub3RoZXIgdXNpbmcgYSBzcGVjaWZpZWQgTmF2aWdhYmxlIG9iamVjdFxyXG5cdCAqIEBwYXJhbSBuYXZOYW1lIFRoZSBuYW1lIG9mIHRoZSByZWdpc3RlcmVkIE5hdmlnYWJsZSBvYmplY3RcclxuXHQgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiBuYXZpZ2F0aW9uXHJcblx0ICogQHBhcmFtIHRvUG9zaXRpb24gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiBOYXZpZ2F0aW9uXHJcblx0ICogQHJldHVybnMgQSBOYXZpZ2F0aW9uUGF0aCBjb250YWluaW5nIHRoZSByb3V0ZSB0byB0YWtlIG92ZXIgdGhlIE5hdmlnYWJsZSBlbnRpdHkgdG8gZ2V0IGJldHdlZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9ucy5cclxuXHQgKi9cclxuXHRnZXRQYXRoKG5hdk5hbWU6IHN0cmluZywgZnJvbVBvc2l0aW9uOiBWZWMyLCB0b1Bvc2l0aW9uOiBWZWMyKTogTmF2aWdhdGlvblBhdGgge1xyXG5cdFx0bGV0IG5hdiA9IHRoaXMubmF2aWdhYmxlRW50aXRpZXMuZ2V0KG5hdk5hbWUpO1xyXG5cdFx0cmV0dXJuIG5hdi5nZXROYXZpZ2F0aW9uUGF0aChmcm9tUG9zaXRpb24uY2xvbmUoKSwgdG9Qb3NpdGlvbi5jbG9uZSgpKTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uL0RhdGFUeXBlcy9TdGFja1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgcGF0aCB0aGF0IEFJcyBjYW4gZm9sbG93LiBVc2VzIGZpbmlzaE1vdmUoKSBpbiBQaHlzaWNhbCB0byBkZXRlcm1pbmUgcHJvZ3Jlc3Mgb24gdGhlIHJvdXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uUGF0aCB7XHJcblx0LyoqIFRoZSBuYXZpZ2F0aW9uIHBhdGgsIHN0b3JlZCBhcyBhIHN0YWNrIG9mIG5leHQgcG9zaXRpb25zICovXHJcblx0cHJvdGVjdGVkIHBhdGg6IFN0YWNrPFZlYzI+O1xyXG5cdC8qKiBUaGUgY3VycmVudCBkaXJlY3Rpb24gb2YgbW92ZW1lbnQgKi9cclxuXHRwcm90ZWN0ZWQgY3VycmVudE1vdmVEaXJlY3Rpb246IFZlYzI7XHJcblx0LyoqIFRoZSBkaXN0YW5jZSBhIG5vZGUgbXVzdCBiZSB0byBhIHBvaW50IHRvIGNvbnNpZGVyIGl0IGFzIGhhdmluZyBhcnJpdmVkICovXHJcblx0cHJvdGVjdGVkIGRpc3RhbmNlVGhyZXNob2xkOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgTmF2aWdhdGlvblBhdGhcclxuXHQgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiBub2RlcyB0byB0YWtlXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocGF0aDogU3RhY2s8VmVjMj4pe1xyXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHRcdHRoaXMuY3VycmVudE1vdmVEaXJlY3Rpb24gPSBWZWMyLlpFUk87XHJcblx0XHR0aGlzLmRpc3RhbmNlVGhyZXNob2xkID0gNDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBuYXZpZ2F0aW9uIGFsb25nIHRoaXMgTmF2aWdhdGlvblBhdGhcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBub2RlIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhdGgsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdGlzRG9uZSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnBhdGguaXNFbXB0eSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbW92ZW1lbnQgZGlyZWN0aW9uIGluIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFsb25nIHRoZSBwYXRoXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gbW92ZSBhbG9uZyB0aGUgcGF0aFxyXG5cdCAqIEByZXR1cm5zIFRoZSBtb3ZlbWVudCBkaXJlY3Rpb24gYXMgYSBWZWMyXHJcblx0ICovXHJcblx0Z2V0TW92ZURpcmVjdGlvbihub2RlOiBHYW1lTm9kZSk6IFZlYzIge1xyXG5cdFx0Ly8gUmV0dXJuIGRpcmVjdGlvbiB0byBuZXh0IHBvaW50IGluIHRoZSBuYXZcclxuXHRcdHJldHVybiBub2RlLnBvc2l0aW9uLmRpclRvKHRoaXMucGF0aC5wZWVrKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIE5hdmlnYXRpb25QYXRoIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBHYW1lTm9kZVxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIG1vdmluZyBhbG9uZyB0aGUgcGF0aFxyXG5cdCAqL1xyXG5cdGhhbmRsZVBhdGhQcm9ncmVzcyhub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xyXG5cdFx0aWYobm9kZS5wb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5wYXRoLnBlZWsoKSkgPCB0aGlzLmRpc3RhbmNlVGhyZXNob2xkKnRoaXMuZGlzdGFuY2VUaHJlc2hvbGQpe1xyXG5cdFx0XHQvLyBXZSd2ZSByZWFjaGVkIG91ciBub2RlLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGRlc3RpbmF0aW9uXHJcblx0XHRcdHRoaXMucGF0aC5wb3AoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKClcclxuXHR9XHJcbn0iLCJpbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XHJcbmltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL05hdmlnYWJsZVwiO1xyXG5pbXBvcnQgU3RhY2sgZnJvbSBcIi4uL0RhdGFUeXBlcy9TdGFja1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdyYXBoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL0dyYXBoVXRpbHNcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuL05hdmlnYXRpb25QYXRoXCI7XHJcblxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBOYXZtZXNoLiBOYXZtZXNoZXMgYXJlIGdyYXBocyBpbiB0aGUgZ2FtZSB3b3JsZCBhbG9uZyB3aGljaCBub2RlcyBjYW4gbW92ZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdm1lc2ggaW1wbGVtZW50cyBOYXZpZ2FibGUge1xyXG5cdC8qKiBUaGUgZ3JhcGggb2YgcG9pbnRzIGluIHRoZSBOYXZNZXNoICovXHJcblx0cHJvdGVjdGVkIGdyYXBoOiBQb3NpdGlvbkdyYXBoO1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IE5hdm1lc2ggZnJvbSB0aGUgcG9pbnRzIGluIHRoZSBzcGVlY2lmaWVkIGdyYXBoXHJcblx0ICogQHBhcmFtIGdyYXBoIFRoZSBncmFwaCB0byBjb25zdHJ1Y3QgYSBuYXZtZXNoIGZyb21cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihncmFwaDogUG9zaXRpb25HcmFwaCl7XHJcblx0XHR0aGlzLmdyYXBoID0gZ3JhcGg7XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRnZXROYXZpZ2F0aW9uUGF0aChmcm9tUG9zaXRpb246IFZlYzIsIHRvUG9zaXRpb246IFZlYzIpOiBOYXZpZ2F0aW9uUGF0aCB7XHJcblx0XHRsZXQgc3RhcnQgPSB0aGlzLmdldENsb3Nlc3ROb2RlKGZyb21Qb3NpdGlvbik7XHJcblx0XHRsZXQgZW5kID0gdGhpcy5nZXRDbG9zZXN0Tm9kZSh0b1Bvc2l0aW9uKTtcclxuXHJcblx0XHRsZXQgcGFyZW50ID0gR3JhcGhVdGlscy5kamlrc3RyYSh0aGlzLmdyYXBoLCBzdGFydCk7XHJcblxyXG5cdFx0bGV0IHBhdGhTdGFjayA9IG5ldyBTdGFjazxWZWMyPih0aGlzLmdyYXBoLm51bVZlcnRpY2VzKTtcclxuXHRcdFxyXG5cdFx0Ly8gUHVzaCB0aGUgZmluYWwgcG9zaXRpb24gYW5kIHRoZSBmaW5hbCBwb3NpdGlvbiBpbiB0aGUgZ3JhcGhcclxuXHRcdHBhdGhTdGFjay5wdXNoKHRvUG9zaXRpb24uY2xvbmUoKSk7XHJcblx0XHRwYXRoU3RhY2sucHVzaCh0aGlzLmdyYXBoLnBvc2l0aW9uc1tlbmRdKTtcclxuXHJcblx0XHQvLyBBZGQgYWxsIHBhcmVudHMgYWxvbmcgdGhlIHBhdGhcclxuXHRcdGxldCBpID0gZW5kO1xyXG5cdFx0d2hpbGUocGFyZW50W2ldICE9PSAtMSl7XHJcblx0XHRcdHBhdGhTdGFjay5wdXNoKHRoaXMuZ3JhcGgucG9zaXRpb25zW3BhcmVudFtpXV0pO1xyXG5cdFx0XHRpID0gcGFyZW50W2ldO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTmF2aWdhdGlvblBhdGgocGF0aFN0YWNrKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGNsb3Nlc3Qgbm9kZSBpbiB0aGlzIE5hdm1lc2ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gcXVlcnlcclxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGNsb3Nlc3Qgbm9kZSBpbiB0aGUgTmF2bWVzaCB0byB0aGUgcG9zaXRpb25cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZ2V0Q2xvc2VzdE5vZGUocG9zaXRpb246IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0bGV0IG4gPSB0aGlzLmdyYXBoLm51bVZlcnRpY2VzO1xyXG5cdFx0bGV0IGkgPSAxO1xyXG5cdFx0bGV0IGluZGV4ID0gMDtcclxuXHRcdGxldCBkaXN0ID0gcG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMuZ3JhcGgucG9zaXRpb25zWzBdKTtcclxuXHRcdHdoaWxlKGkgPCBuKXtcclxuXHRcdFx0bGV0IGQgPSBwb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5ncmFwaC5wb3NpdGlvbnNbaV0pO1xyXG5cdFx0XHRpZihkIDwgZGlzdCl7XHJcblx0XHRcdFx0ZGlzdCA9IGQ7XHJcblx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGkrKztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5kZXg7XHJcblx0fVxyXG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi9QaHlzaWNzTWFuYWdlclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBBcmVhQ29sbGlzaW9uIGZyb20gXCIuLi9EYXRhVHlwZXMvUGh5c2ljcy9BcmVhQ29sbGlzaW9uXCI7XHJcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFMR09SSVRITTpcclxuICogXHRJbiBhbiBlZmZvcnQgdG8ga2VlcCB0aGluZ3Mgc2ltcGxlIGFuZCB3b3JraW5nIGVmZmVjdGl2ZWx5LCBlYWNoIGR5bmFtaWMgbm9kZSB3aWxsIHJlc29sdmUgaXRzXHJcbiAqIFx0Y29sbGlzaW9ucyBjb25zaWRlcmluZyB0aGUgcmVzdCBvZiB0aGUgd29ybGQgYXMgc3RhdGljLlxyXG4gKiBcclxuICogXHRDb2xsaXNpb24gZGV0ZWN0aW5nIHdpbGwgaGFwcGVuIGZpcnN0LiBUaGlzIGNhbiBiZSBjb25zaWRlcmVkIGEgYnJvYWQgcGhhc2UsIGJ1dCBpdCBpcyBub3QgZXNwZWNpYWxseVxyXG4gKiBcdGVmZmljaWVudCwgYXMgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBmb3IgdGhpcyBnYW1lIGVuZ2luZS4gRXZlcnkgZHluYW1pYyBub2RlIGlzIGNoZWNrZWQgYWdhaW5zdCBldmVyeVxyXG4gKiBcdG90aGVyIG5vZGUgZm9yIGNvbGxpc2lvbiBhcmVhLiBJZiBjb2xsaXNpb24gYXJlYSBpcyBub24temVybyAobWVhbmluZyB0aGUgY3VycmVudCBub2RlIHN3ZWVwcyBpbnRvIGFub3RoZXIpLFxyXG4gKiBcdGl0IGlzIGFkZGVkIHRvIGEgbGlzdCBvZiBoaXRzLlxyXG4gKiBcclxuICogXHRJTklUSUFMSVpBVElPTjpcclxuICogXHRcdC0gUGh5c2ljcyBjb25zdGFudHMgYXJlIHJlc2V0XHJcbiAqIFx0XHQtIFN3ZXB0IHNoYXBlcyBhcmUgcmVjYWxjdWxhdGVkLiBJZiBhIG5vZGUgaXNuJ3QgbW92aW5nLCBpdCBpcyBza2lwcGVkLlxyXG4gKiBcclxuICogXHRDT0xMSVNJT04gREVURUNUSU9OOlxyXG4gKiBcdFx0LSBGb3IgYSBub2RlLCBjb2xsaXNpb24gYXJlYSB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIHN3ZXB0IEFBQkIgb2YgdGhlIG5vZGUgYWdhaW5zdCBldmVyeSBvdGhlciBBQUJCIGluIGEgc3RhdGljIHN0YXRlXHJcbiAqIFx0XHQtIFRoZXNlIGNvbGxpc2lvbnMgd2lsbCBiZSBzb3J0ZWQgYnkgYXJlYSBpbiBkZXNjZW5kaW5nIG9yZGVyXHJcbiAqIFx0XHJcbiAqIFx0Q09MTElTSU9OIFJFU09MVVRJT046XHJcbiAqIFx0XHQtIEZvciBlYWNoIGhpdCwgdGltZSBvZiBjb2xsaXNpb24gaXMgY2FsY3VsYXRlZCB1c2luZyBhIHN3ZXB0IGxpbmUgdGhyb3VnaCB0aGUgQUFCQiBvZiB0aGUgc3RhdGljIG5vZGUgZXhwYW5kZWRcclxuICogXHRcdFx0d2l0aCBtaW5rb3dza2kgc3VtcyAoZGlzY3JldGVseSwgYnV0IHRoZSBjb25jZXB0IGlzIHRoZXJlKVxyXG4gKiBcdFx0LSBUaGUgY29sbGlzaW9uIGlzIHJlc29sdmVkIGJhc2VkIG9uIHRoZSBuZWFyIHRpbWUgb2YgdGhlIGNvbGxpc2lvbiAoZnJvbSBtZXRob2Qgb2Ygc2VwYXJhdGVkIGF4ZXMpXHJcbiAqIFx0XHRcdC0gWCBpcyByZXNvbHZlZCBieSBuZWFyIHgsIFkgYnkgbmVhciB5LlxyXG4gKiBcdFx0XHQtIFRoZXJlIGlzIHNvbWUgZnVkZ2luZyB0byBhbGxvdyBmb3Igc2xpZGluZyBhbG9uZyB3YWxscyBvZiBzZXBhcmF0ZSBjb2xsaWRlcnMuIFNvcnRpbmcgYnkgYXJlYSBhbHNvIGhlbHBzIHdpdGggdGhpcy5cclxuICogXHRcdFx0LSBDb3JuZXIgdG8gY29ybmVyIGNvbGxpc2lvbnMgYXJlIHJlc29sdmUgdG8gZmF2b3IgeC1tb3ZlbWVudC4gVGhpcyBpcyBpbiBjb25zaWRlcmF0aW9uIG9mIHBsYXRmb3JtZXJzLCB0byBnaXZlXHJcbiAqIFx0XHRcdFx0dGhlIHBsYXllciBzb21lIGhlbHAgd2l0aCBqdW1wc1xyXG4gKiBcclxuICogXHRQcm9zOlxyXG4gKiBcdFx0LSBFdmVyeXRoaW5nIGhhcHBlbnMgd2l0aCBhIGNvbnNpc3RlbnQgdGltZS4gVGhlcmUgaXMgYSBkaXN0aW5jdCBiZWZvcmUgYW5kIGFmdGVyIGZvciBlYWNoIHJlc29sdXRpb24uXHJcbiAqIFx0XHQtIE5vIGJhY2stdHJhY2tpbmcgbmVlZHMgdG8gYmUgZG9uZS4gT25jZSB3ZSByZXNvbHZlIGEgbm9kZSwgaXQgaXMgZGVmaW5pdGl2ZWx5IHJlc29sdmVkLlxyXG4gKiBcdFxyXG4gKiBcdENvbnM6XHJcbiAqIFx0XHQtIE5vZGVzIHRoYXQgYXJlIHByb2Nlc3NlZCBlYXJseSBoYXZlIG1vdmVtZW50IHByaW9yaXR5IG92ZXIgb3RoZXIgbm9kZXMuIFRoaXMgY2FuIGxlYWQgdG8gc29tZSB1bmRlc2lyYWJsZSBpbnRlcmFjdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BoeXNpY3NNYW5hZ2VyIGV4dGVuZHMgUGh5c2ljc01hbmFnZXIge1xyXG5cclxuXHQvKiogVGhlIGFycmF5IG9mIHN0YXRpYyBub2RlcyAqL1xyXG5cdHByb3RlY3RlZCBzdGF0aWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xyXG5cclxuXHQvKiogVGhlIGFycmF5IG9mIGR5bmFtaWMgbm9kZXMgKi9cclxuXHRwcm90ZWN0ZWQgZHluYW1pY05vZGVzOiBBcnJheTxQaHlzaWNhbD47XHJcblxyXG5cdC8qKiBUaGUgYXJyYXkgb2YgdGlsZW1hcHMgKi9cclxuXHRwcm90ZWN0ZWQgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xyXG5cclxuXHQvKiogQW4gYXJyYXkgb2YgdGhlIGNvbGxpc2lvbiBtYXNrcyBmb3IgZWFjaCBncm91cCAqL1xyXG5cdHByb3RlY3RlZCBjb2xsaXNpb25NYXNrczogQXJyYXk8bnVtYmVyPjtcclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pil7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5zdGF0aWNOb2RlcyA9IG5ldyBBcnJheSgpO1xyXG5cdFx0dGhpcy5keW5hbWljTm9kZXMgPSBuZXcgQXJyYXkoKTtcclxuXHRcdHRoaXMudGlsZW1hcHMgPSBuZXcgQXJyYXkoKTtcclxuXHRcdHRoaXMuY29sbGlzaW9uTWFza3MgPSBuZXcgQXJyYXkoMzIpO1xyXG5cclxuXHRcdC8vIFBhcnNlIG9wdGlvbnNcclxuXHRcdHRoaXMucGFyc2VPcHRpb25zKG9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2VzIHRoZSBvcHRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGhlIHBoeXNpY3MgbWFuYWdlclxyXG5cdCAqIEBwYXJhbSBvcHRpb25zIEEgcmVjb3JkIG9mIG9wdGlvbnNcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcGFyc2VPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuXHRcdGlmKG9wdGlvbnMuZ3JvdXBOYW1lcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuY29sbGlzaW9ucyAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuZ3JvdXBOYW1lcy5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0bGV0IGdyb3VwID0gb3B0aW9ucy5ncm91cE5hbWVzW2ldO1xyXG5cclxuXHRcdFx0XHQvLyBSZWdpc3RlciB0aGUgZ3JvdXAgbmFtZSBhbmQgbnVtYmVyXHJcblx0XHRcdFx0dGhpcy5ncm91cE5hbWVzW2ldID0gZ3JvdXA7XHJcblxyXG5cdFx0XHRcdHRoaXMuZ3JvdXBNYXAuc2V0KGdyb3VwLCAxIDw8IGkpO1xyXG5cclxuXHRcdFx0XHRsZXQgY29sbGlzaW9uTWFzayA9IDA7XHJcblxyXG5cdFx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCBvcHRpb25zLmNvbGxpc2lvbnNbaV0ubGVuZ3RoOyBqKyspe1xyXG5cdFx0XHRcdFx0aWYob3B0aW9ucy5jb2xsaXNpb25zW2ldW2pdKXtcclxuXHRcdFx0XHRcdFx0Y29sbGlzaW9uTWFzayB8PSAxIDw8IGo7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmNvbGxpc2lvbk1hc2tzW2ldID0gY29sbGlzaW9uTWFzaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0cmVnaXN0ZXJPYmplY3Qobm9kZTogUGh5c2ljYWwpOiB2b2lkIHtcclxuXHRcdGlmKG5vZGUuaXNTdGF0aWMpe1xyXG5cdFx0XHQvLyBTdGF0aWMgYW5kIG5vdCBjb2xsaWRhYmxlXHJcblx0XHRcdHRoaXMuc3RhdGljTm9kZXMucHVzaChub2RlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIER5bmFtaWMgYW5kIG5vdCBjb2xsaWRhYmxlXHJcblx0XHRcdHRoaXMuZHluYW1pY05vZGVzLnB1c2gobm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRkZXJlZ2lzdGVyT2JqZWN0KG5vZGU6IFBoeXNpY2FsKTogdm9pZCB7XHJcblx0XHRjb25zb2xlLmxvZyhcIkRlcmVnaXN0ZXJpbmcgcGh5c2ljcyBvYmplY3RcIik7XHJcblx0XHRpZihub2RlLmlzU3RhdGljKXtcclxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIHN0YXRpYyBsaXN0XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5zdGF0aWNOb2Rlcy5pbmRleE9mKG5vZGUpO1xyXG5cdFx0XHR0aGlzLnN0YXRpY05vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgZHluYW1pYyBsaXN0XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5keW5hbWljTm9kZXMuaW5kZXhPZihub2RlKTtcclxuXHRcdFx0dGhpcy5keW5hbWljTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdHJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcblx0XHR0aGlzLnRpbGVtYXBzLnB1c2godGlsZW1hcCk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcblx0XHRjb25zdCBpbmRleCA9IHRoaXMudGlsZW1hcHMuaW5kZXhPZih0aWxlbWFwKTtcclxuXHRcdHRoaXMudGlsZW1hcHMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Zm9yKGxldCBub2RlIG9mIHRoaXMuZHluYW1pY05vZGVzKXtcclxuXHRcdFx0LyotLS0tLS0tLS0tIElOSVRJQUxJWkFUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xyXG5cdFx0XHQvLyBDbGVhciBmcmFtZSBkZXBlbmRlbnQgYm9vbGVhbiB2YWx1ZXMgZm9yIGVhY2ggbm9kZVxyXG5cdFx0XHRub2RlLm9uR3JvdW5kID0gZmFsc2U7XHJcblx0XHRcdG5vZGUub25DZWlsaW5nID0gZmFsc2U7XHJcblx0XHRcdG5vZGUub25XYWxsID0gZmFsc2U7XHJcblx0XHRcdG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xyXG5cdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0XHQvLyBJZiB0aGlzIG5vZGUgaXMgbm90IGFjdGl2ZSwgZG9uJ3QgcHJvY2VzcyBpdFxyXG5cdFx0XHRpZighbm9kZS5hY3RpdmUpe1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgdGhlIHN3ZXB0IHNoYXBlcyBvZiBlYWNoIG5vZGVcclxuXHRcdFx0aWYobm9kZS5tb3Zpbmcpe1xyXG5cdFx0XHRcdC8vIElmIG1vdmluZywgcmVmbGVjdCB0aGF0IGluIHRoZSBzd2VwdCBzaGFwZVxyXG5cdFx0XHRcdG5vZGUuc3dlcHRSZWN0LnN3ZWVwKG5vZGUuX3ZlbG9jaXR5LCBub2RlLmNvbGxpc2lvblNoYXBlLmNlbnRlciwgbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gSWYgb3VyIG5vZGUgaXNuJ3QgbW92aW5nLCBkb24ndCBib3RoZXIgdG8gY2hlY2sgaXQgKG90aGVyIG5vZGVzIHdpbGwgZGV0ZWN0IGlmIHRoZXkgcnVuIGludG8gaXQpXHJcblx0XHRcdFx0bm9kZS5fdmVsb2NpdHkuemVybygpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKi0tLS0tLS0tLS0gREVURUNUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xyXG5cdFx0XHQvLyBHYXRoZXIgYSBzZXQgb2Ygb3ZlcmxhcHNcclxuXHRcdFx0bGV0IG92ZXJsYXBzID0gbmV3IEFycmF5PEFyZWFDb2xsaXNpb24+KCk7XHJcblxyXG5cdFx0XHRsZXQgZ3JvdXBJbmRleCA9IE1hdGgubG9nMihub2RlLmdyb3VwKTtcclxuXHJcblx0XHRcdC8vIEZpcnN0LCBjaGVjayB0aGlzIG5vZGUgYWdhaW5zdCBldmVyeSBzdGF0aWMgbm9kZSAob3JkZXIgZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSwgc2luY2Ugd2Ugc29ydCBhbnl3YXlzKVxyXG5cdFx0XHRmb3IobGV0IG90aGVyIG9mIHRoaXMuc3RhdGljTm9kZXMpe1xyXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xyXG5cdFx0XHRcdGlmKCFvdGhlci5hY3RpdmUpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRsZXQgY29sbGlkZXIgPSBvdGhlci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcclxuXHRcdFx0XHRpZihhcmVhID4gMCl7XHJcblx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cclxuXHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIG90aGVyLCBcIkdhbWVOb2RlXCIsIG51bGwpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRoZW4sIGNoZWNrIGl0IGFnYWluc3QgZXZlcnkgZHluYW1pYyBub2RlXHJcblx0XHRcdGZvcihsZXQgb3RoZXIgb2YgdGhpcy5keW5hbWljTm9kZXMpe1xyXG5cdFx0XHRcdC8vIElnbm9yZSBvdXJzZWx2ZXNcclxuXHRcdFx0XHRpZihub2RlID09PSBvdGhlcikgY29udGludWU7XHJcblxyXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xyXG5cdFx0XHRcdGlmKCFvdGhlci5hY3RpdmUpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRsZXQgY29sbGlkZXIgPSBvdGhlci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcclxuXHRcdFx0XHRpZihhcmVhID4gMCl7XHJcblx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cclxuXHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIG90aGVyLCBcIkdhbWVOb2RlXCIsIG51bGwpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExhc3RseSwgZ2F0aGVyIGEgc2V0IG9mIEFBQkJzIGZyb20gdGhlIHRpbGVtYXAuXHJcblx0XHRcdC8vIFRoaXMgc3RlcCBpbnZvbHZlcyB0aGUgbW9zdCBleHRyYSB3b3JrLCBzbyBpdCBpcyBhYnN0cmFjdGVkIGludG8gYSBtZXRob2RcclxuXHRcdFx0Zm9yKGxldCB0aWxlbWFwIG9mIHRoaXMudGlsZW1hcHMpe1xyXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSB0aWxlbWFwc1xyXG5cdFx0XHRcdGlmKCF0aWxlbWFwLmFjdGl2ZSkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmKHRpbGVtYXAgaW5zdGFuY2VvZiBPcnRob2dvbmFsVGlsZW1hcCl7XHJcblx0XHRcdFx0XHR0aGlzLmNvbGxpZGVXaXRoT3J0aG9nb25hbFRpbGVtYXAobm9kZSwgdGlsZW1hcCwgb3ZlcmxhcHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU29ydCB0aGUgb3ZlcmxhcHMgYnkgYXJlYVxyXG5cdFx0XHRvdmVybGFwcyA9IG92ZXJsYXBzLnNvcnQoKGEsIGIpID0+IGIuYXJlYSAtIGEuYXJlYSk7XHJcblxyXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIGhpdHMgdG8gdXNlIGxhdGVyXHJcblx0XHRcdGxldCBoaXRzID0gW107XHJcblxyXG5cdFx0XHQvKi0tLS0tLS0tLS0gUkVTT0xVVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cclxuXHRcdFx0Ly8gRm9yIGV2ZXJ5IG92ZXJsYXAsIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIGNvbGxpZGUgd2l0aCBpdCBhbmQgd2hlblxyXG5cdFx0XHRmb3IobGV0IG92ZXJsYXAgb2Ygb3ZlcmxhcHMpe1xyXG5cdFx0XHRcdC8vIElnbm9yZSBub2RlcyB3ZSBkb24ndCBpbnRlcmFjdCB3aXRoXHJcblx0XHRcdFx0aWYodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAhPT0gdW5kZWZpbmVkICYmICh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHQvLyBEbyBhIHN3ZXB0IGxpbmUgdGVzdCBvbiB0aGUgc3RhdGljIEFBQkIgd2l0aCB0aGlzIEFBQkIgc2l6ZSBhcyBwYWRkaW5nICh0aGlzIGlzIGJhc2ljYWxseSB1c2luZyBhIG1pbmtvd3NraSBzdW0hKVxyXG5cdFx0XHRcdC8vIFN0YXJ0IHRoZSBzd2VlcCBhdCB0aGUgcG9zaXRpb24gb2YgdGhpcyBub2RlIHdpdGggYSBkZWx0YSBvZiBfdmVsb2NpdHlcclxuXHRcdFx0XHRjb25zdCBwb2ludCA9IG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyO1xyXG5cdFx0XHRcdGNvbnN0IGRlbHRhID0gbm9kZS5fdmVsb2NpdHk7XHJcblx0XHRcdFx0Y29uc3QgcGFkZGluZyA9IG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemU7XHJcblx0XHRcdFx0Y29uc3Qgb3RoZXJBQUJCID0gb3ZlcmxhcC5jb2xsaWRlcjtcclxuXHJcblxyXG5cdFx0XHRcdGNvbnN0IGhpdCA9IG90aGVyQUFCQi5pbnRlcnNlY3RTZWdtZW50KG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyLCBub2RlLl92ZWxvY2l0eSwgbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZSk7XHJcblxyXG5cdFx0XHRcdG92ZXJsYXAuaGl0ID0gaGl0O1xyXG5cclxuXHRcdFx0XHRpZihoaXQgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0aGl0cy5wdXNoKGhpdCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gV2UgZ290IGEgaGl0LCByZXNvbHZlIHdpdGggdGhlIHRpbWUgaW5zaWRlIG9mIHRoZSBoaXRcclxuXHRcdFx0XHRcdGxldCB0bmVhcnggPSBoaXQubmVhclRpbWVzLng7XHJcblx0XHRcdFx0XHRsZXQgdG5lYXJ5ID0gaGl0Lm5lYXJUaW1lcy55O1xyXG5cclxuXHRcdFx0XHRcdC8vIEFsbG93IGVkZ2UgY2xpcHBpbmcgKGVkZ2Ugb3ZlcmxhcHMgZG9uJ3QgY291bnQsIG9ubHkgYXJlYSBvdmVybGFwcylcclxuXHRcdFx0XHRcdC8vIEltcG9ydGFudGx5IGRvbid0IGFsbG93IGJvdGggY2FzZXMgdG8gYmUgdHJ1ZS4gVGhlbiB3ZSBjbGlwIHRocm91Z2ggY29ybmVycy4gRmF2b3IgeCB0byBoZWxwIHBsYXllcnMgbGFuZCBqdW1wc1xyXG5cdFx0XHRcdFx0aWYodG5lYXJ4IDwgMS4wICYmIChwb2ludC55ID09PSBvdGhlckFBQkIudG9wIC0gcGFkZGluZy55IHx8IHBvaW50LnkgPT09IG90aGVyQUFCQi5ib3R0b20gKyBwYWRkaW5nLnkpICYmIGRlbHRhLnggIT09IDApIHtcclxuXHRcdFx0XHRcdFx0dG5lYXJ4ID0gMS4wO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHRuZWFyeSA8IDEuMCAmJiAocG9pbnQueCA9PT0gb3RoZXJBQUJCLmxlZnQgLSBwYWRkaW5nLnggfHwgcG9pbnQueCA9PT0gb3RoZXJBQUJCLnJpZ2h0ICsgcGFkZGluZy54KSAmJiBkZWx0YS55ICE9PSAwKSB7XHJcblx0XHRcdFx0XHRcdHRuZWFyeSA9IDEuMDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdFx0aWYoaGl0Lm5lYXJUaW1lcy54ID49IDAgJiYgaGl0Lm5lYXJUaW1lcy54IDwgMSl7XHJcblx0XHRcdFx0XHRcdC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcclxuXHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XHJcblx0XHRcdFx0XHRcdFx0bm9kZS5fdmVsb2NpdHkueCA9IG5vZGUuX3ZlbG9jaXR5LnggKiB0bmVhcng7XHJcblx0XHRcdFx0XHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZihoaXQubmVhclRpbWVzLnkgPj0gMCAmJiBoaXQubmVhclRpbWVzLnkgPCAxKXtcclxuXHRcdFx0XHRcdFx0Ly8gQW55IHRpbGVtYXAgb2JqZWN0cyB0aGF0IG1hZGUgaXQgaGVyZSBhcmUgY29sbGlkYWJsZVxyXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT09IFwiVGlsZW1hcFwiIHx8IG92ZXJsYXAub3RoZXIuaXNDb2xsaWRhYmxlKXtcclxuXHRcdFx0XHRcdFx0XHRub2RlLl92ZWxvY2l0eS55ID0gbm9kZS5fdmVsb2NpdHkueSAqIHRuZWFyeTtcclxuXHRcdFx0XHRcdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0LyotLS0tLS0tLS0tIElORk9STUFUSU9OL1RSSUdHRVIgUEhBU0UgLS0tLS0tLS0tLSovXHJcblx0XHRcdC8vIENoZWNrIGlmIHdlIGVuZGVkIHVwIG9uIHRoZSBncm91bmQsIGNlaWxpbmcgb3Igd2FsbFxyXG5cdFx0XHQvLyBBbHNvIGNoZWNrIGZvciB0cmlnZ2Vyc1xyXG5cdFx0XHRmb3IobGV0IG92ZXJsYXAgb2Ygb3ZlcmxhcHMpe1xyXG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIHRyaWdnZXIuIElmIHdlIGNhcmUgYWJvdXQgdGhlIHRyaWdnZXIsIHJlYWN0XHJcblx0XHRcdFx0aWYob3ZlcmxhcC5vdGhlci5pc1RyaWdnZXIgJiYgKG92ZXJsYXAub3RoZXIudHJpZ2dlck1hc2sgJiBub2RlLmdyb3VwKSl7XHJcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGJpdCB0aGF0IHRoaXMgZ3JvdXAgaXMgcmVwcmVzZW50ZWQgYnlcclxuXHRcdFx0XHRcdGxldCBpbmRleCA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKG5vZGUuZ3JvdXApKTtcclxuXHJcblx0XHRcdFx0XHQvLyBFeHRyYWN0IHRoZSB0cmlnZ2VyRW50ZXIgZXZlbnQgbmFtZVxyXG5cdFx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudChvdmVybGFwLm90aGVyLnRyaWdnZXJFbnRlcnNbaW5kZXhdLCB7XHJcblx0XHRcdFx0XHRcdG5vZGU6ICg8R2FtZU5vZGU+bm9kZSkuaWQsXHJcblx0XHRcdFx0XHRcdG90aGVyOiAoPEdhbWVOb2RlPm92ZXJsYXAub3RoZXIpLmlkXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIElnbm9yZSBjb2xsaXNpb24gc2lkZXMgZm9yIG5vZGVzIHdlIGRvbid0IGludGVyYWN0IHdpdGhcclxuXHRcdFx0XHRpZigodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAmIG92ZXJsYXAub3RoZXIuZ3JvdXApID09PSAwKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Ly8gT25seSBjaGVjayBmb3IgZGlyZWN0aW9uIGlmIHRoZSBvdmVybGFwIHdhcyBjb2xsaWRhYmxlXHJcblx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XHJcblx0XHRcdFx0XHRsZXQgY29sbGlzaW9uU2lkZSA9IG92ZXJsYXAuY29sbGlkZXIudG91Y2hlc0FBQkJXaXRob3V0Q29ybmVycyhub2RlLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpKTtcclxuXHRcdFx0XHRcdGlmKGNvbGxpc2lvblNpZGUgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSB0b3VjaCwgbm90IGluY2x1ZGluZyBjb3JuZXIgY2FzZXMsIGNoZWNrIHRoZSBjb2xsaXNpb24gbm9ybWFsXHJcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAuaGl0ICE9PSBudWxsKXtcclxuXHRcdFx0XHRcdFx0XHQvLyBJZiB3ZSBoaXQgYSB0aWxlbWFwLCBrZWVwIHRyYWNrIG9mIGl0XHJcblx0XHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09IFwiVGlsZW1hcFwiKXtcclxuXHRcdFx0XHRcdFx0XHRcdG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZihjb2xsaXNpb25TaWRlLnkgPT09IC0xKXtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgaXMgb24gdG9wIG9mIG92ZXJsYXAsIHNvIG9uR3JvdW5kXHJcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uR3JvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoY29sbGlzaW9uU2lkZS55ID09PSAxKXtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgaXMgb24gYm90dG9tIG9mIG92ZXJsYXAsIHNvIG9uQ2VpbGluZ1xyXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5vbkNlaWxpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBOb2RlIHdhc24ndCB0b3VjaGluZyBvbiB5LCBzbyBpdCBpcyB0b3VjaGluZyBvbiB4XHJcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uV2FsbCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBjb2xsaXNpb24gd2l0aCB0aGUgbm9kZSwgYW5kIG1vdmUgaXRcclxuXHRcdFx0bm9kZS5maW5pc2hNb3ZlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBIYW5kbGVzIGEgY29sbGlzaW9uIGJldHdlZW4gdGhpcyBub2RlIGFuZCBhbiBvcnRob2dvbmFsIHRpbGVtYXBcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZVxyXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRoZSBub2RlIG1heSBiZSBjb2xsaWRpbmcgd2l0aFxyXG5cdCAqIEBwYXJhbSBvdmVybGFwcyBUaGUgbGlzdCBvZiBvdmVybGFwc1xyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBjb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGU6IFBoeXNpY2FsLCB0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcCwgb3ZlcmxhcHM6IEFycmF5PEFyZWFDb2xsaXNpb24+KTogdm9pZCB7XHJcblx0XHQvLyBHZXQgdGhlIG1pbiBhbmQgbWF4IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdmluZyBub2RlXHJcblx0XHRsZXQgbWluID0gbmV3IFZlYzIobm9kZS5zd2VwdFJlY3QubGVmdCwgbm9kZS5zd2VwdFJlY3QudG9wKTtcclxuXHRcdGxldCBtYXggPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5yaWdodCwgbm9kZS5zd2VwdFJlY3QuYm90dG9tKTtcclxuXHJcblx0XHQvLyBDb252ZXJ0IHRoZSBtaW4vbWF4IHgveSB0byB0aGUgbWluIGFuZCBtYXggcm93L2NvbCBpbiB0aGUgdGlsZW1hcCBhcnJheVxyXG5cdFx0bGV0IG1pbkluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtaW4pO1xyXG5cdFx0bGV0IG1heEluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtYXgpO1xyXG5cclxuXHRcdGxldCB0aWxlU2l6ZSA9IHRpbGVtYXAuZ2V0VGlsZVNpemUoKTtcclxuXHJcblx0XHQvLyBMb29wIG92ZXIgYWxsIHBvc3NpYmxlIHRpbGVzICh3aGljaCBpc24ndCBtYW55IGluIHRoZSBzY29wZSBvZiB0aGUgdmVsb2NpdHkgcGVyIGZyYW1lKVxyXG5cdFx0Zm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xyXG5cdFx0XHRmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XHJcblx0XHRcdFx0aWYodGlsZW1hcC5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XHJcblx0XHRcdFx0XHQvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxyXG5cdFx0XHRcdFx0bGV0IHRpbGVQb3MgPSBuZXcgVmVjMihjb2wgKiB0aWxlU2l6ZS54ICsgdGlsZVNpemUueC8yLCByb3cgKiB0aWxlU2l6ZS55ICsgdGlsZVNpemUueS8yKTtcclxuXHJcblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgY29sbGlkZXIgZm9yIHRoaXMgdGlsZVxyXG5cdFx0XHRcdFx0bGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xyXG5cclxuXHRcdFx0XHRcdC8vIENhbGN1bGF0ZSBjb2xsaXNpb24gYXJlYSBiZXR3ZWVuIHRoZSBub2RlIGFuZCB0aGUgdGlsZVxyXG5cdFx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XHJcblx0XHRcdFx0XHRpZihhcmVhID4gMCl7XHJcblx0XHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxyXG5cdFx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCB0aWxlbWFwLCBcIlRpbGVtYXBcIiwgbmV3IFZlYzIoY29sLCByb3cpKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IHBoeXNpY3MgbWFuYWdlci5cclxuICogVGhpcyBjbGFzcyBleHBvc2VzIGZ1bmN0aW9ucyBmb3Igc3ViY2xhc3NlcyB0byBpbXBsZW1lbnQgdGhhdCBzaG91bGQgYWxsb3cgZm9yIGEgd29ya2luZyBwaHlzaWNzIHN5c3RlbSB0byBiZSBjcmVhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUGh5c2ljc01hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHQvKiogVGhlIGV2ZW50IHJlY2VpdmVyIGZvciB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cclxuXHRwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cdC8qKiBUaGUgZXZlbnQgZW1pdHRlciBmb3IgdGhlIHBoeXNpY3Mgc3lzdGVtICovXHJcblx0cHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG5cdC8qKiBNYXBzIGxheWVyIG5hbWVzIHRvIG51bWJlcnMgKi9cclxuXHRwcm90ZWN0ZWQgZ3JvdXBNYXA6IE1hcDxudW1iZXI+O1xyXG5cclxuXHQvKiogTWFwcyBsYXllciBudW1iZXJzIHRvIG5hbWVzICovXHJcblx0cHJvdGVjdGVkIGdyb3VwTmFtZXM6IEFycmF5PHN0cmluZz47XHJcblxyXG5cdC8qKiBUaGUgZGVmYXVsdCBncm91cCBuYW1lICovXHJcblx0cHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0dST1VQID0gXCJEZWZhdWx0XCI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuXHRcdC8vIFRoZSBjcmVhdGlvbiBhbmQgaW1wbGVtZW50YXRpb24gb2YgbGF5ZXJzIGlzIGRlZmVycmVkIHRvIHRoZSBzdWJjbGFzc1xyXG5cdFx0dGhpcy5ncm91cE1hcCA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMuZ3JvdXBOYW1lcyA9IG5ldyBBcnJheSgpO1xyXG5cdH1cclxuXHJcblx0ZGVzdHJveSgpOiB2b2lkIHtcclxuXHRcdHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIGEgZ2FtZW5vZGUgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxyXG5cdCAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byByZWdpc3RlclxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IHJlZ2lzdGVyT2JqZWN0KG9iamVjdDogUGh5c2ljYWwpOiB2b2lkO1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcclxuXHQgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZGVyZWdpc3RlclxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IGRlcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhIHRpbGVtYXAgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxyXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRvIHJlZ2lzdGVyXHJcblx0ICovXHJcblx0YWJzdHJhY3QgcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhpcyB0aWxlbWFwIGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcclxuXHJcblx0YWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgcGh5c2ljcyBsYXllciBvZiB0aGUgR2FtZU5vZGVcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGVcclxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIGdyb3VwIHRoYXQgdGhlIEdhbWVOb2RlIHNob3VsZCBiZSBvblxyXG5cdCAqL1xyXG5cdHNldEdyb3VwKG5vZGU6IFBoeXNpY2FsLCBncm91cDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHRub2RlLmdyb3VwID0gdGhpcy5ncm91cE1hcC5nZXQoZ3JvdXApO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0cmlldmVzIHRoZSBsYXllciBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXHJcblx0ICogQHBhcmFtIGxheWVyIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG5cdCAqIEByZXR1cm5zIFRoZSBsYXllciBudW1iZXIsIG9yIDAgaWYgdGhlcmUgaXMgbm90IGEgbGF5ZXIgd2l0aCB0aGF0IG5hbWUgcmVnaXN0ZXJlZFxyXG5cdCAqL1xyXG5cdGdldEdyb3VwTnVtYmVyKGdyb3VwOiBzdHJpbmcpOiBudW1iZXIge1xyXG5cdFx0aWYodGhpcy5ncm91cE1hcC5oYXMoZ3JvdXApKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBNYXAuZ2V0KGdyb3VwKTtcclxuXHRcdH0gZWxzZXtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIGFsbCBncm91cCBuYW1lcyBhc3NvY2lhdGVkIHdpdGggdGhlIG51bWJlciBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSBncm91cHMgQSBtYXNrIG9mIGdyb3Vwc1xyXG5cdCAqIEByZXR1cm5zIEFsbCBncm91cHMgY29udGFpbmVkIGluIHRoZSBtYXNrXHJcblx0ICovXHJcblx0Z2V0R3JvdXBOYW1lcyhncm91cHM6IG51bWJlcik6IEFycmF5PHN0cmluZz4ge1xyXG5cdFx0aWYoZ3JvdXBzID09PSAtMSl7XHJcblx0XHRcdHJldHVybiBbUGh5c2ljc01hbmFnZXIuREVGQVVMVF9HUk9VUF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgZyA9IDE7XHJcblx0XHRcdGxldCBuYW1lcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IDMyOyBpKyspe1xyXG5cdFx0XHRcdGlmKGcgJiBncm91cHMpe1xyXG5cdFx0XHRcdFx0Ly8gVGhpcyBncm91cCBpcyBpbiB0aGUgZ3JvdXBzIG51bWJlclxyXG5cdFx0XHRcdFx0bmFtZXMucHVzaCh0aGlzLmdyb3VwTmFtZXNbaV0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gU2hpZnQgdGhlIGJpdCBvdmVyXHJcblx0XHRcdFx0ZyA9IGcgPDwgMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNvcmRlciB7XHJcblx0cHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblx0cHJpdmF0ZSBsb2c6IFF1ZXVlPExvZ0l0ZW0+O1xyXG5cdHByaXZhdGUgcmVjb3JkaW5nOiBib29sZWFuO1xyXG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuXHRwcml2YXRlIGZyYW1lOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBwbGF5aW5nOiBib29sZWFuO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG5cdFx0dGhpcy5sb2cgPSBuZXcgUXVldWUoMTAwMCk7XHJcblx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmZyYW1lID0gMDtcclxuXHJcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcblx0XHR0aGlzLmV2ZW50UXVldWUuc3Vic2NyaWJlKHRoaXMucmVjZWl2ZXIsIFwiYWxsXCIpO1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLnJlY29yZGluZyl7XHJcblx0XHRcdHRoaXMuZnJhbWUgKz0gMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLnBsYXlpbmcpe1xyXG5cdFx0XHQvLyBJZiBwbGF5aW5nLCBpZ25vcmUgZXZlbnRzLCBqdXN0IGZlZWQgdGhlIHJlY29yZCB0byB0aGUgZXZlbnQgcXVldWVcclxuXHRcdFx0dGhpcy5yZWNlaXZlci5pZ25vcmVFdmVudHMoKTtcclxuXHJcblx0XHRcdC8qXHJcblx0XHRcdFx0V2hpbGUgdGhlcmUgaXMgYSBuZXh0IGl0ZW0sIGFuZCB3aGlsZSBpdCBzaG91bGQgb2NjdXIgaW4gdGhpcyBmcmFtZSxcclxuXHRcdFx0XHRzZW5kIHRoZSBldmVudC4gaS5lLiwgd2hpbGUgY3VycmVudF9mcmFtZSAqIGN1cnJlbnRfZGVsdGFfdCBpcyBncmVhdGVyXHJcblx0XHRcdFx0dGhhbiByZWNvcmRlZF9mcmFtZSAqIHJlY29yZGVkX2RlbHRhX3RcclxuXHRcdFx0Ki9cclxuXHRcdFx0d2hpbGUodGhpcy5sb2cuaGFzSXRlbXMoKVxyXG5cdFx0XHRcdFx0JiYgdGhpcy5sb2cucGVla05leHQoKS5mcmFtZSAqIHRoaXMubG9nLnBlZWtOZXh0KCkuZGVsdGEgPCB0aGlzLmZyYW1lICogZGVsdGFUKXtcclxuXHRcdFx0XHRsZXQgZXZlbnQgPSB0aGlzLmxvZy5kZXF1ZXVlKCkuZXZlbnQ7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coZXZlbnQpO1xyXG5cdFx0XHRcdHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChldmVudCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKCF0aGlzLmxvZy5oYXNJdGVtcygpKXtcclxuXHRcdFx0XHR0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5mcmFtZSArPSAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gSWYgbm90IHBsYXlpbmcsIGhhbmRsZSBldmVudHNcclxuXHRcdFx0d2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XHJcblx0XHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcblx0XHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5TVE9QX1JFQ09SRElORyl7XHJcblx0XHRcdFx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYodGhpcy5yZWNvcmRpbmcpe1xyXG5cdFx0XHRcdFx0dGhpcy5sb2cuZW5xdWV1ZShuZXcgTG9nSXRlbSh0aGlzLmZyYW1lLCBkZWx0YVQsIGV2ZW50KSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlNUQVJUX1JFQ09SRElORyl7XHJcblx0XHRcdFx0XHR0aGlzLmxvZy5jbGVhcigpO1xyXG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0dGhpcy5mcmFtZSA9IDBcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9SRUNPUkRJTkcpe1xyXG5cdFx0XHRcdFx0dGhpcy5mcmFtZSA9IDA7XHJcblx0XHRcdFx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0dGhpcy5wbGF5aW5nID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmNsYXNzIExvZ0l0ZW0ge1xyXG5cdGZyYW1lOiBudW1iZXI7XHJcblx0ZGVsdGE6IG51bWJlcjtcclxuXHRldmVudDogR2FtZUV2ZW50O1xyXG5cclxuXHRjb25zdHJ1Y3RvcihmcmFtZTogbnVtYmVyLCBkZWx0YVQ6IG51bWJlciwgZXZlbnQ6IEdhbWVFdmVudCl7XHJcblx0XHR0aGlzLmZyYW1lID0gZnJhbWU7XHJcblx0XHR0aGlzLmRlbHRhID0gZGVsdGFUO1xyXG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xyXG5cdH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlZ2lzdHJ5PFQ+IGV4dGVuZHMgTWFwPFQ+e1xyXG5cclxuICAgIC8qKiBQcmVsb2FkcyByZWdpc3RyeSBkYXRhICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgcHJlbG9hZCgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGFuIGl0ZW0gYW5kIHByZWxvYWRzIGFueSBuZWNlc3NhcnkgZmlsZXNcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZWdpc3RlciB0aGlzIGl0ZW0gd2l0aFxyXG4gICAgICogQHBhcmFtIGFyZ3MgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIG5lZWRlZCBmb3IgcmVnaXN0cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nLCAuLi5hcmdzOiBhbnkpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGFuIGl0ZW0gYW5kIHByZWxvYWRzIGFueSBuZWNlc3NhcnkgZmlsZXNcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZWdpc3RlciB0aGlzIGl0ZW0gd2l0aFxyXG4gICAgICogQHBhcmFtIGFyZ3MgQW55IGFkaXRpb25hbCBhcmd1bWVudHMgbmVlZGVkIGZvciByZWdpc3RyYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IHJlZ2lzdGVySXRlbShrZXk6IHN0cmluZywgLi4uYXJnczogYW55KTogdm9pZDtcclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlXCI7XHJcbmltcG9ydCBMYWJlbFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9MYWJlbFNoYWRlclR5cGVcIjtcclxuaW1wb3J0IFBvaW50U2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1BvaW50U2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgUmVjdFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgU3ByaXRlU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1Nwcml0ZVNoYWRlclR5cGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cnlcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHJlZ2lzdHJ5IHRoYXQgaGFuZGxlcyBzaGFkZXJzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJSZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5PFNoYWRlclR5cGU+IHtcclxuXHJcblx0Ly8gU2hhZGVyIG5hbWVzXHJcblx0cHVibGljIHN0YXRpYyBQT0lOVF9TSEFERVIgPSBcInBvaW50XCI7XHJcblx0cHVibGljIHN0YXRpYyBSRUNUX1NIQURFUiA9IFwicmVjdFwiO1xyXG5cdHB1YmxpYyBzdGF0aWMgU1BSSVRFX1NIQURFUiA9IFwic3ByaXRlXCI7XHJcblx0cHVibGljIHN0YXRpYyBMQUJFTF9TSEFERVIgPSBcImxhYmVsXCI7XHJcblxyXG5cdHByaXZhdGUgcmVnaXN0cnlJdGVtczogQXJyYXk8U2hhZGVyUmVnaXN0cnlJdGVtPiA9IG5ldyBBcnJheSgpO1xyXG5cclxuXHQvKipcclxuXHQgKiBQcmVsb2FkcyBhbGwgYnVpbHQtaW4gc2hhZGVyc1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmVsb2FkKCl7XHJcblx0XHQvLyBHZXQgdGhlIHJlc291cmNlTWFuYWdlciBhbmQgcXVldWUgYWxsIGJ1aWx0LWluIHNoYWRlcnMgZm9yIHByZWxvYWRpbmdcclxuXHRcdGNvbnN0IHJtID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblxyXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgcG9pbnQgc2hhZGVyXHJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuUE9JTlRfU0hBREVSLCBQb2ludFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3BvaW50LnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvcG9pbnQuZnNoYWRlclwiKTtcclxuXHJcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSByZWN0IHNoYWRlclxyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlJFQ1RfU0hBREVSLCBSZWN0U2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvcmVjdC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3JlY3QuZnNoYWRlclwiKTtcclxuXHJcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBzcHJpdGUgc2hhZGVyXHJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUiwgU3ByaXRlU2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvc3ByaXRlLnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvc3ByaXRlLmZzaGFkZXJcIik7XHJcblx0XHJcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBsYWJlbCBzaGFkZXJcclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5MQUJFTF9TSEFERVIsIExhYmVsU2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvbGFiZWwudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9sYWJlbC5mc2hhZGVyXCIpO1xyXG5cclxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgYW55IHByZWxvYWRlZCBpdGVtc1xyXG5cdFx0Zm9yKGxldCBpdGVtIG9mIHRoaXMucmVnaXN0cnlJdGVtcyl7XHJcblx0XHRcdGNvbnN0IHNoYWRlciA9IG5ldyBpdGVtLmNvbnN0cihpdGVtLmtleSk7XHJcblx0XHRcdHNoYWRlci5pbml0QnVmZmVyT2JqZWN0KCk7XHJcblx0XHRcdHRoaXMuYWRkKGl0ZW0ua2V5LCBzaGFkZXIpO1xyXG5cclxuXHRcdFx0Ly8gTG9hZCBpZiBkZXNpcmVkXHJcblx0XHRcdGlmKGl0ZW0ucHJlbG9hZCAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0XHRybS5zaGFkZXIoaXRlbS5rZXksIGl0ZW0ucHJlbG9hZC52c2hhZGVyTG9jYXRpb24sIGl0ZW0ucHJlbG9hZC5mc2hhZGVyTG9jYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgYSBzaGFkZXIgaW4gdGhlIHJlZ2lzdHJ5IGFuZCBsb2FkcyBpdCBiZWZvcmUgdGhlIGdhbWUgYmVnaW5zXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHlvdSB3aXNoIHRvIGFzc2lnbiB0byB0aGUgc2hhZGVyXHJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIFNoYWRlclR5cGVcclxuXHQgKiBAcGFyYW0gdnNoYWRlckxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvZiB0aGUgdmVydGV4IHNoYWRlclxyXG5cdCAqIEBwYXJhbSBmc2hhZGVyTG9jYXRpb24gdGhlIGxvY2F0aW9uIG9mIHRoZSBmcmFnbWVudCBzaGFkZXJcclxuXHQgKi9cclxuXHRwdWJsaWMgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZywgY29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZSwgdnNoYWRlckxvY2F0aW9uOiBzdHJpbmcsIGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nKTogdm9pZCB7XHJcblx0XHRsZXQgc2hhZGVyUHJlbG9hZCA9IG5ldyBTaGFkZXJQcmVsb2FkKCk7XHJcblx0XHRzaGFkZXJQcmVsb2FkLnZzaGFkZXJMb2NhdGlvbiA9IHZzaGFkZXJMb2NhdGlvbjtcclxuXHRcdHNoYWRlclByZWxvYWQuZnNoYWRlckxvY2F0aW9uID0gZnNoYWRlckxvY2F0aW9uO1xyXG5cclxuXHRcdGxldCByZWdpc3RyeUl0ZW0gPSBuZXcgU2hhZGVyUmVnaXN0cnlJdGVtKCk7XHJcblx0XHRyZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xyXG5cdFx0cmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcclxuXHRcdHJlZ2lzdHJ5SXRlbS5wcmVsb2FkID0gc2hhZGVyUHJlbG9hZDtcclxuXHJcblx0XHR0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIGEgc2hhZGVyIGluIHRoZSByZWdpc3RyeS4gTk9URTogSWYgeW91IHVzZSB0aGlzLCB5b3UgTVVTVCBsb2FkIHRoZSBzaGFkZXIgYmVmb3JlIHVzZS5cclxuXHQgKiBJZiB5b3Ugd2lzaCB0byBwcmVsb2FkIHRoZSBzaGFkZXIsIHVzZSByZWdpc3RlckFuZFByZWxvYWRJdGVtKClcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgeW91IHdpc2ggdG8gYXNzaWduIHRvIHRoZSBzaGFkZXJcclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgU2hhZGVyVHlwZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGUpOiB2b2lkIHtcclxuXHRcdGxldCByZWdpc3RyeUl0ZW0gPSBuZXcgU2hhZGVyUmVnaXN0cnlJdGVtKCk7XHJcblx0XHRyZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xyXG5cdFx0cmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcclxuXHJcblx0XHR0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgU2hhZGVyUmVnaXN0cnlJdGVtIHtcclxuXHRrZXk6IHN0cmluZztcclxuXHRjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlO1xyXG5cdHByZWxvYWQ6IFNoYWRlclByZWxvYWQ7XHJcbn1cclxuXHJcbmNsYXNzIFNoYWRlclByZWxvYWQge1xyXG5cdHZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xyXG5cdGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cmllcy9SZWdpc3RyeVwiO1xyXG5pbXBvcnQgU2hhZGVyUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBSZWdpc3RyeSBpcyB0aGUgc3lzdGVtJ3Mgd2F5IG9mIGNvbnZlcnRpbmcgY2xhc3NlcyBhbmQgdHlwZXMgaW50byBzdHJpbmdcclxuICogcmVwcmVzZW50YXRpb25zIGZvciB1c2UgZWxzZXdoZXJlIGluIHRoZSBhcHBsaWNhdGlvbi5cclxuICogSXQgYWxsb3dzIGNsYXNzZXMgdG8gYmUgYWNjZXNzZWQgd2l0aG91dCBleHBsaWNpdGx5IHVzaW5nIGNvbnN0cnVjdG9ycyBpbiBjb2RlLFxyXG4gKiBhbmQgZm9yIHJlc291cmNlcyB0byBiZSBsb2FkZWQgYXQgR2FtZSBjcmVhdGlvbiB0aW1lLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVnaXN0cnlNYW5hZ2VyIHtcclxuXHJcblx0cHVibGljIHN0YXRpYyBzaGFkZXJzID0gbmV3IFNoYWRlclJlZ2lzdHJ5KCk7XHJcblxyXG5cdC8qKiBBZGRpdGlvbmFsIGN1c3RvbSByZWdpc3RyaWVzIHRvIGFkZCB0byB0aGUgcmVnaXN0cnkgbWFuYWdlciAqL1xyXG5cdHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0cmllczogTWFwPFJlZ2lzdHJ5PGFueT4+ID0gbmV3IE1hcCgpO1xyXG5cclxuXHRzdGF0aWMgcHJlbG9hZCgpe1xyXG5cdFx0dGhpcy5zaGFkZXJzLnByZWxvYWQoKTtcclxuXHJcblx0XHR0aGlzLnJlZ2lzdHJpZXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHRoaXMucmVnaXN0cmllcy5nZXQoa2V5KS5wcmVsb2FkKCkpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGFkZEN1c3RvbVJlZ2lzdHJ5KG5hbWU6IHN0cmluZywgcmVnaXN0cnk6IFJlZ2lzdHJ5PGFueT4pe1xyXG5cdFx0dGhpcy5yZWdpc3RyaWVzLmFkZChuYW1lLCByZWdpc3RyeSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0UmVnaXN0cnkoa2V5OiBzdHJpbmcpe1xyXG5cdFx0cmV0dXJuIHRoaXMucmVnaXN0cmllcy5nZXQoa2V5KTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgeyBBbmltYXRpb25EYXRhLCBBbmltYXRpb25TdGF0ZSB9IGZyb20gXCIuL0FuaW1hdGlvblR5cGVzXCI7XHJcblxyXG4vKipcclxuICogQW4gYW5pbWF0aW9uIG1hbmFnZXIgY2xhc3MgZm9yIGFuIGFuaW1hdGVkIENhbnZhc05vZGUuXHJcbiAqIFRoaXMgY2xhc3Mga2VlcHMgdHJhY2sgb2YgdGhlIHBvc3NpYmxlIGFuaW1hdGlvbnMsIGFzIHdlbGwgYXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlLFxyXG4gKiBhbmQgYWJzdHJhY3RzIGFsbCBpbnRlcmFjdGlvbnMgd2l0aCBwbGF5aW5nLCBwYXVzaW5nLCBhbmQgc3RvcHBpbmcgYW5pbWF0aW9ucyBhcyB3ZWxsIGFzIFxyXG4gKiBjcmVhdGluZyBuZXcgYW5pbWF0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uTWFuYWdlciB7XHJcbiAgICAvKiogVGhlIG93bmVyIG9mIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cclxuICAgIHByb3RlY3RlZCBvd25lcjogQ2FudmFzTm9kZTtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSBvZiB0aGlzIHNwcml0ZSAqL1xyXG4gICAgcHJvdGVjdGVkIGFuaW1hdGlvblN0YXRlOiBBbmltYXRpb25TdGF0ZTtcclxuXHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIG9mIHRoaXMgc3ByaXRlICovXHJcbiAgICBwcm90ZWN0ZWQgY3VycmVudEFuaW1hdGlvbjogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGlzIGFuaW1hdGlvbiAqL1xyXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRGcmFtZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHRocm91Z2ggdGhlIGN1cnJlbnQgZnJhbWUgKi9cclxuICAgIHByb3RlY3RlZCBmcmFtZVByb2dyZXNzOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGxvb3Bpbmcgb3Igbm90ICovXHJcbiAgICBwcm90ZWN0ZWQgbG9vcDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIG1hcCBvZiBhbmltYXRpb25zICovXHJcbiAgICBwcm90ZWN0ZWQgYW5pbWF0aW9uczogTWFwPEFuaW1hdGlvbkRhdGE+O1xyXG5cclxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGlmIGFueSkgdG8gc2VuZCB3aGVuIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdG9wcyBwbGF5aW5nLiAqL1xyXG4gICAgcHJvdGVjdGVkIG9uRW5kRXZlbnQ6IHN0cmluZztcclxuXHJcbiAgICAvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cclxuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAgIC8qKiBBIHF1ZXVlZCBhbmltYXRpb24gKi9cclxuICAgIHByb3RlY3RlZCBwZW5kaW5nQW5pbWF0aW9uOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIFRoZSBsb29wIHN0YXR1cyBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXHJcbiAgICBwcm90ZWN0ZWQgcGVuZGluZ0xvb3A6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBvbkVuZCBldmVudCBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXHJcbiAgICBwcm90ZWN0ZWQgcGVuZGluZ09uRW5kOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFuaW1hdGlvbk1hbmFnZXJcclxuICAgICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgb2YgdGhlIEFuaW1hdGlvbk1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3duZXI6IENhbnZhc05vZGUpe1xyXG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gYW5pbWF0aW9uIHRvIHRoaXMgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5IG9mIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiBkYXRhXHJcbiAgICAgKi9cclxuICAgIGFkZChrZXk6IHN0cmluZywgYW5pbWF0aW9uOiBBbmltYXRpb25EYXRhKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmFkZChrZXksIGFuaW1hdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBzcGVjaWZpZWQgYnkgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCBjdXJyZW50IGZyYW1lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggaW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4KCk6IG51bWJlciB7XHJcbiAgICAgICAgaWYodGhpcy5hbmltYXRpb25zLmhhcyh0aGlzLmN1cnJlbnRBbmltYXRpb24pKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9ucy5nZXQodGhpcy5jdXJyZW50QW5pbWF0aW9uKS5mcmFtZXNbdGhpcy5jdXJyZW50RnJhbWVdLmluZGV4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCB3YXJuIHRoZSB1c2VyXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5pbWF0aW9uIGluZGV4IHdhcyByZXF1ZXN0ZWQsIGJ1dCB0aGUgY3VycmVudCBhbmltYXRpb246ICR7dGhpcy5jdXJyZW50QW5pbWF0aW9ufSB3YXMgaW52YWxpZGApO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBhbmltYXRpb24gaXMgY3VycmVudGx5IHBsYXlpbmdcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYW5pbWF0aW9uIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIGlzIHBsYXlpbmcsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBpc1BsYXlpbmcoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbWF0aW9uID09PSBrZXkgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBhbmltYXRpb24gaW5kZXggYW5kIGFkdmFuY2VzIHRoZSBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpOiBudW1iZXIge1xyXG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCBwbGF5aW5nLCB3ZSB3b24ndCBiZSBhZHZhbmNpbmcgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgIGlmKCEodGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORykpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbmRleCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5hbmltYXRpb25zLmhhcyh0aGlzLmN1cnJlbnRBbmltYXRpb24pKXtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KHRoaXMuY3VycmVudEFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5pbmRleDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgKz0gMTtcclxuICAgICAgICAgICAgaWYodGhpcy5mcmFtZVByb2dyZXNzID49IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5kdXJhdGlvbil7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gb24gdGhpcyBmcmFtZSBmb3IgaXRzIHdob2xlIGR1cmF0aW9uLCBnbyB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudEZyYW1lID49IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhpcyBhbmltYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmxvb3Ape1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDdXJyZW50QW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCBjYW4ndCBhZHZhbmNlLiBXYXJuIHRoZSB1c2VyXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5pbWF0aW9uIGluZGV4IGFuZCBhZHZhbmNlIHdhcyByZXF1ZXN0ZWQsIGJ1dCB0aGUgY3VycmVudCBhbmltYXRpb24gKCR7dGhpcy5jdXJyZW50QW5pbWF0aW9ufSkgaW4gbm9kZSB3aXRoIGlkOiAke3RoaXMub3duZXIuaWR9IHdhcyBpbnZhbGlkYCk7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogRW5kcyB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIGZpcmVzIGFueSBuZWNlc3NhcnkgZXZlbnRzLCBhcyB3ZWxsIGFzIHN0YXJ0aW5nIGFueSBuZXcgYW5pbWF0aW9ucyAqL1xyXG4gICAgcHJvdGVjdGVkIGVuZEN1cnJlbnRBbmltYXRpb24oKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG5cclxuICAgICAgICBpZih0aGlzLm9uRW5kRXZlbnQgIT09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25FbmRFdmVudCwge293bmVyOiB0aGlzLm93bmVyLmlkLCBhbmltYXRpb246IHRoaXMuY3VycmVudEFuaW1hdGlvbn0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGFuaW1hdGlvbiwgcGxheSBpdFxyXG4gICAgICAgIGlmKHRoaXMucGVuZGluZ0FuaW1hdGlvbiAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMucGxheSh0aGlzLnBlbmRpbmdBbmltYXRpb24sIHRoaXMucGVuZGluZ0xvb3AsIHRoaXMucGVuZGluZ09uRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gRG9lcyBub3QgcmVzdGFydCBpdCBpZiBpdCBpcyBhbHJlYWR5IHBsYXlpbmdcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBwbGF5XHJcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBhbmltYXRpb24uIEZhbHNlIGJ5IGRlZmF1bHRcclxuICAgICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHBsYXlJZk5vdEFscmVhZHkoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A/OiBib29sZWFuLCBvbkVuZD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMuY3VycmVudEFuaW1hdGlvbiAhPT0gYW5pbWF0aW9uKXtcclxuICAgICAgICAgICAgdGhpcy5wbGF5KGFuaW1hdGlvbiwgbG9vcCwgb25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxyXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgYW5pbWF0aW9uLiBGYWxzZSBieSBkZWZhdWx0XHJcbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIG5hbWUgb2YgYW4gZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgYW5pbWF0aW9uIG5hdHVyYWxseSBzdG9wcyBwbGF5aW5nLiBUaGlzIG9ubHkgbWF0dGVycyBpZiBsb29wIGlzIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBwbGF5KGFuaW1hdGlvbjogc3RyaW5nLCBsb29wPzogYm9vbGVhbiwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcblxyXG4gICAgICAgIC8vIElmIGxvb3AgYXJnIHdhcyBwcm92aWRlZCwgdXNlIHRoYXRcclxuICAgICAgICBpZihsb29wICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHdoYXQgdGhlIGpzb24gZmlsZSBzcGVjaWZpZWRcclxuICAgICAgICAgICAgdGhpcy5sb29wID0gdGhpcy5hbmltYXRpb25zLmdldChhbmltYXRpb24pLnJlcGVhdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG9uRW5kICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBvbkVuZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzZXQgcGVuZGluZyBhbmltYXRpb25cclxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUXVldWVzIGEgc2luZ2xlIGFuaW1hdGlvbiB0byBiZSBwbGF5ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLiBEb2VzIE5PVCBzdGFjay5cclxuICAgICAqIFF1ZXVlaW5nIGFkZGl0aW9uYWwgYW5pbWF0aW9ucyBwYXN0IDEgd2lsbCBqdXN0IHJlcGxhY2UgdGhlIHF1ZXVlZCBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiB0byBxdWV1ZVxyXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIGxvb3AgdGhlIHF1ZXVlZCBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBvbkVuZCBUaGUgZXZlbnQgdG8gZmlyZSB3aGVuIHRoZSBxdWV1ZWQgYW5pbWF0aW9uIGVuZHNcclxuICAgICAqL1xyXG4gICAgcXVldWUoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4gPSBmYWxzZSwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9vcCA9IGxvb3A7XHJcbiAgICAgICAgaWYob25FbmQgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ09uRW5kID0gb25FbmQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nT25FbmQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogUGF1c2VzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiAqL1xyXG4gICAgcGF1c2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBBVVNFRDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVzdW1lcyB0aGUgY3VycmVudCBhbmltYXRpb24gaWYgcG9zc2libGUgKi9cclxuICAgIHJlc3VtZSgpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpe1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFN0b3BzIHRoZSBjdXJyZW50IGFuaW1hdGlvbi4gVGhlIGFuaW1hdGlvbiBjYW5ub3QgYmUgcmVzdW1lZCBhZnRlciB0aGlzLiAqL1xyXG4gICAgc3RvcCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuICAgIH1cclxufSIsImltcG9ydCB7IFR3ZWVuYWJsZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IHsgRWFzZUZ1bmN0aW9uVHlwZSB9IGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuZXhwb3J0IGVudW0gQW5pbWF0aW9uU3RhdGUge1xyXG4gICAgU1RPUFBFRCA9IDAsXHJcbiAgICBQQVVTRUQgPSAxLFxyXG4gICAgUExBWUlORyA9IDIsXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBbmltYXRpb25EYXRhIHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGZyYW1lczogQXJyYXk8e2luZGV4OiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXJ9PjtcclxuICAgIHJlcGVhdDogYm9vbGVhbiA9IGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHdlZW5FZmZlY3Qge1xyXG4gICAgLyoqIFRoZSBwcm9wZXJ0eSB0byB0d2VlbiAqL1xyXG4gICAgcHJvcGVydHk6IFR3ZWVuYWJsZVByb3BlcnRpZXM7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBUd2VlbiBzaG91bGQgcmVzZXQgdGhlIHByb3BlcnR5IHRvIGl0cyBvcmlnaW5hbCB2YWx1ZSBhZnRlciBwbGF5aW5nICovXHJcbiAgICByZXNldE9uQ29tcGxldGU6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIHR3ZWVuICovXHJcbiAgICBzdGFydDogYW55O1xyXG5cclxuICAgIC8qKiBUaGUgZW5kaW5nIHZhbHVlIGZvciB0aGUgdHdlZW4gKi9cclxuICAgIGVuZDogYW55O1xyXG5cclxuICAgIC8qKiBUaGUgZWFzZSBmdW5jdGlvbiB0byB1c2UgKi9cclxuICAgIGVhc2U6IEVhc2VGdW5jdGlvblR5cGU7XHJcblxyXG4gICAgLyoqIERPIE5PVCBNT0RJRlkgLSBUaGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5IC0gc2V0IGF1dG9tYXRpY2FsbHkgKi9cclxuICAgIGluaXRpYWxWYWx1ZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHdlZW5EYXRhIHtcclxuICAgIC8vIE1lbWJlcnMgZm9yIGluaXRpYWxpemF0aW9uIGJ5IHRoZSB1c2VyXHJcbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgdHdlZW4gKi9cclxuICAgIHN0YXJ0RGVsYXk6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgZHVyYXRpb24gb2YgdGltZSBvdmVyIHdoaWNoIHRoZSB2YWx1ZSB3aXRoIGNoYW5nZSBmcm9tIHN0YXJ0IHRvIGVuZCAqL1xyXG4gICAgZHVyYXRpb246IG51bWJlcjtcclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgZWZmZWN0cyBvbiB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0ICovXHJcbiAgICBlZmZlY3RzOiBBcnJheTxUd2VlbkVmZmVjdD47XHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBzaG91bGQgcmV2ZXJzZSBmcm9tIGVuZCB0byBzdGFydCBmb3IgZWFjaCBwcm9wZXJ0eSB3aGVuIGl0IGZpbmlzaGVzICovXHJcbiAgICByZXZlcnNlT25Db21wbGV0ZTogYm9vbGVhbjtcclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIHNob3VsZCBsb29wIHdoZW4gaXQgY29tcGxldGVzICovXHJcbiAgICBsb29wOiBib29sZWFuO1xyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIChpZiBhbnkpIHdoZW4gdGhlIHR3ZWVuIGZpbmlzaGVzIHBsYXlpbmcgKi9cclxuICAgIG9uRW5kOiBzdHJpbmdcclxuICAgIFxyXG4gICAgLy8gTWVtYmVycyBmb3IgbWFuYWdlbWVudCBieSB0aGUgdHdlZW4gbWFuYWdlclxyXG4gICAgLyoqIFRoZSBwcm9ncmVzcyBvZiB0aGlzIHR3ZWVuIHRocm91Z2ggaXRzIGVmZmVjdHMgKi9cclxuICAgIHByb2dyZXNzOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0aGF0IGhhcyBwYXNzZWQgZnJvbSB3aGVuIHRoaXMgdHdlZW4gc3RhcnRlZCBydW5uaW5nICovXHJcbiAgICBlbGFwc2VkVGltZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgc3RhdGUgb2YgdGhpcyB0d2VlbiAqL1xyXG4gICAgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIGlzIGN1cnJlbnRseSByZXZlcnNpbmcgKi9cclxuICAgIHJldmVyc2luZzogYm9vbGVhbjtcclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgeyBBbmltYXRpb25TdGF0ZSwgVHdlZW5EYXRhIH0gZnJvbSBcIi4vQW5pbWF0aW9uVHlwZXNcIjtcclxuaW1wb3J0IEVhc2VGdW5jdGlvbnMgZnJvbSBcIi4uLy4uL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBUd2Vlbk1hbmFnZXIgZnJvbSBcIi4vVHdlZW5NYW5hZ2VyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWFuYWdlciBmb3IgdGhlIHR3ZWVucyBvZiBhIEdhbWVOb2RlLlxyXG4gKiBUd2VlbnMgYXJlIHNob3J0IGFuaW1hdGlvbnMgcGxheWVkIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiB0d28gcHJvcGVydGllcyB1c2luZyBhbiBlYXNpbmcgZnVuY3Rpb24uXHJcbiAqIEZvciBhIGdvb2QgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMsIGNoZWNrIG91dCBAbGluayhodHRwczovL2Vhc2luZ3MubmV0LykoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pLlxyXG4gKiBNdWx0aXBsZSB0d2VlbiBjYW4gYmUgcGxheWVkIGF0IHRoZSBzYW1lIHRpbWUsIGFzIGxvbmcgYXMgdGhleSBkb24ndCBjaGFuZ2UgdGhlIHNhbWUgcHJvcGVydHkuXHJcbiAqIFRoaXMgYWxsb3dzIGZvciBzb21lIGludGVyZXN0aW5nIHBvbGlzaGVzIG9yIGFuaW1hdGlvbnMgdGhhdCBtYXkgYmUgdmVyeSBkaWZmaWN1bHQgdG8gZG8gd2l0aCBzcHJpdGUgd29yayBhbG9uZVxyXG4gKiAtIGVzcGVjaWFsbHkgcGl4ZWwgYXJ0IChzdWNoIGFzIHJvdGF0aW9ucyBvciBzY2FsaW5nKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuQ29udHJvbGxlciB7XHJcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoaXMgVHdlZW5Db250cm9sbGVyIGFjdHMgdXBvbiAqL1xyXG4gICAgcHJvdGVjdGVkIG93bmVyOiBHYW1lTm9kZTtcclxuICAgIC8qKiBUaGUgbGlzdCBvZiBjcmVhdGVkIHR3ZWVucyAqL1xyXG4gICAgcHJvdGVjdGVkIHR3ZWVuczogTWFwPFR3ZWVuRGF0YT47XHJcbiAgICAvKiogQW4gZXZlbnQgZW1pdHRlciAqL1xyXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFR3ZWVuQ29udHJvbGxlclxyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgVHdlZW5Db250cm9sbGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG93bmVyOiBHYW1lTm9kZSl7XHJcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgICAgIHRoaXMudHdlZW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcblxyXG4gICAgICAgIC8vIEdpdmUgb3Vyc2VsdmVzIHRvIHRoZSBUd2Vlbk1hbmFnZXJcclxuICAgICAgICBUd2Vlbk1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5yZWdpc3RlclR3ZWVuQ29udHJvbGxlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgVHdlZW5Db250cm9sbGVyXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKXtcclxuICAgICAgICAvLyBPbmx5IHRoZSBnYW1lbm9kZSBhbmQgdGhlIHR3ZWVuIG1hbmFnZXIgc2hvdWxkIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhpc1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm93bmVyLnR3ZWVucztcclxuICAgICAgICBUd2Vlbk1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5kZXJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHdlZW4gdG8gdGhpcyBnYW1lIG5vZGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuXHJcbiAgICAgKiBAcGFyYW0gdHdlZW4gVGhlIGRhdGEgb2YgdGhlIHR3ZWVuXHJcbiAgICAgKi9cclxuICAgIGFkZChrZXk6IHN0cmluZywgdHdlZW46IFJlY29yZDxzdHJpbmcsIGFueT4gfCBUd2VlbkRhdGEpOiB2b2lkIHtcclxuICAgICAgICBsZXQgdHlwZWRUd2VlbiA9IDxUd2VlbkRhdGE+dHdlZW47XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgbWVtYmVycyB0aGF0IHdlIG5lZWQgKGFuZCB0aGUgdXNlciBkaWRuJ3QgcHJvdmlkZSlcclxuICAgICAgICB0eXBlZFR3ZWVuLnByb2dyZXNzID0gMDtcclxuICAgICAgICB0eXBlZFR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0eXBlZFR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuXHJcbiAgICAgICAgdGhpcy50d2VlbnMuYWRkKGtleSwgdHlwZWRUd2Vlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5IGEgdHdlZW4gd2l0aCBhIGNlcnRhaW4gbmFtZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGxheVxyXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIHR3ZWVuIHNob3VsZCBsb29wXHJcbiAgICAgKi9cclxuICAgIHBsYXkoa2V5OiBzdHJpbmcsIGxvb3A/OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBsb29wIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBpZihsb29wICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgdHdlZW4ubG9vcCA9IGxvb3A7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XHJcbiAgICAgICAgICAgICAgICBpZihlZmZlY3QucmVzZXRPbkNvbXBsZXRlKXtcclxuICAgICAgICAgICAgICAgICAgICBlZmZlY3QuaW5pdGlhbFZhbHVlID0gdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdHdlZW4gcnVubmluZ1xyXG4gICAgICAgICAgICB0d2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcbiAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgICB0d2Vlbi5yZXZlcnNpbmcgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRyaWVkIHRvIHBsYXkgdHdlZW4gXCIke2tleX1cIiBvbiBub2RlIHdpdGggaWQgJHt0aGlzLm93bmVyLmlkfSwgYnV0IG5vIHN1Y2ggdHdlZW4gZXhpc3RzYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGF1c2VzIGEgcGxheWluZyB0d2Vlbi4gRG9lcyBub3QgYWZmZWN0IHR3ZWVucyB0aGF0IGFyZSBzdG9wcGVkLlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGF1c2UuXHJcbiAgICAgKi9cclxuICAgIHBhdXNlKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVucy5nZXQoa2V5KS5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBBVVNFRDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN1bWVzIGEgcGF1c2VkIHR3ZWVuLlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcmVzdW1lXHJcbiAgICAgKi9cclxuICAgIHJlc3VtZShrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcclxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpXHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0d2VlblxyXG4gICAgICovXHJcbiAgICBzdG9wKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRvIHRoZSBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcclxuICAgICAgICAgICAgICAgIGlmKGVmZmVjdC5yZXNldE9uQ29tcGxldGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XSA9IGVmZmVjdC5pbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmF0dXJhbCBzdG9wIG9mIGEgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGVuZChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc3RvcChrZXkpO1xyXG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB0d2VlblxyXG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGhhcyBhbiBvbkVuZCwgc2VuZCBhbiBldmVudFxyXG4gICAgICAgICAgICBpZih0d2Vlbi5vbkVuZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHR3ZWVuLm9uRW5kLCB7a2V5OiBrZXksIG5vZGU6IHRoaXMub3duZXIuaWR9KTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBhbGwgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5zXHJcbiAgICAgKi9cclxuICAgIHN0b3BBbGwoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50d2VlbnMuZm9yRWFjaChrZXkgPT4gdGhpcy5zdG9wKGtleSkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZih0d2Vlbi5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORyl7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIG9mIHRoZSB0d2VlblxyXG4gICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgKz0gZGVsdGFUKjEwMDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgcGFzdCB0aGUgc3RhcnREZWxheSwgZG8gdGhlIHR3ZWVuXHJcbiAgICAgICAgICAgICAgICBpZih0d2Vlbi5lbGFwc2VkVGltZSA+PSB0d2Vlbi5zdGFydERlbGF5KXtcclxuICAgICAgICAgICAgICAgICAgICBpZighdHdlZW4ucmV2ZXJzaW5nICYmIHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkgKyB0d2Vlbi5kdXJhdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG92ZXIgdGltZSwgc3RvcCB0aGUgdHdlZW4sIGxvb3AsIG9yIHJldmVyc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ucmV2ZXJzZU9uQ29tcGxldGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgb3ZlciB0aW1lIGFuZCBjYW4gcmV2ZXJzZSwgZG8gc29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0d2Vlbi5sb29wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHJldmVyc2UgYW5kIGNhbiBsb29wLCBkbyBzb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gdHdlZW4uZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmVuJ3QgbG9vcGluZyBhbmQgY2FuJ3QgcmV2ZXJzZSwgc28gc3RvcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBlbmQgb2YgcmV2ZXJzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ucmV2ZXJzaW5nICYmIHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkgKyAyKnR3ZWVuLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ubG9vcCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5yZXZlcnNpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lIC09IDIqdHdlZW4uZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzLCBtYWtlIHN1cmUgaXQgaXMgYmV0d2VlbiAwIGFuZCAxLiBFcnJvcnMgZnJvbSB0aGlzIHNob3VsZCBuZXZlciBiZSBsYXJnZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2luZyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnByb2dyZXNzID0gTWF0aFV0aWxzLmNsYW1wMDEoKDIqdHdlZW4uZHVyYXRpb24gLSAodHdlZW4uZWxhcHNlZFRpbWUtIHR3ZWVuLnN0YXJ0RGVsYXkpKS90d2Vlbi5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSBNYXRoVXRpbHMuY2xhbXAwMSgodHdlZW4uZWxhcHNlZFRpbWUgLSB0d2Vlbi5zdGFydERlbGF5KS90d2Vlbi5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWUgZnJvbSB0aGUgZWFzZSBmdW5jdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIG91ciBwcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWFzZSA9IEVhc2VGdW5jdGlvbnNbZWZmZWN0LmVhc2VdKHR3ZWVuLnByb2dyZXNzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgdmFsdWUgdG8gbGVycCB0aGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gTWF0aFV0aWxzLmxlcnAoZWZmZWN0LnN0YXJ0LCBlZmZlY3QuZW5kLCBlYXNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFR3ZWVuQ29udHJvbGxlciBmcm9tIFwiLi9Ud2VlbkNvbnRyb2xsZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBUd2Vlbk1hbmFnZXIgPSBudWxsO1xyXG4gICAgXHJcbiAgICBwcm90ZWN0ZWQgdHdlZW5Db250cm9sbGVyczogQXJyYXk8VHdlZW5Db250cm9sbGVyPjtcclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzID0gbmV3IEFycmF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCk6IFR3ZWVuTWFuYWdlciB7XHJcbiAgICAgICAgaWYoVHdlZW5NYW5hZ2VyLmluc3RhbmNlID09PSBudWxsKXtcclxuICAgICAgICAgICAgVHdlZW5NYW5hZ2VyLmluc3RhbmNlID0gbmV3IFR3ZWVuTWFuYWdlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFR3ZWVuTWFuYWdlci5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RlclR3ZWVuQ29udHJvbGxlcihjb250cm9sbGVyOiBUd2VlbkNvbnRyb2xsZXIpe1xyXG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycy5wdXNoKGNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIoY29udHJvbGxlcjogVHdlZW5Db250cm9sbGVyKXtcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKTtcclxuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhclR3ZWVuQ29udHJvbGxlcnMoKXtcclxuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBmb3IobGV0IHR3ZWVuQ29udHJvbGxlciBvZiB0aGlzLnR3ZWVuQ29udHJvbGxlcnMpe1xyXG4gICAgICAgICAgICB0d2VlbkNvbnRyb2xsZXIudXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBHcmFwaGljUmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL0dyYXBoaWNSZW5kZXJlclwiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCJcclxuaW1wb3J0IFRpbGVtYXBSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvVGlsZW1hcFJlbmRlcmVyXCI7XHJcbmltcG9ydCBVSUVsZW1lbnRSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvVUlFbGVtZW50UmVuZGVyZXJcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XHJcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcblxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFJlbmRlcmluZ01hbmFnZXIgY2xhc3MgdXNpbmcgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcclxuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuICAgIHByb3RlY3RlZCBncmFwaGljUmVuZGVyZXI6IEdyYXBoaWNSZW5kZXJlcjtcclxuICAgIHByb3RlY3RlZCB0aWxlbWFwUmVuZGVyZXI6IFRpbGVtYXBSZW5kZXJlcjtcclxuICAgIHByb3RlY3RlZCB1aUVsZW1lbnRSZW5kZXJlcjogVUlFbGVtZW50UmVuZGVyZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIG9yaWdpbjogVmVjMjtcclxuICAgIHByb3RlY3RlZCB6b29tOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpe1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy53b3JsZFNpemUgPSBuZXcgVmVjMih3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlciA9IG5ldyBHcmFwaGljUmVuZGVyZXIodGhpcy5jdHgpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyID0gbmV3IFRpbGVtYXBSZW5kZXJlcih0aGlzLmN0eCk7XHJcbiAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlciA9IG5ldyBVSUVsZW1lbnRSZW5kZXJlcih0aGlzLmN0eClcclxuXHJcbiAgICAgICAgLy8gRm9yIGNyaXNwIHBpeGVsIGFydFxyXG4gICAgICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICByZW5kZXIodmlzaWJsZVNldDogQ2FudmFzTm9kZVtdLCB0aWxlbWFwczogVGlsZW1hcFtdLCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZCB7XHJcbiAgICAgICAgLy8gU29ydCBieSBkZXB0aCwgdGhlbiBieSB2aXNpYmxlIHNldCBieSB5LXZhbHVlXHJcbiAgICAgICAgdmlzaWJsZVNldC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGlmKGEuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpID09PSBiLmdldExheWVyKCkuZ2V0RGVwdGgoKSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGEuYm91bmRhcnkuYm90dG9tKSAtIChiLmJvdW5kYXJ5LmJvdHRvbSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRMYXllcigpLmdldERlcHRoKCkgLSBiLmdldExheWVyKCkuZ2V0RGVwdGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgdGlsZW1hcEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgdGlsZW1hcExlbmd0aCA9IHRpbGVtYXBzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgbGV0IHZpc2libGVTZXRJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IHZpc2libGVTZXRMZW5ndGggPSB2aXNpYmxlU2V0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUodGlsZW1hcEluZGV4IDwgdGlsZW1hcExlbmd0aCB8fCB2aXNpYmxlU2V0SW5kZXggPCB2aXNpYmxlU2V0TGVuZ3RoKXtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgY29uZGl0aW9ucyB3aGVyZSB3ZSd2ZSBhbHJlYWR5IHJlYWNoZWQgdGhlIGVkZ2Ugb2Ygb25lIGxpc3RcclxuICAgICAgICAgICAgaWYodGlsZW1hcEluZGV4ID49IHRpbGVtYXBMZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSByZW5kZXIgdGhlIHJlbWFpbmluZyB2aXNpYmxlIHNldFxyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIGlmKG5vZGUudmlzaWJsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHZpc2libGVTZXRJbmRleCA+PSB2aXNpYmxlU2V0TGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVuZGVyIHRpbGVtYXBzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGVtYXAodGlsZW1hcHNbdGlsZW1hcEluZGV4KytdKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW5kZXIgd2hpY2hldmVyIGlzIGZ1cnRoZXIgZG93blxyXG4gICAgICAgICAgICBpZih0aWxlbWFwc1t0aWxlbWFwSW5kZXhdLmdldExheWVyKCkuZ2V0RGVwdGgoKSA8PSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleF0uZ2V0TGF5ZXIoKS5nZXREZXB0aCgpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZW1hcCh0aWxlbWFwc1t0aWxlbWFwSW5kZXgrK10pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIGlmKG5vZGUudmlzaWJsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW5kZXIgdGhlIHVpTGF5ZXJzIG9uIHRvcCBvZiBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICBsZXQgc29ydGVkVUlMYXllcnMgPSBuZXcgQXJyYXk8VUlMYXllcj4oKTtcclxuXHJcbiAgICAgICAgdWlMYXllcnMuZm9yRWFjaChrZXkgPT4gc29ydGVkVUlMYXllcnMucHVzaCh1aUxheWVycy5nZXQoa2V5KSkpO1xyXG5cclxuICAgICAgICBzb3J0ZWRVSUxheWVycyA9IHNvcnRlZFVJTGF5ZXJzLnNvcnQoKHVpMSwgdWkyKSA9PiB1aTEuZ2V0RGVwdGgoKSAtIHVpMi5nZXREZXB0aCgpKTtcclxuXHJcbiAgICAgICAgc29ydGVkVUlMYXllcnMuZm9yRWFjaCh1aUxheWVyID0+IHtcclxuXHRcdFx0aWYoIXVpTGF5ZXIuaXNIaWRkZW4oKSlcclxuXHRcdFx0XHR1aUxheWVyLmdldEl0ZW1zKCkuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZigoPENhbnZhc05vZGU+bm9kZSkudmlzaWJsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZSg8Q2FudmFzTm9kZT5ub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcblx0XHR9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBzcGVjaWZpZWQgQ2FudmFzTm9kZVxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIENhbnZhc05vZGUgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCByZW5kZXJOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbihub2RlKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB6b29tIGxldmVsIG9mIHRoZSBzY2VuZVxyXG4gICAgICAgIHRoaXMuem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTW92ZSB0aGUgY2FudmFzIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbmQgcm90YXRlXHJcbiAgICAgICAgbGV0IHhTY2FsZSA9IDE7XHJcbiAgICAgICAgbGV0IHlTY2FsZSA9IDE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XHJcbiAgICAgICAgICAgIHhTY2FsZSA9IG5vZGUuaW52ZXJ0WCA/IC0xIDogMTtcclxuICAgICAgICAgICAgeVNjYWxlID0gbm9kZS5pbnZlcnRZID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHhTY2FsZSwgMCwgMCwgeVNjYWxlLCAobm9kZS5wb3NpdGlvbi54IC0gdGhpcy5vcmlnaW4ueCkqdGhpcy56b29tLCAobm9kZS5wb3NpdGlvbi55IC0gdGhpcy5vcmlnaW4ueSkqdGhpcy56b29tKTtcclxuICAgICAgICB0aGlzLmN0eC5yb3RhdGUoLW5vZGUucm90YXRpb24pO1xyXG4gICAgICAgIGxldCBnbG9iYWxBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBSZWN0KXtcclxuICAgICAgICAgICAgRGVidWcubG9nKFwibm9kZVwiICsgbm9kZS5pZCwgXCJOb2RlXCIgKyBub2RlLmlkICsgXCIgQWxwaGE6IFwiICsgbm9kZS5hbHBoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbm9kZS5hbHBoYTtcclxuICAgICAgICBcclxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckFuaW1hdGVkU3ByaXRlKDxBbmltYXRlZFNwcml0ZT5ub2RlKTtcclxuICAgICAgICB9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU3ByaXRlKDxTcHJpdGU+bm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBHcmFwaGljKXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmFwaGljKDxHcmFwaGljPm5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgVUlFbGVtZW50KXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJVSUVsZW1lbnQoPFVJRWxlbWVudD5ub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcHJvdGVjdGVkIHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHNwcml0ZS5pbWFnZUlkKTtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSBpbWFnZTpcclxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc3RhcnQgLT4geCwgeVxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzaXplICAtPiB3LCBoXHJcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgd29ybGRcclxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc3RhcnQgLT4geCwgeVxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzaXplICAtPiB3LCBoXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXHJcbiAgICAgICAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC54LCBzcHJpdGUuaW1hZ2VPZmZzZXQueSxcclxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCwgc3ByaXRlLnNpemUueSxcclxuICAgICAgICAgICAgKC1zcHJpdGUuc2l6ZS54KnNwcml0ZS5zY2FsZS54LzIpKnRoaXMuem9vbSwgKC1zcHJpdGUuc2l6ZS55KnNwcml0ZS5zY2FsZS55LzIpKnRoaXMuem9vbSxcclxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCAqIHNwcml0ZS5zY2FsZS54KnRoaXMuem9vbSwgc3ByaXRlLnNpemUueSAqIHNwcml0ZS5zY2FsZS55KnRoaXMuem9vbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHNwcml0ZS5pbWFnZUlkKTtcclxuXHJcbiAgICAgICAgbGV0IGFuaW1hdGlvbkluZGV4ID0gc3ByaXRlLmFuaW1hdGlvbi5nZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTtcclxuXHJcbiAgICAgICAgbGV0IGFuaW1hdGlvbk9mZnNldCA9IHNwcml0ZS5nZXRBbmltYXRpb25PZmZzZXQoYW5pbWF0aW9uSW5kZXgpO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIGltYWdlOlxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzdGFydCAtPiB4LCB5XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHNpemUgIC0+IHcsIGhcclxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSB3b3JsZCAoZ2l2ZW4gd2UgbW92ZWQpXHJcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHN0YXJ0IC0+IC13LzIsIC1oLzJcclxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc2l6ZSAgLT4gdywgaFxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxyXG4gICAgICAgICAgICBzcHJpdGUuaW1hZ2VPZmZzZXQueCArIGFuaW1hdGlvbk9mZnNldC54LCBzcHJpdGUuaW1hZ2VPZmZzZXQueSArIGFuaW1hdGlvbk9mZnNldC55LFxyXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54LCBzcHJpdGUuc2l6ZS55LFxyXG4gICAgICAgICAgICAoLXNwcml0ZS5zaXplLngqc3ByaXRlLnNjYWxlLngvMikqdGhpcy56b29tLCAoLXNwcml0ZS5zaXplLnkqc3ByaXRlLnNjYWxlLnkvMikqdGhpcy56b29tLFxyXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54ICogc3ByaXRlLnNjYWxlLngqdGhpcy56b29tLCBzcHJpdGUuc2l6ZS55ICogc3ByaXRlLnNjYWxlLnkqdGhpcy56b29tKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkIHtcclxuICAgICAgICBpZihncmFwaGljIGluc3RhbmNlb2YgUG9pbnQpe1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJQb2ludCg8UG9pbnQ+Z3JhcGhpYywgdGhpcy56b29tKTtcclxuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIExpbmUpe1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJMaW5lKDxMaW5lPmdyYXBoaWMsIHRoaXMub3JpZ2luLCB0aGlzLnpvb20pO1xyXG4gICAgICAgIH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgUmVjdCl7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlclJlY3QoPFJlY3Q+Z3JhcGhpYywgdGhpcy56b29tKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGlsZW1hcCBpbnN0YW5jZW9mIE9ydGhvZ29uYWxUaWxlbWFwKXtcclxuICAgICAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIucmVuZGVyT3J0aG9nb25hbFRpbGVtYXAoPE9ydGhvZ29uYWxUaWxlbWFwPnRpbGVtYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBMYWJlbCl7XHJcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyTGFiZWwodWlFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgQnV0dG9uKXtcclxuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJCdXR0b24odWlFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgU2xpZGVyKXtcclxuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJTbGlkZXIodWlFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgVGV4dElucHV0KXtcclxuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJUZXh0SW5wdXQodWlFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoY2xlYXJDb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53b3JsZFNpemUueCwgdGhpcy53b3JsZFNpemUueSk7XHJcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGhlbHAgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHJlbmRlciBAcmVmZXJlbmNlW0dyYXBoaWNdc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhpY1JlbmRlcmVyIHtcclxuICAgIC8qKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBvZiB0aGUgZ2FtZSBlbmdpbmUgKi9cclxuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIC8qKiBUaGUgY3VycmVudCBzY2VuZSAqL1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuICAgIC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgKi9cclxuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgR3JhcGhpY1JlbmRlcmVyXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAqL1xyXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcclxuICAgICAqL1xyXG4gICAgcmVuZGVyUG9pbnQocG9pbnQ6IFBvaW50LCB6b29tOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHBvaW50LmNvbG9yLnRvU3RyaW5nUkdCQSgpO1xyXG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KCgtcG9pbnQuc2l6ZS54LzIpKnpvb20sICgtcG9pbnQuc2l6ZS55LzIpKnpvb20sXHJcbiAgICAgICAgcG9pbnQuc2l6ZS54Knpvb20sIHBvaW50LnNpemUueSp6b29tKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJMaW5lKGxpbmU6IExpbmUsIG9yaWdpbjogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBsaW5lLmNvbG9yLnRvU3RyaW5nUkdCQSgpO1xyXG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IGxpbmUudGhpY2tuZXNzO1xyXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCAwKTtcclxuICAgICAgICB0aGlzLmN0eC5saW5lVG8oKGxpbmUuZW5kLnggLSBsaW5lLnN0YXJ0LngpKnpvb20sIChsaW5lLmVuZC55IC0gbGluZS5zdGFydC55KSp6b29tKTtcclxuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSByZWN0XHJcbiAgICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdCB0byByZW5kZXJcclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclJlY3QocmVjdDogUmVjdCwgem9vbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRHJhdyB0aGUgaW50ZXJpb3Igb2YgdGhlIHJlY3RcclxuICAgICAgICBpZihyZWN0LmNvbG9yLmEgIT09IDApe1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSByZWN0LmNvbG9yLnRvU3RyaW5nUkdCKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KCgtcmVjdC5zaXplLngvMikqem9vbSwgKC1yZWN0LnNpemUueS8yKSp6b29tLCByZWN0LnNpemUueCp6b29tLCByZWN0LnNpemUueSp6b29tKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgdGhlIGJvcmRlciBvZiB0aGUgcmVjdCBpZiBpdCBpc24ndCB0cmFuc3BhcmVudFxyXG4gICAgICAgIGlmKHJlY3QuYm9yZGVyQ29sb3IuYSAhPT0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gcmVjdC5nZXRCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHJlY3QuZ2V0Qm9yZGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlUmVjdCgoLXJlY3Quc2l6ZS54LzIpKnpvb20sICgtcmVjdC5zaXplLnkvMikqem9vbSwgcmVjdC5zaXplLngqem9vbSwgcmVjdC5zaXplLnkqem9vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHRvIHJlbmRlciBAcmVmZXJlbmNlW1RpbGVtYXBdc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZW1hcFJlbmRlcmVyIHtcclxuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpe1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBvZiB0aGlzIFRpbGVtYXBSZW5kZXJlclxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgKi9cclxuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYW4gb3J0aG9nb25hbCB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyT3J0aG9nb25hbFRpbGVtYXAodGlsZW1hcDogT3J0aG9nb25hbFRpbGVtYXApOiB2b2lkIHtcclxuICAgICAgICBsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdGlsZW1hcC5nZXRMYXllcigpLmdldEFscGhhKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IG9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKHRpbGVtYXApO1xyXG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldEhhbGZTaXplKCk7XHJcbiAgICAgICAgbGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xyXG4gICAgICAgIGxldCBib3R0b21SaWdodCA9IG9yaWdpbi5jbG9uZSgpLmFkZChzaXplLnNjYWxlZCgyKnpvb20pKTtcclxuXHJcbiAgICAgICAgaWYodGlsZW1hcC52aXNpYmxlKXtcclxuICAgICAgICAgICAgbGV0IG1pbkNvbFJvdyA9IHRpbGVtYXAuZ2V0Q29sUm93QXQob3JpZ2luKTtcclxuICAgICAgICAgICAgbGV0IG1heENvbFJvdyA9IHRpbGVtYXAuZ2V0Q29sUm93QXQoYm90dG9tUmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCB4ID0gbWluQ29sUm93Lng7IHggPD0gbWF4Q29sUm93Lng7IHgrKyl7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IHkgPSBtaW5Db2xSb3cueTsgeSA8PSBtYXhDb2xSb3cueTsgeSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRpbGUgYXQgdGhpcyBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlID0gdGlsZW1hcC5nZXRUaWxlQXRSb3dDb2wobmV3IFZlYzIoeCwgeSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSByb3QvZmxpcCBwYXJhbWV0ZXJzIGlmIHRoZXJlIGFyZSBhbnlcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4RSA8PCAyOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm90RmxpcCA9ICgobWFzayAmIHRpbGUpID4+IDI4KSAmIDB4RjtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlID0gdGlsZSAmIH5tYXNrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aWxlc2V0IHRoYXQgb3ducyB0aGlzIHRpbGUgaW5kZXggYW5kIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwLmdldFRpbGVzZXRzKCkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aWxlc2V0Lmhhc1RpbGUodGlsZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKHRpbGVzZXQsIHRpbGUsIHgsIHksIG9yaWdpbiwgdGlsZW1hcC5zY2FsZSwgem9vbSwgcm90RmxpcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSB0aWxlXHJcbiAgICAgKiBAcGFyYW0gdGlsZXNldCBUaGUgdGlsZXNldCB0aGlzIHRpbGUgYmVsb25ncyB0byBcclxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcFJvdyBUaGUgcm93IG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcENvbCBUaGUgY29sdW1uIG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHJlbmRlclRpbGUodGlsZXNldDogVGlsZXNldCwgdGlsZUluZGV4OiBudW1iZXIsIHRpbGVtYXBSb3c6IG51bWJlciwgdGlsZW1hcENvbDogbnVtYmVyLCBvcmlnaW46IFZlYzIsIHNjYWxlOiBWZWMyLCB6b29tOiBudW1iZXIsIHJvdEZsaXA6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxyXG4gICAgICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRpbGVzZXQuZ2V0U3RhcnRJbmRleCgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHJvdyBhbmQgY29sIG9mIHRoZSB0aWxlIGluIGltYWdlIHNwYWNlXHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aWxlc2V0LmdldE51bUNvbHMoKSk7XHJcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGlsZXNldC5nZXROdW1Db2xzKCk7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gdGlsZXNldC5nZXRUaWxlU2l6ZSgpLng7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS55O1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxyXG4gICAgICAgIGxldCBsZWZ0ID0gY29sICogd2lkdGg7XHJcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBpbiB0aGUgd29ybGQgdG8gcmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKHRpbGVtYXBSb3cgKiB3aWR0aCAqIHNjYWxlLngpO1xyXG4gICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcih0aWxlbWFwQ29sICogaGVpZ2h0ICogc2NhbGUueSk7XHJcblxyXG4gICAgICAgIGxldCB3b3JsZFggPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luLngpKnpvb20pO1xyXG4gICAgICAgIGxldCB3b3JsZFkgPSBNYXRoLmZsb29yKCh5IC0gb3JpZ2luLnkpKnpvb20pO1xyXG4gICAgICAgIGxldCB3b3JsZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pO1xyXG4gICAgICAgIGxldCB3b3JsZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBzY2FsZS55ICogem9vbSk7XHJcblxyXG4gICAgICAgIGlmKHJvdEZsaXAgIT09IDApe1xyXG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gMTtcclxuICAgICAgICAgICAgbGV0IHNjYWxlWSA9IDE7XHJcbiAgICAgICAgICAgIGxldCBzaGVhclggPSAwO1xyXG4gICAgICAgICAgICBsZXQgc2hlYXJZID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIEZsaXAgb24gdGhlIHgtYXhpc1xyXG4gICAgICAgICAgICBpZihyb3RGbGlwICYgOCl7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVggPSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmxpcCBvbiB0aGUgeS1heGlzXHJcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiA0KXtcclxuICAgICAgICAgICAgICAgIHNjYWxlWSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGbGlwIG92ZXIgdGhlIGxpbmUgeT14XHJcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiAyKXtcclxuICAgICAgICAgICAgICAgIHNoZWFyWCA9IHNjYWxlWTtcclxuICAgICAgICAgICAgICAgIHNoZWFyWSA9IHNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHNjYWxlWCA9IDA7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCBzaGVhclgsIHNoZWFyWSwgc2NhbGVZLCB3b3JsZFggKyB3b3JsZFdpZHRoLzIsIHdvcmxkWSArIHdvcmxkSGVpZ2h0LzIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHRpbGVcclxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxyXG4gICAgICAgICAgICAgICAgbGVmdCwgdG9wLFxyXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcclxuICAgICAgICAgICAgICAgIC13b3JsZFdpZHRoLzIsIC13b3JsZEhlaWdodC8yLFxyXG4gICAgICAgICAgICAgICAgd29ybGRXaWR0aCwgd29ybGRIZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgaWYocm90RmxpcCAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyByb3RhdGlvbnMsIGRvbid0IGRvIHRoZSBjYWxjdWxhdGlvbnMsIGp1c3QgcmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgdGlsZVxyXG4gICAgICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0LCB0b3AsXHJcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgd29ybGRYLCB3b3JsZFksXHJcbiAgICAgICAgICAgICAgICB3b3JsZFdpZHRoLCB3b3JsZEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XHJcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbVUlFbGVtZW50XXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJRWxlbWVudFJlbmRlcmVyIHtcclxuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpe1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBvZiB0aGlzIFVJRWxlbWVudFJlbmRlcmVyXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAqL1xyXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIGxhYmVsXHJcbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJMYWJlbChsYWJlbDogTGFiZWwpOiB2b2lkIHtcclxuICAgICAgICAvLyBJZiB0aGUgc2l6ZSBpcyB1bmFzc2lnbmVkIChieSB0aGUgdXNlciBvciBhdXRvbWF0aWNhbGx5KSBhc3NpZ24gaXRcclxuICAgICAgICBsYWJlbC5oYW5kbGVJbml0aWFsU2l6aW5nKHRoaXMuY3R4KTtcclxuXHRcdFxyXG5cdFx0Ly8gR3JhYiB0aGUgZ2xvYmFsIGFscGhhIHNvIHdlIGNhbiBhZGp1c3QgaXQgZm9yIHRoaXMgcmVuZGVyXHJcblx0XHRsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGZvbnQgYW5kIHRleHQgcG9zaXRpb24gaW4gbGFiZWxcclxuXHRcdHRoaXMuY3R4LmZvbnQgPSBsYWJlbC5nZXRGb250U3RyaW5nKCk7XHJcblx0XHRsZXQgb2Zmc2V0ID0gbGFiZWwuY2FsY3VsYXRlVGV4dE9mZnNldCh0aGlzLmN0eCk7XHJcblxyXG5cdFx0Ly8gU3Ryb2tlIGFuZCBmaWxsIGEgcm91bmRlZCByZWN0IGFuZCBnaXZlIGl0IHRleHRcclxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYmFja2dyb3VuZENvbG9yLmE7XHJcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBsYWJlbC5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKS50b1N0cmluZ1JHQkEoKTtcclxuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCgtbGFiZWwuc2l6ZS54LzIsIC1sYWJlbC5zaXplLnkvMixcclxuXHRcdFx0bGFiZWwuc2l6ZS54LCBsYWJlbC5zaXplLnksIGxhYmVsLmJvcmRlclJhZGl1cyk7XHJcblx0XHRcclxuXHRcdHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGFiZWwuY2FsY3VsYXRlQm9yZGVyQ29sb3IoKS50b1N0cmluZ1JHQkEoKTtcclxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYm9yZGVyQ29sb3IuYTtcclxuXHRcdHRoaXMuY3R4LmxpbmVXaWR0aCA9IGxhYmVsLmJvcmRlcldpZHRoO1xyXG5cdFx0dGhpcy5jdHguc3Ryb2tlUm91bmRlZFJlY3QoLWxhYmVsLnNpemUueC8yLCAtbGFiZWwuc2l6ZS55LzIsXHJcblx0XHRcdGxhYmVsLnNpemUueCwgbGFiZWwuc2l6ZS55LCBsYWJlbC5ib3JkZXJSYWRpdXMpO1xyXG5cclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZVRleHRDb2xvcigpO1xyXG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC50ZXh0Q29sb3IuYTtcclxuXHRcdHRoaXMuY3R4LmZpbGxUZXh0KGxhYmVsLnRleHQsIG9mZnNldC54IC0gbGFiZWwuc2l6ZS54LzIsIG9mZnNldC55IC0gbGFiZWwuc2l6ZS55LzIpO1xyXG5cdFxyXG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIGJ1dHRvblxyXG4gICAgICogQHBhcmFtIGJ1dHRvbiBUaGUgYnV0dG9uIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJCdXR0b24oYnV0dG9uOiBCdXR0b24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnJlbmRlckxhYmVsKGJ1dHRvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgc2xpZGVyXHJcbiAgICAgKiBAcGFyYW0gc2xpZGVyIFRoZSBzbGlkZXIgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclNsaWRlcihzbGlkZXI6IFNsaWRlcik6IHZvaWQge1xyXG5cdFx0Ly8gR3JhYiB0aGUgZ2xvYmFsIGFscGhhIHNvIHdlIGNhbiBhZGp1c3QgaXQgZm9yIHRoaXMgcmVuZGVyXHJcblx0XHRsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBzbGlkZXIuZ2V0TGF5ZXIoKS5nZXRBbHBoYSgpO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWFsYXRlIHRoZSBzbGlkZXIgc2l6ZVxyXG4gICAgICAgIGxldCBzbGlkZXJTaXplID0gbmV3IFZlYzIoc2xpZGVyLnNpemUueCwgMik7XHJcblxyXG4gICAgICAgIC8vIERyYXcgdGhlIHNsaWRlclxyXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gc2xpZGVyLnNsaWRlckNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHR0aGlzLmN0eC5maWxsUm91bmRlZFJlY3QoLXNsaWRlclNpemUueC8yLCAtc2xpZGVyU2l6ZS55LzIsXHJcbiAgICAgICAgICAgIHNsaWRlclNpemUueCwgc2xpZGVyU2l6ZS55LCBzbGlkZXIuYm9yZGVyUmFkaXVzKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuaWIgc2l6ZSBhbmQgcG9zaXRpb25cclxuICAgICAgICBsZXQgeCA9IE1hdGhVdGlscy5sZXJwKC1zbGlkZXIuc2l6ZS54LzIsIHNsaWRlci5zaXplLngvMiwgc2xpZGVyLmdldFZhbHVlKCkpO1xyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSBuaWJcclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNsaWRlci5uaWJDb2xvci50b1N0cmluZygpO1xyXG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KHgtc2xpZGVyLm5pYlNpemUueC8yLCAtc2xpZGVyLm5pYlNpemUueS8yLFxyXG4gICAgICAgICAgICBzbGlkZXIubmliU2l6ZS54LCBzbGlkZXIubmliU2l6ZS55LCBzbGlkZXIuYm9yZGVyUmFkaXVzKTtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFscGhhXHJcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHRleHRJbnB1dFxyXG4gICAgICogQHBhcmFtIHRleHRJbnB1dCBUaGUgdGV4dElucHV0IHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJUZXh0SW5wdXQodGV4dElucHV0OiBUZXh0SW5wdXQpOiB2b2lkIHtcclxuICAgICAgICAvLyBTaG93IGEgY3Vyc29yIHNvbWV0aW1lc1xyXG4gICAgICAgIGlmKHRleHRJbnB1dC5mb2N1c2VkICYmIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICUgNjAgPiAzMCl7XHJcbiAgICAgICAgICAgIHRleHRJbnB1dC50ZXh0ICs9IFwifFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJMYWJlbCh0ZXh0SW5wdXQpO1xyXG5cclxuICAgICAgICBpZih0ZXh0SW5wdXQuZm9jdXNlZCl7XHJcbiAgICAgICAgICAgIGlmKHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICUgNjAgPiAzMCl7XHJcbiAgICAgICAgICAgICAgICB0ZXh0SW5wdXQudGV4dCA9IHRleHRJbnB1dC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0SW5wdXQudGV4dC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgKz0gMTtcclxuICAgICAgICAgICAgaWYodGV4dElucHV0LmN1cnNvckNvdW50ZXIgPj0gNjApe1xyXG4gICAgICAgICAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBmcmFtZXdvcmsgdG8gcHV0IGFsbCByZW5kZXJpbmcgaW4gb25jZSBwbGFjZSBpbiB0aGUgYXBwbGljYXRpb25cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlbmRlcmluZ01hbmFnZXIge1xyXG4gICAgLyoqIFRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cclxuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgICAvKiogVGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZCAqL1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWRcclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBTY2VuZVxyXG4gICAgICovXHJcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBjYW52YXMgZm9yIHRoZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcclxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBjYW52YXNcclxuICAgICAqIEByZXR1cm5zIFRoZSByZW5kZXJpbmcgY29udGV4dCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBhbnk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2RlcyBhbmQgdmlzaWJsZSBwb3J0aW9ucyBvZiB0aWxlbWFwcywgYXMgd2VsbCBhcyBhbnkgVUlFbGVtZW50IGluIFVJTGF5ZXJzXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZVNldCBUaGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXNcclxuICAgICAqIEBwYXJhbSB0aWxlbWFwcyBUaGUgdGlsZW1hcHMgdXNlZCBpbiB0aGUgYXBwbGljYXRpb25cclxuICAgICAqIEBwYXJhbSB1aUxheWVycyBUaGUgdXNlciBpbnRlcmZhY2UgbGF5ZXJzXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHJlbmRlcih2aXNpYmxlU2V0OiBBcnJheTxDYW52YXNOb2RlPiwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+LCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZDtcclxuXHJcbiAgICAvKiogQ2xlYXJzIHRoZSBjYW52YXMgKi9cclxuICAgIGFic3RyYWN0IGNsZWFyKGNvbG9yOiBDb2xvcik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0gc3ByaXRlIFRoZSBzcHJpdGUgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhbiBhbmltYXRlZCBzcHJpdGVcclxuICAgICAqIEBwYXJhbSBzcHJpdGUgVGhlIGFuaW1hdGVkIHNwcml0ZSB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIGdyYXBoaWNcclxuICAgICAqIEBwYXJhbSBncmFwaGljIFRoZSBncmFwaGljIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQ7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIFVJRWxlbWVudFxyXG4gICAgICogQHBhcmFtIHVpRWxlbWVudCBUaGUgVUlFbGVtZW50IHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZDtcclxufSIsImltcG9ydCBHcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9HcmFwaFwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBTaGFkZXJSZWdpc3RyeSBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xyXG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXJcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcclxuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcclxuXHJcblx0cHJvdGVjdGVkIG9yaWdpbjogVmVjMjtcclxuXHRwcm90ZWN0ZWQgem9vbTogbnVtYmVyO1xyXG5cdHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XHJcblxyXG5cdHByb3RlY3RlZCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG5cdHByb3RlY3RlZCB0ZXh0Q3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG5cdGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQge1xyXG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHR0aGlzLndvcmxkU2l6ZSA9IFZlYzIuWkVSTztcclxuXHRcdHRoaXMud29ybGRTaXplLnggPSB3aWR0aDtcclxuXHRcdHRoaXMud29ybGRTaXplLnkgPSBoZWlnaHQ7XHJcblxyXG5cdFx0Ly8gR2V0IHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgICAgdGhpcy5nbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIik7XHJcblxyXG5cdFx0dGhpcy5nbC52aWV3cG9ydCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuXHRcdHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xyXG4gICAgICAgIHRoaXMuZ2wuYmxlbmRGdW5jKHRoaXMuZ2wuU1JDX0FMUEhBLCB0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcclxuXHJcblx0XHQvLyBUZWxsIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHdlJ3JlIHVzaW5nIFdlYkdMXHJcblx0XHRSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51c2VXZWJHTCh0cnVlLCB0aGlzLmdsKTtcclxuXHJcblx0XHQvLyBTaG93IHRoZSB0ZXh0IGNhbnZhcyBhbmQgZ2V0IGl0cyBjb250ZXh0XHJcblx0XHRsZXQgdGV4dENhbnZhcyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRleHQtY2FudmFzXCIpO1xyXG5cdFx0dGV4dENhbnZhcy5oaWRkZW4gPSBmYWxzZTtcclxuXHRcdHRoaXMudGV4dEN0eCA9IHRleHRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuXHRcdC8vIFNpemUgdGhlIHRleHQgY2FudmFzIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBnYW1lIGNhbnZhc1xyXG5cdFx0dGV4dENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHR0ZXh0Q2FudmFzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdsO1xyXG5cdH1cclxuXHJcblx0cmVuZGVyKHZpc2libGVTZXQ6IENhbnZhc05vZGVbXSwgdGlsZW1hcHM6IFRpbGVtYXBbXSwgdWlMYXllcnM6IE1hcDxVSUxheWVyPik6IHZvaWQge1xyXG5cdFx0Zm9yKGxldCBub2RlIG9mIHZpc2libGVTZXQpe1xyXG5cdFx0XHR0aGlzLnJlbmRlck5vZGUobm9kZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dWlMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRpZighdWlMYXllcnMuZ2V0KGtleSkuaXNIaWRkZW4oKSlcclxuXHRcdFx0XHR1aUxheWVycy5nZXQoa2V5KS5nZXRJdGVtcygpLmZvckVhY2gobm9kZSA9PiB0aGlzLnJlbmRlck5vZGUoPENhbnZhc05vZGU+bm9kZSkpXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGNsZWFyKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0dGhpcy5nbC5jbGVhckNvbG9yKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xyXG5cdFx0dGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCB0aGlzLmdsLkRFUFRIX0JVRkZFUl9CSVQpO1xyXG5cclxuXHRcdHRoaXMudGV4dEN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53b3JsZFNpemUueCwgdGhpcy53b3JsZFNpemUueSk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyTm9kZShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XHJcblx0XHQvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbihub2RlKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB6b29tIGxldmVsIG9mIHRoZSBzY2VuZVxyXG4gICAgICAgIHRoaXMuem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcblx0XHRcclxuXHRcdGlmKG5vZGUuaGFzQ3VzdG9tU2hhZGVyKXtcclxuXHRcdFx0Ly8gSWYgdGhlIG5vZGUgaGFzIGEgY3VzdG9tIHNoYWRlciwgcmVuZGVyIHVzaW5nIHRoYXRcclxuXHRcdFx0dGhpcy5yZW5kZXJDdXN0b20obm9kZSk7XHJcblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIEdyYXBoaWMpe1xyXG5cdFx0XHR0aGlzLnJlbmRlckdyYXBoaWMobm9kZSk7XHJcblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XHJcblx0XHRcdGlmKG5vZGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XHJcblx0XHRcdFx0dGhpcy5yZW5kZXJBbmltYXRlZFNwcml0ZShub2RlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnJlbmRlclNwcml0ZShub2RlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBVSUVsZW1lbnQpe1xyXG5cdFx0XHR0aGlzLnJlbmRlclVJRWxlbWVudChub2RlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkIHtcclxuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUik7XHJcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhzcHJpdGUpLCBzcHJpdGUpO1xyXG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZCB7XHJcblx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIpO1xyXG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoc3ByaXRlKSwgc3ByaXRlKTtcclxuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZCB7XHJcblxyXG5cdFx0aWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFBvaW50KXtcclxuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5QT0lOVF9TSEFERVIpO1xyXG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhncmFwaGljKSwgZ3JhcGhpYyk7XHJcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFJlY3QpIHtcclxuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5SRUNUX1NIQURFUik7XHJcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcclxuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHRcdH0gXHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkIHtcclxuXHRcdGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcclxuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5MQUJFTF9TSEFERVIpO1xyXG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyh1aUVsZW1lbnQpLCB1aUVsZW1lbnQpO1xyXG5cdFx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAodWlFbGVtZW50LnBvc2l0aW9uLnggLSB0aGlzLm9yaWdpbi54KSp0aGlzLnpvb20sICh1aUVsZW1lbnQucG9zaXRpb24ueSAtIHRoaXMub3JpZ2luLnkpKnRoaXMuem9vbSk7XHJcblx0XHRcdHRoaXMudGV4dEN0eC5yb3RhdGUoLXVpRWxlbWVudC5yb3RhdGlvbik7XHJcblx0XHRcdGxldCBnbG9iYWxBbHBoYSA9IHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYTtcclxuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gdWlFbGVtZW50LmFscGhhO1xyXG5cclxuXHRcdFx0Ly8gUmVuZGVyIHRleHRcclxuXHRcdFx0dGhpcy50ZXh0Q3R4LmZvbnQgPSB1aUVsZW1lbnQuZ2V0Rm9udFN0cmluZygpO1xyXG5cdFx0XHRsZXQgb2Zmc2V0ID0gdWlFbGVtZW50LmNhbGN1bGF0ZVRleHRPZmZzZXQodGhpcy50ZXh0Q3R4KTtcclxuXHRcdFx0dGhpcy50ZXh0Q3R4LmZpbGxTdHlsZSA9IHVpRWxlbWVudC5jYWxjdWxhdGVUZXh0Q29sb3IoKTtcclxuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gdWlFbGVtZW50LnRleHRDb2xvci5hO1xyXG5cdFx0XHR0aGlzLnRleHRDdHguZmlsbFRleHQodWlFbGVtZW50LnRleHQsIG9mZnNldC54IC0gdWlFbGVtZW50LnNpemUueC8yLCBvZmZzZXQueSAtIHVpRWxlbWVudC5zaXplLnkvMik7XHJcblxyXG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcclxuICAgICAgICBcdHRoaXMudGV4dEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyQ3VzdG9tKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcclxuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQobm9kZS5jdXN0b21TaGFkZXJLZXkpO1xyXG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMobm9kZSksIG5vZGUpO1xyXG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBhZGRPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4sIG5vZGU6IENhbnZhc05vZGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuXHRcdC8vIEdpdmUgdGhlIHNoYWRlciBhY2Nlc3MgdG8gdGhlIHdvcmxkIHNpemVcclxuXHRcdG9wdGlvbnMud29ybGRTaXplID0gdGhpcy53b3JsZFNpemU7XHJcblxyXG5cdFx0Ly8gQWRqdXN0IHRoZSBvcmlnaW4gcG9zaXRpb24gdG8gdGhlIHBhcmFsbGF4XHJcblx0XHRsZXQgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XHJcblx0XHRsZXQgcGFyYWxsYXggPSBuZXcgVmVjMigxLCAxKTtcclxuXHRcdGlmKGxheWVyIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllcil7XHJcblx0XHRcdHBhcmFsbGF4ID0gKDxQYXJhbGxheExheWVyPmxheWVyKS5wYXJhbGxheDtcclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zLm9yaWdpbiA9IHRoaXMub3JpZ2luLmNsb25lKCkubXVsdChwYXJhbGxheCk7XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG5cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBjbGFzcyBmb3IgV2ViR0wgc2hhZGVycy5cclxuICogVGhpcyBjbGFzcyBpcyBhIHNpbmdsZXRvbiwgYW5kIHRoZXJlIGlzIG9ubHkgb25lIGZvciBlYWNoIHNoYWRlciB0eXBlLlxyXG4gKiBBbGwgb2JqZWN0cyB0aGF0IHVzZSB0aGlzIHNoYWRlciB0eXBlIHdpbGwgcmVmZXIgdG8gYW5kIG1vZGlmeSB0aGlzIHNhbWUgdHlwZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNoYWRlclR5cGUge1xyXG5cdC8qKiBUaGUgbmFtZSBvZiB0aGlzIHNoYWRlciAqL1xyXG5cdHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBUaGUga2V5IHRvIHRoZSBXZWJHTFByb2dyYW0gaW4gdGhlIFJlc291cmNlTWFuYWdlciAqL1xyXG5cdHByb3RlY3RlZCBwcm9ncmFtS2V5OiBzdHJpbmc7XHJcblxyXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgcmVzb3VyY2UgbWFuYWdlciAqL1xyXG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHRoaXMucHJvZ3JhbUtleSA9IHByb2dyYW1LZXk7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgYW55IGJ1ZmZlciBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNoYWRlciB0eXBlLlxyXG5cdCAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIExvYWRzIGFueSB1bmlmb3Jtc1xyXG5cdCAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmdcclxuXHQgKi9cclxuXHRhYnN0cmFjdCByZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4dHJhY3RzIHRoZSBvcHRpb25zIGZyb20gdGhlIENhbnZhc05vZGUgYW5kIGdpdmVzIHRoZW0gdG8gdGhlIHJlbmRlciBmdW5jdGlvblxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGdldCBvcHRpb25zIGZyb21cclxuXHQgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHJlbmRlciBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdGdldE9wdGlvbnMobm9kZTogQ2FudmFzTm9kZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge3JldHVybiB7fTt9XHJcbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cdH1cclxuXHJcblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJsYWJlbFwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci50b1dlYkdMKCk7XHJcblx0XHRjb25zdCBib3JkZXJDb2xvciA9IG9wdGlvbnMuYm9yZGVyQ29sb3IudG9XZWJHTCgpO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG5cdFx0Ly8gQXR0cmlidXRlc1xyXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcclxuXHJcblx0XHQvLyBVbmlmb3Jtc1xyXG5cdFx0Y29uc3QgdV9CYWNrZ3JvdW5kQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JhY2tncm91bmRDb2xvclwiKTtcclxuXHRcdGdsLnVuaWZvcm00ZnYodV9CYWNrZ3JvdW5kQ29sb3IsIGJhY2tncm91bmRDb2xvcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlckNvbG9yXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTRmdih1X0JvcmRlckNvbG9yLCBib3JkZXJDb2xvcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfTWF4U2l6ZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfTWF4U2l6ZVwiKTtcclxuICAgICAgICBnbC51bmlmb3JtMmYodV9NYXhTaXplLCAtdmVydGV4RGF0YVswXSwgdmVydGV4RGF0YVsxXSk7XHJcblxyXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxyXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyV2lkdGggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlcldpZHRoXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTFmKHVfQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgvbWF4RGltZW5zaW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdV9Cb3JkZXJSYWRpdXMgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlclJhZGl1c1wiKTtcclxuXHRcdGdsLnVuaWZvcm0xZih1X0JvcmRlclJhZGl1cywgb3B0aW9ucy5ib3JkZXJSYWRpdXMvbWF4RGltZW5zaW9uKTtcclxuXHJcblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXHJcblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XHJcblxyXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XHJcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XHJcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XHJcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcclxuXHJcblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcclxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xyXG5cclxuXHRcdC8vIERyYXcgdGhlIHF1YWRcclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcclxuXHQgKi9cclxuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRsZXQgeCwgeTtcclxuXHJcblx0XHRpZihoID4gdyl7XHJcblx0XHRcdHkgPSAwLjU7XHJcblx0XHRcdHggPSB3LygyKmgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9IDAuNTtcclxuXHRcdFx0eSA9IGgvKDIqdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHQteCwgIHksXHJcblx0XHRcdC14LCAteSxcclxuXHRcdFx0IHgsICB5LFxyXG5cdFx0XHQgeCwgLXlcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0Z2V0T3B0aW9ucyhyZWN0OiBMYWJlbCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcblx0XHRcdHBvc2l0aW9uOiByZWN0LnBvc2l0aW9uLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHJlY3QuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCksXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWN0LmNhbGN1bGF0ZUJvcmRlckNvbG9yKCksXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiByZWN0LmJvcmRlcldpZHRoLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlY3QuYm9yZGVyUmFkaXVzLFxyXG5cdFx0XHRzaXplOiByZWN0LnNpemUsXHJcblx0XHRcdHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi8uLi8uLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vU2hhZGVyVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XHJcblxyXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cdH1cclxuXHJcblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJwb2ludFwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRsZXQgcG9zaXRpb24gPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29vcmRzKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMub3JpZ2luLCBvcHRpb25zLndvcmxkU2l6ZSk7XHJcblx0XHRsZXQgY29sb3IgPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29sb3Iob3B0aW9ucy5jb2xvcik7XHJcblxyXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcclxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblxyXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gcG9zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cclxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuXHRcdC8vIEF0dHJpYnV0ZXNcclxuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xyXG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XHJcblxyXG5cdFx0Ly8gVW5pZm9ybXNcclxuXHRcdGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTRmdih1X0NvbG9yLCBjb2xvcik7XHJcblxyXG5cdFx0Y29uc3QgdV9Qb2ludFNpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1BvaW50U2l6ZVwiKTtcclxuXHRcdGdsLnVuaWZvcm0xZih1X1BvaW50U2l6ZSwgb3B0aW9ucy5wb2ludFNpemUpO1xyXG5cclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdGdldE9wdGlvbnMocG9pbnQ6IFBvaW50KTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuXHRcdFx0cG9zaXRpb246IHBvaW50LnBvc2l0aW9uLFxyXG5cdFx0XHRjb2xvcjogcG9pbnQuY29sb3IsXHJcblx0XHRcdHBvaW50U2l6ZTogcG9pbnQuc2l6ZSxcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XHJcblxyXG4vKiogUmVwcmVzZW50cyBhbnkgV2ViR0wgb2JqZWN0cyB0aGF0IGhhdmUgYSBxdWFkIG1lc2ggKGkuZS4gYSByZWN0YW5ndWxhciBnYW1lIG9iamVjdCBjb21wb3NlZCBvZiBvbmx5IHR3byB0cmlhbmdsZXMpICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFF1YWRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XHJcblx0LyoqIFRoZSBrZXkgdG8gdGhlIGJ1ZmZlciBvYmplY3QgZm9yIHRoaXMgc2hhZGVyICovXHJcblx0cHJvdGVjdGVkIGJ1ZmZlck9iamVjdEtleTogc3RyaW5nO1xyXG5cclxuXHQvKiogVGhlIHNjYWxlIG1hdHJpYyAqL1xyXG5cdHByb3RlY3RlZCBzY2FsZTogTWF0NHg0O1xyXG5cclxuXHQvKiogVGhlIHJvdGF0aW9uIG1hdHJpeCAqL1xyXG5cdHByb3RlY3RlZCByb3RhdGlvbjogTWF0NHg0O1xyXG5cclxuXHQvKiogVGhlIHRyYW5zbGF0aW9uIG1hdHJpeCAqL1xyXG5cdHByb3RlY3RlZCB0cmFuc2xhdGlvbjogTWF0NHg0O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XHJcblxyXG5cdFx0dGhpcy5zY2FsZSA9IE1hdDR4NC5JREVOVElUWTtcclxuXHRcdHRoaXMucm90YXRpb24gPSBNYXQ0eDQuSURFTlRJVFk7XHJcblx0XHR0aGlzLnRyYW5zbGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xyXG5cdH1cclxufSIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFF1YWRTaGFkZXJUeXBlIGZyb20gXCIuL1F1YWRTaGFkZXJUeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0U2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XHJcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicmVjdFwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3IudG9XZWJHTCgpO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG5cdFx0Ly8gQXR0cmlidXRlc1xyXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcclxuXHJcblx0XHQvLyBVbmlmb3Jtc1xyXG5cdFx0Y29uc3QgdV9Db2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQ29sb3JcIik7XHJcblx0XHRnbC51bmlmb3JtNGZ2KHVfQ29sb3IsIGNvbG9yKTtcclxuXHJcblx0XHQvLyBHZXQgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXHJcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXHJcblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XHJcblxyXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XHJcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XHJcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XHJcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcclxuXHJcblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcclxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xyXG5cclxuXHRcdC8vIERyYXcgdGhlIHF1YWRcclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG5cdH1cclxuXHJcblxyXG5cdC8qXHJcblx0XHRTbyBhcyBpdCB0dXJucyBvdXQsIFdlYkdMIGhhcyBhbiBpc3N1ZSB3aXRoIG5vbi1zcXVhcmUgcXVhZHMuXHJcblx0XHRJdCBkb2Vzbid0IGxpa2Ugd2hlbiB5b3UgZG9uJ3QgaGF2ZSBhIDEtMSBzY2FsZSwgYW5kIHJvdGF0aW9ucyBhcmUgZW50aXJlbHkgbWVzc2VkIHVwIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxyXG5cdFx0VG8gc29sdmUgdGhpcywgSSB1c2VkIHRoZSBzY2FsZSBvZiB0aGUgTEFSR0VTVCBkaW1lbnNpb24gb2YgdGhlIHF1YWQgdG8gbWFrZSBhIHNxdWFyZSwgdGhlbiBhZGp1c3RlZCB0aGUgdmVydGV4IGNvb3JkaW5hdGVzIGluc2lkZSBvZiB0aGF0LlxyXG5cdFx0QSBkaWFncmFtIG9mIHRoZSBzb2x1dGlvbiBmb2xsb3dzLlxyXG5cclxuXHRcdFRoZXJlIGlzIGEgYm91bmRpbmcgc3F1YXJlIGZvciB0aGUgcXVhZCB3aXRoIGRpbWVuc2lvbnMgaHhoIChpbiB0aGlzIGNhc2UsIHNpbmNlIGhlaWdodCBpcyB0aGUgbGFyZ2VzdCBkaW1lbnNpb24pLlxyXG5cdFx0VGhlIG9mZnNldCBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uIGlzIHRoZXJlZm9yZSAwLjUsIGFzIGl0IGlzIG5vcm1hbGx5LlxyXG5cdFx0SG93ZXZlciwgdGhlIG9mZnNldCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gaXMgbm90IHNvIHN0cmFpZ2h0Zm9yd2FyZCwgYnV0IGlzbid0IGNvbmNlcHR1YWxseSBoYXJkLlxyXG5cdFx0QWxsIHdlIHJlYWxseSBoYXZlIHRvIGRvIGlzIGEgcmFuZ2UgY2hhbmdlIGZyb20gWzAsIGhlaWdodC8yXSB0byBbMCwgMC41XSwgd2hlcmUgb3VyIHZhbHVlIGlzIHQgPSB3aWR0aC8yLCBhbmQgMCA8PSB0IDw9IGhlaWdodC8yLlxyXG5cclxuXHRcdFNvIG5vdyB3ZSBoYXZlIG91ciByZWN0LCBpbiBhIHNwYWNlIHNjYWxlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uLlxyXG5cdFx0Um90YXRpb25zIHdvcmsgYXMgeW91IHdvdWxkIGV4cGVjdCwgZXZlbiBmb3IgbG9uZyByZWN0YW5nbGVzLlxyXG5cclxuXHRcdFx0XHRcdDAuNVxyXG5cdFx0XHRfXyBfXyBfXyBfXyBfXyBfXyBfX1xyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdFx0LTAuNXxfIF98ODg4ODg4ODg4ODh8XyBffDAuNVxyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdCAgXHRcdHxfX198ODg4ODg4ODg4ODh8X19ffFxyXG5cdFx0XHQgIFx0XHQtMC41XHJcblxyXG5cdFx0VGhlIGdldFZlcnRpY2VzIGZ1bmN0aW9uIGJlbG93IGRvZXMgYXMgZGVzY3JpYmVkLCBhbmQgY29udmVydHMgdGhlIHJhbmdlXHJcblx0Ki9cclxuXHQvKipcclxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxyXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxyXG5cdCAqL1xyXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcclxuXHRcdGxldCB4LCB5O1xyXG5cclxuXHRcdGlmKGggPiB3KXtcclxuXHRcdFx0eSA9IDAuNTtcclxuXHRcdFx0eCA9IHcvKDIqaCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4ID0gMC41O1xyXG5cdFx0XHR5ID0gaC8oMip3KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdC14LCAgeSxcclxuXHRcdFx0LXgsIC15LFxyXG5cdFx0XHQgeCwgIHksXHJcblx0XHRcdCB4LCAteVxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRnZXRPcHRpb25zKHJlY3Q6IFJlY3QpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xyXG5cdFx0XHRwb3NpdGlvbjogcmVjdC5wb3NpdGlvbixcclxuXHRcdFx0Y29sb3I6IHJlY3QuY29sb3IsXHJcblx0XHRcdHNpemU6IHJlY3Quc2l6ZSxcclxuXHRcdFx0cm90YXRpb246IHJlY3Qucm90YXRpb25cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xyXG5cclxuLyoqIEEgc2hhZGVyIGZvciBzcHJpdGVzIGFuZCBhbmltYXRlZCBzcHJpdGVzICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcml0ZVNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XHJcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwic3ByaXRlXCI7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cdH1cclxuXHJcblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRleHR1cmUob3B0aW9ucy5pbWFnZUtleSk7XHJcblxyXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnksIG9wdGlvbnMuc2NhbGUpO1xyXG5cclxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcblx0XHQvLyBCaW5kIHRoZSBidWZmZXJcclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcblx0XHQvLyBBdHRyaWJ1dGVzXHJcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiBGU0laRSwgMCAqIEZTSVpFKTtcclxuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xyXG5cclxuXHRcdGNvbnN0IGFfVGV4Q29vcmQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfVGV4Q29vcmRcIik7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfVGV4Q29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIEZTSVpFLCAyKkZTSVpFKTtcclxuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfVGV4Q29vcmQpO1xyXG5cclxuXHRcdC8vIFVuaWZvcm1zXHJcblx0XHQvLyBHZXQgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXHJcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXHJcblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XHJcblxyXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XHJcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XHJcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XHJcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcclxuXHJcblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcclxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xyXG5cclxuXHRcdC8vIFNldCB1cCBvdXIgc2FtcGxlciB3aXRoIG91ciBhc3NpZ25lZCB0ZXh0dXJlIHVuaXRcclxuXHRcdGNvbnN0IHVfU2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfU2FtcGxlclwiKTtcclxuXHRcdGdsLnVuaWZvcm0xaSh1X1NhbXBsZXIsIHRleHR1cmUpO1xyXG5cclxuXHRcdC8vIFBhc3MgaW4gdGV4U2hpZnRcclxuXHRcdGNvbnN0IHVfdGV4U2hpZnQgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3RleFNoaWZ0XCIpO1xyXG5cdFx0Z2wudW5pZm9ybTJmdih1X3RleFNoaWZ0LCBvcHRpb25zLnRleFNoaWZ0KTtcclxuXHJcblx0XHQvLyBQYXNzIGluIHRleFNjYWxlXHJcblx0XHRjb25zdCB1X3RleFNjYWxlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXhTY2FsZVwiKTtcclxuXHRcdGdsLnVuaWZvcm0yZnYodV90ZXhTY2FsZSwgb3B0aW9ucy50ZXhTY2FsZSk7XHJcblxyXG5cdFx0Ly8gRHJhdyB0aGUgcXVhZFxyXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxyXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxyXG5cdCAqL1xyXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyLCBzY2FsZTogRmxvYXQzMkFycmF5KTogRmxvYXQzMkFycmF5IHtcclxuXHRcdGxldCB4LCB5O1xyXG5cclxuXHRcdGlmKGggPiB3KXtcclxuXHRcdFx0eSA9IDAuNTtcclxuXHRcdFx0eCA9IHcvKDIqaCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4ID0gMC41O1xyXG5cdFx0XHR5ID0gaC8oMip3KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTY2FsZSB0aGUgcmVuZGVyaW5nIHNwYWNlIGlmIG5lZWRlZFxyXG5cdFx0eCAqPSBzY2FsZVswXTtcclxuXHRcdHkgKj0gc2NhbGVbMV07XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHQteCwgIHksIDAuMCwgMC4wLFxyXG5cdFx0XHQteCwgLXksIDAuMCwgMS4wLFxyXG5cdFx0XHQgeCwgIHksIDEuMCwgMC4wLFxyXG5cdFx0XHQgeCwgLXksIDEuMCwgMS4wXHJcblx0XHRdKTtcclxuXHR9XHJcblxyXG5cdGdldE9wdGlvbnMoc3ByaXRlOiBTcHJpdGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuXHRcdGxldCB0ZXhTaGlmdDtcclxuXHRcdGxldCB0ZXhTY2FsZTtcclxuXHJcblx0XHRpZihzcHJpdGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XHJcblx0XHRcdGxldCBhbmltYXRpb25JbmRleCA9IHNwcml0ZS5hbmltYXRpb24uZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk7XHJcblx0XHRcdGxldCBvZmZzZXQgPSBzcHJpdGUuZ2V0QW5pbWF0aW9uT2Zmc2V0KGFuaW1hdGlvbkluZGV4KTtcclxuXHRcdFx0dGV4U2hpZnQgPSBuZXcgRmxvYXQzMkFycmF5KFtvZmZzZXQueCAvIChzcHJpdGUuY29scyAqIHNwcml0ZS5zaXplLngpLCBvZmZzZXQueSAvIChzcHJpdGUucm93cyAqIHNwcml0ZS5zaXplLnkpXSk7XHJcblx0XHRcdHRleFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbMS8oc3ByaXRlLmNvbHMpLCAxLyhzcHJpdGUucm93cyldKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRleFNoaWZ0ID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pO1xyXG5cdFx0XHR0ZXhTY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDFdKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuXHRcdFx0cG9zaXRpb246IHNwcml0ZS5wb3NpdGlvbixcclxuXHRcdFx0cm90YXRpb246IHNwcml0ZS5yb3RhdGlvbixcclxuXHRcdFx0c2l6ZTogc3ByaXRlLnNpemUsXHJcblx0XHRcdHNjYWxlOiBzcHJpdGUuc2NhbGUudG9BcnJheSgpLFxyXG5cdFx0XHRpbWFnZUtleTogc3ByaXRlLmltYWdlSWQsXHJcblx0XHRcdHRleFNoaWZ0LFxyXG5cdFx0XHR0ZXhTY2FsZVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvcHRpb25zO1xyXG5cdH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSB9IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCI7XHJcbmltcG9ydCBTdHJpbmdVdGlscyBmcm9tIFwiLi4vVXRpbHMvU3RyaW5nVXRpbHNcIjtcclxuaW1wb3J0IEF1ZGlvTWFuYWdlciBmcm9tIFwiLi4vU291bmQvQXVkaW9NYW5hZ2VyXCI7XHJcbmltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XHJcbmltcG9ydCBXZWJHTFByb2dyYW1UeXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBmb3IgdGhlIGdhbWUgZW5naW5lLlxyXG4gKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBpbnRlcmZhY2VzIHdpdGggdGhlIGxvYWRhYmxlIGFzc2V0cyBvZiBhIGdhbWUgc3VjaCBhcyBpbWFnZXMsIGRhdGEgZmlsZXMsXHJcbiAqIGFuZCBzb3VuZHMsIHdoaWNoIGFyZSBhbGwgZm91bmQgaW4gdGhlIGRpc3QgZm9sZGVyLlxyXG4gKiBUaGlzIGNsYXNzIGNvbnRyb2xzIGxvYWRpbmcgYW5kIHVwZGF0ZXMgdGhlIEByZWZlcmVuY2VbU2NlbmVdIHdpdGggdGhlIGxvYWRpbmcgcHJvZ3Jlc3MsIHNvIHRoYXQgdGhlIHNjZW5lIGRvZXMgXHJcbiAqIG5vdCBzdGFydCBiZWZvcmUgYWxsIG5lY2Vzc2FyeSBhc3NldHMgYXJlIGxvYWRlZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc291cmNlTWFuYWdlciB7XHJcbiAgICAvLyBJbnN0YW5jZSBmb3IgdGhlIHNpbmdsZXRvbiBjbGFzc1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIFxyXG4gICAgLy8gQm9vbGVhbnMgdG8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgUmVzb3VyY2VNYW5hZ2VyIGlzIGN1cnJlbnRseSBsb2FkaW5nIHNvbWV0aGluZ1xyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IGFueSByZXNvdXJjZXMgYXJlIGxvYWRpbmcgKi9cclxuICAgIHByaXZhdGUgbG9hZGluZzogYm9vbGVhbjtcclxuICAgIC8qKiBBIGJvb2xlYW4gdG8gaW5kaWNhdGUgdGhhdCB0aGUgYXNzZXRzIGp1c3QgZmluaXNoZWQgbG9hZGluZyAqL1xyXG4gICAgcHJpdmF0ZSBqdXN0TG9hZGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8vIEZ1bmN0aW9ucyB0byBkbyBzb21ldGhpbmcgd2hlbiBsb2FkaW5nIHByb2dyZXNzZXMgb3IgaXMgY29tcGxldGVkIHN1Y2ggYXMgcmVuZGVyIGEgbG9hZGluZyBzY3JlZW5cclxuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBwcm9ncmVzc2VzICovXHJcbiAgICBwdWJsaWMgb25Mb2FkUHJvZ3Jlc3M6IEZ1bmN0aW9uO1xyXG4gICAgLyoqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBsb2FkaW5nIGNvbXBsZXRlcyAqL1xyXG4gICAgcHVibGljIG9uTG9hZENvbXBsZXRlOiBGdW5jdGlvbjtcclxuXHJcblxyXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGltYWdlcyBuZWVkIHRvIGJlIGxvYWRlZCovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlc0xvYWRlZDogbnVtYmVyO1xyXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGltYWdlcyBhcmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlc1RvTG9hZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBxdWV1ZSBvZiBpbWFnZXMgd2UgbXVzdCBsb2FkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICAvKiogQSBtYXAgb2YgdGhlIGltYWdlcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZS4gVGhlIHJlZmVyZW5jZSB0byB0aGVzZSBpbWFnZXMgb25seSBleGlzdCBoZXJlIGZvciBlYXN5IGNsZWFudXAuICovXHJcbiAgICBwcml2YXRlIGltYWdlczogTWFwPEhUTUxJbWFnZUVsZW1lbnQ+O1xyXG5cclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBuZWVkIHRvIGJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQ6IG51bWJlcjtcclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBxdWV1ZSBvZiB0aWxlbWFwcyB3ZSBtdXN0IGxvYWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcclxuICAgIC8qKiBBIG1hcCBvZiB0aGUgdGlsZW1hcHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXHJcbiAgICBwcml2YXRlIHNwcml0ZXNoZWV0czogTWFwPFNwcml0ZXNoZWV0PjtcclxuXHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQ6IG51bWJlcjtcclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHRpbGVtYXBzIHdlIG11c3QgbG9hZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICAvKiogQSBtYXAgb2YgdGhlIHRpbGVtYXBzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xyXG4gICAgcHJpdmF0ZSB0aWxlbWFwczogTWFwPFRpbGVkVGlsZW1hcERhdGE+O1xyXG5cclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VuZHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Mb2FkZWQ6IG51bWJlcjtcclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VuZHMgYXJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb1RvTG9hZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBxdWV1ZSBvZiBzb3VuZHMgd2UgbXVzdCBsb2FkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICAvKiogQSBtYXAgb2YgdGhlIHNvdW5kcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cclxuICAgIHByaXZhdGUgYXVkaW9CdWZmZXJzOiBNYXA8QXVkaW9CdWZmZXI+O1xyXG5cclxuICAgIC8qKiBUaGUgdG90YWwgbnVtYmVyIG9mIFwidHlwZXNcIiBvZiB0aGluZ3MgdGhhdCBuZWVkIHRvIGJlIGxvYWRlZCAoaS5lLiBpbWFnZXMgYW5kIHRpbGVtYXBzKSAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90eXBlc1RvTG9hZDogbnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfanNvbkxvYWRlZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uVG9Mb2FkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcclxuICAgIHByaXZhdGUganNvbk9iamVjdHM6IE1hcDxSZWNvcmQ8c3RyaW5nLCBhbnk+PjtcclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIElORk9STUFUSU9OIFNQRUNJQUwgVE8gV0VCR0wgIyMjIyMjIyMjIyAqL1xyXG4gICAgcHJpdmF0ZSBnbF9XZWJHTEFjdGl2ZTogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aF9TaGFkZXI+O1xyXG5cclxuICAgIHByaXZhdGUgZ2xfU2hhZGVyUHJvZ3JhbXM6IE1hcDxXZWJHTFByb2dyYW1UeXBlPjtcclxuXHJcbiAgICBwcml2YXRlIGdsX1RleHR1cmVzOiBNYXA8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgZ2xfTmV4dFRleHR1cmVJRDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBnbF9CdWZmZXJzOiBNYXA8V2ViR0xCdWZmZXI+OyBcclxuXHJcbiAgICBwcml2YXRlIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBVTkxPQURJTkcgQU5EIEVYQ0xVU0lPTiBMSVNUICMjIyMjIyMjIyMgKi9cclxuICAgIC8qKiBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRoYXQgd2lsbCBiZSB1bmxvYWRlZCBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHNjZW5lICovXHJcbiAgICBwcml2YXRlIHJlc291cmNlc1RvVW5sb2FkOiBBcnJheTxSZXNvdXJjZVJlZmVyZW5jZT47XHJcblxyXG4gICAgLyoqIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8ga2VlcCB1bnRpbCBmdXJ0aGVyIG5vdGljZSAqL1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZXNUb0tlZXA6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID0gMDtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5qc29uT2JqZWN0cyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbF9UZXh0dXJlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmdsX05leHRUZXh0dXJlSUQgPSAwO1xyXG4gICAgICAgIHRoaXMuZ2xfQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZCA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzVG9LZWVwID0gbmV3IEFycmF5KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgU0lOR0xFVE9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoaXMgY2xhc3Mgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSBleGlzdFxyXG4gICAgICogQHJldHVybnMgVGhlIHJlc291cmNlIG1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCk6IFJlc291cmNlTWFuYWdlciB7XHJcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFJlc291cmNlTWFuYWdlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBQVUJMSUMgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2YXRlcyBvciBkZWFjdGl2YXRlcyB0aGUgdXNlIG9mIFdlYkdMXHJcbiAgICAgKiBAcGFyYW0gZmxhZyBUcnVlIGlmIFdlYkdMIHNob3VsZCBiZSB1c2VkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgaW5zdGFuY2Ugb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQsIGlmIGFwcGxpY2FibGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZVdlYkdMKGZsYWc6IGJvb2xlYW4sIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmdsX1dlYkdMQWN0aXZlID0gZmxhZztcclxuXHJcbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XHJcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbiBpbWFnZSBmcm9tIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgdGhlIGxvYWRlZCBpbWFnZSB3aXRoXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW1hZ2Uoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMga2VlcEltYWdlKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIGltYWdlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBpbWFnZVxyXG4gICAgICogQHJldHVybnMgVGhlIGltYWdlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRJbWFnZShrZXk6IHN0cmluZyk6IEhUTUxJbWFnZUVsZW1lbnQge1xyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMuaW1hZ2VzLmdldChrZXkpO1xyXG4gICAgICAgIGlmKGltYWdlID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aHJvdyBgVGhlcmUgaXMgbm8gaW1hZ2UgYXNzb2NpYXRlZCB3aXRoIGtleSBcIiR7a2V5fVwiYFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNwcml0ZXNoZWV0IGZyb20gZmlsZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB0aGUgbG9hZGVkIHNwcml0ZXNoZWV0IHdpdGhcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzcHJpdGVzaGVldChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBrZWVwU3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgc3ByaXRlc2hlZXRcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxyXG4gICAgICogQHJldHVybnMgVGhlIGxvYWRlZCBTcHJpdGVzaGVldFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcpOiBTcHJpdGVzaGVldCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc2hlZXRzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYW4gYXVkaW8gZmlsZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgYXVkaW8gZmlsZVxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXVkaW8oa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICAgcHVibGljIGtlZXBBdWRpbyhrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvQnVmZmVyIGNyZWF0ZWQgZnJvbSB0aGUgbG9hZGVkIGF1ZGlvIGZsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXVkaW8oa2V5OiBzdHJpbmcpOiBBdWRpb0J1ZmZlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9CdWZmZXJzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhIHRpbGVtYXAgZnJvbSBhIGpzb24gZmlsZS4gQXV0b21hdGljYWxseSBsb2FkcyByZWxhdGVkIGltYWdlc1xyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGlsZW1hcChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgIHB1YmxpYyBrZWVwVGlsZW1hcChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLlRJTEVNQVApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmVpdmVzIGEgbG9hZGVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIHRpbGVtYXBcclxuICAgICAqIEByZXR1cm5zIFRoZSB0aWxlbWFwIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRpbGVtYXAoa2V5OiBzdHJpbmcpOiBUaWxlZFRpbGVtYXBEYXRhIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlbWFwcy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFuIG9iamVjdCBmcm9tIGEganNvbiBmaWxlLlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUganNvbiBmaWxlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9iamVjdChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKXtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICAgcHVibGljIGtlZXBPYmplY3Qoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5KU09OKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJlaXZlcyBhIGxvYWRlZCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIG9iamVjdFxyXG4gICAgICogQHJldHVybnMgVGhlIG9iamVjdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPYmplY3Qoa2V5OiBzdHJpbmcpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmpzb25PYmplY3RzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgTE9BRCBGVU5DVElPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIHJlc291cmNlcyBjdXJyZW50bHkgaW4gdGhlIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbCB3aGVuIHRoZSByZXNvdXJjZXMgYXJlIGZpbmlzaGVkIGxvYWRpbmdcclxuICAgICAqL1xyXG4gICAgbG9hZFJlc291cmNlc0Zyb21RdWV1ZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3R5cGVzVG9Mb2FkID0gNTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gTG9hZCBldmVyeXRoaW5nIGluIHRoZSBxdWV1ZXMuIFRpbGVtYXBzIGhhdmUgdG8gY29tZSBiZWZvcmUgaW1hZ2VzIGJlY2F1c2UgdGhleSB3aWxsIGFkZCBuZXcgaW1hZ2VzIHRvIHRoZSBxdWV1ZVxyXG4gICAgICAgIHRoaXMubG9hZFRpbGVtYXBzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgVGlsZW1hcHNcIik7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFNwcml0ZXNoZWV0c0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBTcHJpdGVzaGVldHNcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRJbWFnZXNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIEltYWdlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRBdWRpb0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIEF1ZGlvXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRPYmplY3RzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIE9iamVjdHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xfTG9hZFNoYWRlcnNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBTaGFkZXJzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICAvLyBEb25lIGxvYWRpbmdcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBVTkxPQUQgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXHJcbiAgICBcclxuICAgIHByaXZhdGUga2VlcFJlc291cmNlKGtleTogc3RyaW5nLCB0eXBlOiBSZXNvdXJjZVR5cGUpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIktlZXAgcmVzb3VyY2UuLi5cIik7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucmVzb3VyY2VzVG9VbmxvYWQubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1RvVW5sb2FkW2ldO1xyXG4gICAgICAgICAgICBpZihyZXNvdXJjZS5rZXkgPT09IGtleSAmJiByZXNvdXJjZS5yZXNvdXJjZVR5cGUgPT09IHR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCByZXNvdXJjZSBcIiArIGtleSArIFwiIG9mIHR5cGUgXCIgKyB0eXBlICsgXCIuIEtlZXBpbmcuXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlVG9Nb3ZlID0gdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvS2VlcC5wdXNoKC4uLnJlc291cmNlVG9Nb3ZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHJlZmVyZW5jZXMgdG8gYWxsIHJlc291cmNlcyBpbiB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgICovXHJcbiAgICB1bmxvYWRBbGxSZXNvdXJjZXMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvcihsZXQgcmVzb3VyY2Ugb2YgdGhpcy5yZXNvdXJjZXNUb1VubG9hZCl7XHJcbiAgICAgICAgICAgIC8vIFVubG9hZCB0aGUgcmVzb3VyY2VcclxuICAgICAgICAgICAgdGhpcy51bmxvYWRSZXNvdXJjZShyZXNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdW5sb2FkUmVzb3VyY2UocmVzb3VyY2U6IFJlc291cmNlUmVmZXJlbmNlKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRGVsZXRlIHRoZSByZXNvdXJjZSBpdHNlbGZcclxuICAgICAgICBzd2l0Y2gocmVzb3VyY2UucmVzb3VyY2VUeXBlKXtcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuSU1BR0U6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuVElMRU1BUDpcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZW1hcHMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5BVURJTzpcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLkpTT046XHJcbiAgICAgICAgICAgICAgICB0aGlzLmpzb25PYmplY3RzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLlNIQURFUjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KHJlc291cmNlLmtleSkuZGVsZXRlKHRoaXMuZ2wpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVsZXRlIGFueSBkZXBlbmRlbmNpZXNcclxuICAgICAgICBmb3IobGV0IGRlcGVuZGVuY3kgb2YgcmVzb3VyY2UuZGVwZW5kZW5jaWVzKXtcclxuICAgICAgICAgICAgdGhpcy51bmxvYWRSZXNvdXJjZShkZXBlbmRlbmN5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBXT1JLIEZVTkNUSU9OUyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIHRpbGVtYXBzIGN1cnJlbnRseSBpbiB0aGUgdGlsZW1hcCBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gbG9hZGluZyBpcyBjb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvYWRUaWxlbWFwc0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIGxldCB0aWxlbWFwID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkVGlsZW1hcCh0aWxlbWFwLmtleSwgdGlsZW1hcC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgdGlsZW1hcCBcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIHBhdGhUb1RpbGVtYXBKU09OIFRoZSBwYXRoIHRvIHRoZSB0aWxlbWFwIEpTT04gZmlsZVxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZFRpbGVtYXAoa2V5OiBzdHJpbmcsIHBhdGhUb1RpbGVtYXBKU09OOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGhUb1RpbGVtYXBKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdGlsZW1hcE9iamVjdCA9IDxUaWxlZFRpbGVtYXBEYXRhPkpTT04ucGFyc2UoZmlsZVRleHQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gV2UgY2FuIHBhcnNlIHRoZSBvYmplY3QgbGF0ZXIgLSBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gbG9hZGluZ1xyXG4gICAgICAgICAgICB0aGlzLnRpbGVtYXBzLmFkZChrZXksIHRpbGVtYXBPYmplY3QpO1xyXG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuVElMRU1BUCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSB0aWxlc2V0IGltYWdlcyB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBpbWFnZWxvYWRpbmcgcXVldWVcclxuICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXBPYmplY3QudGlsZXNldHMpe1xyXG4gICAgICAgICAgICAgICAgaWYodGlsZXNldC5pbWFnZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IHRpbGVzZXQuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1RpbGVtYXBKU09OKSArIGtleTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgaW1hZ2UgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0aWxlbWFwXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aWxlc2V0LnRpbGVzKXtcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGUgb2YgdGlsZXNldC50aWxlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aWxlLmltYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvVGlsZW1hcEpTT04pICsga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGltYWdlIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgdGlsZW1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZXNvdXJjZSByZWZlcmVuY2UgdG8gdGhlIGxpc3Qgb2YgcmVzb3VyY2UgdG8gdW5sb2FkXHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChyZXNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZ1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdUaWxlbWFwKGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGEgdGlsZW1hcC4gQ2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCBiZWluZyBsb2FkZWRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdUaWxlbWFwKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCl7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyB0aWxlbWFwc1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFsbCBzcHJpdGVzaGVldHMgY3VycmVudGx5IGluIHRoZSBzcHJpdGVzaGVldCBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHNwcml0ZXNoZWV0cyBhcmUgZG9uZSBsb2FkaW5nXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZFNwcml0ZXNoZWV0c0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPT09IDApe1xyXG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgbGV0IHNwcml0ZXNoZWV0ID0gdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFNwcml0ZXNoZWV0KHNwcml0ZXNoZWV0LmtleSwgc3ByaXRlc2hlZXQucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIHNwcml0ZXNoZWV0IFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gcGF0aFRvU3ByaXRlc2hlZXRKU09OIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCBKU09OIGZpbGVcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZFNwcml0ZXNoZWV0KGtleTogc3RyaW5nLCBwYXRoVG9TcHJpdGVzaGVldEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aFRvU3ByaXRlc2hlZXRKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3ByaXRlc2hlZXQgPSA8U3ByaXRlc2hlZXQ+SlNPTi5wYXJzZShmaWxlVGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBXZSBjYW4gcGFyc2UgdGhlIG9iamVjdCBsYXRlciAtIGl0J3MgbXVjaCBmYXN0ZXIgdGhhbiBsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc2hlZXRzLmFkZChrZXksIHNwcml0ZXNoZWV0KTtcclxuXHJcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSBpbWFnZSB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCBpdCB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXHJcbiAgICAgICAgICAgIGxldCBwYXRoID0gU3RyaW5nVXRpbHMuZ2V0UGF0aEZyb21GaWxlUGF0aChwYXRoVG9TcHJpdGVzaGVldEpTT04pICsgc3ByaXRlc2hlZXQuc3ByaXRlU2hlZXRJbWFnZTtcclxuICAgICAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IHNwcml0ZXNoZWV0Lm5hbWUsIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xyXG5cclxuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoc3ByaXRlc2hlZXQubmFtZSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChyZXNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZ1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdTcHJpdGVzaGVldChjYWxsYmFja0lmTGFzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhIHNwcml0ZXNoZWV0LiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaWYgdGhpcyBpcyB0aGUgbGFzdCBzcHJpdGVzaGVldCBiZWluZyBsb2FkZWRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0IHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nU3ByaXRlc2hlZXQoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHNwcml0ZXNoZWV0c1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFsbCBpbWFnZXMgY3VycmVudGx5IGluIHRoZSBpbWFnZSBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgaW1hZ2VzIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkSW1hZ2VzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2UoaW1hZ2Uua2V5LCBpbWFnZS5wYXRoLCBpbWFnZS5pc0RlcGVuZGVuY3ksIG9uRmluaXNoTG9hZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciBpbWFnZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRJbWFnZShrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBpc0RlcGVuZGVuY3k6IGJvb2xlYW4sIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0byBsb2FkZWQgaW1hZ2VzXHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLmFkZChrZXksIGltYWdlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vdCBhIGRlcGVuZGVuY3ksIHB1c2ggaXQgdG8gdGhlIHVubG9hZCBsaXN0LiBPdGhlcndpc2UgaXQncyBtYW5hZ2VkIGJ5IHNvbWV0aGluZyBlbHNlXHJcbiAgICAgICAgICAgIGlmKCFpc0RlcGVuZGVuY3kpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBXZWJHTCBpcyBhY3RpdmUsIGNyZWF0ZSBhIHRleHR1cmVcclxuICAgICAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVdlYkdMVGV4dHVyZShrZXksIGltYWdlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmluaXNoIGltYWdlIGxvYWRcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW1hZ2Uuc3JjID0gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIGltYWdlLiBJZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlLCBpdCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ0ltYWdlKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCApe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgaW1hZ2VzXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIGF1ZGlvIGN1cnJlbnRseSBpbiB0aGUgdGlsZW1hcCBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGlsZW1hcHMgYXJlIGRvbmUgbG9hZGluZ1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvYWRBdWRpb0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKXtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICBsZXQgYXVkaW8gPSB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQXVkaW8oYXVkaW8ua2V5LCBhdWRpby5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBzaW5ndWxhciBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZEF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIGxldCBhdWRpb0N0eCA9IEF1ZGlvTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEF1ZGlvQ29udGV4dCgpO1xyXG5cclxuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG5cclxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgYXVkaW9DdHguZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIChidWZmZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsaXN0IG9mIGF1ZGlvIGJ1ZmZlcnNcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmcgc291bmRcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ0F1ZGlvKGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICAgICAgfSwgKGVycm9yKSA9PntcclxuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgbG9hZGluZyBzb3VuZFwiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBhdWRpbyBmaWxlLiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3RvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIHNhbXBsZSBiZWluZyBsb2FkZWQuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBmaWxlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIGF1ZGlvXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIG9iamVjdHMgY3VycmVudGx5IGluIHRoZSBvYmplY3QgbG9hZGluZyBxdWV1ZVxyXG4gICAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIG9iamVjdHMgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvYWRPYmplY3RzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPSB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID09PSAwKXtcclxuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdChvYmoua2V5LCBvYmoucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIG9iamVjdFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIG9iamVjdCB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRPYmplY3Qoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aCwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UoZmlsZVRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLmpzb25PYmplY3RzLmFkZChrZXksIG9iaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ09iamVjdChjYWxsYmFja0lmTGFzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBvYmplY3QuIElmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0LCBpdCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdPYmplY3QoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIG9iamVjdHNcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBXRUJHTCBTUEVDSUZJQyBGVU5DVElPTlMgIyMjIyMjIyMjIyAqL1xyXG5cclxuICAgIHB1YmxpYyBnZXRUZXh0dXJlKGtleTogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbF9UZXh0dXJlcy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0U2hhZGVyUHJvZ3JhbShrZXk6IHN0cmluZyk6IFdlYkdMUHJvZ3JhbSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KGtleSkucHJvZ3JhbTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QnVmZmVyKGtleTogc3RyaW5nKTogV2ViR0xCdWZmZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdsX0J1ZmZlcnMuZ2V0KGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVXZWJHTFRleHR1cmUoaW1hZ2VLZXk6IHN0cmluZywgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICAvLyBHZXQgdGhlIHRleHR1cmUgSURcclxuICAgICAgICBjb25zdCB0ZXh0dXJlSUQgPSB0aGlzLmdldFRleHR1cmVJRCh0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHR1cmVcclxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCB0aGUgdGV4dHVyZVxyXG4gICAgICAgIC8vIEVuYWJsZSB0ZXh0dXJlMFxyXG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlSUQpO1xyXG5cclxuICAgICAgICAvLyBCaW5kIG91ciB0ZXh0dXJlIHRvIHRleHR1cmUgMFxyXG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnNcclxuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xyXG4gICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIGltYWdlXHJcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIHRleHR1cmUgdG8gb3VyIG1hcCB3aXRoIHRoZSBzYW1lIGtleSBhcyB0aGUgaW1hZ2VcclxuICAgICAgICB0aGlzLmdsX1RleHR1cmVzLmFkZChpbWFnZUtleSwgdGhpcy5nbF9OZXh0VGV4dHVyZUlEKTtcclxuXHJcbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBrZXlcclxuICAgICAgICB0aGlzLmdsX05leHRUZXh0dXJlSUQgKz0gMTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFRleHR1cmVJRChpZDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICAvLyBTdGFydCB3aXRoIDkgY2FzZXMgLSB0aGlzIGNhbiBiZSBleHBhbmRlZCBpZiBuZWVkZWQsIGJ1dCBmb3IgdGhlIGJlc3QgcGVyZm9ybWFuY2UsXHJcbiAgICAgICAgLy8gVGV4dHVyZXMgc2hvdWxkIGJlIHN0aXRjaGVkIGludG8gYW4gYXRsYXNcclxuICAgICAgICBzd2l0Y2goaWQpe1xyXG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUwO1xyXG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUxO1xyXG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUyO1xyXG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUzO1xyXG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU0O1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU1O1xyXG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU2O1xyXG4gICAgICAgICAgICBjYXNlIDc6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU3O1xyXG4gICAgICAgICAgICBjYXNlIDg6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU4O1xyXG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFOTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUJ1ZmZlcihrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xyXG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2xfQnVmZmVycy5hZGQoa2V5LCBidWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVucXVldWVzIGxvYWRpbmcgb2YgYSBuZXcgc2hhZGVyIHByb2dyYW1cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc2hhZGVyIHByb2dyYW1cclxuICAgICAqIEBwYXJhbSB2U2hhZGVyRmlsZXBhdGggXHJcbiAgICAgKiBAcGFyYW0gZlNoYWRlckZpbGVwYXRoIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hhZGVyKGtleTogc3RyaW5nLCB2U2hhZGVyRmlsZXBhdGg6IHN0cmluZywgZlNoYWRlckZpbGVwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBsZXQgc3BsaXRQYXRoID0gdlNoYWRlckZpbGVwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICBsZXQgZW5kID0gc3BsaXRQYXRoW3NwbGl0UGF0aC5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgaWYoZW5kICE9PSBcInZzaGFkZXJcIil7XHJcbiAgICAgICAgICAgIHRocm93IGAke3ZTaGFkZXJGaWxlcGF0aH0gaXMgbm90IGEgdmFsaWQgdmVydGV4IHNoYWRlciAtIG11c3QgZW5kIGluIFwiLnZzaGFkZXJgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3BsaXRQYXRoID0gZlNoYWRlckZpbGVwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICBpZihlbmQgIT09IFwiZnNoYWRlclwiKXtcclxuICAgICAgICAgICAgdGhyb3cgYCR7ZlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIuZnNoYWRlcmA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcGF0aHMgPSBuZXcgS2V5UGF0aF9TaGFkZXIoKTtcclxuICAgICAgICBwYXRocy5rZXkgPSBrZXk7XHJcbiAgICAgICAgcGF0aHMudnBhdGggPSB2U2hhZGVyRmlsZXBhdGg7XHJcbiAgICAgICAgcGF0aHMuZnBhdGggPSBmU2hhZGVyRmlsZXBhdGg7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmVucXVldWUocGF0aHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgKi9cclxuICAgICBwdWJsaWMga2VlcFNoYWRlcihrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdsX0xvYWRTaGFkZXJzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZWJHTCBpc24nYWN0aXZlIG9yIHRoZXJlIGFyZSBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxyXG4gICAgICAgIGlmKCF0aGlzLmdsX1dlYkdMQWN0aXZlIHx8IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPT09IDApe1xyXG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIGxldCBzaGFkZXIgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xfTG9hZFNoYWRlcihzaGFkZXIua2V5LCBzaGFkZXIudnBhdGgsIHNoYWRlci5mcGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnbF9Mb2FkU2hhZGVyKGtleTogc3RyaW5nLCB2cGF0aDogc3RyaW5nLCBmcGF0aDogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZSh2cGF0aCwgKHZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZTaGFkZXIgPSB2RmlsZVRleHQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShmcGF0aCwgKGZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmU2hhZGVyID0gZkZpbGVUZXh0XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgcHJvZ3JhbSBhbmQgc2hhZGVyc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3NoYWRlclByb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdID0gdGhpcy5jcmVhdGVTaGFkZXJQcm9ncmFtKHZTaGFkZXIsIGZTaGFkZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgdHlwZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3JhbVdyYXBwZXIgPSBuZXcgV2ViR0xQcm9ncmFtVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbVdyYXBwZXIucHJvZ3JhbSA9IHNoYWRlclByb2dyYW07XHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBvdXIgbWFwXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmFkZChrZXksIHByb2dyYW1XcmFwcGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNIQURFUikpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHNoYWRlcnNcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVTaGFkZXJQcm9ncmFtKHZTaGFkZXJTb3VyY2U6IHN0cmluZywgZlNoYWRlclNvdXJjZTogc3RyaW5nKXtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmxvYWRWZXJ0ZXhTaGFkZXIodlNoYWRlclNvdXJjZSk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmxvYWRGcmFnbWVudFNoYWRlcihmU2hhZGVyU291cmNlKTtcclxuICAgIFxyXG4gICAgICAgIGlmKHZlcnRleFNoYWRlciA9PT0gbnVsbCB8fCBmcmFnbWVudFNoYWRlciA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhIHByb2JsZW0gaW50aWFsaXppbmcgLSBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBDcmVhdGUgYSBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICBpZighcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICAvLyBFcnJvciBjcmVhdGluZ1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW1cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIEF0dGFjaCBvdXIgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuICAgIFxyXG4gICAgICAgIC8vIExpbmtcclxuICAgICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGlmKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUykpe1xyXG4gICAgICAgICAgICAvLyBFcnJvciBsaW5raW5nXHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGxpbmsgcHJvZ3JhbTogXCIgKyBlcnJvcik7XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcclxuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIFdlIHN1Y2Nlc3NmdWxseSBjcmVhdGUgYSBwcm9ncmFtXHJcbiAgICAgICAgcmV0dXJuIFtwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBsb2FkVmVydGV4U2hhZGVyKHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZlcnRleCBzaGFkZXJcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUiwgc2hhZGVyU291cmNlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBsb2FkRnJhZ21lbnRTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUiwgc2hhZGVyU291cmNlKTtcdFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIGxvYWRTaGFkZXIodHlwZTogbnVtYmVyLCBzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xyXG4gICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgY3JlYXRlIHRoZSBzaGFkZXIsIGVycm9yXHJcbiAgICAgICAgaWYoc2hhZGVyID09PSBudWxsKXtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGNyZWF0ZSBzaGFkZXJcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIEFkZCB0aGUgc291cmNlIHRvIHRoZSBzaGFkZXIgYW5kIGNvbXBpbGVcclxuICAgICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XHJcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICBcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgd2VyZSBubyBlcnJvcnMgZHVyaW5nIHRoaXMgcHJvY2Vzc1xyXG4gICAgICAgIGlmKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKXtcclxuICAgICAgICAgICAgLy8gTm90IGNvbXBpbGVkIC0gZXJyb3JcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNvbXBpbGUgc2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBTdWNlc3MsIHNvIHJldHVybiB0aGUgc2hhZGVyXHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIEdFTkVSQUwgTE9BRElORyBGVU5DVElPTlMgIyMjIyMjIyMjIyAqL1xyXG5cclxuICAgIHByaXZhdGUgbG9hZFRleHRGaWxlKHRleHRGaWxlUGF0aDogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBsZXQgeG9iajogWE1MSHR0cFJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB4b2JqLm92ZXJyaWRlTWltZVR5cGUoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xyXG4gICAgICAgIHhvYmoub3BlbignR0VUJywgdGV4dEZpbGVQYXRoLCB0cnVlKTtcclxuICAgICAgICB4b2JqLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCh4b2JqLnJlYWR5U3RhdGUgPT0gNCkgJiYgKHhvYmouc3RhdHVzID09IDIwMCkpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhvYmoucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgeG9iai5zZW5kKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMgTE9BRElORyBCQVIgSU5GTyAjIyMjIyMjIyMjICovXHJcblxyXG4gICAgcHJpdmF0ZSBnZXRMb2FkUGVyY2VudCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZC90aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkXHJcbiAgICAgICAgICAgICsgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQvdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWRcclxuICAgICAgICAgICAgKyB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZC90aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZFxyXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQvdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZClcclxuICAgICAgICAgICAgLyB0aGlzLmxvYWRvbmx5X3R5cGVzVG9Mb2FkO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMubG9hZGluZyl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkUHJvZ3Jlc3Mpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRQcm9ncmVzcyh0aGlzLmdldExvYWRQZXJjZW50KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuanVzdExvYWRlZCl7XHJcbiAgICAgICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZih0aGlzLm9uTG9hZENvbXBsZXRlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgcmVmZXJlbmNlIHRvIGEgcmVzb3VyY2UuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgdGhlIGV4ZW1wdGlvbiBsaXN0IHRvIGFzc3VyZSBhc3NldHMgYW5kIHRoZWlyIGRlcGVuZGVuY2llcyBkb24ndCBnZXRcclxuICogZGVzdHJveWVkIGlmIHRoZXkgYXJlIHN0aWxsIG5lZWRlZC5cclxuICovXHJcbmNsYXNzIFJlc291cmNlUmVmZXJlbmNlIHtcclxuICAgIGtleTogc3RyaW5nO1xyXG4gICAgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGU7XHJcbiAgICBkZXBlbmRlbmNpZXM6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihrZXk6IHN0cmluZywgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGUpe1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VUeXBlID0gcmVzb3VyY2VUeXBlO1xyXG4gICAgICAgIHRoaXMuIGRlcGVuZGVuY2llcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZERlcGVuZGVuY3kocmVzb3VyY2U6IFJlc291cmNlUmVmZXJlbmNlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMucHVzaChyZXNvdXJjZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5lbnVtIFJlc291cmNlVHlwZSB7XHJcbiAgICBJTUFHRSA9IFwiSU1BR0VcIixcclxuICAgIFRJTEVNQVAgPSBcIlRJTEVNQVBcIixcclxuICAgIFNQUklURVNIRUVUID0gXCJTUFJJVEVTSEVFVFwiLFxyXG4gICAgQVVESU8gPSBcIkFVRElPXCIsXHJcbiAgICBKU09OID0gXCJKU09OXCIsXHJcbiAgICBTSEFERVIgPSBcIlNIQURFUlwiXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHBhaXIgcmVwcmVzZW50aW5nIGEga2V5IGFuZCB0aGUgcGF0aCBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZFxyXG4gKi9cclxuY2xhc3MgS2V5UGF0aFBhaXIge1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICBwYXRoOiBzdHJpbmc7XHJcbiAgICBpc0RlcGVuZGVuY3k/OiBib29sZWFuID0gZmFsc2U7XHJcbn1cclxuXHJcbmNsYXNzIEtleVBhdGhfU2hhZGVyIHtcclxuICAgIGtleTogc3RyaW5nO1xyXG4gICAgdnBhdGg6IHN0cmluZztcclxuICAgIGZwYXRoOiBzdHJpbmc7XHJcbn0iLCJpbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4vVmlld3BvcnRcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3QgaW50ZXJmYWNlIG9mIGEgU2NlbmVHcmFwaC5cclxuICogRXhwb3NlcyBtZXRob2RzIGZvciB1c2UgYnkgb3RoZXIgY29kZSwgYnV0IGxlYXZlcyB0aGUgaW1wbGVtZW50YXRpb24gdXAgdG8gdGhlIHN1YmNsYXNzZXMuXHJcbiAqIFRoZSBTY2VuZUdyYXBoIG1hbmFnZXMgdGhlIHBvc2l0aW9ucyBvZiBhbGwgR2FtZU5vZGVzLCBhbmQgY2FuIGVhc2lseSBwcnVuZSBhIHZpc2libGUgc2V0IGZvciByZW5kZXJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTY2VuZUdyYXBoIHtcclxuXHQvKipcdEEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCAqL1xyXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblx0LyoqXHRBIG1hcCBvZiBDYW52YXNOb2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cclxuXHRwcm90ZWN0ZWQgbm9kZU1hcDogQXJyYXk8Q2FudmFzTm9kZT47XHJcblx0LyoqIEEgY291bnRlciBvZiBJRHMgZm9yIG5vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xyXG5cdHByb3RlY3RlZCBpZENvdW50ZXI6IG51bWJlcjtcclxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoaXMgU2NlbmVHcmFwaCBiZWxvbmdzIHRvICovXHJcblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoXHJcblx0ICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydFxyXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cclxuXHQgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmU6IFNjZW5lKXtcclxuXHRcdHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHRcdHRoaXMubm9kZU1hcCA9IG5ldyBBcnJheSgpO1xyXG5cdFx0dGhpcy5pZENvdW50ZXIgPSAwO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBub2RlIHRvIHRoZSBTY2VuZUdyYXBoXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIENhbnZhc05vZGUgdG8gYWRkIHRvIHRoZSBTY2VuZUdyYXBoXHJcblx0ICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGggSUQgb2YgdGhpcyBuZXdseSBhZGRlZCBDYW52YXNOb2RlXHJcblx0ICovXHJcbiAgICBhZGROb2RlKG5vZGU6IENhbnZhc05vZGUpOiBudW1iZXIge1xyXG5cdFx0dGhpcy5ub2RlTWFwW25vZGUuaWRdID0gbm9kZTtcclxuXHRcdHRoaXMuYWRkTm9kZVNwZWNpZmljKG5vZGUsIHRoaXMuaWRDb3VudGVyKTtcclxuXHRcdHRoaXMuaWRDb3VudGVyICs9IDE7XHJcblx0XHRyZXR1cm4gdGhpcy5pZENvdW50ZXIgLSAxO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIG92ZXJyaWRhYmxlIG1ldGhvZCB0byBhZGQgYSBDYW52YXNOb2RlIHRvIHRoZSBzcGVjaWZpYyBkYXRhIHN0cnVjdHVyZSBvZiB0aGUgU2NlbmVHcmFwaFxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGUgZGF0YSBzdHJ1Y3R1cmVcclxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBDYW52YXNOb2RlXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGFkZE5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgU2NlbmVHcmFwaFxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG5cdCAqL1xyXG4gICAgcmVtb3ZlTm9kZShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XHJcblx0XHQvLyBGaW5kIGFuZCByZW1vdmUgbm9kZSBpbiBPKG4pXHJcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnJlbW92ZU5vZGVTcGVjaWZpYyhub2RlLCBub2RlLmlkKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gb2YgcmVtb3ZpbmcgYSBub2RlXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXHJcblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbm9kZSB0byByZW1vdmVcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYSBzcGVjaWZpYyBub2RlIHVzaW5nIGl0cyBpZFxyXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIENhbnZhc05vZGUgdG8gcmV0cmlldmVcclxuXHQgKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIHRoaXMgSURcclxuXHQgKi9cclxuXHRnZXROb2RlKGlkOiBudW1iZXIpOiBDYW52YXNOb2RlIHtcclxuXHRcdHJldHVybiB0aGlzLm5vZGVNYXBbaWRdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgYXQgc3BlY2lmaWMgY29vcmRpbmF0ZXNcclxuXHQgKiBAcGFyYW0gdmVjT3JYIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHBvc2l0aW9uLCBvciB0aGUgY29vcmRpbmF0ZXMgaW4gYSBWZWMyXHJcblx0ICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb25cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBhdCB0aGUgcG9zaXRpb24gcHJvdmlkZWRcclxuXHQgKi9cclxuICAgIGdldE5vZGVzQXQodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLngsIHZlY09yWC55KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLCB5KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG5vZGVzIHRoYXQgb3ZlcmxhcCBhIHNwZWNpZmljIGJvdW5kYXJ5XHJcblx0ICogQHBhcmFtIGJvdW5kYXJ5IFRoZSByZWdpb24gdG8gY2hlY2tcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBvdmVybGFwcGluZyB0aGUgcHJvdmlkZWQgYm91bmRhcnlcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBnZXROb2Rlc0luUmVnaW9uKGJvdW5kYXJ5OiBBQUJCKTogQXJyYXk8Q2FudmFzTm9kZT47XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcclxuXHQgKiBAcmV0dXJucyBBbiBBcnJheSBjb250YWluaW5nIGFsbCBub2RlcyBpbiB0aGUgU2NlbmVHcmFwaFxyXG5cdCAqL1xyXG5cdGdldEFsbE5vZGVzKCk6IEFycmF5PENhbnZhc05vZGU+IHtcclxuXHRcdGxldCBhcnIgPSBuZXcgQXJyYXk8Q2FudmFzTm9kZT4oKTtcclxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm5vZGVNYXAubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRpZih0aGlzLm5vZGVNYXBbaV0gIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdFx0YXJyLnB1c2godGhpcy5ub2RlTWFwW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiBnZXR0aW5nIGEgbm9kZSBhdCBjZXJ0YWluIGNvb3JkaW5hdGVzXHJcblx0ICogQHBhcmFtIHggVGhlIHgtY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVcclxuXHQgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlcyBvZiB0aGUgbm9kZVxyXG5cdCAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHJcblx0YWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcclxuXHRcclxuXHRhYnN0cmFjdCByZW5kZXIoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2RlcyBiYXNlZCBvbiB0aGUgQHJlZmVyZW5jZVtWaWV3cG9ydF1cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCB2aXNpYmxlIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXHJcblx0ICovXHJcbiAgICBhYnN0cmFjdCBnZXRWaXNpYmxlU2V0KCk6IEFycmF5PENhbnZhc05vZGU+O1xyXG59IiwiaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4vU2NlbmVHcmFwaFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4vVmlld3BvcnRcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIFNjZW5lR3JhcGggdGhhdCBzaW1wbHkgc3RvcmVkIENhbnZhc05vZGVzIGluIGFuIGFycmF5LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVHcmFwaEFycmF5IGV4dGVuZHMgU2NlbmVHcmFwaCB7XHJcbiAgICAvKiogVGhlIGxpc3Qgb2YgQ2FudmFzTm9kZXMgaW4gdGhpcyBTY2VuZUdyYXBoICovXHJcbiAgICBwcml2YXRlIG5vZGVMaXN0OiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2NlbmVHcmFwaEFycmF5XHJcbiAgICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIFZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIFNjZW5lIHRoaXMgU2NlbmVHcmFwaCBiZWxvbmdzIHRvXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmU6IFNjZW5lKXtcclxuICAgICAgICBzdXBlcih2aWV3cG9ydCwgc2NlbmUpO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGVMaXN0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgYWRkTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm5vZGVMaXN0LnB1c2gobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm5vZGVMaXN0LmluZGV4T2Yobm9kZSk7XHJcbiAgICAgICAgaWYoaW5kZXggPiAtMSl7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZUxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBnZXROb2Rlc0F0Q29vcmRzKHg6IG51bWJlciwgeTogbnVtYmVyKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XHJcblxyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcclxuICAgICAgICAgICAgaWYobm9kZS5jb250YWlucyh4LCB5KSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgZ2V0Tm9kZXNJblJlZ2lvbihib3VuZGFyeTogQUFCQik6IEFycmF5PENhbnZhc05vZGU+IHtcclxuICAgICAgICBsZXQgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5ub2RlTGlzdCl7XHJcbiAgICAgICAgICAgIGlmKGJvdW5kYXJ5Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBTdGF0cy5sb2coXCJzZ3F1ZXJ5XCIsICh0MS10MCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5ub2RlTGlzdCl7XHJcbiAgICAgICAgICAgIGlmKCFub2RlLmdldExheWVyKCkuaXNQYXVzZWQoKSl7XHJcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0MSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIFN0YXRzLmxvZyhcInNndXBkYXRlXCIsICh0MS10MCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge31cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG4gICAgICAgIGxldCB2aXNpYmxlU2V0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcclxuICAgICAgICAgICAgaWYoIW5vZGUuZ2V0TGF5ZXIoKS5pc0hpZGRlbigpICYmIG5vZGUudmlzaWJsZSAmJiB0aGlzLnZpZXdwb3J0LmluY2x1ZGVzKG5vZGUpKXtcclxuICAgICAgICAgICAgICAgIHZpc2libGVTZXQucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZpc2libGVTZXQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWUuIENvcnJlc3BvbmRzIHRvIHRoZSB2aXNpYmxlIHdpbmRvdyBkaXNwbGF5ZWQgaW4gdGhlIGJyb3dzZXIuXHJcbiAqIFRoZSB2aWV3cG9ydCBrZWVwcyB0cmFjayBvZiBpdHMgcG9zaXRpb24gaW4gdGhlIGdhbWUgd29ybGQsIGFuZCBjYW4gYWN0IGFzIGEgY2FtZXJhIHRvIGZvbGxvdyBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xyXG4gICAgLyoqIFRoZSBBQUJCIHRoYXQgY29udGFpbnMgdGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSB2aWV3cG9ydCB2aWV3ICovXHJcbiAgICBwcml2YXRlIHZpZXc6IEFBQkI7XHJcbiAgICAvKiogVGhlIGJvdW5kYXJ5IGZvciB0aGUgdmlld3BvcnQuIFRoaXMgcmVwcmVzZW50cyB0aGUgbGltaXRzIHRvIHdoZXJlIHRoZSB2aWV3cG9ydCBjYW4gZ28gKi9cclxuICAgIHByaXZhdGUgYm91bmRhcnk6IEFBQkI7XHJcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoZSBWaWV3cG9ydCBpcyBmb2xsb3dpbmcgKi9cclxuICAgIHByaXZhdGUgZm9sbG93aW5nOiBHYW1lTm9kZTtcclxuICAgIC8qKiBUaGUgcG9zaXRpb24gdGhlIEdhbWVOb2RlIGlzIGZvY3VzaW5nIG9uLiBUaGlzIGlzIG92ZXJyaWRkZW4gaWYgXCJmb2xsb3dpbmdcIiBpcyBzZXQuICovXHJcbiAgICBwcml2YXRlIGZvY3VzOiBWZWMyO1xyXG5cclxuICAgIC8qKiBBIHF1ZXVlIG9mIHByZXZpb3VzIHBvc2l0aW9ucyBvZiB3aGF0IHRoaXMgdmlld3BvcnQgaXMgZm9sbG93aW5nLiBVc2VkIGZvciBzbW9vdGhpbmcgdmlld3BvcnQgbW92ZW1lbnQgKi9cclxuICAgIHByaXZhdGUgbGFzdFBvc2l0aW9uczogUXVldWU8VmVjMj47XHJcblxyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgcG9zaXRpb25zIHRoaXMgdmlld3BvcnQgdHJhY2tzICovXHJcbiAgICBwcml2YXRlIHNtb290aGluZ0ZhY3RvcjogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBBIGJvb2xlYW4gdGhhIHJlcHJlc2VudHMgd2hldGhlciB0aGUgcGxheWVyIGNhbiB6b29tIGJ5IHNjcm9sbGluZyB3aXRoIHRoZSBtb3VzZSB3aGVlbCAqL1xyXG4gICAgcHJpdmF0ZSBzY3JvbGxab29tRW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIGFtb3VudCB0aGF0IGlzIHpvb21lZCBpbiBvciBvdXQuICovXHJcbiAgICBwcml2YXRlIFpPT01fRkFDVE9SOiBudW1iZXIgPSAxLjI7XHJcblxyXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBjYW52YXMgKi9cclxuICAgIHByaXZhdGUgY2FudmFzU2l6ZTogVmVjMjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXNTaXplOiBWZWMyLCB6b29tTGV2ZWw6IG51bWJlcil7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IEFBQkIoVmVjMi5aRVJPLCBWZWMyLlpFUk8pO1xyXG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XHJcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5zbW9vdGhpbmdGYWN0b3IgPSAxMDtcclxuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYW52YXNTaXplID0gVmVjMi5aRVJPO1xyXG4gICAgICAgIHRoaXMuZm9jdXMgPSBWZWMyLlpFUk87XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzXHJcbiAgICAgICAgdGhpcy5zZXRDYW52YXNTaXplKGNhbnZhc1NpemUpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgICAgdGhpcy5zZXRTaXplKGNhbnZhc1NpemUpO1xyXG4gICAgICAgIHRoaXMuc2V0Wm9vbUxldmVsKHpvb21MZXZlbCk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgY2VudGVyIChhbmQgbWFrZSB0aGUgdmlld3BvcnQgc3RheSB0aGVyZSlcclxuICAgICAgICB0aGlzLnNldENlbnRlcih0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5zZXRGb2N1cyh0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEVuYWJsZXMgdGhlIHZpZXdwb3J0IHRvIHpvb20gaW4gYW5kIG91dCAqL1xyXG4gICAgZW5hYmxlWm9vbSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHJldHVybnMgVGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgYXMgYSBWZWMyXHJcbiAgICAgKi9cclxuICAgIGdldENlbnRlcigpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmNlbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjMiB3aXRoIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG9wIGxlZnQgY29ybmRlciBvZiB0aGUgVmllcG9ydCBhcyBhIFZlYzJcclxuICAgICAqL1xyXG4gICAgZ2V0T3JpZ2luKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnZpZXcubGVmdCwgdGhpcy52aWV3LnRvcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGlzIHZpZXdwb3J0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQUFCQiBjb250YWluaW5nIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgZ2V0VmlldygpOiBBQUJCIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIG5ldyBwb3NpdGlvbiBvciB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBzZXRDZW50ZXIodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHBvczogVmVjMjtcclxuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xyXG4gICAgICAgICAgICBwb3MgPSB2ZWNPclg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zID0gbmV3IFZlYzIodmVjT3JYLCB5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIgPSBwb3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcclxuICAgICAqIEByZXR1cm5zIFRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxyXG4gICAgICovXHJcbiAgICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEhhbGZTaXplKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIG5ldyB3aWR0aCBvZiB0aGUgdmlld3BvcnQgb3IgdGhlIG5ldyBzaXplIGFzIGEgVmVjMlxyXG4gICAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHNldFNpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKHZlY09yWC5zY2FsZWQoMS8yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYLzIsIHkvMikpO1xyXG5cdFx0fVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaGFsZi1zaXplIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IGhhbGYtd2lkdGggb2YgdGhlIHZpZXdwb3J0IG9yIHRoZSBuZXcgaGFsZi1zaXplIGFzIGEgVmVjMlxyXG4gICAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHNldEhhbGZTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xyXG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XHJcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZSh2ZWNPclguY2xvbmUoKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYLCB5KSk7XHJcblx0XHR9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IENhbnZhc1xyXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcywgb3IgdGhlIGNhbnZhcyBzaXplIGFzIGEgVmVjMlxyXG4gICAgICogQHBhcmFtIHkgVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIHNldENhbnZhc1NpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0dGhpcy5jYW52YXNTaXplID0gdmVjT3JYLmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNhbnZhc1NpemUgPSBuZXcgVmVjMih2ZWNPclgsIHkpO1xyXG5cdFx0fVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXHJcbiAgICAgKi9cclxuICAgIHNldFpvb21MZXZlbCh6b29tOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnZpZXcuaGFsZlNpemUuY29weSh0aGlzLmNhbnZhc1NpemUuc2NhbGVkKDEvem9vbS8yKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHJldHVybnMgVGhlIHpvb20gbGV2ZWxcclxuICAgICAqL1xyXG4gICAgZ2V0Wm9vbUxldmVsKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzU2l6ZS54L3RoaXMudmlldy5ody8yXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnQgbW92ZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gc21vb3RoaW5nRmFjdG9yIFRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgc2V0U21vb3RoaW5nRmFjdG9yKHNtb290aGluZ0ZhY3RvcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYoc21vb3RoaW5nRmFjdG9yIDwgMSkgc21vb3RoaW5nRmFjdG9yID0gMTtcclxuICAgICAgICB0aGlzLnNtb290aGluZ0ZhY3RvciA9IHNtb290aGluZ0ZhY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSB2aWV3cG9ydCB0byBmb2N1cyBvbiBhIHBvaW50LiBPdmVyaWRkZW4gYnkgXCJmb2xsb3dpbmdcIi5cclxuICAgICAqIEBwYXJhbSBmb2N1cyBUaGUgcG9pbnQgdGhlICB2aWV3cG9ydCBzaG91bGQgZm9jdXMgb25cclxuICAgICAqL1xyXG4gICAgc2V0Rm9jdXMoZm9jdXM6IFZlYzIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZvY3VzLmNvcHkoZm9jdXMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgQ2FudmFzTm9kZSBpcyBpbnNpZGUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQsIGZhbHNlIGlmIG5vdFxyXG4gICAgICovXHJcbiAgICBpbmNsdWRlcyhub2RlOiBDYW52YXNOb2RlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IHBhcmFsbGF4ID0gbm9kZS5nZXRMYXllcigpIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBVSUxheWVyID8gKDxQYXJhbGxheExheWVyPm5vZGUuZ2V0TGF5ZXIoKSkucGFyYWxsYXggOiBuZXcgVmVjMigxLCAxKTtcclxuICAgICAgICBsZXQgY2VudGVyID0gdGhpcy52aWV3LmNlbnRlci5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIubXVsdChwYXJhbGxheCk7XHJcbiAgICAgICAgbGV0IG92ZXJsYXBzID0gdGhpcy52aWV3Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpO1xyXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIgPSBjZW50ZXJcclxuICAgICAgICByZXR1cm4gb3ZlcmxhcHM7XHJcbiAgICB9XHJcblxyXG5cdC8vIFRPRE86IFB1dCBzb21lIGVycm9yIGhhbmRsaW5nIG9uIHRoaXMgZm9yIHRyeWluZyB0byBtYWtlIHRoZSBib3VuZHMgdG9vIHNtYWxsIGZvciB0aGUgdmlld3BvcnRcclxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGRvbmUgYXV0b21hdGljYWxseSwgb3Igc2hvdWxkIGNvbnNpZGVyIHRoZSBhc3BlY3QgcmF0aW8gb3Igc29tZXRoaW5nXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJvdW5kcyBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBsb3dlclggVGhlIGxlZnQgZWRnZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBsb3dlclkgVGhlIHRvcCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHVwcGVyWCBUaGUgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB1cHBlclkgVGhlIGJvdHRvbSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBzZXRCb3VuZHMobG93ZXJYOiBudW1iZXIsIGxvd2VyWTogbnVtYmVyLCB1cHBlclg6IG51bWJlciwgdXBwZXJZOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaHdpZHRoID0gKHVwcGVyWCAtIGxvd2VyWCkvMjtcclxuICAgICAgICBsZXQgaGhlaWdodCA9ICh1cHBlclkgLSBsb3dlclkpLzI7XHJcbiAgICAgICAgbGV0IHggPSBsb3dlclggKyBod2lkdGg7XHJcbiAgICAgICAgbGV0IHkgPSBsb3dlclkgKyBoaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuYm91bmRhcnkuY2VudGVyLnNldCh4LCB5KTtcclxuICAgICAgICB0aGlzLmJvdW5kYXJ5LmhhbGZTaXplLnNldChod2lkdGgsIGhoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZSB0aGUgdmlld3BvcnQgZm9sbG93IHRoZSBzcGVjaWZpZWQgR2FtZU5vZGVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBHYW1lTm9kZSB0byBmb2xsb3dcclxuICAgICAqL1xyXG4gICAgZm9sbG93KG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mb2xsb3dpbmcgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVZpZXcoKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5sYXN0UG9zaXRpb25zLmdldFNpemUoKSA+IHRoaXMuc21vb3RoaW5nRmFjdG9yKXtcclxuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmRlcXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2V0IHRoZSBhdmVyYWdlIG9mIHRoZSBsYXN0IDEwIHBvc2l0aW9uc1xyXG4gICAgICAgIGxldCBwb3MgPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gcG9zLmFkZChwb3NpdGlvbikpO1xyXG4gICAgICAgIHBvcy5zY2FsZSgxL3RoaXMubGFzdFBvc2l0aW9ucy5nZXRTaXplKCkpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhpcyBwb3NpdGlvbiBlaXRoZXIgdG8gdGhlIG9iamVjdCBvciB0byBpdHMgYm91bmRzXHJcbiAgICAgICAgcG9zLnggPSBNYXRoVXRpbHMuY2xhbXAocG9zLngsIHRoaXMuYm91bmRhcnkubGVmdCArIHRoaXMudmlldy5odywgdGhpcy5ib3VuZGFyeS5yaWdodCAtIHRoaXMudmlldy5odyk7XHJcbiAgICAgICAgcG9zLnkgPSBNYXRoVXRpbHMuY2xhbXAocG9zLnksIHRoaXMuYm91bmRhcnkudG9wICsgdGhpcy52aWV3LmhoLCB0aGlzLmJvdW5kYXJ5LmJvdHRvbSAtIHRoaXMudmlldy5oaCk7XHJcblxyXG4gICAgICAgIC8vIEFzc3VyZSB0aGVyZSBhcmUgbm8gbGluZXMgaW4gdGhlIHRpbGVtYXBcclxuICAgICAgICBwb3MueCA9IE1hdGguZmxvb3IocG9zLngpO1xyXG4gICAgICAgIHBvcy55ID0gTWF0aC5mbG9vcihwb3MueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlci5jb3B5KHBvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gSWYgem9vbSBpcyBlbmFibGVkXHJcbiAgICAgICAgaWYodGhpcy5zY3JvbGxab29tRW5hYmxlZCl7XHJcbiAgICAgICAgICAgIGlmKElucHV0LmRpZEp1c3RTY3JvbGwoKSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFNpemUgPSB0aGlzLnZpZXcuZ2V0SGFsZlNpemUoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYoSW5wdXQuZ2V0U2Nyb2xsRGlyZWN0aW9uKCkgPCAwKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBab29tIGluXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUuc2NhbGUoMS90aGlzLlpPT01fRkFDVE9SKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWm9vbSBvdXRcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSh0aGlzLlpPT01fRkFDVE9SKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50U2l6ZS54ID4gdGhpcy5ib3VuZGFyeS5odyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaHcvY3VycmVudFNpemUueDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS54ID0gdGhpcy5ib3VuZGFyeS5odztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS55ICo9IGZhY3RvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50U2l6ZS55ID4gdGhpcy5ib3VuZGFyeS5oaCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaGgvY3VycmVudFNpemUueTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS55ID0gdGhpcy5ib3VuZGFyeS5oaDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS54ICo9IGZhY3RvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0SGFsZlNpemUoY3VycmVudFNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB2aWV3cG9ydCBpcyBmb2xsb3dpbmcgYW4gb2JqZWN0XHJcbiAgICAgICAgaWYodGhpcy5mb2xsb3dpbmcpe1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgb3VyIGxpc3Qgb2YgcHJldmlvdXMgcG9zaXRpb25zXHJcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9sbG93aW5nLnBvc2l0aW9uLmNsb25lKCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9jdXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudFwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcclxuaW1wb3J0IFRleHRJbnB1dCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXRcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5cclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBBIGZhY3RvcnkgdGhhdCBhYnN0cmFjdHMgYWRkaW5nIEByZWZlcmVuY2VbQ2FudmFzTm9kZV1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cclxuICogQWNjZXNzIG1ldGhvZHMgaW4gdGhpcyBmYWN0b3J5IHRocm91Z2ggU2NlbmUuYWRkLlttZXRob2ROYW1lXSgpLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzTm9kZUZhY3Rvcnkge1xyXG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuXHRpbml0KHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXHJcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XHJcblx0ICovXHJcblx0YWRkVUlFbGVtZW50ID0gKHR5cGU6IHN0cmluZyB8IFVJRWxlbWVudFR5cGUsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFVJRWxlbWVudCA9PiB7XHJcblx0XHQvLyBHZXQgdGhlIGxheWVyXHJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblxyXG5cdFx0bGV0IGluc3RhbmNlOiBVSUVsZW1lbnQ7XHJcblxyXG5cdFx0c3dpdGNoKHR5cGUpe1xyXG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuQlVUVE9OOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZEJ1dHRvbihvcHRpb25zKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5MQUJFTDpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRMYWJlbChvcHRpb25zKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5TTElERVI6XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkU2xpZGVyKG9wdGlvbnMpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLlRFWFRfSU5QVVQ6XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkVGV4dElucHV0KG9wdGlvbnMpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBgVUlFbGVtZW50VHlwZSAnJHt0eXBlfScgZG9lcyBub3QgZXhpc3QsIG9yIGlzIHJlZ2lzdGVyZWQgaW5jb3JyZWN0bHkuYFxyXG5cdFx0fVxyXG5cclxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcclxuXHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSlcclxuXHJcblx0XHRyZXR1cm4gaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcclxuXHQgKi9cclxuXHRhZGRTcHJpdGUgPSAoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlID0+IHtcclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcclxuXHJcblx0XHRsZXQgaW5zdGFuY2UgPSBuZXcgU3ByaXRlKGtleSk7XHJcblxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIHNjZW5lXHJcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcclxuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcblxyXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhbiBBbmltYXRlZFNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXHJcblx0ICogQHJldHVybnMgQSBuZXcgQW5pbWF0ZWRTcHJpdGVcclxuXHQgKi9cclxuXHRhZGRBbmltYXRlZFNwcml0ZSA9IChrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBBbmltYXRlZFNwcml0ZSA9PiB7XHJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblx0XHRsZXQgc3ByaXRlc2hlZXQgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTcHJpdGVzaGVldChrZXkpO1xyXG5cdFx0bGV0IGluc3RhbmNlID0gbmV3IEFuaW1hdGVkU3ByaXRlKHNwcml0ZXNoZWV0KTtcclxuXHJcblx0XHQvLyBBZGQgaW5zdGFuY2UgZm8gc2NlbmVcclxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcclxuXHRcdFxyXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXHJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcclxuXHJcblx0XHRyZXR1cm4gaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxyXG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGdyYXBoaWMgdG8gYWRkXHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljXHJcblx0ICovXHJcblx0YWRkR3JhcGhpYyA9ICh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyA9PiB7XHJcblx0XHQvLyBHZXQgdGhlIGxheWVyXHJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblxyXG5cdFx0bGV0IGluc3RhbmNlOiBHcmFwaGljO1xyXG5cclxuXHRcdHN3aXRjaCh0eXBlKXtcclxuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5QT0lOVDpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRQb2ludChvcHRpb25zKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5MSU5FOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZExpbmUob3B0aW9ucyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuUkVDVDpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRSZWN0KG9wdGlvbnMpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93IGBHcmFwaGljVHlwZSAnJHt0eXBlfScgZG9lcyBub3QgZXhpc3QsIG9yIGlzIHJlZ2lzdGVyZWQgaW5jb3JyZWN0bHkuYFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBzY2VuZVxyXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG5cclxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XHJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xyXG5cdH1cclxuXHJcblx0LyogLS0tLS0tLS0tLSBCVUlMREVSUyAtLS0tLS0tLS0tICovXHJcblxyXG5cdGJ1aWxkQnV0dG9uKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogQnV0dG9uIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiQnV0dG9uXCIsIG9wdGlvbnMsIFwidGV4dFwiLCBcInN0cmluZ1wiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJ1dHRvbihvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpO1xyXG5cdH1cclxuXHJcblx0YnVpbGRMYWJlbChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IExhYmVsIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInRleHRcIiwgXCJzdHJpbmdcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYWJlbChvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpXHJcblx0fVxyXG5cclxuXHRidWlsZFNsaWRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogU2xpZGVyIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJTbGlkZXJcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0bGV0IGluaXRWYWx1ZSA9IDA7XHJcblx0XHRpZihvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpe1xyXG5cdFx0XHRpbml0VmFsdWUgPSBvcHRpb25zLnZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgU2xpZGVyKG9wdGlvbnMucG9zaXRpb24sIGluaXRWYWx1ZSk7XHJcblx0fVxyXG5cclxuXHRidWlsZFRleHRJbnB1dChvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVGV4dElucHV0IHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJUZXh0SW5wdXRcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUZXh0SW5wdXQob3B0aW9ucy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHRidWlsZFBvaW50KG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBvaW50XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQob3B0aW9ucy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHRidWlsZExpbmUob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQb2ludCB7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGluZVwiLCBvcHRpb25zLCBcInN0YXJ0XCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMaW5lXCIsIG9wdGlvbnMsIFwiZW5kXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExpbmUob3B0aW9ucy5zdGFydCwgb3B0aW9ucy5lbmQpO1xyXG5cdH1cclxuXHJcblx0YnVpbGRSZWN0KG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjdCB7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUmVjdFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBSZWN0KG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMuc2l6ZSk7XHJcblx0fVxyXG5cclxuXHQvKiAtLS0tLS0tLS0tIEVSUk9SIEhBTkRMSU5HIC0tLS0tLS0tLS0gKi9cclxuXHJcblx0Y2hlY2tJZlByb3BFeGlzdHM8VD4ob2JqZWN0TmFtZTogc3RyaW5nLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcm9wOiBzdHJpbmcsIHR5cGU6IChuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCkgfCBzdHJpbmcsIHR5cGVOYW1lPzogc3RyaW5nKXtcclxuXHRcdGlmKCFvcHRpb25zIHx8IG9wdGlvbnNbcHJvcF0gPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHlcclxuXHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGVOYW1lfSwgYnV0IG5vbmUgd2FzIHByb3ZpZGVkLmA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBwcm9wZXJ0eSBoYXMgdGhlIGNvcnJlY3QgdHlwZVxyXG5cdFx0XHRpZigodHlwZW9mIHR5cGUpID09PSBcInN0cmluZ1wiKXtcclxuXHRcdFx0XHRpZighKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSB0eXBlKSl7XHJcblx0XHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGV9LmA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcclxuXHRcdFx0XHQvLyBJZiB0eXBlIGlzIGEgY29uc3RydWN0b3IsIGNoZWNrIGFnYWluc3QgdGhhdFxyXG5cdFx0XHRcdGlmKCEob3B0aW9uc1twcm9wXSBpbnN0YW5jZW9mIHR5cGUpKXtcclxuXHRcdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlTmFtZX0uYDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcclxuaW1wb3J0IENhbnZhc05vZGVGYWN0b3J5IGZyb20gXCIuL0NhbnZhc05vZGVGYWN0b3J5XCI7XHJcbmltcG9ydCBUaWxlbWFwRmFjdG9yeSBmcm9tIFwiLi9UaWxlbWFwRmFjdG9yeVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFuYWdlciBvZiBhbGwgZmFjdG9yaWVzIHVzZWQgZm9yIGFkZGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjdG9yeU1hbmFnZXIge1xyXG5cclxuICAgIC8vIENvbnN0cnVjdG9ycyBhcmUgY2FsbGVkIGhlcmUgdG8gYWxsb3cgYXNzaWdubWVudCBvZiB0aGVpciBmdW5jdGlvbnMgdG8gZnVuY3Rpb25zIGluIHRoaXMgY2xhc3NcclxuICAgIHByaXZhdGUgY2FudmFzTm9kZUZhY3Rvcnk6IENhbnZhc05vZGVGYWN0b3J5ID0gbmV3IENhbnZhc05vZGVGYWN0b3J5KCk7XHJcbiAgICBwcml2YXRlIHRpbGVtYXBGYWN0b3J5OiBUaWxlbWFwRmFjdG9yeSA9IG5ldyBUaWxlbWFwRmFjdG9yeSgpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+KXtcclxuICAgICAgICB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmluaXQoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcEZhY3RvcnkuaW5pdChzY2VuZSwgdGlsZW1hcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4cG9zZSBhbGwgb2YgdGhlIGZhY3RvcmllcyB0aHJvdWdoIHRoZSBmYWN0b3J5IG1hbmFnZXJcclxuICAgIC8qKlxyXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXHJcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XHJcblx0ICovXHJcbiAgICB1aUVsZW1lbnQodHlwZTogc3RyaW5nIHwgVUlFbGVtZW50VHlwZSwgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVUlFbGVtZW50IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRVSUVsZW1lbnQodHlwZSwgbGF5ZXJOYW1lLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcclxuXHQgKi9cclxuXHRzcHJpdGUoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIEFkZHMgYW4gQW5pbWF0ZWRTcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGVkU3ByaXRlXHJcblx0ICovXHJcblx0YW5pbWF0ZWRTcHJpdGUoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogQW5pbWF0ZWRTcHJpdGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZEFuaW1hdGVkU3ByaXRlKGtleSwgbGF5ZXJOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxyXG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGdyYXBoaWMgdG8gYWRkXHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljXHJcblx0ICovXHJcblx0Z3JhcGhpYyh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkR3JhcGhpYyh0eXBlLCBsYXllck5hbWUsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkZXNpcmVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG5cdHRpbGVtYXAoa2V5OiBzdHJpbmcsIHNjYWxlPzogVmVjMik6IEFycmF5PExheWVyPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZW1hcEZhY3RvcnkuYWRkKGtleSwgc2NhbGUpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xyXG5pbXBvcnQgVGlsZXNldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVzZXRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IFRpbGVkQ29sbGVjdGlvblRpbGUgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XHJcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuLi8uLi9QYXRoZmluZGluZy9OYXZtZXNoXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuLyoqXHJcbiAqIEEgZmFjdG9yeSB0aGF0IGFic3RyYWN0cyBhZGRpbmcgQHJlZmVyZW5jZVtUaWxlbWFwXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxyXG4gKiBBY2Nlc3MgbWV0aG9kcyBpbiB0aGlzIGZhY3RvcnkgdGhyb3VnaCBTY2VuZS5hZGQuW21ldGhvZE5hbWVdKCkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwRmFjdG9yeSB7XHJcbiAgICBwcml2YXRlIHNjZW5lOiBTY2VuZTtcclxuICAgIHByaXZhdGUgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIFxyXG4gICAgaW5pdChzY2VuZTogU2NlbmUsIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgICAgICB0aGlzLnRpbGVtYXBzID0gdGlsZW1hcHM7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIC0gVGhpcyBpcyBzcGVjaWZpY2FsbHkgY2F0ZXJlZCB0byBUaWxlZCB0aWxlbWFwcyByaWdodCBub3cuIEluIHRoZSBmdXR1cmUsXHJcbiAgICAvLyBpdCB3b3VsZCBiZSBnb29kIHRvIGhhdmUgYSBcInBhcnNlVGlsZW1hcFwiIGZ1bmN0aW9uIHRoYXQgd291bGQgY29udmVydCB0aGUgdGlsZW1hcFxyXG4gICAgLy8gZGF0YSBpbnRvIGEgc3RhbmRhcmQgZm9ybWF0LiBUaGlzIGNvdWxkIGFsbG93IGZvciBzdXBwb3J0IGZyb20gb3RoZXIgcHJvZ3JhbXNcclxuICAgIC8vIG9yIHRoZSBkZXZlbG9wbWVudCBvZiBhbiBpbnRlcm5hbCBsZXZlbCBidWlsZGVyIHRvb2xcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkZXNpcmVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG5cdGFkZCA9IChrZXk6IHN0cmluZywgc2NhbGU6IFZlYzIgPSBuZXcgVmVjMigxLCAxKSk6IEFycmF5PExheWVyPiA9PiB7XHJcbiAgICAgICAgLy8gR2V0IFRpbGVtYXAgRGF0YVxyXG4gICAgICAgIGxldCB0aWxlbWFwRGF0YSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRpbGVtYXAoa2V5KTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyB0aWxlbWFwIHRvIGVpdGhlciBiZSBvcnRob2dyYXBoaWMgb3IgaXNvbWV0cmljXHJcbiAgICAgICAgbGV0IGNvbnN0cjogbmV3KC4uLmFyZ3M6IGFueSkgPT4gVGlsZW1hcDtcclxuICAgICAgICBpZih0aWxlbWFwRGF0YS5vcmllbnRhdGlvbiA9PT0gXCJvcnRob2dyYXBoaWNcIil7XHJcbiAgICAgICAgICAgIGNvbnN0ciA9IE9ydGhvZ29uYWxUaWxlbWFwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGlzb21ldHJpYyB0aWxlbWFwIHN1cHBvcnQgcmlnaHQgbm93LCBzbyBPcnRob2dyYXBoaWMgdGlsZW1hcFxyXG4gICAgICAgICAgICBjb25zdHIgPSBPcnRob2dvbmFsVGlsZW1hcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJldHVybiB2YWx1ZSBhcnJheVxyXG4gICAgICAgIGxldCBzY2VuZUxheWVycyA9IG5ldyBBcnJheTxMYXllcj4oKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBvZiB0aGUgdGlsZXNldHMgZm9yIHRoaXMgdGlsZW1hcFxyXG4gICAgICAgIGxldCB0aWxlc2V0cyA9IG5ldyBBcnJheTxUaWxlc2V0PigpO1xyXG5cclxuICAgICAgICBsZXQgY29sbGVjdGlvblRpbGVzID0gbmV3IEFycmF5PFRpbGVkQ29sbGVjdGlvblRpbGU+KCk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwRGF0YS50aWxlc2V0cyl7XHJcbiAgICAgICAgICAgIGlmKHRpbGVzZXQuaW1hZ2Upe1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0YW5kYXJkIHRpbGVzZXQgYW5kIG5vdCBhIGNvbGxlY3Rpb24sIGNyZWF0ZSBhIHRpbGVzZXQgZm9yIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIFdlIGFyZSBpZ25vcmluZyBjb2xsZWN0aW9uIHRpbGVzZXRzIGZvciBub3cuIFRoaXMgaXMgbGlrZWx5IG5vdCBhIGdyZWF0IGlkZWEgaW4gcHJhY3RpY2UsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGVvcmV0aWNhbGx5IHNvbWVvbmUgY291bGQgd2FudCB0byB1c2Ugb25lIGZvciBhIHN0YW5kYXJkIHRpbGVtYXAuIFdlIGFyZSBhc3N1bWluZyBmb3Igbm93XHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIG9ubHkgd2FudCB0byB1c2UgdGhlbSBmb3Igb2JqZWN0IGxheWVyc1xyXG4gICAgICAgICAgICAgICAgdGlsZXNldHMucHVzaChuZXcgVGlsZXNldCh0aWxlc2V0KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlc2V0LnRpbGVzLmZvckVhY2godGlsZSA9PiB0aWxlLmlkICs9IHRpbGVzZXQuZmlyc3RnaWQpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblRpbGVzLnB1c2goLi4udGlsZXNldC50aWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSB0aWxlbWFwIGFuZCBjcmVhdGUgdGlsZWRsYXllcnMgb3Igb2JqZWN0IGxheWVyc1xyXG4gICAgICAgIGZvcihsZXQgbGF5ZXIgb2YgdGlsZW1hcERhdGEubGF5ZXJzKXtcclxuXHJcbiAgICAgICAgICAgIGxldCBzY2VuZUxheWVyO1xyXG4gICAgICAgICAgICBsZXQgaXNQYXJhbGxheExheWVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiUGFyYWxsYXhcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFyYWxsYXhMYXllciA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJEZXB0aFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGlzUGFyYWxsYXhMYXllcil7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRQYXJhbGxheExheWVyKGxheWVyLm5hbWUsIG5ldyBWZWMyKDEsIDEpLCBkZXB0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRMYXllcihsYXllci5uYW1lLCBkZXB0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGxheWVyLnR5cGUgPT09IFwidGlsZWxheWVyXCIpe1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHRpbGVtYXAgb2JqZWN0IGZvciB0aGUgbGF5ZXJcclxuICAgICAgICAgICAgICAgIGxldCB0aWxlbWFwID0gbmV3IGNvbnN0cih0aWxlbWFwRGF0YSwgbGF5ZXIsIHRpbGVzZXRzLCBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGlsZW1hcCB0byBzY2VuZVxyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyLmFkZE5vZGUodGlsZW1hcCk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRpbGVtYXAgd2l0aCBwaHlzaWNzIGlmIGl0J3MgY29sbGlkYWJsZVxyXG4gICAgICAgICAgICAgICAgaWYodGlsZW1hcC5pc0NvbGxpZGFibGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuYWRkUGh5c2ljcygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5uYW1lID09PSBcIkdyb3VwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuc2V0R3JvdXAoaXRlbS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGlzTmF2bWVzaFBvaW50cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5hdm1lc2hOYW1lO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVkZ2VzO1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXIucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiTmF2bWVzaFBvaW50c1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmF2bWVzaFBvaW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwibmFtZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdm1lc2hOYW1lID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJlZGdlc1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gcHJvcC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihpc05hdm1lc2hQb2ludHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBnID0gbmV3IFBvc2l0aW9uR3JhcGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBvYmogb2YgbGF5ZXIub2JqZWN0cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcuYWRkUG9zaXRpb25lZE5vZGUobmV3IFZlYzIob2JqLngsIG9iai55KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVkZ2Ugb2YgZWRnZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnLmFkZEVkZ2UoZWRnZS5mcm9tLCBlZGdlLnRvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5hZGROYXZpZ2FibGVFbnRpdHkobmF2bWVzaE5hbWUsIG5ldyBOYXZtZXNoKGcpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGF5ZXIgaXMgYW4gb2JqZWN0IGxheWVyLCBzbyBhZGQgZWFjaCBvYmplY3QgYXMgYSBzcHJpdGUgdG8gYSBuZXcgbGF5ZXJcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9iaiBpcyBjb2xsaWRhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1BoeXNpY3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNDb2xsaWRhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvbkVudGVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb25FeGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJpZ2dlckdyb3VwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihvYmoucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBvYmoucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiSGFzUGh5c2ljc1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQaHlzaWNzID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbGxpZGFibGUgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJHcm91cFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cCA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIklzVHJpZ2dlclwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RyaWdnZXIgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJUcmlnZ2VyR3JvdXBcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckdyb3VwID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiVHJpZ2dlck9uRW50ZXJcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbnRlciA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkV4aXRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FeGl0ID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwcml0ZTogU3ByaXRlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvYmogaXMgYSB0aWxlIGZyb20gYSB0aWxlc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVzZXRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGlsZXNldC5oYXNUaWxlKG9iai5naWQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgaXMgYSB0aWxlIGZyb20gdGhpcyBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aWxlc2V0LmdldEltYWdlT2Zmc2V0Rm9yVGlsZShvYmouZ2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHRoaXMuc2NlbmUuYWRkLnNwcml0ZShpbWFnZUtleSwgbGF5ZXIubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCgob2JqLnggKyBzaXplLngvMikqc2NhbGUueCwgKG9iai55IC0gc2l6ZS55LzIpKnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEltYWdlT2Zmc2V0KG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2l6ZS5jb3B5KHNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGluIGEgdGlsZXNldCwgbXVzdCBjb3JyZXNwb25kIHRvIGEgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzcHJpdGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGUgb2YgY29sbGVjdGlvblRpbGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9iai5naWQgPT09IHRpbGUuaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGUuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUucG9zaXRpb24uc2V0KChvYmoueCArIHRpbGUuaW1hZ2V3aWR0aC8yKSpzY2FsZS54LCAob2JqLnkgLSB0aWxlLmltYWdlaGVpZ2h0LzIpKnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHNwcml0ZS4gQXNzb2NpYXRlIGl0IHdpdGggb3VyIHBoeXNpY3Mgb2JqZWN0IGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1BoeXNpY3Mpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBzcHJpdGUgYSBzdGF0aWMgcGh5c2ljcyBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmFkZFBoeXNpY3Moc3ByaXRlLmJvdW5kYXJ5LmNsb25lKCksIFZlYzIuWkVSTywgaXNDb2xsaWRhYmxlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEdyb3VwKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNUcmlnZ2VyICYmIHRyaWdnZXJHcm91cCAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0VHJpZ2dlcih0cmlnZ2VyR3JvdXAsIG9uRW50ZXIsIG9uRXhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgIHNjZW5lTGF5ZXJzLnB1c2goc2NlbmVMYXllcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NlbmVMYXllcnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuL1NjZW5lXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgbGF5ZXIgaW4gdGhlIHNjZW5lLiBMYXllcnMgYXJlIHVzZWQgZm9yIHNvcnRpbmcgQHJlZmVyZW5jZVtHYW1lTm9kZV1zIGJ5IGRlcHRoLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xyXG4gICAgLyoqIFRoZSBzY2VuZSB0aGlzIGxheWVyIGJlbG9uZ3MgdG8gKi9cclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcblxyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBsYXllciBpcyBwYXVzZWQgb3Igbm90ICovXHJcbiAgICBwcm90ZWN0ZWQgcGF1c2VkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgaGlkZGVuIGZyb20gYmVpbmcgcmVuZGVyZWQgb3Igbm90ICovXHJcbiAgICBwcm90ZWN0ZWQgaGlkZGVuOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgZ2xvYmFsIGFscGhhIGxldmVsIG9mIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgR2FtZU5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBpdGVtczogQXJyYXk8R2FtZU5vZGU+O1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGxheWVyIHNob3VsZCBiZSB5c29ydGVkICovXHJcbiAgICBwcm90ZWN0ZWQgeVNvcnQ6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBkZXB0aCBvZiB0aGlzIGxheWVyIGNvbXBhcmVkIHRvIG90aGVyIGxheWVycyAqL1xyXG4gICAgcHJvdGVjdGVkIGRlcHRoOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxheWVyLiBUbyBkbyB0aGlzIGluIGEgZ2FtZSwgdXNlIHRoZSBhZGRMYXllcigpIG1ldGhvZCBpbiBAcmVmcmVuY2VbU2NlbmVdXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGFkZCB0aGUgbGF5ZXIgdG9cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZyl7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnlTb3J0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyZWl2ZXMgdGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqL1xyXG4gICAgZ2V0TmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZXMvVW5wYXVzZXMgdGhlIGxheWVyLiBBZmZlY3RzIGFsbCBlbGVtZW50cyBpbiB0aGlzIGxheWVyXHJcbiAgICAgKiBAcGFyYW0gcGF1c2VWYWx1ZSBUcnVlIGlmIHRoZSBsYXllciBzaG91bGQgYmUgcGF1c2VkLCBmYWxzZSBpZiBub3RcclxuICAgICAqL1xyXG4gICAgc2V0UGF1c2VkKHBhdXNlVmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHBhdXNlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgcGF1c2VkXHJcbiAgICAgKi9cclxuICAgIGlzUGF1c2VkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcGFyYW0gYWxwaGEgVGhlIG5ldyBvcGFjaXR5IHZhbHVlIGluIHRoZSByYW5nZSBbMCwgMV1cclxuICAgICAqL1xyXG4gICAgc2V0QWxwaGEoYWxwaGE6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSBNYXRoVXRpbHMuY2xhbXAoYWxwaGEsIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBvcGFjaXR5XHJcbiAgICAgKi9cclxuICAgIGdldEFscGhhKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBsYXllcidzIGhpZGRlbiB2YWx1ZS4gSWYgaGlkZGVuLCBhIGxheWVyIHdpbGwgbm90IGJlIHJlbmRlcmVkLCBidXQgd2lsbCBzdGlsbCB1cGRhdGVcclxuICAgICAqIEBwYXJhbSBoaWRkZW4gVGhlIGhpZGRlbiB2YWx1ZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqL1xyXG4gICAgc2V0SGlkZGVuKGhpZGRlbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gaGlkZGVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaGlkZWVuIHZhbHVlIG9mIHRoZSBseWFlclxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2NlbmUgaXMgaGlkZGVuLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgaXNIaWRkZW4oKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkZGVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBQYXVzZXMgdGhpcyBzY2VuZSBhbmQgaGlkZXMgaXQgKi9cclxuICAgIGRpc2FibGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVW5wYXVzZXMgdGhpcyBsYXllciBhbmQgbWFrZXMgaXQgdmlzaWJsZSAqL1xyXG4gICAgZW5hYmxlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHNjZW5lIHdpbGwgeVNvcnQgYXV0b21hdGljYWxseS5cclxuICAgICAqIHlTb3J0aW5nIG1lYW5zIHRoYXQgQ2FudmFzTm9kZXMgb24gdGhpcyBsYXllciB3aWxsIGhhdmUgdGhlaXIgZGVwdGggc29ydGVkIGRlcGVuZGluZyBvbiB0aGVpciB5LXZhbHVlLlxyXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGlmIGFuIG9iamVjdCBpcyBcImhpZ2hlclwiIGluIHRoZSBzY2VuZSwgaXQgd2lsbCBzb3J0IGJlaGluZCBvYmplY3RzIHRoYXQgYXJlIFwibG93ZXJcIi5cclxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciAzLzQgdmlldyBnYW1lcywgb3Igc2ltaWxhciBzaXR1YXRpb25zLCB3aGVyZSB5b3Ugc29tZXRpbWVzIHdhbnQgdG8gYmUgaW4gZnJvbnQgb2Ygb2JqZWN0cyxcclxuICAgICAqIGFuZCBvdGhlciB0aW1lcyB3YW50IHRvIGJlIGJlaGluZCB0aGUgc2FtZSBvYmplY3RzLlxyXG4gICAgICogQHBhcmFtIHlTb3J0IFRydWUgaWYgeVNvcnRpbmcgc2hvdWxkIGJlIGFjdGl2ZSwgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIHNldFlTb3J0KHlTb3J0OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy55U29ydCA9IHlTb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgeVNvcnQgc3RhdHVzIG9mIHRoZSBzY2VuZVxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB5U29ydGluZyBpcyBvY2N1cnJpbmcsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBnZXRZU29ydCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55U29ydDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGRlcHRoIG9mIHRoZSBsYXllciBjb21wYXJlZCB0byBvdGhlciBsYXllcnMuIEEgbGFyZ2VyIG51bWJlciBtZWFucyB0aGUgbGF5ZXIgd2lsbCBiZSBjbG9zZXIgdG8gdGhlIHNjcmVlbi5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBzZXREZXB0aChkZXB0aDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVwdGhcclxuICAgICAqL1xyXG4gICAgZ2V0RGVwdGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBub2RlIHRvIHRoaXMgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGlzIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBhZGROb2RlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgIG5vZGUuc2V0TGF5ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoaXMgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSB3YXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBGaW5kIGFuZCByZW1vdmUgdGhlIG5vZGVcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2Yobm9kZSk7XHJcblxyXG4gICAgICAgIGlmKGluZGV4ICE9PSAtMSl7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgbm9kZS5zZXRMYXllcih1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJlaXZlcyBhbGwgR2FtZU5vZGVzIGZyb20gdGhpcyBsYXllclxyXG4gICAgICogQHJldHVybnMgYW4gQXJyYXkgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIEdhbWVOb2RlcyBpbiB0aGlzIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBnZXRJdGVtcygpOiBBcnJheTxHYW1lTm9kZT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGV4dGVuc2lvbiBvZiBhIExheWVyIHRoYXQgaGFzIGEgcGFyYWxsYXggdmFsdWUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJhbGxheExheWVyIGV4dGVuZHMgTGF5ZXIge1xyXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhlIHBhcmFsbGF4IG9mIHRoZSBMYXllciAqL1xyXG5cdHBhcmFsbGF4OiBWZWMyO1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgUGFyYWxsYXhMYXllci5cclxuXHQgKiBVc2UgYWRkUGFyYWxsYXhMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXHJcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0byBhZGQgdGhpcyBQYXJhbGxheExheWVyIHRvXHJcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFBhcmFsbGF4TGF5ZXJcclxuXHQgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyKXtcclxuXHRcdHN1cGVyKHNjZW5lLCBuYW1lKTtcclxuXHRcdHRoaXMucGFyYWxsYXggPSBwYXJhbGxheDtcclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi9QYXJhbGxheExheWVyXCI7XHJcblxyXG4vKipcclxuICogQSBMYXllciBzdHJpY3RseSB0byBiZSB1c2VkIGZvciBtYW5hZ2luZyBVSUVsZW1lbnRzLlxyXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGEgTGF5ZXIgdGhhdCBhbHdheXMgc3RheXMgaW4gdGhlIHNhbWUgcGxhY2UsXHJcbiAqIGFuZCB0aHVzIHJlbmRlcnMgdGhpbmdzIGxpa2UgYSBIVUQgb3IgYW4gaW52ZW50b3J5IHdpdGhvdXQgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgXFxyZWZlcmVuY2VbVmlld3BvcnRdIHNjcm9sbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJTGF5ZXIgZXh0ZW5kcyBQYXJhbGxheExheWVyIHtcclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IFVJTGF5ZXIuXHJcblx0ICogVXNlIGFkZFVJTGF5ZXIoKSBpbiBAcmVmZXJlbmNlW1NjZW5lXSB0byBhZGQgYSBsYXllciBvZiB0aGlzIHR5cGUgdG8geW91ciBnYW1lLlxyXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdG8gYWRkIHRoaXMgVUlMYXllciB0b1xyXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBVSUxheWVyXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIoc2NlbmUsIG5hbWUsIFZlYzIuWkVSTyk7XHJcblx0fVxyXG59IiwiaW1wb3J0IExheWVyIGZyb20gXCIuL0xheWVyXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4uL1NjZW5lR3JhcGgvU2NlbmVHcmFwaFwiO1xyXG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvUGh5c2ljc01hbmFnZXJcIjtcclxuaW1wb3J0IEJhc2ljUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvQmFzaWNQaHlzaWNzTWFuYWdlclwiO1xyXG5pbXBvcnQgU2NlbmVHcmFwaEFycmF5IGZyb20gXCIuLi9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheVwiO1xyXG5pbXBvcnQgRmFjdG9yeU1hbmFnZXIgZnJvbSBcIi4vRmFjdG9yaWVzL0ZhY3RvcnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IEdhbWUgZnJvbSBcIi4uL0xvb3AvR2FtZVwiO1xyXG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25NYW5hZ2VyIGZyb20gXCIuLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgQUlNYW5hZ2VyIGZyb20gXCIuLi9BSS9BSU1hbmFnZXJcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBTY2VuZU9wdGlvbnMgZnJvbSBcIi4vU2NlbmVPcHRpb25zXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBUaW1lck1hbmFnZXIgZnJvbSBcIi4uL1RpbWluZy9UaW1lck1hbmFnZXJcIjtcclxuaW1wb3J0IFR3ZWVuTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5NYW5hZ2VyXCI7XHJcblxyXG4vKipcclxuICogU2NlbmVzIGFyZSB0aGUgbWFpbiBjb250YWluZXIgaW4gdGhlIGdhbWUgZW5naW5lLlxyXG4gKiBZb3VyIG1haW4gc2NlbmUgaXMgdGhlIGN1cnJlbnQgbGV2ZWwgb3IgbWVudSBvZiB0aGUgZ2FtZSwgYW5kIHdpbGwgY29udGFpbiBhbGwgb2YgdGhlIEdhbWVOb2RlcyBuZWVkZWQuXHJcbiAqIFNjZW5lcyBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIGxvYWQgYXNzZXRzLCBhZGQgYXNzZXRzIHRvIHRoZSBnYW1lIHdvcmxkLCBhbmQgdW5sb2FkIGFzc2V0cyxcclxuICogYW5kIGhhdmUgbGlmZWN5Y2xlIG1ldGhvZHMgZXhwb3NlZCBmb3IgdGhlc2UgZnVuY3Rpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmUgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZ2FtZSB3b3JsZC4gKi9cclxuICAgIHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XHJcblxyXG4gICAgLyoqIFRoZSB2aWV3cG9ydC4gKi9cclxuICAgIHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblxyXG4gICAgLyoqIEEgZmxhZyB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGlzIHNjZW5lIGlzIHJ1bm5pbmcgb3Igbm90LiAqL1xyXG4gICAgcHJvdGVjdGVkIHJ1bm5pbmc6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBtYW5hZ2VyIG9mIHRoaXMgc2NlbmUuICovXHJcbiAgICBwcm90ZWN0ZWQgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSByZWNlaXZlciBmb3IgdGhpcyBzY2VuZS4gKi9cclxuICAgIHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblxyXG4gICAgLyoqIFRoZSBlbWl0dGVyIGZvciB0aGlzIHNjZW5lLiAqL1xyXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gICAgLyoqIFRoaXMgbGlzdCBvZiB0aWxlbWFwcyBpbiB0aGlzIHNjZW5lLiAqL1xyXG4gICAgcHJvdGVjdGVkIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcclxuXHJcbiAgICAvKiogQSBtYXAgZnJvbSBsYXllciBuYW1lcyB0byB0aGUgbGF5ZXJzIHRoZW1zZWx2ZXMgKi9cclxuICAgIHByb3RlY3RlZCBsYXllcnM6IE1hcDxMYXllcj47XHJcblxyXG4gICAgLyoqIEEgbWFwIGZyb20gcGFyYWxsYXggbGF5ZXIgbmFtZXMgdG8gdGhlIHBhcmFsbGF4IGxheWVycyB0aGVtc2VsdmVzICovXHJcbiAgICBwcm90ZWN0ZWQgcGFyYWxsYXhMYXllcnM6IE1hcDxQYXJhbGxheExheWVyPjtcclxuXHJcbiAgICAvKiogQSBtYXAgZnJvbSB1aUxheWVyIG5hbWVzIHRvIHRoZSB1aUxheWVycyB0aGVtc2VsdmVzICovXHJcbiAgICBwcm90ZWN0ZWQgdWlMYXllcnM6IE1hcDxVSUxheWVyPjtcclxuXHJcbiAgICAvKiogVGhlIHNjZW5lIGdyYXBoIG9mIHRoZSBTY2VuZSovXHJcbiAgICBwcm90ZWN0ZWQgc2NlbmVHcmFwaDogU2NlbmVHcmFwaDtcclxuXHJcbiAgICAvKiogVGhlIHBoeXNpY3MgbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cclxuICAgIHByb3RlY3RlZCBwaHlzaWNzTWFuYWdlcjogUGh5c2ljc01hbmFnZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgbmF2aWdhdGlvbiBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xyXG4gICAgcHJvdGVjdGVkIG5hdk1hbmFnZXI6IE5hdmlnYXRpb25NYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgQUkgbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cclxuICAgIHByb3RlY3RlZCBhaU1hbmFnZXI6IEFJTWFuYWdlcjtcclxuXHJcbiAgICAvKiogVGhlIHJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIHNjZW5lICovXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcclxuXHJcbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBhZGRpbmcgb2YgZGlmZmVyZW50IG5vZGVzIHRvIHRoZSBzY2VuZSAqL1xyXG4gICAgcHVibGljIGFkZDogRmFjdG9yeU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBvZiBkaWZmZXJlbnQgZmlsZXMgZm9yIHVzZSBpbiB0aGUgc2NlbmUuIEFuIGFsaWFzIGZvciByZXNvdXJjZU1hbmFnZXIgKi9cclxuICAgIHB1YmxpYyBsb2FkOiBSZXNvdXJjZU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBhbmQgdW5sb2FkaW5nIG9mIGRpZmZlcmVudCBmaWxlcyBmb3IgdXNlIGluIHRoZSBzY2VuZSAqL1xyXG4gICAgcHVibGljIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGlzIHNjZW5lICovXHJcbiAgICBwdWJsaWMgc2NlbmVPcHRpb25zOiBTY2VuZU9wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNjZW5lLiBUbyBhZGQgYSBuZXcgU2NlbmUgaW4geW91ciBnYW1lLCB1c2UgY2hhbmdlVG9TY2VuZSgpIGluIEByZWZlcmVuY2VbU2NlbmVNYW5hZ2VyXVxyXG4gICAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydCBvZiB0aGUgZ2FtZVxyXG4gICAgICogQHBhcmFtIHNjZW5lTWFuYWdlciBUaGUgU2NlbmVNYW5hZ2VyIHRoYXQgb3ducyB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcGFyYW0gcmVuZGVyaW5nTWFuYWdlciBUaGUgUmVuZGVyaW5nTWFuYWdlciB0aGF0IHdpbGwgaGFuZGxlIHRoaXMgU2NlbmUncyByZW5kZXJpbmdcclxuICAgICAqIEBwYXJhbSBnYW1lIFRoZSBpbnN0YW5jZSBvZiB0aGUgR2FtZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIFNjZW5lIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXIsIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXIsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pe1xyXG4gICAgICAgIHRoaXMuc2NlbmVPcHRpb25zID0gU2NlbmVPcHRpb25zLnBhcnNlKG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMud29ybGRTaXplID0gbmV3IFZlYzIoNTAwLCA1MDApO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCAyNTYwLCAxMjgwKTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlciA9IHNjZW5lTWFuYWdlcjtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuc2NlbmVHcmFwaCA9IG5ldyBTY2VuZUdyYXBoQXJyYXkodGhpcy52aWV3cG9ydCwgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMubGF5ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMudWlMYXllcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5wYXJhbGxheExheWVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5waHlzaWNzTWFuYWdlciA9IG5ldyBCYXNpY1BoeXNpY3NNYW5hZ2VyKHRoaXMuc2NlbmVPcHRpb25zLnBoeXNpY3MpO1xyXG4gICAgICAgIHRoaXMubmF2TWFuYWdlciA9IG5ldyBOYXZpZ2F0aW9uTWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMuYWlNYW5hZ2VyID0gbmV3IEFJTWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IHJlbmRlcmluZ01hbmFnZXI7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkID0gbmV3IEZhY3RvcnlNYW5hZ2VyKHRoaXMsIHRoaXMudGlsZW1hcHMpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWQgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gdGhpcy5sb2FkO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHRpbWVyIG1hbmFnZXIgYW5kIGNsZWFyIGFueSBleGlzdGluZyB0aW1lcnNcclxuICAgICAgICBUaW1lck1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5jbGVhclRpbWVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBhIG5ldyBzY2VuZSBpcyBjcmVhdGVkLCBiZWZvcmUgYW55dGhpbmcgZWxzZS4gKi9cclxuICAgIGluaXRTY2VuZShpbml0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG5cclxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIGEgbmV3IHNjZW5lIGlzIGNyZWF0ZWQuIExvYWQgYWxsIGZpbGVzIHlvdSB3aXNoIHRvIGFjY2VzcyBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cclxuICAgIGxvYWRTY2VuZSgpOiB2b2lkIHt9XHJcblxyXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgc3RyaWN0bHkgYWZ0ZXIgbG9hZFNjZW5lKCkuIENyZWF0ZSBhbnkgZ2FtZSBvYmplY3RzIHlvdSB3aXNoIHRvIHVzZSBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cclxuICAgIHN0YXJ0U2NlbmUoKTogdm9pZCB7fVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIGNhbGxlZCBldmVyeSBmcmFtZSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyB3aGVyZSB5b3UgY2FuIGR5bmFtaWNhbGx5IGRvIHRoaW5ncyBsaWtlIGFkZCBpbiBuZXcgZW5lbWllc1xyXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSB0aW1lIHRoaXMgZnJhbWUgcmVwcmVzZW50c1xyXG4gICAgICovXHJcbiAgICB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cclxuXHJcbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgb24gc2NlbmUgZGVzdHJ1Y3Rpb24uIFNwZWNpZnkgd2hpY2ggZmlsZXMgeW91IG5vIGxvbmdlciBuZWVkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uICovXHJcbiAgICB1bmxvYWRTY2VuZSgpOiB2b2lkIHt9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTY2VuZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBEbyB0aW1lIHVwZGF0ZXNcclxuICAgICAgICBUaW1lck1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gRG8gYWxsIEFJIHVwZGF0ZXNcclxuICAgICAgICB0aGlzLmFpTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGFsbCBwaHlzaWNzIG9iamVjdHNcclxuICAgICAgICB0aGlzLnBoeXNpY3NNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgYWxsIGNhbnZhcyBvYmplY3RzXHJcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgYWxsIHRpbGVtYXBzXHJcbiAgICAgICAgdGhpcy50aWxlbWFwcy5mb3JFYWNoKHRpbGVtYXAgPT4ge1xyXG4gICAgICAgICAgICBpZighdGlsZW1hcC5nZXRMYXllcigpLmlzUGF1c2VkKCkpe1xyXG4gICAgICAgICAgICAgICAgdGlsZW1hcC51cGRhdGUoZGVsdGFUKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgYWxsIHR3ZWVuc1xyXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdmlld3BvcnRcclxuICAgICAgICB0aGlzLnZpZXdwb3J0LnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdHMgcmVuZGVyYWJsZSBzZXRzIGFuZCBjb29yZGluYXRlcyB3aXRoIHRoZSBSZW5kZXJpbmdNYW5hZ2VyIHRvIGRyYXcgdGhlIFNjZW5lXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcigpOiB2b2lkIHtcclxuICAgICAgICAvLyBHZXQgdGhlIHZpc2libGUgc2V0IG9mIG5vZGVzXHJcbiAgICAgICAgbGV0IHZpc2libGVTZXQgPSB0aGlzLnNjZW5lR3JhcGguZ2V0VmlzaWJsZVNldCgpO1xyXG5cclxuICAgICAgICAvLyBBZGQgcGFyYWxsYXggbGF5ZXIgaXRlbXMgdG8gdGhlIHZpc2libGUgc2V0ICh3ZSdyZSByZW5kZXJpbmcgdGhlbSBhbGwgZm9yIG5vdylcclxuICAgICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgbGV0IHBMYXllciA9IHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGZvcihsZXQgbm9kZSBvZiBwTGF5ZXIuZ2V0SXRlbXMoKSl7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQ2FudmFzTm9kZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgdGhlIHZpc2libGUgc2V0LCB0aWxlbWFwcywgYW5kIHVpTGF5ZXJzIHRvIHRoZSByZW5kZXJlclxyXG4gICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5yZW5kZXIodmlzaWJsZVNldCwgdGhpcy50aWxlbWFwcywgdGhpcy51aUxheWVycyk7XHJcblxyXG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuc2NlbmVHcmFwaC5nZXRBbGxOb2RlcygpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcHMuZm9yRWFjaCh0aWxlbWFwID0+IHRpbGVtYXAudmlzaWJsZSA/IG5vZGVzLnB1c2godGlsZW1hcCkgOiAwKTtcclxuICAgICAgICBEZWJ1Zy5zZXROb2Rlcyhub2Rlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBhcyBydW5uaW5nIG9yIG5vdFxyXG4gICAgICogQHBhcmFtIHJ1bm5pbmcgVHJ1ZSBpZiB0aGUgU2NlbmUgc2hvdWxkIGJlIHJ1bm5pbmcsIGZhbHNlIGlmIG5vdFxyXG4gICAgICovXHJcbiAgICBzZXRSdW5uaW5nKHJ1bm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBydW5uaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgU2NlbmUgaXMgcnVubmluZ1xyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2NlbmUgaXMgcnVubmluZywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGlzUnVubmluZygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIHNjZW5lIGdyYXBoXHJcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIENhbnZhc05vZGUpe1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lR3JhcGgucmVtb3ZlTm9kZShub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEZXN0cm95cyB0aGlzIHNjZW5lIGFuZCBhbGwgbm9kZXMgaW4gaXQgKi9cclxuICAgIGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMuc2NlbmVHcmFwaC5nZXRBbGxOb2RlcygpKXtcclxuICAgICAgICAgICAgbm9kZS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IobGV0IHRpbGVtYXAgb2YgdGhpcy50aWxlbWFwcyl7XHJcbiAgICAgICAgICAgIHRpbGVtYXAuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XHJcblxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lR3JhcGg7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc01hbmFnZXI7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMubmF2TWFuYWdlcjtcclxuICAgICAgICBkZWxldGUgdGhpcy5haU1hbmFnZXI7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucmVjZWl2ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGxheWVyIHRvIHRoZSBzY2VuZSBhbmQgcmV0dXJucyBpdFxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBsYXllclxyXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIExheWVyXHJcbiAgICAgKi9cclxuICAgIGFkZExheWVyKG5hbWU6IHN0cmluZywgZGVwdGg/OiBudW1iZXIpOiBMYXllciB7XHJcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcclxuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBMYXllcih0aGlzLCBuYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5sYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcclxuXHJcbiAgICAgICAgaWYoZGVwdGgpe1xyXG4gICAgICAgICAgICBsYXllci5zZXREZXB0aChkZXB0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IHBhcmFsbGF4IGxheWVyIHRvIHRoaXMgc2NlbmUgYW5kIHJldHVybnMgaXRcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJhbGxheCBsYXllclxyXG4gICAgICogQHBhcmFtIHBhcmFsbGF4IFRoZSBwYXJhbGxheCBsZXZlbFxyXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIFBhcmFsbGF4TGF5ZXJcclxuICAgICAqL1xyXG4gICAgYWRkUGFyYWxsYXhMYXllcihuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyLCBkZXB0aD86IG51bWJlcik6IFBhcmFsbGF4TGF5ZXIge1xyXG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGF5ZXIgPSBuZXcgUGFyYWxsYXhMYXllcih0aGlzLCBuYW1lLCBwYXJhbGxheCk7XHJcblxyXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcclxuXHJcbiAgICAgICAgaWYoZGVwdGgpe1xyXG4gICAgICAgICAgICBsYXllci5zZXREZXB0aChkZXB0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IFVJTGF5ZXIgdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IFVJbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIFVJTGF5ZXJcclxuICAgICAqL1xyXG4gICAgYWRkVUlMYXllcihuYW1lOiBzdHJpbmcpOiBVSUxheWVyIHtcclxuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xyXG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxheWVyID0gbmV3IFVJTGF5ZXIodGhpcywgbmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMudWlMYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxheWVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGxheWVyIGZyb20gdGhlIHNjZW5lIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxyXG4gICAgICogVGhpcyBjYW4gYmUgYSBMYXllciBvciBhbnkgb2YgaXRzIHN1YmNsYXNzZXNcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIExheWVyIGZvdW5kIHdpdGggdGhhdCBuYW1lXHJcbiAgICAgKi9cclxuICAgIGdldExheWVyKG5hbWU6IHN0cmluZyk6IExheWVyIHtcclxuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllcnMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFsbGF4TGF5ZXJzLmdldChuYW1lKTtcclxuICAgICAgICB9IGVsc2UgaWYodGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51aUxheWVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgYFJlcXVlc3RlZCBsYXllciAke25hbWV9IGRvZXMgbm90IGV4aXN0LmA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGF5ZXIgaXMgYSBQYXJhbGxheExheWVyXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBhIFBhcmFsbGF4TGF5ZXJcclxuICAgICAqL1xyXG4gICAgaXNQYXJhbGxheExheWVyKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgVUlMYXllclxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgbGF5ZXIgaXMgUGFyYWxsYXhMYXllclxyXG4gICAgICovXHJcbiAgICBpc1VJTGF5ZXIobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudWlMYXllcnMuaGFzKG5hbWUpO1xyXG4gICAgfSAgICBcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIHJlc3BlY3QgdG8gY2FtZXJhIHNwYWNlIChkdWUgdG8gdGhlIHZpZXdwb3J0IG1vdmluZykuXHJcbiAgICAgKiBUaGlzIHZhbHVlIGlzIGFmZmVjdGVkIGJ5IHRoZSBwYXJhbGxheCBsZXZlbCBvZiB0aGUgQHJlZmVyZW5jZVtMYXllcl0gdGhlIG5vZGUgaXMgb24uXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVjayB0aGUgdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgdHJhbnNsYXRpb24gb2Ygdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvIHRoaXMgbm9kZS5cclxuICAgICAqL1xyXG4gICAgZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGU6IEdhbWVOb2RlKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xyXG5cclxuICAgICAgICBpZihsYXllciBpbnN0YW5jZW9mIFBhcmFsbGF4TGF5ZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBVSUxheWVyKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luKCkubXVsdChsYXllci5wYXJhbGxheCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luKCk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIGxldmVsIG9mIHRoZSB2aWV3XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgICovXHJcblx0Z2V0Vmlld1NjYWxlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKTtcclxuXHR9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBWaWV3cG9ydCBhc3NvY2lhdGVkIHdpdGggdGhpcyBzY2VuZVxyXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgVmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgZ2V0Vmlld3BvcnQoKTogVmlld3BvcnQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgd29ybGQgc2l6ZSBvZiB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgd29ybGQgc2l6ZSBpbiBhIFZlYzJcclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRTaXplKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIFNjZW5lR3JhcGggYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSBTY2VuZUdyYXBoXHJcbiAgICAgKi9cclxuICAgIGdldFNjZW5lR3JhcGgoKTogU2NlbmVHcmFwaCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVHcmFwaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIFBoeXNpY3NNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgUGh5c2ljc01hbmFnZXJcclxuICAgICAqL1xyXG4gICAgZ2V0UGh5c2ljc01hbmFnZXIoKTogUGh5c2ljc01hbmFnZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBoeXNpY3NNYW5hZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgTmF2aWdhdGlvbk1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSBOYXZpZ2F0aW9uTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXROYXZpZ2F0aW9uTWFuYWdlcigpOiBOYXZpZ2F0aW9uTWFuYWdlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2TWFuYWdlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEFJTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxyXG4gICAgICogQHJldHVybnMgVGhlIEFJTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXRBSU1hbmFnZXIoKTogQUlNYW5hZ2VyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5haU1hbmFnZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYW4gSUQgZm9yIGEgR2FtZU5vZGVcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgSURcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVJZCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lTWFuYWdlci5nZW5lcmF0ZUlkKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBUaWxlbWFwIGluIHRoaXMgU2NlbmVcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBUaWxlbWFwXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVGlsZW1hcCwgaWYgb25lIHRoaXMgbmFtZSBleGlzdHMsIG90aGVyd2lzZSBudWxsXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVtYXAobmFtZTogc3RyaW5nKTogVGlsZW1hcCB7XHJcbiAgICAgICAgZm9yKGxldCB0aWxlbWFwIG9mIHRoaXMgLnRpbGVtYXBzKXtcclxuICAgICAgICAgICAgaWYodGlsZW1hcC5uYW1lID09PSBuYW1lKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlbWFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi9TY2VuZVwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcclxuaW1wb3J0IE1lbW9yeVV0aWxzIGZyb20gXCIuLi9VdGlscy9NZW1vcnlVdGlsc1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBTY2VuZU1hbmFnZXIgYWN0cyBhcyBhbiBpbnRlcmZhY2UgdG8gY3JlYXRlIFNjZW5lcywgYW5kIGhhbmRsZXMgdGhlIGxpZmVjeWNsZSBtZXRob2RzIG9mIFNjZW5lcy5cclxuICogSXQgZ2l2ZXMgU2NlbmVzIGFjY2VzcyB0byBpbmZvcm1hdGlvbiB0aGV5IG5lZWQgZnJvbSB0aGUgQHJlZmVyZW5jZVtHYW1lXSBjbGFzcyB3aGlsZSBrZWVwaW5nIGEgbGF5ZXIgb2Ygc2VwYXJhdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lTWFuYWdlciB7XHJcblx0LyoqIFRoZSBjdXJyZW50IFNjZW5lIG9mIHRoZSBnYW1lICovXHJcblx0cHJvdGVjdGVkIGN1cnJlbnRTY2VuZTogU2NlbmU7XHJcblxyXG5cdC8qKiBUaGUgVmlld3BvcnQgb2YgdGhlIGdhbWUgKi9cclxuXHRwcm90ZWN0ZWQgdmlld3BvcnQ6IFZpZXdwb3J0O1xyXG5cclxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIFJlc291cmNlTWFuYWdlciAqL1xyXG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcblx0LyoqIEEgY291bnRlciB0byBrZWVwIHRyYWNrIG9mIGdhbWUgaWRzICovXHJcblx0cHJvdGVjdGVkIGlkQ291bnRlcjogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIFJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIGdhbWUgKi9cclxuXHRwcm90ZWN0ZWQgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcclxuXHJcblx0LyoqIEZvciBjb25zaXN0ZW5jeSwgb25seSBjaGFuZ2Ugc2NlbmVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHVwZGF0ZSBjeWNsZSAqL1xyXG5cdHByb3RlY3RlZCBwZW5kaW5nU2NlbmU6IFNjZW5lO1xyXG5cdHByb3RlY3RlZCBwZW5kaW5nU2NlbmVJbml0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IFNjZW5lTWFuYWdlclxyXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgVmlld3BvcnQgb2YgdGhlIGdhbWVcclxuXHQgKiBAcGFyYW0gZ2FtZSBUaGUgR2FtZSBpbnN0YW5jZVxyXG5cdCAqIEBwYXJhbSByZW5kZXJpbmdNYW5hZ2VyIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIG9mIHRoZSBnYW1lXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyKXtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblx0XHR0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcblx0XHR0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSByZW5kZXJpbmdNYW5hZ2VyO1xyXG5cdFx0dGhpcy5pZENvdW50ZXIgPSAwO1xyXG5cdFx0dGhpcy5wZW5kaW5nU2NlbmUgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGEgc2NlbmUgYXMgdGhlIG1haW4gc2NlbmUuXHJcblx0ICogVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSd2ZSBjcmVhdGVkIGEgc3ViY2xhc3Mgb2YgU2NlbmUsIGFuZCB5b3Ugd2FudCB0byBhZGQgaXQgYXMgdGhlIG1haW4gU2NlbmUuXHJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHNjZW5lIHRvIGFkZFxyXG5cdCAqIEBwYXJhbSBpbml0IEFuIG9iamVjdCB0byBwYXNzIHRvIHRoZSBpbml0IGZ1bmN0aW9uIG9mIHRoZSBuZXcgc2NlbmVcclxuXHQgKi9cclxuXHRwdWJsaWMgY2hhbmdlVG9TY2VuZTxUIGV4dGVuZHMgU2NlbmU+KGNvbnN0cjogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQsIGluaXQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG5cdFx0Y29uc29sZS5sb2coXCJDcmVhdGluZyB0aGUgbmV3IHNjZW5lIC0gY2hhbmdlIGlzIHBlbmRpbmcgdW50aWwgbmV4dCB1cGRhdGVcIik7XHJcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG5ldyBjb25zdHIodGhpcy52aWV3cG9ydCwgdGhpcywgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zKTtcclxuXHRcdHRoaXMucGVuZGluZ1NjZW5lSW5pdCA9IGluaXQ7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZG9TY2VuZUNoYW5nZSgpe1xyXG5cdFx0Y29uc29sZS5sb2coXCJQZXJmb3JtaW5nIHNjZW5lIGNoYW5nZVwiKTtcclxuXHRcdHRoaXMudmlld3BvcnQuc2V0Q2VudGVyKHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54LCB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSk7XHJcblx0XHRcclxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lKXtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHNjZW5lXCIpXHJcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnVubG9hZFNjZW5lKCk7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkRlc3Ryb3lpbmcgb2xkIHNjZW5lXCIpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5kZXN0cm95KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHJlc291cmNlcy4uLlwiKTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLnVubG9hZEFsbFJlc291cmNlcygpO1xyXG5cclxuXHRcdC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgdGhlIGN1cnJlbnQgb25lXHJcblx0XHR0aGlzLmN1cnJlbnRTY2VuZSA9IHRoaXMucGVuZGluZ1NjZW5lO1xyXG5cclxuXHRcdC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgbnVsbFxyXG5cdFx0dGhpcy5wZW5kaW5nU2NlbmUgPSBudWxsO1xyXG5cclxuXHRcdC8vIEluaXQgdGhlIHNjZW5lXHJcblx0XHR0aGlzLmN1cnJlbnRTY2VuZS5pbml0U2NlbmUodGhpcy5wZW5kaW5nU2NlbmVJbml0KTtcclxuXHJcblx0XHQvLyBFbnF1ZXVlIGFsbCBzY2VuZSBhc3NldCBsb2Fkc1xyXG5cdFx0dGhpcy5jdXJyZW50U2NlbmUubG9hZFNjZW5lKCk7XHJcblxyXG5cdFx0Ly8gTG9hZCBhbGwgYXNzZXRzXHJcblx0XHRjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIFNjZW5lIExvYWRcIik7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJTdGFydGluZyBTY2VuZVwiKTtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuc3RhcnRTY2VuZSgpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zZXRSdW5uaW5nKHRydWUpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJpbmdNYW5hZ2VyLnNldFNjZW5lKHRoaXMuY3VycmVudFNjZW5lKTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGVzIGEgdW5pcXVlIElEXHJcblx0ICogQHJldHVybnMgQSBuZXcgSURcclxuXHQgKi9cclxuXHRwdWJsaWMgZ2VuZXJhdGVJZCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuaWRDb3VudGVyKys7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBjdXJyZW50IFNjZW5lXHJcblx0ICovXHJcblx0cHVibGljIHJlbmRlcigpOiB2b2lkIHtcclxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lKXtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUucmVuZGVyKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSBjdXJyZW50IFNjZW5lXHJcblx0ICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZXN0ZXAgb2YgdGhlIFNjZW5lXHJcblx0ICovXHJcblx0cHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XHJcblx0XHRpZih0aGlzLnBlbmRpbmdTY2VuZSAhPT0gbnVsbCl7XHJcblx0XHRcdHRoaXMuZG9TY2VuZUNoYW5nZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmlzUnVubmluZygpKXtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUudXBkYXRlKGRlbHRhVCk7XHJcblx0XHR9XHJcblx0fVxyXG59IiwiaW1wb3J0IEFycmF5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL0FycmF5VXRpbHNcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogVGhlIG9wdGlvbnMgdG8gZ2l2ZSBhIEByZWZlcmVuY2VbU2NlbmVdIGZvciBpbml0aWFsaXphdGlvblxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVPcHRpb25zIHtcclxuICAgIHBoeXNpY3M6IHtcclxuICAgICAgICBncm91cHM6IEFycmF5PHN0cmluZz4sXHJcbiAgICAgICAgY29sbGlzaW9uczogQXJyYXk8QXJyYXk8bnVtYmVyPj47XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBTY2VuZU9wdGlvbnN7XHJcbiAgICAgICAgbGV0IHNPcHQgPSBuZXcgU2NlbmVPcHRpb25zKCk7XHJcblxyXG4gICAgICAgIGlmKG9wdGlvbnMucGh5c2ljcyA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgc09wdC5waHlzaWNzID0ge2dyb3VwczogdW5kZWZpbmVkLCBjb2xsaXNpb25zOiB1bmRlZmluZWR9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNPcHQucGh5c2ljcyA9IG9wdGlvbnMucGh5c2ljcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzT3B0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBNYW5hZ2VzIGFueSBzb3VuZHMgb3IgbXVzaWMgbmVlZGVkIGZvciB0aGUgZ2FtZS5cclxuICogVGhyb3VnaCB0aGUgRXZlbnRRdWV1ZSwgZXhwb3NlcyBpbnRlcmZhY2UgdG8gcGxheSBzb3VuZHMgc28gR2FtZU5vZGVzIGNhbiBhY3RpdmF0ZSBzb3VuZHMgd2l0aG91dFxyXG4gKiBuZWVkaW5nIGRpcmVjdCByZWZlcmVuY2VzIHRvIHRoZSBhdWRpbyBzeXN0ZW1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvTWFuYWdlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogQXVkaW9NYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgZXZlbnQgcmVjZWl2ZXIgb2YgdGhpcyBBdWRpb01hbmFnZXIgKi9cclxuICAgIHByaXZhdGUgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cclxuICAgIC8qKiBBIE1hcCBvZiB0aGUgbmFtZXMgb2YgY3VycmVudGx5IHBsYXlpbmcgKG9yIHBhdXNlZCkgc291bmRzIHRvIHRoZWlyIEF1ZGlvQnVmZmVycyAqL1xyXG4gICAgcHJpdmF0ZSBjdXJyZW50U291bmRzOiBNYXA8QXVkaW9CdWZmZXJTb3VyY2VOb2RlPjtcclxuXHJcbiAgICBwcml2YXRlIGF1ZGlvQ3R4OiBBdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgcHJpdmF0ZSBnYWluTm9kZXM6IEFycmF5PEdhaW5Ob2RlPjtcclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5pbml0QXVkaW8oKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoW1xyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQsXHJcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCxcclxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5QTEFZX01VU0lDLFxyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYLFxyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLk1VVEVfQ0hBTk5FTCxcclxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5VTk1VVEVfQ0hBTk5FTFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNvdW5kcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nYWluTm9kZXMgPSBuZXcgQXJyYXk8R2Fpbk5vZGU+KE1BWF9BVURJT19DSEFOTkVMUyk7XHJcbiAgICAgICAgdGhpcy5pbml0R2Fpbk5vZGVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGluc3RhbmNlIG9mIHRoZSBBdWRpb01hbmFnZXIgY2xhc3Mgb3IgY3JlYXRlIGEgbmV3IG9uZSBpZiBub25lIGV4aXN0c1xyXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IEF1ZGlvTWFuYWdlciB7XHJcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IEF1ZGlvTWFuYWdlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSB3ZWJBdWRpbyBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaW5pdEF1ZGlvKCk6IHZvaWQge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0Oy8vIHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7IFxyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvQ3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpOyBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dlYiBBdWRpbyBBUEkgc3VjY2Vzc2Z1bGx5IGxvYWRlZCcpO1xyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYiBBdWRpbyBBUEkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTsgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5pdEdhaW5Ob2RlcygpOiB2b2lkIHtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgTUFYX0FVRElPX0NIQU5ORUxTOyBpKyspe1xyXG4gICAgICAgICAgICB0aGlzLmdhaW5Ob2Rlc1tpXSA9IHRoaXMuYXVkaW9DdHguY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXVkaW8gY29udGV4dFxyXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvQ29udGV4dFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXVkaW9Db250ZXh0KCk6IEF1ZGlvQ29udGV4dCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9DdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAgICBBY2NvcmRpbmcgdG8gdGhlIE1ETiwgY3JlYXRlIGEgbmV3IHNvdW5kIGZvciBldmVyeSBjYWxsOlxyXG5cclxuICAgICAgICBBbiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgY2FuIG9ubHkgYmUgcGxheWVkIG9uY2U7IGFmdGVyIGVhY2ggY2FsbCB0byBzdGFydCgpLCB5b3UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgbm9kZVxyXG4gICAgICAgIGlmIHlvdSB3YW50IHRvIHBsYXkgdGhlIHNhbWUgc291bmQgYWdhaW4uIEZvcnR1bmF0ZWx5LCB0aGVzZSBub2RlcyBhcmUgdmVyeSBpbmV4cGVuc2l2ZSB0byBjcmVhdGUsIGFuZCB0aGVcclxuICAgICAgICBhY3R1YWwgQXVkaW9CdWZmZXJzIGNhbiBiZSByZXVzZWQgZm9yIG11bHRpcGxlIHBsYXlzIG9mIHRoZSBzb3VuZC4gSW5kZWVkLCB5b3UgY2FuIHVzZSB0aGVzZSBub2RlcyBpbiBhXHJcbiAgICAgICAgXCJmaXJlIGFuZCBmb3JnZXRcIiBtYW5uZXI6IGNyZWF0ZSB0aGUgbm9kZSwgY2FsbCBzdGFydCgpIHRvIGJlZ2luIHBsYXlpbmcgdGhlIHNvdW5kLCBhbmQgZG9uJ3QgZXZlbiBib3RoZXIgdG9cclxuICAgICAgICBob2xkIGEgcmVmZXJlbmNlIHRvIGl0LiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgYXQgYW4gYXBwcm9wcmlhdGUgdGltZSwgd2hpY2ggd29uJ3QgYmVcclxuICAgICAgICB1bnRpbCBzb21ldGltZSBhZnRlciB0aGUgc291bmQgaGFzIGZpbmlzaGVkIHBsYXlpbmcuXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNvdW5kIGZyb20gdGhlIGtleSBvZiBhIGxvYWRlZCBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBhdWRpbyBmaWxlIHRvIGNyZWF0ZSBhIG5ldyBzb3VuZCBmb3JcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIEF1ZGlvQnVmZmVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVTb3VuZChrZXk6IHN0cmluZywgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgb3B0aW9uczogTWFwPGFueT4pOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUge1xyXG4gICAgICAgIC8vIEdldCBhdWRpbyBidWZmZXJcclxuICAgICAgICBsZXQgYnVmZmVyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0QXVkaW8oa2V5KTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc291bmQgc291cmNlXHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuYXVkaW9DdHguY3JlYXRlQnVmZmVyU291cmNlKCk7IFxyXG4gICAgICBcclxuICAgICAgICAvLyBUZWxsIHRoZSBzb3VyY2Ugd2hpY2ggc291bmQgdG8gcGxheVxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSBidWZmZXI7ICAgICAgICAgICAgICAgXHJcbiAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBhbnkgYWRkaXRpb25hbCBub2Rlc1xyXG4gICAgICAgIGNvbnN0IG5vZGVzOiBBcnJheTxBdWRpb05vZGU+ID0gW3NvdXJjZV07XHJcblxyXG4gICAgICAgIC8vIERvIGFueSBhZGRpdGlvbmFsIG5vZGVzIGhlcmU/XHJcbiAgICAgICAgLy8gT2YgY291cnNlLCB0aGVyZSBhcmVuJ3QgYW55IHN1cHBvcnRlZCB5ZXQuLi5cclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBnYWluIG5vZGUgZm9yIHRoaXMgY2hhbm5lbFxyXG4gICAgICAgIG5vZGVzLnB1c2godGhpcy5nYWluTm9kZXNbY2hhbm5lbF0pO1xyXG5cclxuICAgICAgICAvLyBDb25uZWN0IGFueSBub2RlcyBhbG9uZyB0aGUgcGF0aFxyXG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIG5vZGVzW2ktMV0uY29ubmVjdChub2Rlc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25uZWN0IHRoZSBzb3VyY2UgdG8gdGhlIGNvbnRleHQncyBkZXN0aW5hdGlvblxyXG4gICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5hdWRpb0N0eC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYXkgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNvdW5kIHRvIHBsYXlcclxuICAgICAqIEBwYXJhbSBsb29wIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgc291bmRcclxuICAgICAqIEBwYXJhbSBob2xkUmVmZXJlbmNlIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3Qgd2Ugd2FudCB0byBob2xkIG9uIHRvIGEgcmVmZXJlbmNlIG9mIHRoZSBhdWRpbyBub2RlLiBUaGlzIGlzIGdvb2QgZm9yIHBsYXlpbmcgbXVzaWMgb24gYSBsb29wIHRoYXQgd2lsbCBldmVudHVhbGx5IG5lZWQgdG8gYmUgc3RvcHBlZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBsYXlTb3VuZChrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgb3B0aW9uczogTWFwPGFueT4pOiB2b2lkIHtcclxuICAgICAgICBsZXQgc291bmQgPSB0aGlzLmNyZWF0ZVNvdW5kKGtleSwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmKGxvb3Ape1xyXG4gICAgICAgICAgICBzb3VuZC5sb29wID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBhIHJlZmVyZW5jZSBvZiB0aGUgbmV3IHNvdW5kIHRvIGEgbWFwLiBUaGlzIHdpbGwgYWxsb3cgdXMgdG8gc3RvcCBhIGxvb3Bpbmcgb3IgbG9uZyBzb3VuZCBhdCBhIGxhdGVyIHRpbWVcclxuICAgICAgICBpZihob2xkUmVmZXJlbmNlKXtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U291bmRzLmFkZChrZXksIHNvdW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc291bmQuc3RhcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdG9wU291bmQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBsZXQgc291bmQgPSB0aGlzLmN1cnJlbnRTb3VuZHMuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYoc291bmQpe1xyXG4gICAgICAgICAgICBzb3VuZC5zdG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNvdW5kcy5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG11dGVDaGFubmVsKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUpe1xyXG4gICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGhpcy5hdWRpb0N0eC5jdXJyZW50VGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHVubXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XHJcbiAgICAgICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZvbHVtZSBvZiBhIGNoYW5uZWwgdXNpbmcgdGhlIEdhaW5Ob2RlIGZvciB0aGF0IGNoYW5uZWwuIEZvciBtb3JlXHJcbiAgICAgKiBpbmZvcm1hdGlvbiBvbiBHYWluTm9kZXMsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2Fpbk5vZGVcclxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBhdWRpbyBjaGFubmVsIHRvIHNldCB0aGUgdm9sdW1lIGZvclxyXG4gICAgICogQHBhcmFtIHZvbHVtZSBUaGUgdm9sdW1lIG9mIHRoZSBjaGFubmVsLiAwIGlzIG11dGVkLiBWYWx1ZXMgYmVsb3cgemVybyB3aWxsIGJlIHNldCB0byB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2V0Vm9sdW1lKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUsIHZvbHVtZTogbnVtYmVyKXtcclxuICAgICAgICBpZih2b2x1bWUgPCAwKXtcclxuICAgICAgICAgICAgdm9sdW1lID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFtID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgYW0uZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sdW1lLCBhbS5hdWRpb0N0eC5jdXJyZW50VGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBHYWluTm9kZSBmb3IgdGhpcyBjaGFubmVsLlxyXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCBHYWluTm9kZXMgaGVyZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2Fpbk5vZGVcclxuICAgICAqIERPTidUIFVTRSBUSElTIFVOTEVTUyBZT1UgS05PVyBXSEFUIFlPVSdSRSBET0lOR1xyXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWxcclxuICAgICAqIEByZXR1cm5zIFRoZSBHYWluTm9kZSBmb3IgdGhlIHNwZWNpZmllZCBjaGFubmVsXHJcbiAgICAgKi9cclxuICAgIGdldENoYW5uZWxHYWluTm9kZShjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5nYWluTm9kZXNbY2hhbm5lbF07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIC8vIFBsYXkgZWFjaCBhdWRpbyBjbGlwIHJlcXVlc3RlZFxyXG4gICAgICAgIC8vIFRPRE8gLSBBZGQgbG9naWMgdG8gbWVyZ2Ugc291bmRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBvZiB0aGUgc2FtZSBrZXlcclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX1NPVU5EIHx8IGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyB8fCBldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYKXtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VuZEtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvb3AgPSBldmVudC5kYXRhLmdldChcImxvb3BcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgaG9sZFJlZmVyZW5jZSA9IGV2ZW50LmRhdGEuZ2V0KFwiaG9sZFJlZmVyZW5jZVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuREVGQVVMVDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLk1VU0lDO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKEdhbWVFdmVudFR5cGUuUExBWV9TRlgpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLlNGWDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihldmVudC5kYXRhLmhhcyhcImNoYW5uZWxcIikpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBldmVudC5kYXRhLmdldChcImNoYW5uZWxcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5U291bmQoc291bmRLZXksIGxvb3AsIGhvbGRSZWZlcmVuY2UsIGNoYW5uZWwsIGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlNUT1BfU09VTkQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdW5kS2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BTb3VuZChzb3VuZEtleSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTVVURV9DSEFOTkVMKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5VTk1VVEVfQ0hBTk5FTCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gQXVkaW9DaGFubmVsVHlwZSB7XHJcbiAgICBERUZBVUxUID0gMCxcclxuICAgIFNGWCA9IDEsXHJcbiAgICBNVVNJQyA9IDIsXHJcbiAgICBDVVNUT01fMSA9IDMsXHJcbiAgICBDVVNUT01fMiA9IDQsXHJcbiAgICBDVVNUT01fMyA9IDUsXHJcbiAgICBDVVNUT01fNCA9IDYsXHJcbiAgICBDVVNUT01fNSA9IDcsXHJcbiAgICBDVVNUT01fNiA9IDgsXHJcbiAgICBDVVNUT01fNyA9IDksXHJcbiAgICBDVVNUT01fOCA9IDEwLFxyXG4gICAgQ1VTVE9NXzkgPSAxMSxcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9BVURJT19DSEFOTkVMUyA9IDEyOyIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgVGltZXJNYW5hZ2VyIGZyb20gXCIuL1RpbWVyTWFuYWdlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHJcbiAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyB0aW1lciAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRlOiBUaW1lclN0YXRlO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIHRpbWVyIGVuZHMgKi9cclxuICAgIHByb3RlY3RlZCBvbkVuZDogRnVuY3Rpb247XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdGltZXIgc2hvdWxkIGxvb3AgKi9cclxuICAgIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgdG90YWwgYW1vdW50IG9mIHRpbWUgdGhpcyB0aW1lciBydW5zIGZvciAqL1xyXG4gICAgcHJvdGVjdGVkIHRvdGFsVGltZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgbGVmdCBvbiB0aGUgY3VycmVudCBydW4gKi9cclxuICAgIHByb3RlY3RlZCB0aW1lTGVmdDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoaXMgdGltZXIgaGFzIGJlZW4gcnVuICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtUnVuczogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRpbWU6IG51bWJlciwgb25FbmQ/OiBGdW5jdGlvbiwgbG9vcDogYm9vbGVhbiA9IGZhbHNlKXtcclxuICAgICAgICAvLyBSZWdpc3RlciB0aGlzIHRpbWVyXHJcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuYWRkVGltZXIodGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHRoaXMudGltZUxlZnQgPSAwO1xyXG4gICAgICAgIHRoaXMub25FbmQgPSBvbkVuZDtcclxuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XHJcbiAgICAgICAgdGhpcy5udW1SdW5zID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc1N0b3BwZWQoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5TVE9QUEVEO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUGF1c2VkKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFRpbWVyU3RhdGUuUEFVU0VEO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbWVyIGhhcyBiZWVuIHJ1biBiZWZvcmVcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgaXQgaGFzIGJlZW4gcnVuIGF0IGxlYXN0IG9uY2UgKGFmdGVyIHRoZSBsYXRlc3QgcmVzZXQpLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGhhc1J1bigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1SdW5zID4gMDtcclxuICAgIH1cclxuXHJcbiAgICBzdGFydCh0aW1lPzogbnVtYmVyKXtcclxuICAgICAgICBpZih0aW1lICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IHRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLkFDVElWRTtcclxuICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlc2V0cyB0aGlzIHRpbWVyLiBTZXRzIHRoZSBwcm9ncmVzcyBiYWNrIHRvIHplcm8sIGFuZCBzZXRzIHRoZSBudW1iZXIgb2YgcnVucyBiYWNrIHRvIHplcm8gKi9cclxuICAgIHJlc2V0KCl7XHJcbiAgICAgICAgdGhpcy50aW1lTGVmdCA9IHRoaXMudG90YWxUaW1lO1xyXG4gICAgICAgIHRoaXMubnVtUnVucyA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcGF1c2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuUEFVU0VEO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XHJcbiAgICAgICAgaWYodGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5BQ1RJVkUpe1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVMZWZ0IC09IGRlbHRhVCoxMDAwO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy50aW1lTGVmdCA8PSAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZUxlZnQgPSBNYXRoVXRpbHMuY2xhbXBMb3cwKHRoaXMudGltZUxlZnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZW5kKCl7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XHJcbiAgICAgICAgdGhpcy5udW1SdW5zICs9IDE7XHJcblxyXG4gICAgICAgIC8vIENhbGwgdGhlIGVuZCBmdW5jdGlvbiBpZiB0aGVyZSBpcyBvbmVcclxuICAgICAgICBpZih0aGlzLm9uRW5kKXtcclxuICAgICAgICAgICAgdGhpcy5vbkVuZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTG9vcCBpZiB3ZSB3YW50IHRvXHJcbiAgICAgICAgaWYodGhpcy5sb29wKXtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuQUNUSVZFO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ3tcclxuICAgICAgICByZXR1cm4gXCJUaW1lcjogXCIgKyB0aGlzLnN0YXRlICsgXCIgLSBUaW1lIExlZnQ6IFwiICsgdGhpcy50aW1lTGVmdCArIFwibXMgb2YgXCIgKyB0aGlzLnRvdGFsVGltZSArIFwibXNcIjtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gVGltZXJTdGF0ZSB7XHJcbiAgICBBQ1RJVkUgPSBcIkFDVElWRVwiLFxyXG4gICAgUEFVU0VEID0gXCJQQVVTRURcIixcclxuICAgIFNUT1BQRUQgPSBcIlNUT1BQRURcIlxyXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL1RpbWVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lck1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgdGltZXJzOiBBcnJheTxUaW1lcj47XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5zdGFuY2U6IFRpbWVyTWFuYWdlcjtcclxuXHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVGltZXJNYW5hZ2VyIHtcclxuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgVGltZXJNYW5hZ2VyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRUaW1lcih0aW1lcjogVGltZXIpe1xyXG4gICAgICAgIHRoaXMudGltZXJzLnB1c2godGltZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyVGltZXJzKCl7XHJcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnRpbWVycy5mb3JFYWNoKHRpbWVyID0+IHRpbWVyLnVwZGF0ZShkZWx0YVQpKTtcclxuICAgIH1cclxufSIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4vTWF0aFV0aWxzXCI7XHJcblxyXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgZGF0YXR5cGVzIGZvbGRlclxyXG4vKipcclxuICogQSBDb2xvciB1dGlsIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgY29sb3JzIGxpa2UgYSB2ZWN0b3IsIGJ1dCBjYW4gYmUgY29udmVydGVkIGludG8gYSBzdHJpbmcgZm9ybWF0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvciB7XHJcblx0LyoqIFRoZSByZWQgdmFsdWUgKi9cclxuXHRwdWJsaWMgcjogbnVtYmVyO1xyXG5cdC8qKiBUaGUgZ3JlZW4gdmFsdWUgKi9cclxuXHRwdWJsaWMgZzogbnVtYmVyO1xyXG5cdC8qKiBUaGUgYmx1ZSB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBiOiBudW1iZXI7XHJcblx0LyoqIFRoZSBhbHBoYSB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBhOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgY29sb3JcclxuXHQgKiBAcGFyYW0gciBSZWRcclxuXHQgKiBAcGFyYW0gZyBHcmVlblxyXG5cdCAqIEBwYXJhbSBiIEJsdWVcclxuXHQgKiBAcGFyYW0gYSBBbHBoYVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHI6IG51bWJlciA9IDAsIGc6IG51bWJlciA9IDAsIGI6IG51bWJlciA9IDAsIGE6IG51bWJlciA9IDEpe1xyXG4gICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgdGhpcy5nID0gZztcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYSA9IGE7XHJcblx0fVxyXG5cclxuXHQvKipcdFxyXG5cdCAqIFRyYW5zcGFyZW50IGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiYSgwLCAwLCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgVFJBTlNQQVJFTlQoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHRcclxuXHQgKiBSZWQgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgUkVEKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogR3JlZW4gY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgR1JFRU4oKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDAsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBCbHVlIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDAsIDAsIDI1NSlcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IEJMVUUoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAyNTUsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBZZWxsb3cgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDApXHJcblx0ICovXHJcblx0c3RhdGljIGdldCBZRUxMT1coKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDI1NSwgMCwgMSk7XHJcblx0fVxyXG5cclxuXHQvKipcdFxyXG5cdCAqIE1hZ2VudGEgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAyNTUpXHJcblx0ICovXHJcblx0c3RhdGljIGdldCBNQUdFTlRBKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAyNTUsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBDeWFuIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDAsIDI1NSwgMjU1KVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgQ1lBTigpOiBDb2xvciB7XHJcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDI1NSwgMjU1LCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogV2hpdGUgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDI1NSlcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IFdISVRFKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSwgMSk7XHJcblx0fSBcclxuXHJcblx0LyoqXHRcclxuXHQgKiBCbGFjayBjb2xvclxyXG5cdCAqIEByZXR1cm5zIHJnYigwLCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgQkxBQ0soKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogT3JhbmdlIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMTAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgT1JBTkdFKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAxMDAsIDAsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgY29sb3IgdG8gdGhlIHZhbHVlcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSByIFJlZFxyXG5cdCAqIEBwYXJhbSBnIEdyZWVuXHJcblx0ICogQHBhcmFtIGIgQmx1ZVxyXG5cdCAqIEBwYXJhbSBhIEFscGhhXHJcblx0ICovXHJcblx0c2V0KHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuXHRcdHRoaXMuciA9IHI7XHJcblx0XHR0aGlzLmcgPSBnO1xyXG5cdFx0dGhpcy5iID0gYjtcclxuXHRcdHRoaXMuYSA9IGE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGxpZ2h0ZXIgdGhhbiB0aGUgY3VycmVudCBjb2xvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IGxpZ2h0ZXIgQ29sb3JcclxuXHQgKi9cclxuXHRsaWdodGVuKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoTWF0aFV0aWxzLmNsYW1wKHRoaXMuciArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5nICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmIgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYSArIDEwLCAwLCAyNTUpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igc2xpZ2h0bHkgZGFya2VyIHRoYW4gdGhlIGN1cnJlbnQgY29sb3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBkYXJrZXIgQ29sb3JcclxuXHQgKi9cclxuXHRkYXJrZW4oKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcihNYXRoVXRpbHMuY2xhbXAodGhpcy5yIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmcgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYiAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5hICsgMTAsIDAsIDI1NSkpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoaXMgY29sb3IgYXMgYW4gYXJyYXlcclxuXHQgKiBAcmV0dXJucyBbciwgZywgYiwgYV1cclxuXHQgKi9cclxuXHR0b0FycmF5KCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gI1JSR0dCQlxyXG5cdCAqIEByZXR1cm5zICNSUkdHQkJcclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiI1wiICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuciwgMikgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5nLCAyKSArIE1hdGhVdGlscy50b0hleCh0aGlzLmIsIDIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiKHIsIGcsIGIpXHJcblx0ICogQHJldHVybnMgcmdiKHIsIGcsIGIpXHJcblx0ICovXHJcblx0dG9TdHJpbmdSR0IoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcInJnYihcIiArIHRoaXMuci50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5nLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmIudG9TdHJpbmcoKSArIFwiKVwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiYShyLCBnLCBiLCBhKVxyXG5cdCAqIEByZXR1cm5zIHJnYmEociwgZywgYiwgYSlcclxuXHQgKi9cclxuXHR0b1N0cmluZ1JHQkEoKTogc3RyaW5nIHtcclxuXHRcdGlmKHRoaXMuYSA9PT0gMCl7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nUkdCKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCJyZ2JhKFwiICsgdGhpcy5yLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmcudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYi50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5hLnRvU3RyaW5nKCkgK1wiKVwiXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUdXJucyB0aGlzIGNvbG9yIGludG8gYSBmbG9hdDMyQXJyYXkgYW5kIGNoYW5nZXMgY29sb3IgcmFuZ2UgdG8gWzAuMCwgMS4wXVxyXG5cdCAqIEByZXR1cm5zIGEgRmxvYXQzMkFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbG9yXHJcblx0ICovXHJcblx0dG9XZWJHTCgpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHR0aGlzLnIvMjU1LFxyXG5cdFx0XHR0aGlzLmcvMjU1LFxyXG5cdFx0XHR0aGlzLmIvMjU1LFxyXG5cdFx0XHR0aGlzLmFcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21TdHJpbmdIZXgoc3RyOiBzdHJpbmcpOiBDb2xvciB7XHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRpZihzdHIuY2hhckF0KDApID09IFwiI1wiKSBpKz0gMTtcclxuXHRcdGxldCByID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpLCBpKzIpKTtcclxuXHRcdGxldCBnID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpKzIsIGkrNCkpO1xyXG5cdFx0bGV0IGIgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGkrNCwgaSs2KSk7XHJcblx0XHRyZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIpO1xyXG5cdH1cclxufSIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYXNlRnVuY3Rpb25zIHtcclxuXHJcbiAgICBzdGF0aWMgZWFzZUluT3V0U2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZWFzZU91dEluU2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gLU1hdGguY29zKE1hdGguUEkqKHggKyAwLjUpKS8yIDogLU1hdGguY29zKE1hdGguUEkqKHggLSAwLjUpKS8yICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZWFzZU91dFNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zaW4oKHggKiBNYXRoLlBJKSAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5TaW5lKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoeCAqIE1hdGguUEkpIC8gMik7IFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWludCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gMTYgKiB4ICogeCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCA1KSAvIDI7ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgMikgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlT3V0SW5RdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyB0aGlzLmVhc2VPdXRJbl9PdXRQb3coeCwgMikgOiB0aGlzLmVhc2VPdXRJbl9JblBvdyh4LCAyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fT3V0UG93KHg6IG51bWJlciwgcG93OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAwLjUgLSBNYXRoLnBvdygtMiAqIHggKyAxLCBwb3cpIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fSW5Qb3coeDogbnVtYmVyLCBwb3c6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSArIE1hdGgucG93KDIgKiB4IC0gMSwgcG93KSAvIDI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEVhc2VGdW5jdGlvblR5cGUge1xyXG4gICAgLy8gU0lORVxyXG4gICAgSU5fT1VUX1NJTkUgPSBcImVhc2VJbk91dFNpbmVcIixcclxuICAgIE9VVF9JTl9TSU5FID0gXCJlYXNlT3V0SW5TaW5lXCIsXHJcbiAgICBJTl9TSU5FID0gXCJlYXNlSW5TaW5lXCIsXHJcbiAgICBPVVRfU0lORSA9IFwiZWFzZU91dFNpbmVcIixcclxuXHJcbiAgICAvLyBRVUFEXHJcbiAgICBJTl9PVVRfUVVBRCA9IFwiZWFzZUluT3V0UXVhZFwiLFxyXG4gICAgT1VUX0lOX1FVQUQgPSBcImVhc2VPdXRJblF1YWRcIixcclxuXHJcbiAgICAvLyBRVUlOVFxyXG4gICAgSU5fT1VUX1FVSU5UID0gXCJlYXNlSW5PdXRRdWludFwiXHJcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcclxuaW1wb3J0IEVkZ2VOb2RlIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0VkZ2VOb2RlXCI7XHJcblxyXG4vKiogQSBjbGFzcyB0byBwcm92aWRlcyBzb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBncmFwaHMgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhVdGlscyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERqaWtzdHJhJ3Mgc2hvcnRlc3QgcGF0aCBhbGdvcml0aG0gYmFzZWQgb24gdGhlIG9uZSBkZXNjcmliZWQgaW4gVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxyXG5cdCAqIEBwYXJhbSBnIFRoZSBncmFwaFxyXG5cdCAqIEBwYXJhbSBzdGFydCBUaGUgbnVtYmVyIHRvIHN0YXJ0IHRoZSBzaG9ydGVzdCBwYXRoIGZyb21cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwYXJlbnQgb2YgZWFjaCBub2RlIG9mIHRoZSBHcmFwaCBpbiB0aGUgc2hvcnRlc3QgcGF0aC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZGppa3N0cmEoZzogR3JhcGgsIHN0YXJ0OiBudW1iZXIpOiBBcnJheTxudW1iZXI+IHtcclxuXHRcdGxldCBpOiBudW1iZXI7XHRcdC8vIENvdW50ZXJcclxuXHRcdGxldCBwOiBFZGdlTm9kZTtcdC8vIFBvaW50ZXIgdG8gZWRnZW5vZGVcclxuXHRcdGxldCBpblRyZWU6IEFycmF5PGJvb2xlYW4+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG5cdFx0bGV0IGRpc3RhbmNlOiBBcnJheTxudW1iZXI+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG5cdFx0bGV0IHBhcmVudDogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcclxuXHRcdGxldCB2OiBudW1iZXI7XHRcdC8vIEN1cnJlbnQgdmVydGV4IHRvIHByb2Nlc3NcclxuXHRcdGxldCB3OiBudW1iZXI7IFx0XHQvLyBDYW5kaWRhdGUgZm9yIG5leHQgdmVydGV4XHJcblx0XHRsZXQgd2VpZ2h0OiBudW1iZXI7XHQvLyBFZGdlIHdlaWdodFxyXG5cdFx0bGV0IGRpc3Q7XHRcdFx0Ly8gQmVzdCBjdXJyZW50IGRpc3RhbmNlIGZyb20gc3RhcnRcclxuXHJcblx0XHRmb3IoaSA9IDA7IGkgPCBnLm51bVZlcnRpY2VzOyBpKyspe1xyXG5cdFx0XHRpblRyZWVbaV0gPSBmYWxzZTtcclxuXHRcdFx0ZGlzdGFuY2VbaV0gPSBJbmZpbml0eTtcclxuXHRcdFx0cGFyZW50W2ldID0gLTE7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGlzdGFuY2Vbc3RhcnRdID0gMDtcclxuXHRcdHYgPSBzdGFydDtcclxuXHJcblx0XHR3aGlsZSghaW5UcmVlW3ZdKXtcclxuXHRcdFx0aW5UcmVlW3ZdID0gdHJ1ZTtcclxuXHRcdFx0cCA9IGcuZWRnZXNbdl07XHJcblxyXG5cdFx0XHR3aGlsZShwICE9PSBudWxsKXtcclxuXHRcdFx0XHR3ID0gcC55O1xyXG5cdFx0XHRcdHdlaWdodCA9IHAud2VpZ2h0O1xyXG5cclxuXHRcdFx0XHRpZihkaXN0YW5jZVt3XSA+IGRpc3RhbmNlW3ZdICsgd2VpZ2h0KXtcclxuXHRcdFx0XHRcdGRpc3RhbmNlW3ddID0gZGlzdGFuY2Vbdl0gKyB3ZWlnaHQ7XHJcblx0XHRcdFx0XHRwYXJlbnRbd10gPSB2O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cCA9IHAubmV4dDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0diA9IDA7XHJcblxyXG5cdFx0XHRkaXN0ID0gSW5maW5pdHk7XHJcblxyXG5cdFx0XHRmb3IoaSA9IDA7IGkgPD0gZy5udW1WZXJ0aWNlczsgaSsrKXtcclxuXHRcdFx0XHRpZighaW5UcmVlW2ldICYmIGRpc3QgPiBkaXN0YW5jZVtpXSl7XHJcblx0XHRcdFx0XHRkaXN0ID0gZGlzdGFuY2U7XHJcblx0XHRcdFx0XHR2ID0gaTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFyZW50O1xyXG5cclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKiBBIGNsYXNzIGNvbnRhaW5pbmcgc29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgbWF0aCBvcGVyYXRpb25zICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGhVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgdGhlIHZhbHVlIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gZXh0cmFjdCB0aGUgc2lnbiBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyAtMSBpZiB0aGUgbnVtYmVyIGlzIGxlc3MgdGhhbiAwLCAxIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2lnbih4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMCA/IC0xIDogMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgeCBpcyBiZXR3ZWVuIGEgYW5kIGJcclxuICAgICAqIEBwYXJhbSBhIFRoZSBtaW4gYm91bmRcclxuICAgICAqIEBwYXJhbSBiIFRoZSBtYXggYm91bmRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIGV4Y2x1c2l2ZSBXaGV0aGVyIG9yIG5vdCBhIGFuZCBiIGFyZSBleGNsdXNpdmUgYm91bmRzXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHggaXMgYmV0d2VlbiBhIGFuZCBiLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJldHdlZW4oYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciwgZXhjbHVzaXZlPzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmKGV4Y2x1c2l2ZSl7XHJcbiAgICAgICAgICAgIHJldHVybiAoYSA8IHgpICYmICh4IDwgYik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhIDw9IHgpICYmICh4IDw9IGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgW21pbiwgbWF4XSwgcm91bmRpbmcgdXAgb3IgZG93biBpZiBuZWVkZWRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW4gb2YgdGhlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbWF4IFRoZSBtYXggb2YgdGhlIHJhbmdlXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCBvciBtaW4vbWF4IGlmIGl0IGV4Y2VlZHMgdGhlaXIgYm91bmRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbGFtcCh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgaWYoeCA8IG1pbikgcmV0dXJuIG1pbjtcclxuICAgICAgICBpZih4ID4gbWF4KSByZXR1cm4gbWF4O1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhbXBzIHRoZSB2YWx1ZSB4IHRvIHRoZSByYW5nZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEsIG9yIDAvMSBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2xhbXAwMSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXAoeCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFtcHMgdGhlIGxvd2VyIGVuZCBvZiB0aGUgdmFsdWUgb2YgeCB0byB0aGUgcmFuZ2UgdG8gbWluXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxyXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIG9mIHhcclxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiBtaW4sIG90aGVyd2lzZSBtaW5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsYW1wTG93KHg6IG51bWJlciwgbWluOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgbG93ZXIgZW5kIG9mIHRoZSB2YWx1ZSBvZiB4IHRvIHplcm9cclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMCwgb3RoZXJ3aXNlIDBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsYW1wTG93MCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXBMb3coeCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNsYW1wTWFnbml0dWRlKHY6IFZlYzIsIG06IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIGlmKHYubWFnU3EoKSA+IG0qbSl7XHJcbiAgICAgICAgICAgIHJldHVybiB2LnNjYWxlVG8obSk7XHJcbiAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNoYW5nZVJhbmdlKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBuZXdNaW46IG51bWJlciwgbmV3TWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlcnAobmV3TWluLCBuZXdNYXgsIHRoaXMuaW52TGVycChtaW4sIG1heCwgeCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIExpbmVhciBJbnRlcnBvbGF0aW9uXHJcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXHJcblx0ICogQHBhcmFtIHQgVGhlIHRpbWUgd2UgYXJlIGludGVycG9sYXRpbmcgdG9cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIgYXQgdGltZSB0XHJcblx0ICovXHJcblx0c3RhdGljIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIGEgKyB0ICogKGIgLSBhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludmVyc2UgTGluZWFyIEludGVycG9sYXRpb24uIEZpbmRzIHRoZSB0aW1lIGF0IHdoaWNoIGEgdmFsdWUgYmV0d2VlbiBhIGFuZCBiIHdvdWxkIG9jY3VyXHJcbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXHJcbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdGltZSBhdCB3aGljaCB0aGUgY3VycmVudCB2YWx1ZSBvY2N1cnMgYmV0d2VlbiBhIGFuZCBiXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnZMZXJwKGE6IG51bWJlciwgYjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKXtcclxuICAgICAgICByZXR1cm4gKHZhbHVlIC0gYSkvKGIgLSBhKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXRzIG9mZiBkZWNpbWFsIHBvaW50cyBvZiBhIG51bWJlciBhZnRlciBhIHNwZWNpZmllZCBwbGFjZVxyXG4gICAgICogQHBhcmFtIG51bSBUaGUgbnVtYmVyIHRvIGZsb29yXHJcbiAgICAgKiBAcGFyYW0gcGxhY2UgVGhlIGxhc3QgZGVjaW1hbCBwbGFjZSBvZiB0aGUgbmV3IG51bWJlclxyXG4gICAgICogQHJldHVybnMgVGhlIGZsb29yZWQgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmbG9vclRvUGxhY2UobnVtOiBudW1iZXIsIHBsYWNlOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGlmKHBsYWNlID09PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmYWN0b3IgPSAxMDtcclxuICAgICAgICB3aGlsZShwbGFjZSA+IDEpe1xyXG4gICAgICAgICAgICBmYWN0b3IgIT0gMTA7XHJcbiAgICAgICAgICAgIHBsYWNlLS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW0qZmFjdG9yKS9mYWN0b3I7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG51bWJlciBmcm9tIGEgaGV4IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGhleCBudW1iZXJcclxuICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgaW4gZGVjaW1hbCByZXByZXNlbnRlZCBieSB0aGUgaGV4IHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUhleChzdHI6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIGFzIGEgaGV4YWRlY2ltYWxcclxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGhleFxyXG4gICAgICogQHBhcmFtIG1pbkxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBoZXggc3RyaW5nIChhZGRzIHplcm8gcGFkZGluZyBpZiBuZWVkZWQpXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRvSGV4KG51bTogbnVtYmVyLCBtaW5MZW5ndGg6IG51bWJlciA9IG51bGwpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBmYWN0b3IgPSAxO1xyXG4gICAgICAgIHdoaWxlKGZhY3RvcioxNiA8IG51bSl7XHJcbiAgICAgICAgICAgIGZhY3RvciAqPSAxNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhleFN0ciA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUoZmFjdG9yID49IDEpe1xyXG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBNYXRoLmZsb29yKG51bS9mYWN0b3IpO1xyXG4gICAgICAgICAgICBoZXhTdHIgKz0gTWF0aFV0aWxzLnRvSGV4RGlnaXQoZGlnaXQpO1xyXG4gICAgICAgICAgICBudW0gLT0gZGlnaXQgKiBmYWN0b3I7XHJcbiAgICAgICAgICAgIGZhY3RvciAvPSAxNjtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYobWluTGVuZ3RoICE9PSBudWxsKXtcclxuXHRcdFx0d2hpbGUoaGV4U3RyLmxlbmd0aCA8IG1pbkxlbmd0aCl7XHJcblx0XHRcdFx0aGV4U3RyID0gXCIwXCIgKyBoZXhTdHI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGhleFN0cjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgZGlnaXQgdG8gaGV4YWRlY2ltYWwuIEluIHRoaXMgY2FzZSwgYSBkaWdpdCBpcyBiZXR3ZWVuIDAgYW5kIDE1IGluY2x1c2l2ZVxyXG4gICAgICogQHBhcmFtIG51bSBUaGUgZGlnaXQgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbFxyXG4gICAgICogQHJldHVybnMgVGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGlnaXQgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRvSGV4RGlnaXQobnVtOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmKG51bSA8IDEwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBudW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBudW0gLSAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi9Db2xvclwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuL01hdGhVdGlsc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyaW5nVXRpbHMge1xyXG5cdHN0YXRpYyB0b1dlYkdMQ29vcmRzKHBvaW50OiBWZWMyLCBvcmlnaW46IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShwb2ludC54LCBvcmlnaW4ueCwgb3JpZ2luLnggKyB3b3JsZFNpemUueCwgLTEsIDEpLFxyXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueSwgb3JpZ2luLnksIG9yaWdpbi55ICsgd29ybGRTaXplLnksIDEsIC0xKVxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgdG9XZWJHTFNjYWxlKHNpemU6IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdDIqc2l6ZS54L3dvcmxkU2l6ZS54LFxyXG5cdFx0XHQyKnNpemUueS93b3JsZFNpemUueSxcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIHRvV2ViR0xDb2xvcihjb2xvcjogQ29sb3IpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuciwgMCwgMjU1LCAwLCAxKSxcclxuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLmcsIDAsIDI1NSwgMCwgMSksXHJcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5iLCAwLCAyNTUsIDAsIDEpLFxyXG5cdFx0XHRjb2xvci5hXHJcblx0XHRdKTtcclxuXHR9XHJcbn0iLCIvKiogU29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIHN0cmluZ3MgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nVXRpbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyB0aGUgcGF0aCBmcm9tIGEgZmlsZXBhdGggdGhhdCBpbmNsdWRlcyB0aGUgZmlsZVxyXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHRoZSBmaWxlcGF0aCB0byBleHRyYWN0IHRoZSBwYXRoIGZyb21cclxuICAgICAqIEByZXR1cm5zIFRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIGZpbGVwYXRoIHByb3ZpZGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQYXRoRnJvbUZpbGVQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgc3BsaXRQYXRoLnBvcCgpO1xyXG4gICAgICAgIHNwbGl0UGF0aC5wdXNoKFwiXCIpO1xyXG4gICAgICAgIHJldHVybiBzcGxpdFBhdGguam9pbihcIi9cIik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR2FtZSBmcm9tIFwiLi9Xb2xmaWUyRC9Mb29wL0dhbWVcIjtcclxuaW1wb3J0IFNwbGFzaFNjcmVlbiBmcm9tIFwiLi9TY2VuZXMvU3BsYXNoU2NyZWVuXCI7XHJcblxyXG4vLyBUaGUgbWFpbiBmdW5jdGlvbiBpcyB5b3VyIGVudHJ5cG9pbnQgaW50byBXb2xmaWUyRC4gU3BlY2lmeSB5b3VyIGZpcnN0IHNjZW5lIGFuZCBhbnkgb3B0aW9ucyBoZXJlLlxyXG4oZnVuY3Rpb24gbWFpbigpe1xyXG4gICAgLy8gUnVuIGFueSB0ZXN0c1xyXG4gICAgcnVuVGVzdHMoKTtcclxuXHJcbiAgICAvLyBTZXQgdXAgb3B0aW9ucyBmb3Igb3VyIGdhbWVcclxuICAgIGxldCBvcHRpb25zID0ge1xyXG4gICAgICAgIGNhbnZhc1NpemU6IHt4OiAxMjgwLCB5OiA3MjB9LCAgICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgZ2FtZVxyXG4gICAgICAgIGNsZWFyQ29sb3I6IHtyOiAwLCBnOiAwLCBiOiAwfSwgICAgICAgICAvLyBUaGUgY29sb3IgdGhlIGdhbWUgY2xlYXJzIHRvXHJcbiAgICAgICAgaW5wdXRzOiBbICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHVwIGlucHV0c1xyXG4gICAgICAgICAgICB7bmFtZTogXCJ1cFwiLCBrZXlzOiBbXCJ3XCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwiZG93blwiLCBrZXlzOiBbXCJzXCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwibGVmdFwiLCBrZXlzOiBbXCJhXCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwicmlnaHRcIiwga2V5czogW1wiZFwiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImludGVyYWN0XCIsIGtleXM6IFtcImVcIl19LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJwYXVzZVwiLCBrZXlzOiBbXCJlc2NhcGVcIl19LFxyXG4gICAgICAgIF1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgYSBnYW1lIHdpdGggdGhlIG9wdGlvbnMgc3BlY2lmaWVkXHJcbiAgICBjb25zdCBnYW1lID0gbmV3IEdhbWUob3B0aW9ucyk7XHJcblxyXG4gICAgLy8gU3RhcnQgb3VyIGdhbWVcclxuICAgIGdhbWUuc3RhcnQoU3BsYXNoU2NyZWVuLCB7fSk7XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBydW5UZXN0cygpe307Il19
