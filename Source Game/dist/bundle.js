(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Registry_1 = require("../../Wolfie2D/Registry/Registries/Registry");
const ResourceManager_1 = require("../../Wolfie2D/ResourceManager/ResourceManager");
const Punch_1 = require("../WeaponTypes/Punch");
class WeaponRegistry extends Registry_1.default {
    preload() {
        const rm = ResourceManager_1.default.getInstance();
        rm.image("fist", "game_assets/images/splash_screen.png");
        // load spritesheets
        // TODO PROJECT - import punch spritesheet
        rm.spritesheet("fist", "game_assets/spritesheets/impact.json");
        console.log("loaded sprite");
        this.registerItem("fist", Punch_1.default);
    }
    registerAndPreloadItem(key) { }
    registerItem(key, constr) {
        this.add(key, constr);
    }
}
exports.default = WeaponRegistry;
},{"../../Wolfie2D/Registry/Registries/Registry":61,"../../Wolfie2D/ResourceManager/ResourceManager":80,"../WeaponTypes/Punch":3}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Registry_1 = require("../../Wolfie2D/Registry/Registries/Registry");
class WeaponTypeRegistry extends Registry_1.default {
    preload() { }
    // We don't need this for this assignment
    registerAndPreloadItem(key) { }
    registerItem(key, type) {
        this.add(key, type);
    }
}
exports.default = WeaponTypeRegistry;
},{"../../Wolfie2D/Registry/Registries/Registry":61}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"dup":3}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../Wolfie2D/Scene/Scene");
const Color_1 = require("../Wolfie2D/Utils/Color");
const MainMenu_1 = require("./MainMenu");
class SplashScreen extends Scene_1.default {
    loadScene() {
        this.load.image("splashImage", "game_assets/images/splash_screen.png");
    }
    startScene() {
        const center = this.viewport.getCenter();
        // The splash screen
        this.splash = this.addUILayer("splashScreen");
        // Add a background to the scene
        this.splash_background = this.addParallaxLayer("splash_background", new Vec2_1.default(0.5, 1), -1);
        let sb = this.add.sprite("splashImage", "splash_background");
        sb.position.set(sb.size.x / 2, sb.size.y / 2);
        // Add transparent button
        const confirm = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "splashScreen", { position: new Vec2_1.default(center.x, center.y), text: "" });
        confirm.size.set(1280, 720);
        confirm.borderWidth = 0;
        confirm.borderColor = Color_1.default.TRANSPARENT;
        confirm.backgroundColor = Color_1.default.TRANSPARENT;
        confirm.onClickEventId = "confirm";
        // Subscribe to the button events
        this.receiver.subscribe("confirm");
    }
    updateScene() {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === "confirm") {
                this.splash_background.disable();
                this.sceneManager.changeToScene(MainMenu_1.default, {});
            }
        }
    }
}
exports.default = SplashScreen;
},{"../Wolfie2D/DataTypes/Vec2":23,"../Wolfie2D/Nodes/UIElements/UIElementTypes":54,"../Wolfie2D/Scene/Scene":90,"../Wolfie2D/Utils/Color":95,"./MainMenu":4}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
class AIManager {
    constructor() {
        this.actors = new Array();
        this.registeredAI = new Map_1.default();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    registerActor(actor) {
        this.actors.push(actor);
    }
    removeActor(actor) {
        let index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    }
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    registerAI(name, constr) {
        this.registeredAI.add(name, constr);
    }
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    generateAI(name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw `Cannot create AI with name ${name}, no AI with that name is registered`;
        }
    }
    update(deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(actor => { if (actor.aiActive)
            actor.ai.update(deltaT); });
    }
}
exports.default = AIManager;
},{"../DataTypes/Map":12}],7:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A placeholder function for No Operation. Does nothing
 */
const NullFunc = () => { };
exports.default = NullFunc;
},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A linked-list for the edges in a @reference[Graph].
 */
class EdgeNode {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    constructor(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
}
exports.default = EdgeNode;
},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_V = void 0;
const EdgeNode_1 = require("./EdgeNode");
exports.MAX_V = 100;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
class Graph {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
    */
    addNode() {
        this.numVertices++;
        return this.numVertices;
    }
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
    */
    addEdge(x, y, weight) {
        let edge = new EdgeNode_1.default(y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1.default(x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    }
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    edgeExists(x, y) {
        let edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    }
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    getEdges(x) {
        return this.edges[x];
    }
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    getDegree(x) {
        return this.degree[x];
    }
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    nodeToString(index) {
        return "Node " + index;
    }
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    toString() {
        let retval = "";
        for (let i = 0; i < this.numVertices; i++) {
            let edge = this.edges[i];
            let edgeStr = "";
            while (edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    }
}
exports.default = Graph;
},{"./EdgeNode":8}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = require("./Graph");
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
*/
class PositionGraph extends Graph_1.default {
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        super(directed);
        this.debugRender = () => {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        this.positions = new Array(Graph_1.MAX_V);
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    addPositionedNode(position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    }
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    setNodePosition(index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (let i = 0; i < this.numEdges; i++) {
            let edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    }
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    getNodePosition(index) {
        return this.positions[index];
    }
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    addEdge(x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        let weight = this.positions[x].distanceTo(this.positions[y]);
        super.addEdge(x, y, weight);
    }
    // @override
    nodeToString(index) {
        return "Node " + index + " - " + this.positions[index].toString();
    }
}
exports.default = PositionGraph;
},{"./Graph":9}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;
},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Associates strings with elements of type T
 */
class Map {
    /** Creates a new map */
    constructor() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    add(key, value) {
        this.map[key] = value;
    }
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    get(key) {
        return this.map[key];
    }
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    set(key, value) {
        this.add(key, value);
    }
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    has(key) {
        return this.map[key] !== undefined;
    }
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    keys() {
        return Object.keys(this.map);
    }
    // @implemented
    forEach(func) {
        Object.keys(this.map).forEach(key => func(key));
    }
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    delete(key) {
        delete this.map[key];
    }
    // @implemented
    clear() {
        this.forEach(key => delete this.map[key]);
    }
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    toString() {
        let str = "";
        this.forEach((key) => str += key + " -> " + this.get(key).toString() + "\n");
        return str;
    }
}
exports.default = Map;
},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("./Vec2");
/** A 4x4 matrix0 */
class Mat4x4 {
    constructor() {
        this.mat = new Float32Array([
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ]);
    }
    // Static members
    static get IDENTITY() {
        return new Mat4x4().identity();
    }
    static get ZERO() {
        return new Mat4x4().zero();
    }
    // Accessors
    set _00(x) {
        this.mat[0] = x;
    }
    set(col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
        }
        this.mat[row * 4 + col] = value;
        return this;
    }
    get(col, row) {
        return this.mat[row * 4 + col];
    }
    setAll(...items) {
        this.mat.set(items);
        return this;
    }
    identity() {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    zero() {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    rotate(zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    translate(translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1.default) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    }
    scale(scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1.default) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    mult(other, out) {
        let temp = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let value = 0;
                for (let k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll(...temp);
        }
        else {
            return new Mat4x4().setAll(...temp);
        }
    }
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    static MULT(...mats) {
        // Create a new array
        let temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (let i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    }
    toArray() {
        return this.mat;
    }
    toString() {
        return `|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
            `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
            `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
            `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`;
    }
}
exports.default = Mat4x4;
},{"./Vec2":23}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
class AreaCollision {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    constructor(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
}
exports.default = AreaCollision;
},{}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class Hit {
    constructor() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1.default.ZERO;
        /** The position of the collision */
        this.pos = Vec2_1.default.ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1.default.ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1.default.ZERO;
    }
}
exports.default = Hit;
},{"../Vec2":23}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FIFO queue with elements of type T
 */
class Queue {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    enqueue(item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    }
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    dequeue() {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        let item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    }
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    peekNext() {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        let item = this.q[this.head];
        return item;
    }
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    hasItems() {
        return this.head !== this.tail;
    }
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    getSize() {
        return this.size;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.q[index]);
        this.size = 0;
        this.head = this.tail;
    }
    // @implemented
    forEach(func) {
        let i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    }
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Queue;
},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A container for info about a webGL shader program */
class WebGLProgramType {
    /**
     * Deletes this shader program
     */
    delete(gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    }
}
exports.default = WebGLProgramType;
},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Shape_1 = require("./Shape");
const Vec2_1 = require("../Vec2");
const MathUtils_1 = require("../../Utils/MathUtils");
const Circle_1 = require("./Circle");
const Hit_1 = require("../Physics/Hit");
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class AABB extends Shape_1.default {
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    constructor(center, halfSize) {
        super();
        this.center = center ? center : new Vec2_1.default(0, 0);
        this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
    }
    /** Returns a point representing the top left corner of the AABB */
    get topLeft() {
        return new Vec2_1.default(this.left, this.top);
    }
    /** Returns a point representing the top right corner of the AABB */
    get topRight() {
        return new Vec2_1.default(this.right, this.top);
    }
    /** Returns a point representing the bottom left corner of the AABB */
    get bottomLeft() {
        return new Vec2_1.default(this.left, this.bottom);
    }
    /** Returns a point representing the bottom right corner of the AABB */
    get bottomRight() {
        return new Vec2_1.default(this.right, this.bottom);
    }
    // @override
    getBoundingRect() {
        return this.clone();
    }
    // @override
    getBoundingCircle() {
        let r = Math.max(this.hw, this.hh);
        return new Circle_1.default(this.center.clone(), r);
    }
    // @deprecated
    getHalfSize() {
        return this.halfSize;
    }
    // @deprecated
    setHalfSize(halfSize) {
        this.halfSize = halfSize;
    }
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return point.x >= this.x - this.hw && point.x <= this.x + this.hw
            && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    intersectPoint(point) {
        let dx = point.x - this.x;
        let px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = point.y - this.y;
        let py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPointSoft(point) {
        return point.x > this.x - this.hw && point.x <= this.x + this.hw
            && point.y > this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    intersectSegment(point, delta, padding) {
        let paddingX = padding ? padding.x : 0;
        let paddingY = padding ? padding.y : 0;
        let scaleX = 1 / delta.x;
        let scaleY = 1 / delta.y;
        let signX = MathUtils_1.default.sign(scaleX);
        let signY = MathUtils_1.default.sign(scaleY);
        let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        let tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        let tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        let hit = new Hit_1.default();
        hit.time = MathUtils_1.default.clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    }
    // @override
    overlaps(other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    }
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    overlapsAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    touchesAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    touchesAABBWithoutCorners(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    overlapArea(other) {
        let leftx = Math.max(this.x - this.hw, other.x - other.hw);
        let rightx = Math.min(this.x + this.hw, other.x + other.hw);
        let dx = rightx - leftx;
        let lefty = Math.max(this.y - this.hh, other.y - other.hh);
        let righty = Math.min(this.y + this.hh, other.y + other.hh);
        let dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    }
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    sweep(velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        let centerX = fromPosition.x + velocity.x / 2;
        let centerY = fromPosition.y + velocity.y / 2;
        let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    }
    // @override
    clone() {
        return new AABB(this.center.clone(), this.halfSize.clone());
    }
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    toString() {
        return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
    }
}
exports.default = AABB;
},{"../../Utils/MathUtils":98,"../Physics/Hit":15,"../Vec2":23,"./Circle":19,"./Shape":20}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
const Shape_1 = require("./Shape");
/**
 * A Circle
 */
class Circle extends Shape_1.default {
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    constructor(center, radius) {
        super();
        this._center = center ? center : new Vec2_1.default(0, 0);
        this.radius = radius ? radius : 0;
    }
    get center() {
        return this._center;
    }
    set center(center) {
        this._center = center;
    }
    get halfSize() {
        return new Vec2_1.default(this.radius, this.radius);
    }
    get r() {
        return this.radius;
    }
    set r(radius) {
        this.radius = radius;
    }
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    }
    // @override
    getBoundingRect() {
        return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
    }
    // @override
    getBoundingCircle() {
        return this.clone();
    }
    // @override
    overlaps(other) {
        throw new Error("Method not implemented.");
    }
    // @override
    clone() {
        return new Circle(this._center.clone(), this.radius);
    }
    toString() {
        return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
    }
}
exports.default = Circle;
},{"../Vec2":23,"./AABB":18,"./Shape":20}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
class Shape {
    get x() {
        return this.center.x;
    }
    get y() {
        return this.center.y;
    }
    get hw() {
        return this.halfSize.x;
    }
    get hh() {
        return this.halfSize.y;
    }
    get top() {
        return this.y - this.hh;
    }
    get bottom() {
        return this.y + this.hh;
    }
    get left() {
        return this.x - this.hw;
    }
    get right() {
        return this.x + this.hw;
    }
    static getTimeOfCollision(A, velA, B, velB) {
        if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    }
    static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
        let posSmaller = A.center;
        let posLarger = B.center;
        let sizeSmaller = A.halfSize;
        let sizeLarger = B.halfSize;
        let firstContact = new Vec2_1.default(0, 0);
        let lastContact = new Vec2_1.default(0, 0);
        let collidingX = false;
        let collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            let relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            let relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    }
}
exports.default = Shape;
},{"../Vec2":23,"./AABB":18}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A LIFO stack with items of type T
 */
class Stack {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    push(item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    }
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    pop() {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    }
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    peek() {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    }
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
    */
    isEmpty() {
        return this.head === -1;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.stack[index]);
        this.head = -1;
    }
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    size() {
        return this.head + 1;
    }
    // @implemented
    forEach(func) {
        let i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    }
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Stack;
},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../Vec2");
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
class Tileset {
    // TODO: Change this to be more general and work with other tileset formats
    constructor(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    initFromTiledData(tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
    }
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    getImageKey() {
        return this.imageKey;
    }
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    getImageOffsetForTile(tileIndex) {
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        return new Vec2_1.default(left, top);
    }
    /**
     * Gets the start index
     * @returns The start index
     */
    getStartIndex() {
        return this.startIndex;
    }
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    getNumRows() {
        return this.numRows;
    }
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    getNumCols() {
        return this.numCols;
    }
    getTileCount() {
        return this.endIndex - this.startIndex + 1;
    }
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    hasTile(tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    }
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor((dataIndex % maxCols) * width * scale.x);
        let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    }
}
exports.default = Tileset;
},{"../../ResourceManager/ResourceManager":80,"../Vec2":23}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A two-dimensional vector (x, y)
 */
class Vec2 {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    constructor(x = 0, y = 0) {
        /**
         * When this vector changes its value, do something
         */
        this.onChange = () => { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    // Expose x and y with getters and setters
    get x() {
        return this.vec[0];
    }
    set x(x) {
        this.vec[0] = x;
        if (this.onChange) {
            this.onChange();
        }
    }
    get y() {
        return this.vec[1];
    }
    set y(y) {
        this.vec[1] = y;
        if (this.onChange) {
            this.onChange();
        }
    }
    static get ZERO() {
        return new Vec2(0, 0);
    }
    static get INF() {
        return new Vec2(Infinity, Infinity);
    }
    static get UP() {
        return new Vec2(0, -1);
    }
    static get DOWN() {
        return new Vec2(0, 1);
    }
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    magSq() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    normalize() {
        if (this.x === 0 && this.y === 0)
            return this;
        let mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    }
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    normalized() {
        if (this.isZero()) {
            return this;
        }
        let mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    }
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    zero() {
        return this.set(0, 0);
    }
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    setToAngle(angle, radius = 1) {
        this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    }
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    vecTo(other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    }
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    dirTo(other) {
        return this.vecTo(other).normalize();
    }
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    scaleTo(magnitude) {
        return this.normalize().scale(magnitude);
    }
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    scale(factor, yFactor = null) {
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    scaled(factor, yFactor = null) {
        return this.clone().scale(factor, yFactor);
    }
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    rotateCCW(angle) {
        let cs = Math.cos(angle);
        let sn = Math.sin(angle);
        let tempX = this.x * cs - this.y * sn;
        let tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    }
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    copy(other) {
        return this.set(other.x, other.y);
    }
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    inc(a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    }
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    mult(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    div(other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    remainder(other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    }
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    distanceSqTo(other) {
        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
    }
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    distanceTo(other) {
        return Math.sqrt(this.distanceSqTo(other));
    }
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    angleToCCW(other) {
        let dot = this.dot(other);
        let det = this.x * other.y - this.y * other.x;
        let angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    }
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    toString() {
        return this.toFixed();
    }
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    toFixed(numDecimalPoints = 1) {
        return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
    }
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    strictEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    equals(other) {
        let xEq = Math.abs(this.x - other.x) < 0.0000001;
        let yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    }
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    strictIsZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    isZero() {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    }
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    setOnChange(f) {
        this.onChange = f;
    }
    toArray() {
        return this.vec;
    }
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    static lerp(a, b, t) {
        return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
    }
}
exports.default = Vec2;
Vec2.ZERO_STATIC = new Vec2(0, 0);
},{"../Utils/MathUtils":98}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const Color_1 = require("../Utils/Color");
/**
 * A util class for rendering Debug messages to the canvas.
 */
class Debug {
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    static log(id, ...messages) {
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        let message = messages.map((m) => m.toString()).join(" ");
        this.logMessages.add(id, message);
    }
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    static clearLogItem(id) {
        this.logMessages.delete(id);
    }
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    static setNodes(nodes) {
        this.nodes = nodes;
    }
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    static drawBox(center, halfSize, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    static drawCircle(center, radius, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    static drawRay(from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    }
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    static drawPoint(pos, color) {
        let pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    }
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    static setDefaultTextColor(color) {
        this.defaultTextColor = color;
    }
    /**
     * Performs any necessary setup operations on the Debug canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    static initializeDebugCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1.default(width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    }
    /** Clears the debug canvas */
    static clearCanvas() {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    }
    /** Renders the text and nodes sent to the Debug system */
    static render() {
        this.renderText();
        this.renderNodes();
    }
    /** Renders the text sent to the Debug canvas */
    static renderText() {
        let y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach((key) => {
            this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
            y += 30;
        });
    }
    /** Renders the nodes registered with the debug canvas */
    static renderNodes() {
        if (this.nodes) {
            this.nodes.forEach(node => {
                node.debugRender();
            });
        }
    }
}
exports.default = Debug;
/** A map of log messages to display on the screen */
Debug.logMessages = new Map_1.default();
/** The rendering color for text */
Debug.defaultTextColor = Color_1.default.WHITE;
},{"../DataTypes/Map":12,"../DataTypes/Vec2":23,"../Utils/Color":95}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../Utils/Color");
// @ignorePage
class Stats extends Object {
    static initStats() {
        let canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        let clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        let fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        let updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        let queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        let br1 = document.createElement("br");
        let br2 = document.createElement("br");
        let br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = document.getElementById("chart-option");
        let option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        let option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        let option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        let option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        let option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        let optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    }
    static updateFPS(fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    }
    static log(key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    }
    static render() {
        // Display stats
        this.drawCharts();
    }
    static drawCharts() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        let paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            let param = this.prevfps;
            let color = Color_1.default.BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            let param = this.prevClearTimes;
            let color = Color_1.default.RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            let param = this.prevFillTimes;
            let color = Color_1.default.GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            let param = this.prevUpdateTimes;
            let color = Color_1.default.CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            let param = this.prevQueryTimes;
            let color = Color_1.default.ORANGE.toString();
            this.drawChart(param, color);
        }
    }
    static drawChart(param, color) {
        this.ctx.strokeStyle = Color_1.default.BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        let max = Math.max(...param);
        let prevX = 10;
        let prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (let i = 1; i < param.length; i++) {
            let fps = param[i];
            let x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
            let y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    }
    static updateSGStats() {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime = this.SGClearTimes.reduce((acc, val) => acc + val) / this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime = this.SGFillTimes.reduce((acc, val) => acc + val) / this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime = this.SGUpdateTimes.reduce((acc, val) => acc + val) / this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime = this.SGQueryTimes.reduce((acc, val) => acc + val) / this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
    }
}
exports.default = Stats;
Stats.NUM_POINTS = 60;
Stats.CANVAS_WIDTH = 300;
Stats.CANVAS_HEIGHT = 300;
},{"../Utils/Color":95}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("./EventQueue");
const GameEvent_1 = require("./GameEvent");
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
class Emitter {
    /** Creates a new Emitter */
    constructor() {
        this.eventQueue = EventQueue_1.default.getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    fireEvent(eventType, data = null) {
        this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
    }
}
exports.default = Emitter;
},{"./EventQueue":27,"./GameEvent":28}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Map_1 = require("../DataTypes/Map");
const GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
class EventQueue {
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
        this.receivers = new Map_1.default();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    static getInstance() {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    }
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    addEvent(event) {
        this.q.enqueue(event);
    }
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    subscribe(receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (let t of type) {
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    }
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    unsubscribe(receiver, ...events) {
        this.receivers.forEach(eventName => {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            let index = this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                this.receivers.get(eventName).splice(index, 1);
            }
        });
    }
    // Associate the receiver and the type
    addListener(receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    }
    update(deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            let event = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event.type)) {
                for (let receiver of this.receivers.get(event.type)) {
                    receiver.receive(event);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                    receiver.receive(event);
                }
            }
        }
    }
}
exports.default = EventQueue;
EventQueue.instance = null;
},{"../DataTypes/Map":12,"../DataTypes/Queue":16,"./GameEventType":29}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
class GameEvent {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    constructor(type, data = null) {
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1.default();
        }
        else if (!(data instanceof Map_1.default)) {
            // data is a raw object, unpack
            this.data = new Map_1.default();
            for (let key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    isType(type) {
        return this.type === type;
    }
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    toString() {
        return this.type + ": @" + this.time;
    }
}
exports.default = GameEvent;
},{"../DataTypes/Map":12}],29:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));
},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const EventQueue_1 = require("./EventQueue");
/**
 * Receives subscribed events from the EventQueue.
 */
class Receiver {
    /** Creates a new Receiver */
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
    }
    destroy() {
        EventQueue_1.default.getInstance().unsubscribe(this);
    }
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    subscribe(eventTypes) {
        EventQueue_1.default.getInstance().subscribe(this, eventTypes);
        this.q.clear();
    }
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    receive(event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    }
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    getNextEvent() {
        return this.q.dequeue();
    }
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    peekNextEvent() {
        return this.q.peekNext();
    }
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    hasNextEvent() {
        return this.q.hasItems();
    }
    /**
     * Ignore all events this frame
     */
    ignoreEvents() {
        this.q.clear();
    }
}
exports.default = Receiver;
},{"../DataTypes/Queue":16,"./EventQueue":27}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
class Input {
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     */
    static initialize(viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1.default();
        Input.keyJustPressed = new Map_1.default();
        Input.keyPressed = new Map_1.default();
        Input.mousePosition = new Vec2_1.default(0, 0);
        Input.mousePressPosition = new Vec2_1.default(0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1.default();
        // Add all keys to the keymap
        for (let entry in keyMap) {
            let name = keyMap[entry].name;
            let keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
        Input.eventQueue = EventQueue_1.default.getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
    }
    static update(deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            let event = Input.receiver.getNextEvent();
            // Handle each event type
            if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    }
    static clearKeyPresses() {
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
    }
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    static isKeyJustPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    static getKeysJustPressed() {
        if (Input.keysDisabled)
            return [];
        let keys = Array();
        Input.keyJustPressed.forEach(key => {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    static isKeyPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    static changeKeyBinding(inputName, keys) {
        Input.keyMap.set(inputName, keys);
    }
    /**
     * Clears all key bindings
     */
    static clearAllKeyBindings() {
        Input.keyMap.clear();
    }
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    static isJustPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let justPressed = false;
            for (let key of keys) {
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    static isPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let pressed = false;
            for (let key of keys) {
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not the mouse was newly pressed Input frame
     * @returns True if the mouse was just pressed, false otherwise
     */
    static isMouseJustPressed() {
        return Input.mouseJustPressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether or not the mouse is currently pressed
     * @returns True if the mouse is currently pressed, false otherwise
     */
    static isMousePressed() {
        return Input.mousePressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    static didJustScroll() {
        return Input.justScrolled && !Input.mouseDisabled;
    }
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    static getScrollDirection() {
        return Input.scrollDirection;
    }
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    static getMousePosition() {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    }
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePosition() {
        return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
    }
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    static getMousePressPosition() {
        return Input.mousePressPosition;
    }
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePressPosition() {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    }
    /**
     * Disables all keypress and mouse click inputs
     */
    static disableInput() {
        Input.keysDisabled = true;
        Input.mouseDisabled = true;
    }
    /**
     * Enables all keypress and mouse click inputs
     */
    static enableInput() {
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
    }
}
exports.default = Input;
},{"../DataTypes/Map":12,"../DataTypes/Vec2":23,"../Events/EventQueue":27,"../Events/GameEventType":29,"../Events/Receiver":30}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Vec2_1 = require("../DataTypes/Vec2");
const GameEvent_1 = require("../Events/GameEvent");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
class InputHandler {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    constructor(canvas) {
        this.handleMouseDown = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = (event) => {
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = (event) => {
            event.preventDefault();
            event.stopPropagation();
            let gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1.default.getInstance();
        canvas.onmousedown = (event) => this.handleMouseDown(event, canvas);
        canvas.onmouseup = (event) => this.handleMouseUp(event, canvas);
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = (event) => this.handleMouseMove(event, canvas);
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
    }
    getKey(keyEvent) {
        return keyEvent.key.toLowerCase();
    }
    getMousePosition(mouseEvent, canvas) {
        let rect = canvas.getBoundingClientRect();
        let x = mouseEvent.clientX - rect.left;
        let y = mouseEvent.clientY - rect.top;
        return new Vec2_1.default(x, y);
    }
}
exports.default = InputHandler;
},{"../DataTypes/Vec2":23,"../Events/EventQueue":27,"../Events/GameEvent":28,"../Events/GameEventType":29}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
class EnvironmentInitializer {
    static setup() {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    }
}
exports.default = EnvironmentInitializer;
},{}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLoop_1 = require("./GameLoop");
const Debug_1 = require("../Debug/Debug");
const Stats_1 = require("../Debug/Stats");
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
class FixedUpdateGameLoop extends GameLoop_1.default {
    constructor() {
        super();
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        this.doFrame = (timestamp) => {
            // If a pause was executed, stop doing the loop.
            if (this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame((t) => this.doFrame(t));
            // If we are trying to render too soon, do nothing.
            if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            this.numUpdateSteps = 0;
            let panic = false;
            while (this.frameDelta >= this.updateTimestep) {
                // Do an update
                this._doUpdate(this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                this.frameDelta -= this.updateTimestep;
                // Increment steps and check if we've done too many
                this.numUpdateSteps++;
                if (this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            this._doRender();
            // Wrap up the frame
            this.finishFrame(panic);
        };
        this.maxUpdateFPS = 60;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        this.frameDelta = 0;
        this.lastFrameTime = 0;
        this.minFrameDelay = 0;
        this.frame = 0;
        this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = 0;
        this.framesSinceLastFpsUpdate = 0;
        this.started = false;
        this.paused = false;
        this.running = false;
        this.numUpdateSteps = 0;
    }
    getFPS() {
        return 0;
    }
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    updateFPS(timestamp) {
        this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1.default.updateFPS(this.fps);
    }
    /**
 * Changes the maximum allowed physics framerate of the game
 * @param initMax The max framerate
 */
    setMaxUpdateFPS(initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    }
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    setMaxFPS(maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    }
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    resetFrameDelta() {
        let oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    }
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    start() {
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame((timestamp) => this.doFirstFrame(timestamp));
        }
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    doFirstFrame(timestamp) {
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame((t) => this.doFrame(t));
    }
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    startFrame(timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    }
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    finishFrame(panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
}
exports.default = FixedUpdateGameLoop;
},{"../Debug/Debug":24,"../Debug/Stats":25,"./GameLoop":36}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Input_1 = require("../Input/Input");
const InputHandler_1 = require("../Input/InputHandler");
const Recorder_1 = require("../Playback/Recorder");
const Debug_1 = require("../Debug/Debug");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Viewport_1 = require("../SceneGraph/Viewport");
const SceneManager_1 = require("../Scene/SceneManager");
const AudioManager_1 = require("../Sound/AudioManager");
const Stats_1 = require("../Debug/Stats");
const CanvasRenderer_1 = require("../Rendering/CanvasRenderer");
const Color_1 = require("../Utils/Color");
const GameOptions_1 = require("./GameOptions");
const FixedUpdateGameLoop_1 = require("./FixedUpdateGameLoop");
const EnvironmentInitializer_1 = require("./EnvironmentInitializer");
const Vec2_1 = require("../DataTypes/Vec2");
const RegistryManager_1 = require("../Registry/RegistryManager");
const WebGLRenderer_1 = require("../Rendering/WebGLRenderer");
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
class Game {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    constructor(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1.default.setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1.default.parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1.default();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = document.getElementById("game-canvas");
        this.DEBUG_CANVAS = document.getElementById("debug-canvas");
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1.default();
        }
        else {
            this.renderingManager = new CanvasRenderer_1.default();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1.default.initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1.default.getInstance();
        this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
        Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
        this.recorder = new Recorder_1.default();
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1.default.getInstance();
    }
    /**
     * Set up the game window that holds the canvases
     */
    initializeGameWindow() {
        const gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    }
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    getSceneManager() {
        return this.sceneManager;
    }
    /**
     * Starts the game
     */
    start(InitialScene, options) {
        // Set the update function of the loop
        this.loop.doUpdate = (deltaT) => this.update(deltaT);
        // Set the render function of the loop
        this.loop.doRender = () => this.render();
        // Preload registry items
        RegistryManager_1.default.preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(() => {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            this.sceneManager.changeToScene(InitialScene, options);
            this.loop.start();
        });
    }
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    update(deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1.default.update(deltaT);
            // Update the recording of the game
            this.recorder.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    }
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    render() {
        try {
            // Clear the canvases
            Debug_1.default.clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1.default.isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug render
            if (this.showDebug) {
                Debug_1.default.render();
            }
            if (this.showStats) {
                Stats_1.default.render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    }
}
exports.default = Game;
},{"../DataTypes/Vec2":23,"../Debug/Debug":24,"../Debug/Stats":25,"../Events/EventQueue":27,"../Input/Input":31,"../Input/InputHandler":32,"../Playback/Recorder":60,"../Registry/RegistryManager":63,"../Rendering/CanvasRenderer":68,"../Rendering/WebGLRenderer":73,"../ResourceManager/ResourceManager":80,"../Scene/SceneManager":91,"../SceneGraph/Viewport":83,"../Sound/AudioManager":93,"../Utils/Color":95,"./EnvironmentInitializer":33,"./FixedUpdateGameLoop":34,"./GameOptions":37}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NullFunc_1 = require("../DataTypes/Functions/NullFunc");
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
class GameLoop {
    constructor() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1.default;
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1.default;
    }
    set doUpdate(update) {
        this._doUpdate = update;
    }
    set doRender(render) {
        this._doRender = render;
    }
}
exports.default = GameLoop;
},{"../DataTypes/Functions/NullFunc":7}],37:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/** The options for initializing the @reference[GameLoop] */
class GameOptions {
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    static parse(options) {
        let gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    }
}
exports.default = GameOptions;
},{}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameNode_1 = require("./GameNode");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
class CanvasNode extends GameNode_1.default {
    constructor() {
        super();
        /** A flag for whether or not the CanvasNode is visible */
        this.visible = true;
        this._size = new Vec2_1.default(0, 0);
        this._size.setOnChange(() => this.sizeChanged());
        this._scale = new Vec2_1.default(1, 1);
        this._scale.setOnChange(() => this.scaleChanged());
        this._boundary = new AABB_1.default();
        this.updateBoundary();
        this._hasCustomShader = false;
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(a) {
        this._alpha = a;
    }
    get size() {
        return this._size;
    }
    set size(size) {
        this._size = size;
        // Enter as a lambda to bind "this"
        this._size.setOnChange(() => this.sizeChanged());
        this.sizeChanged();
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this._scale = scale;
        // Enter as a lambda to bind "this"
        this._scale.setOnChange(() => this.scaleChanged());
        this.scaleChanged();
    }
    set scaleX(value) {
        this.scale.x = value;
    }
    set scaleY(value) {
        this.scale.y = value;
    }
    get hasCustomShader() {
        return this._hasCustomShader;
    }
    get customShaderKey() {
        return this._customShaderKey;
    }
    // @override
    positionChanged() {
        super.positionChanged();
        this.updateBoundary();
    }
    /** Called if the size vector is changed or replaced. */
    sizeChanged() {
        this.updateBoundary();
    }
    /** Called if the scale vector is changed or replaced */
    scaleChanged() {
        this.updateBoundary();
    }
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    updateBoundary() {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
    }
    get boundary() {
        return this._boundary;
    }
    get sizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.boundary.halfSize.clone().scaled(zoom, zoom);
    }
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    useCustomShader(key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    }
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    contains(x, y) {
        return this._boundary.containsPoint(new Vec2_1.default(x, y));
    }
    // @implemented
    debugRender() {
        Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
        super.debugRender();
    }
}
exports.default = CanvasNode;
},{"../DataTypes/Shapes/AABB":18,"../DataTypes/Vec2":23,"../Debug/Debug":24,"../Utils/Color":95,"./GameNode":39}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenableProperties = void 0;
const Vec2_1 = require("../DataTypes/Vec2");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Region_1 = require("../DataTypes/Interfaces/Region");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const TweenController_1 = require("../Rendering/Animations/TweenController");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
const Circle_1 = require("../DataTypes/Shapes/Circle");
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
class GameNode {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    constructor() {
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1.default(0, 0);
        this._position.setOnChange(() => this.positionChanged());
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tweens = new TweenController_1.default(this);
        this.rotation = 0;
    }
    destroy() {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    }
    /*---------- POSITIONED ----------*/
    get position() {
        return this._position;
    }
    set position(pos) {
        this._position = pos;
        this._position.setOnChange(() => this.positionChanged());
        this.positionChanged();
    }
    get relativePosition() {
        return this.inRelativeCoordinates(this.position);
    }
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    inRelativeCoordinates(point) {
        let origin = this.scene.getViewTranslation(this);
        let zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    }
    /*---------- UNIQUE ----------*/
    get id() {
        return this._id;
    }
    set id(id) {
        // id can only be set once
        if (this._id === undefined) {
            this._id = id;
        }
        else {
            throw "Attempted to assign id to object that already has id.";
        }
    }
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    move(velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    }
    ;
    moveOnPath(speed, path) {
        if (this.frozen)
            return;
        this.path = path;
        let dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    }
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    finishMove() {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    }
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = new AABB_1.default();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if (Region_1.isRegion(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1.default.ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    }
    /** Removes this object from the physics system */
    removePhysics() {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1.default.ZERO;
        this.sweptRect = null;
    }
    /** Disables physics movement for this node */
    freeze() {
        this.frozen = true;
    }
    /** Reenables physics movement for this node */
    unfreeze() {
        this.frozen = false;
    }
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    disablePhysics() {
        this.active = false;
    }
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    enablePhysics() {
        this.active = true;
    }
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    setCollisionShape(collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    }
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    setTrigger(group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        let index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    }
    ;
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    setGroup(group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    }
    // @implemened
    getLastVelocity() {
        return this._velocity;
    }
    /*---------- ACTOR ----------*/
    get ai() {
        return this._ai;
    }
    set ai(ai) {
        if (!this._ai) {
            // If we haven't been previously had an ai, register us with the ai manager
            this.scene.getAIManager().registerActor(this);
        }
        this._ai = ai;
        this.aiActive = true;
    }
    // @implemented
    addAI(ai, options) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    }
    // @implemented
    setAIActive(active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    }
    /*---------- TWEENABLE PROPERTIES ----------*/
    set positionX(value) {
        this.position.x = value;
    }
    set positionY(value) {
        this.position.y = value;
    }
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
    */
    getScene() {
        return this.scene;
    }
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    setLayer(layer) {
        this.layer = layer;
    }
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
    */
    getLayer() {
        return this.layer;
    }
    /** Called if the position vector is modified or replaced */
    positionChanged() {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position.clone().add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    }
    ;
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    update(deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    }
    // @implemented
    debugRender() {
        // Draw the position of this GameNode
        Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
            if (this.isTrigger) {
                color = Color_1.default.MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1.default) {
                Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1.default) {
                Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    }
}
exports.default = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));
},{"../DataTypes/Interfaces/Region":11,"../DataTypes/Shapes/AABB":18,"../DataTypes/Shapes/Circle":19,"../DataTypes/Vec2":23,"../Debug/Debug":24,"../Events/Emitter":26,"../Events/Receiver":30,"../Rendering/Animations/TweenController":66,"../Utils/Color":95}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
class Graphic extends CanvasNode_1.default {
    constructor() {
        super();
        this.color = Color_1.default.RED;
    }
    get alpha() {
        return this.color.a;
    }
    set alpha(a) {
        this.color.a = a;
    }
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    setColor(color) {
        this.color = color;
    }
}
exports.default = Graphic;
},{"../Utils/Color":95,"./CanvasNode":38}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));
},{}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
class Line extends Graphic_1.default {
    constructor(start, end) {
        super();
        this.start = start;
        this.end = end;
        this.thickness = 2;
        // Does this really have a meaning for lines?
        this.size.set(5, 5);
    }
    set start(pos) {
        this.position = pos;
    }
    get start() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
}
exports.default = Line;
},{"../Graphic":40}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
/** A basic point to be drawn on the screen. */
class Point extends Graphic_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.size.set(5, 5);
    }
}
exports.default = Point;
},{"../Graphic":40}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
const Color_1 = require("../../Utils/Color");
/** A basic rectangle to be drawn on the screen. */
class Rect extends Graphic_1.default {
    constructor(position, size) {
        super();
        this.position = position;
        this.size = size;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = Rect;
},{"../../Utils/Color":95,"../Graphic":40}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("./Sprite");
const AnimationManager_1 = require("../../Rendering/Animations/AnimationManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/** An sprite with specified animation frames. */
class AnimatedSprite extends Sprite_1.default {
    constructor(spritesheet) {
        super(spritesheet.name);
        this.numCols = spritesheet.columns;
        this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        this.animation = new AnimationManager_1.default(this);
        // Add the animations to the animated sprite
        for (let animation of spritesheet.animations) {
            this.animation.add(animation.name, animation);
        }
    }
    get cols() {
        return this.numCols;
    }
    get rows() {
        return this.numRows;
    }
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    getAnimationOffset(index) {
        return new Vec2_1.default((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
    }
}
exports.default = AnimatedSprite;
},{"../../DataTypes/Vec2":23,"../../Rendering/Animations/AnimationManager":64,"./Sprite":46}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("../CanvasNode");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * The representation of a sprite - an in-game image
 */
class Sprite extends CanvasNode_1.default {
    constructor(imageId) {
        super();
        this.imageId = imageId;
        let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
        this.size = new Vec2_1.default(image.width, image.height);
        this.imageOffset = Vec2_1.default.ZERO;
        this.invertX = false;
        this.invertY = false;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    setImageOffset(offset) {
        this.imageOffset = offset;
    }
}
exports.default = Sprite;
},{"../../DataTypes/Vec2":23,"../../ResourceManager/ResourceManager":80,"../CanvasNode":38}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const CanvasNode_1 = require("./CanvasNode");
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
class Tilemap extends CanvasNode_1.default {
    // TODO: Make this no longer be specific to Tiled
    constructor(tilemapData, layer, tilesets, scale) {
        super();
        this.tilesets = tilesets;
        this.tileSize = new Vec2_1.default(0, 0);
        this.name = layer.name;
        let tilecount = 0;
        for (let tileset of tilesets) {
            tilecount += tileset.getTileCount() + 1;
        }
        this.collisionMap = new Array(tilecount);
        for (let i = 0; i < this.collisionMap.length; i++) {
            this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        this.parseTilemapData(tilemapData, layer);
        this.scale.set(scale.x, scale.y);
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    getTilesets() {
        return this.tilesets;
    }
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    getTileSize() {
        return this.tileSize.scaled(this.scale.x, this.scale.y);
    }
    /**
     * Gets the tile size taking zoom into account
     * @returns The tile size with zoom
    */
    getTileSizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.getTileSize().scale(zoom);
    }
    /**
     * Adds this tilemap to the physics system
    */
    addPhysics() {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    }
}
exports.default = Tilemap;
},{"../DataTypes/Vec2":23,"./CanvasNode":38}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Tilemap_1 = require("../Tilemap");
const Vec2_1 = require("../../DataTypes/Vec2");
const Debug_1 = require("../../Debug/Debug");
const Color_1 = require("../../Utils/Color");
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
class OrthogonalTilemap extends Tilemap_1.default {
    // @override
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    getDimensions() {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    /**
     * Gets the data value of the tile at the specified world position
     * @param worldCoords The coordinates in world space
     * @returns The data value of the tile
     */
    getTileAtWorldPosition(worldCoords) {
        let localCoords = this.getColRowAt(worldCoords);
        return this.getTileAtRowCol(localCoords);
    }
    /**
     * Get the tile at the specified row and column
     * @param rowCol The coordinates in tilemap space
     * @returns The data value of the tile
     */
    getTileAtRowCol(rowCol) {
        if (rowCol.x < 0 || rowCol.x >= this.numCols || rowCol.y < 0 || rowCol.y >= this.numRows) {
            return -1;
        }
        return this.data[rowCol.y * this.numCols + rowCol.x];
    }
    /**
     * Gets the world position of the tile at the specified index
     * @param index The index of the tile
     * @returns A Vec2 containing the world position of the tile
     */
    getTileWorldPosition(index) {
        // Get the local position
        let col = index % this.numCols;
        let row = Math.floor(index / this.numCols);
        // Get the world position
        let x = col * this.tileSize.x;
        let y = row * this.tileSize.y;
        return new Vec2_1.default(x, y);
    }
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    getTile(index) {
        return this.data[index];
    }
    // @override
    setTile(index, type) {
        this.data[index] = type;
    }
    /**
     * Sets the tile at the specified row and column
     * @param rowCol The position of the tile in tilemap space
     * @param type The new data value of the tile
     */
    setTileAtRowCol(rowCol, type) {
        let index = rowCol.y * this.numCols + rowCol.x;
        this.setTile(index, type);
    }
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param indexOrCol The index of the tile or the column it is in
     * @param row The row the tile is in
     * @returns A flag representing whether or not the tile is collidable.
     */
    isTileCollidable(indexOrCol, row) {
        // The value of the tile
        let tile = 0;
        if (row) {
            // We have a column and a row
            tile = this.getTileAtRowCol(new Vec2_1.default(indexOrCol, row));
            if (tile < 0) {
                return false;
            }
        }
        else {
            if (indexOrCol < 0 || indexOrCol >= this.data.length) {
                // Tiles that don't exist aren't collidable
                return false;
            }
            // We have an index
            tile = this.getTile(indexOrCol);
        }
        return this.collisionMap[tile];
    }
    /**
     * Takes in world coordinates and returns the row and column of the tile at that position
     * @param worldCoords The coordinates of the potential tile in world space
     * @returns A Vec2 containing the coordinates of the potential tile in tilemap space
     */
    getColRowAt(worldCoords) {
        let col = Math.floor(worldCoords.x / this.tileSize.x / this.scale.x);
        let row = Math.floor(worldCoords.y / this.tileSize.y / this.scale.y);
        return new Vec2_1.default(col, row);
    }
    // @override
    update(deltaT) { }
    // @override
    debugRender() {
        // Half of the tile size
        let zoomedHalfTileSize = this.getTileSizeWithZoom().scaled(0.5);
        let halfTileSize = this.getTileSize().scaled(0.5);
        // The center of the top left tile
        let topLeft = this.position.clone().sub(this.size.scaled(0.5));
        // A vec to store the center
        let center = Vec2_1.default.ZERO;
        for (let col = 0; col < this.numCols; col++) {
            // Calculate the x-position
            center.x = topLeft.x + col * 2 * halfTileSize.x + halfTileSize.x;
            for (let row = 0; row < this.numRows; row++) {
                if (this.isCollidable && this.isTileCollidable(col, row)) {
                    // Calculate the y-position
                    center.y = topLeft.y + row * 2 * halfTileSize.y + halfTileSize.y;
                    // Draw a box for this tile
                    Debug_1.default.drawBox(this.inRelativeCoordinates(center), zoomedHalfTileSize, false, Color_1.default.BLUE);
                }
            }
        }
    }
}
exports.default = OrthogonalTilemap;
},{"../../DataTypes/Vec2":23,"../../Debug/Debug":24,"../../Utils/Color":95,"../Tilemap":47}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
const Vec2_1 = require("../DataTypes/Vec2");
const Input_1 = require("../Input/Input");
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
class UIElement extends CanvasNode_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.backgroundColor = new Color_1.default(0, 0, 0, 0);
        this.borderColor = new Color_1.default(0, 0, 0, 0);
        this.borderRadius = 5;
        this.borderWidth = 1;
        this.padding = Vec2_1.default.ZERO;
        this.onClick = null;
        this.onClickEventId = null;
        this.onRelease = null;
        this.onReleaseEventId = null;
        this.onEnter = null;
        this.onEnterEventId = null;
        this.onLeave = null;
        this.onLeaveEventId = null;
        this.isClicked = false;
        this.isEntered = false;
    }
    // @deprecated
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    // @deprecated
    setPadding(padding) {
        this.padding.copy(padding);
    }
    update(deltaT) {
        super.update(deltaT);
        // See of this object was just clicked
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1.default.isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        let mousePos = Input_1.default.getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    }
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    calculateBackgroundColor() {
        return this.backgroundColor;
    }
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    calculateBorderColor() {
        return this.borderColor;
    }
}
exports.default = UIElement;
},{"../DataTypes/Vec2":23,"../Input/Input":31,"../Utils/Color":95,"./CanvasNode":38}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Label_1 = require("./Label");
const Color_1 = require("../../Utils/Color");
/** A clickable button UIElement */
class Button extends Label_1.default {
    constructor(position, text) {
        super(position, text);
        this.backgroundColor = new Color_1.default(150, 75, 203);
        this.borderColor = new Color_1.default(41, 46, 30);
        this.textColor = new Color_1.default(255, 255, 255);
    }
    // @override
    calculateBackgroundColor() {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    }
}
exports.default = Button;
},{"../../Utils/Color":95,"./Label":51}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAlign = exports.VAlign = void 0;
const Vec2_1 = require("../../DataTypes/Vec2");
const Color_1 = require("../../Utils/Color");
const UIElement_1 = require("../UIElement");
/** A basic text-containing label */
class Label extends UIElement_1.default {
    constructor(position, text) {
        super(position);
        this.text = text;
        this.textColor = new Color_1.default(0, 0, 0, 1);
        this.font = "Arial";
        this.fontSize = 30;
        this.hAlign = "center";
        this.vAlign = "center";
        this.sizeAssigned = false;
    }
    // @deprecated
    setText(text) {
        this.text = text;
    }
    // @deprecated
    setTextColor(color) {
        this.textColor = color;
    }
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    getFontString() {
        return this.fontSize + "px " + this.font;
    }
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    calculateTextColor() {
        return this.textColor.toStringRGBA();
    }
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    calculateTextWidth(ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    }
    setHAlign(align) {
        this.hAlign = align;
    }
    setVAlign(align) {
        this.vAlign = align;
    }
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    calculateTextOffset(ctx) {
        let textWidth = this.calculateTextWidth(ctx);
        let offset = new Vec2_1.default(0, 0);
        let hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    }
    sizeChanged() {
        super.sizeChanged();
        this.sizeAssigned = true;
    }
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    autoSize(ctx) {
        let width = this.calculateTextWidth(ctx);
        let height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    }
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    handleInitialSizing(ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    }
    /** On the next render, size this element to it's current text using its current font size */
    sizeToText() {
        this.sizeAssigned = false;
    }
}
exports.default = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));
},{"../../DataTypes/Vec2":23,"../../Utils/Color":95,"../UIElement":49}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const Input_1 = require("../../Input/Input");
const Color_1 = require("../../Utils/Color");
const MathUtils_1 = require("../../Utils/MathUtils");
const UIElement_1 = require("../UIElement");
/** A slider UIElement */
class Slider extends UIElement_1.default {
    constructor(position, initValue) {
        super(position);
        this.value = initValue;
        this.nibColor = Color_1.default.RED;
        this.sliderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.TRANSPARENT;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.nibSize = new Vec2_1.default(10, 20);
        // Set a default size
        this.size.set(200, 20);
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    getValue() {
        return this.value;
    }
    /** A method called in response to the value changing */
    valueChanged() {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.isClicked) {
            let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
            this.value = MathUtils_1.default.clamp01(val);
            this.valueChanged();
        }
    }
}
exports.default = Slider;
},{"../../DataTypes/Vec2":23,"../../Input/Input":31,"../../Utils/Color":95,"../../Utils/MathUtils":98,"../UIElement":49}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../../Utils/Color");
const Label_1 = require("./Label");
const Input_1 = require("../../Input/Input");
/** A text input UIElement */
class TextInput extends Label_1.default {
    constructor(position) {
        super(position, "");
        this.focused = false;
        this.cursorCounter = 0;
        // Give a default size to the x only
        this.size.set(200, this.fontSize);
        this.hAlign = "left";
        this.borderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.WHITE;
    }
    update(deltaT) {
        super.update(deltaT);
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            let keys = Input_1.default.getKeysJustPressed();
            let nums = "1234567890";
            let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            let letters = "qwertyuiopasdfghjklzxcvbnm";
            let mask = nums + specialChars + letters;
            keys = keys.filter(key => mask.includes(key));
            let shiftPressed = Input_1.default.isKeyPressed("shift");
            let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
            let spacePressed = Input_1.default.isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    }
}
exports.default = TextInput;
},{"../../Input/Input":31,"../../Utils/Color":95,"./Label":51}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));
},{}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
class NavigationManager {
    constructor() {
        this.navigableEntities = new Map_1.default();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    addNavigableEntity(navName, nav) {
        this.navigableEntities.add(navName, nav);
    }
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    getPath(navName, fromPosition, toPosition) {
        let nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone());
    }
}
exports.default = NavigationManager;
},{"../DataTypes/Map":12}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
class NavigationPath {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    constructor(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1.default.ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    isDone() {
        return this.path.isEmpty();
    }
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    getMoveDirection(node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    }
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    handlePathProgress(node) {
        if (node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    }
    toString() {
        return this.path.toString();
    }
}
exports.default = NavigationPath;
},{"../DataTypes/Vec2":23}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../DataTypes/Stack");
const GraphUtils_1 = require("../Utils/GraphUtils");
const NavigationPath_1 = require("./NavigationPath");
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
class Navmesh {
    /**
     * Creates a new Navmesh from the points in the speecified graph
     * @param graph The graph to construct a navmesh from
     */
    constructor(graph) {
        this.graph = graph;
    }
    // @implemented
    getNavigationPath(fromPosition, toPosition) {
        let start = this.getClosestNode(fromPosition);
        let end = this.getClosestNode(toPosition);
        let parent = GraphUtils_1.default.djikstra(this.graph, start);
        let pathStack = new Stack_1.default(this.graph.numVertices);
        // Push the final position and the final position in the graph
        pathStack.push(toPosition.clone());
        pathStack.push(this.graph.positions[end]);
        // Add all parents along the path
        let i = end;
        while (parent[i] !== -1) {
            pathStack.push(this.graph.positions[parent[i]]);
            i = parent[i];
        }
        return new NavigationPath_1.default(pathStack);
    }
    /**
     * Gets the closest node in this Navmesh to the specified position
     * @param position The position to query
     * @returns The index of the closest node in the Navmesh to the position
     */
    getClosestNode(position) {
        let n = this.graph.numVertices;
        let i = 1;
        let index = 0;
        let dist = position.distanceSqTo(this.graph.positions[0]);
        while (i < n) {
            let d = position.distanceSqTo(this.graph.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    }
}
exports.default = Navmesh;
},{"../DataTypes/Stack":21,"../Utils/GraphUtils":97,"./NavigationPath":56}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PhysicsManager_1 = require("./PhysicsManager");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const AreaCollision_1 = require("../DataTypes/Physics/AreaCollision");
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
class BasicPhysicsManager extends PhysicsManager_1.default {
    constructor(options) {
        super();
        this.staticNodes = new Array();
        this.dynamicNodes = new Array();
        this.tilemaps = new Array();
        this.collisionMasks = new Array(32);
        // Parse options
        this.parseOptions(options);
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    parseOptions(options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (let i = 0; i < options.groupNames.length; i++) {
                let group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                let collisionMask = 0;
                for (let j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    }
    // @override
    registerObject(node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    }
    // @override
    deregisterObject(node) {
        console.log("Deregistering physics object");
        if (node.isStatic) {
            // Remove the node from the static list
            const index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            const index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    }
    // @override
    registerTilemap(tilemap) {
        this.tilemaps.push(tilemap);
    }
    // @override
    deregisterTilemap(tilemap) {
        const index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    }
    // @override
    update(deltaT) {
        for (let node of this.dynamicNodes) {
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            let overlaps = new Array();
            let groupIndex = Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (let other of this.staticNodes) {
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (let other of this.dynamicNodes) {
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (let tilemap of this.tilemaps) {
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1.default) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort((a, b) => b.area - a.area);
            // Keep track of hits to use later
            let hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (let overlap of overlaps) {
                // Ignore nodes we don't interact with
                if (this.collisionMasks[groupIndex] !== undefined && (this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                const point = node.collisionShape.center;
                const delta = node._velocity;
                const padding = node.collisionShape.halfSize;
                const otherAABB = overlap.collider;
                const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    let tnearx = hit.nearTimes.x;
                    let tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (let overlap of overlaps) {
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group)) {
                    // Get the bit that this group is represented by
                    let index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if ((this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    }
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    collideWithOrthogonalTilemap(node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
        let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        let minIndex = tilemap.getColRowAt(min);
        let maxIndex = tilemap.getColRowAt(max);
        let tileSize = tilemap.getTileSize();
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a new collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    // Calculate collision area between the node and the tile
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                    }
                }
            }
        }
    }
}
exports.default = BasicPhysicsManager;
},{"../DataTypes/Physics/AreaCollision":14,"../DataTypes/Shapes/AABB":18,"../DataTypes/Vec2":23,"../Nodes/Tilemaps/OrthogonalTilemap":48,"./PhysicsManager":59}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Map_1 = require("../DataTypes/Map");
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
class PhysicsManager {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1.default();
        this.groupNames = new Array();
    }
    destroy() {
        this.receiver.destroy();
    }
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    setGroup(node, group) {
        node.group = this.groupMap.get(group);
    }
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    getGroupNumber(group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    }
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    getGroupNames(groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            let g = 1;
            let names = [];
            for (let i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    }
}
exports.default = PhysicsManager;
/** The default group name */
PhysicsManager.DEFAULT_GROUP = "Default";
},{"../DataTypes/Map":12,"../Events/Emitter":26,"../Events/Receiver":30}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Receiver_1 = require("../Events/Receiver");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
// @ignorePage
class Recorder {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.log = new Queue_1.default(1000);
        this.recording = false;
        this.playing = false;
        this.frame = 0;
        this.eventQueue = EventQueue_1.default.getInstance();
        this.eventQueue.subscribe(this.receiver, "all");
    }
    update(deltaT) {
        if (this.recording) {
            this.frame += 1;
        }
        if (this.playing) {
            // If playing, ignore events, just feed the record to the event queue
            this.receiver.ignoreEvents();
            /*
                While there is a next item, and while it should occur in this frame,
                send the event. i.e., while current_frame * current_delta_t is greater
                than recorded_frame * recorded_delta_t
            */
            while (this.log.hasItems()
                && this.log.peekNext().frame * this.log.peekNext().delta < this.frame * deltaT) {
                let event = this.log.dequeue().event;
                console.log(event);
                this.eventQueue.addEvent(event);
            }
            if (!this.log.hasItems()) {
                this.playing = false;
            }
            this.frame += 1;
        }
        else {
            // If not playing, handle events
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                if (event.type === GameEventType_1.GameEventType.STOP_RECORDING) {
                    this.recording = false;
                }
                if (this.recording) {
                    this.log.enqueue(new LogItem(this.frame, deltaT, event));
                }
                if (event.type === GameEventType_1.GameEventType.START_RECORDING) {
                    this.log.clear();
                    this.recording = true;
                    this.frame = 0;
                }
                if (event.type === GameEventType_1.GameEventType.PLAY_RECORDING) {
                    this.frame = 0;
                    this.recording = false;
                    this.playing = true;
                }
            }
        }
    }
}
exports.default = Recorder;
class LogItem {
    constructor(frame, deltaT, event) {
        this.frame = frame;
        this.delta = deltaT;
        this.event = event;
    }
}
},{"../DataTypes/Queue":16,"../Events/EventQueue":27,"../Events/GameEventType":29,"../Events/Receiver":30}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
class Registry extends Map_1.default {
}
exports.default = Registry;
},{"../../DataTypes/Map":12}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LabelShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType");
const PointShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType");
const RectShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType");
const SpriteShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Registry_1 = require("./Registry");
/**
 * A registry that handles shaders
 */
class ShaderRegistry extends Registry_1.default {
    constructor() {
        super(...arguments);
        this.registryItems = new Array();
    }
    /**
     * Preloads all built-in shaders
     */
    preload() {
        // Get the resourceManager and queue all built-in shaders for preloading
        const rm = ResourceManager_1.default.getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (let item of this.registryItems) {
            const shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    }
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
        let shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    }
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    registerItem(key, constr) {
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    }
}
exports.default = ShaderRegistry;
// Shader names
ShaderRegistry.POINT_SHADER = "point";
ShaderRegistry.RECT_SHADER = "rect";
ShaderRegistry.SPRITE_SHADER = "sprite";
ShaderRegistry.LABEL_SHADER = "label";
class ShaderRegistryItem {
}
class ShaderPreload {
}
},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":75,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":76,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":78,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":79,"../../ResourceManager/ResourceManager":80,"./Registry":61}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const ShaderRegistry_1 = require("./Registries/ShaderRegistry");
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
class RegistryManager {
    static preload() {
        this.shaders.preload();
        this.registries.forEach((key) => this.registries.get(key).preload());
    }
    static addCustomRegistry(name, registry) {
        this.registries.add(name, registry);
    }
    static getRegistry(key) {
        return this.registries.get(key);
    }
}
exports.default = RegistryManager;
RegistryManager.shaders = new ShaderRegistry_1.default();
/** Additional custom registries to add to the registry manager */
RegistryManager.registries = new Map_1.default();
},{"../DataTypes/Map":12,"./Registries/ShaderRegistry":62}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const Emitter_1 = require("../../Events/Emitter");
const AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
class AnimationManager {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    constructor(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1.default();
        this.onEndEvent = null;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    add(key, animation) {
        this.animations.add(key, animation);
    }
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    getIndex() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
            return 0;
        }
    }
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    isPlaying(key) {
        return this.currentAnimation === key && this.animationState === AnimationTypes_1.AnimationState.PLAYING;
    }
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    getIndexAndAdvanceAnimation() {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            let currentAnimation = this.animations.get(this.currentAnimation);
            let index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >= currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
            return 0;
        }
    }
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    endCurrentAnimation() {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, { owner: this.owner.id, animation: this.currentAnimation });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    }
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    playIfNotAlready(animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    }
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    play(animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    }
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    queue(animation, loop = false, onEnd) {
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    }
    /** Pauses the current animation */
    pause() {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    }
    /** Resumes the current animation if possible */
    resume() {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /** Stops the current animation. The animation cannot be resumed after this. */
    stop() {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    }
}
exports.default = AnimationManager;
},{"../../DataTypes/Map":12,"../../Events/Emitter":26,"./AnimationTypes":65}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
class AnimationData {
    constructor() {
        this.repeat = false;
    }
}
exports.AnimationData = AnimationData;
class TweenEffect {
}
exports.TweenEffect = TweenEffect;
class TweenData {
}
exports.TweenData = TweenData;
},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const AnimationTypes_1 = require("./AnimationTypes");
const EaseFunctions_1 = require("../../Utils/EaseFunctions");
const MathUtils_1 = require("../../Utils/MathUtils");
const TweenManager_1 = require("./TweenManager");
const Emitter_1 = require("../../Events/Emitter");
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
class TweenController {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    constructor(owner) {
        this.owner = owner;
        this.tweens = new Map_1.default();
        this.emitter = new Emitter_1.default();
        // Give ourselves to the TweenManager
        TweenManager_1.default.getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    destroy() {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1.default.getInstance().deregisterTweenController(this);
    }
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    add(key, tween) {
        let typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    }
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    play(key, loop) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
        }
    }
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    pause(key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    }
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    resume(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    stop(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    }
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    end(key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            let tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                this.emitter.fireEvent(tween.onEnd, { key: key, node: this.owner.id });
            }
        }
    }
    /**
     * Stops all currently playing tweens
     */
    stopAll() {
        this.tweens.forEach(key => this.stop(key));
    }
    update(deltaT) {
        this.tweens.forEach(key => {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (let effect of tween.effects) {
                        // Get the value from the ease function that corresponds to our progress
                        let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                        // Use the value to lerp the property
                        let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        this.owner[effect.property] = value;
                    }
                }
            }
        });
    }
}
exports.default = TweenController;
},{"../../DataTypes/Map":12,"../../Events/Emitter":26,"../../Utils/EaseFunctions":96,"../../Utils/MathUtils":98,"./AnimationTypes":65,"./TweenManager":67}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TweenManager {
    constructor() {
        this.tweenControllers = new Array();
    }
    static getInstance() {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    }
    registerTweenController(controller) {
        this.tweenControllers.push(controller);
    }
    deregisterTweenController(controller) {
        let index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    }
    clearTweenControllers() {
        this.tweenControllers = new Array();
    }
    update(deltaT) {
        for (let tweenController of this.tweenControllers) {
            tweenController.update(deltaT);
        }
    }
}
exports.default = TweenManager;
TweenManager.instance = null;
},{}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const UIElement_1 = require("../Nodes/UIElement");
const GraphicRenderer_1 = require("./CanvasRendering/GraphicRenderer");
const RenderingManager_1 = require("./RenderingManager");
const TilemapRenderer_1 = require("./CanvasRendering/TilemapRenderer");
const UIElementRenderer_1 = require("./CanvasRendering/UIElementRenderer");
const Label_1 = require("../Nodes/UIElements/Label");
const Button_1 = require("../Nodes/UIElements/Button");
const Slider_1 = require("../Nodes/UIElements/Slider");
const TextInput_1 = require("../Nodes/UIElements/TextInput");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Vec2_1 = require("../DataTypes/Vec2");
const Line_1 = require("../Nodes/Graphics/Line");
const Debug_1 = require("../Debug/Debug");
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
class CanvasRenderer extends RenderingManager_1.default {
    constructor() {
        super();
    }
    // @override
    setScene(scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    }
    // @override
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1.default(width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    }
    // @override
    render(visibleSet, tilemaps, uiLayers) {
        // Sort by depth, then by visible set by y-value
        visibleSet.sort((a, b) => {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return (a.boundary.bottom) - (b.boundary.bottom);
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        let tilemapIndex = 0;
        let tilemapLength = tilemaps.length;
        let visibleSetIndex = 0;
        let visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        let sortedUILayers = new Array();
        uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
        sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
        sortedUILayers.forEach(uiLayer => {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(node => {
                    if (node.visible) {
                        this.renderNode(node);
                    }
                });
        });
    }
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        let xScale = 1;
        let yScale = 1;
        if (node instanceof Sprite_1.default) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        let globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1.default) {
            Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1.default) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1.default) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    // @override
    renderSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world
                image draw start -> x, y
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderAnimatedSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        let animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world (given we moved)
                image draw start -> -w/2, -h/2
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1.default) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1.default) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    }
    // @override
    renderTilemap(tilemap) {
        if (tilemap instanceof OrthogonalTilemap_1.default) {
            this.tilemapRenderer.renderOrthogonalTilemap(tilemap);
        }
    }
    // @override
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1.default) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1.default) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1.default) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    }
    clear(clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
}
exports.default = CanvasRenderer;
},{"../DataTypes/Vec2":23,"../Debug/Debug":24,"../Nodes/Graphic":40,"../Nodes/Graphics/Line":42,"../Nodes/Graphics/Point":43,"../Nodes/Graphics/Rect":44,"../Nodes/Sprites/AnimatedSprite":45,"../Nodes/Sprites/Sprite":46,"../Nodes/Tilemaps/OrthogonalTilemap":48,"../Nodes/UIElement":49,"../Nodes/UIElements/Button":50,"../Nodes/UIElements/Label":51,"../Nodes/UIElements/Slider":52,"../Nodes/UIElements/TextInput":53,"./CanvasRendering/GraphicRenderer":69,"./CanvasRendering/TilemapRenderer":70,"./CanvasRendering/UIElementRenderer":71,"./RenderingManager":72}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
class GraphicRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    renderPoint(point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    }
    renderLine(line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    }
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    renderRect(rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    }
}
exports.default = GraphicRenderer;
},{"../../ResourceManager/ResourceManager":80}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
class TilemapRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    renderOrthogonalTilemap(tilemap) {
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        let origin = this.scene.getViewTranslation(tilemap);
        let size = this.scene.getViewport().getHalfSize();
        let zoom = this.scene.getViewScale();
        let bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            let minColRow = tilemap.getColRowAt(origin);
            let maxColRow = tilemap.getColRowAt(bottomRight);
            for (let x = minColRow.x; x <= maxColRow.x; x++) {
                for (let y = minColRow.y; y <= maxColRow.y; y++) {
                    // Get the tile at this position
                    let tile = tilemap.getTileAtRowCol(new Vec2_1.default(x, y));
                    // Extract the rot/flip parameters if there are any
                    const mask = (0xE << 28);
                    const rotFlip = ((mask & tile) >> 28) & 0xF;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (let tileset of tilemap.getTilesets()) {
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tileset, tile, x, y, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    renderTile(tileset, tileIndex, tilemapRow, tilemapCol, origin, scale, zoom, rotFlip) {
        let image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the true index
        let index = tileIndex - tileset.getStartIndex();
        // Get the row and col of the tile in image space
        let row = Math.floor(index / tileset.getNumCols());
        let col = index % tileset.getNumCols();
        let width = tileset.getTileSize().x;
        let height = tileset.getTileSize().y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor(tilemapRow * width * scale.x);
        let y = Math.floor(tilemapCol * height * scale.y);
        let worldX = Math.floor((x - origin.x) * zoom);
        let worldY = Math.floor((y - origin.y) * zoom);
        let worldWidth = Math.ceil(width * scale.x * zoom);
        let worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            let scaleX = 1;
            let scaleY = 1;
            let shearX = 0;
            let shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    }
}
exports.default = TilemapRenderer;
},{"../../DataTypes/Vec2":23,"../../ResourceManager/ResourceManager":80}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const MathUtils_1 = require("../../Utils/MathUtils");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
class UIElementRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a label
     * @param label The label to render
     */
    renderLabel(label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        let offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a button
     * @param button The button to render
     */
    renderButton(button) {
        this.renderLabel(button);
    }
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    renderSlider(slider) {
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        let sliderSize = new Vec2_1.default(slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    renderTextInput(textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    }
}
exports.default = UIElementRenderer;
},{"../../DataTypes/Vec2":23,"../../ResourceManager/ResourceManager":80,"../../Utils/MathUtils":98}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * An abstract framework to put all rendering in once place in the application
 */
class RenderingManager {
    constructor() {
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    setScene(scene) {
        this.scene = scene;
    }
}
exports.default = RenderingManager;
},{"../ResourceManager/ResourceManager":80}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const UIElement_1 = require("../Nodes/UIElement");
const Label_1 = require("../Nodes/UIElements/Label");
const ShaderRegistry_1 = require("../Registry/Registries/ShaderRegistry");
const RegistryManager_1 = require("../Registry/RegistryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const RenderingManager_1 = require("./RenderingManager");
class WebGLRenderer extends RenderingManager_1.default {
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1.default.ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        let textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    }
    render(visibleSet, tilemaps, uiLayers) {
        for (let node of visibleSet) {
            this.renderNode(node);
        }
        uiLayers.forEach(key => {
            if (!uiLayers.get(key).isHidden())
                uiLayers.get(key).getItems().forEach(node => this.renderNode(node));
        });
    }
    clear(color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1.default) {
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
    }
    renderSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderAnimatedSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    }
    renderTilemap(tilemap) {
        throw new Error("Method not implemented.");
    }
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
            let options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            let globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            let offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    renderCustom(node) {
        let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
        let options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    }
    addOptions(options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        let layer = node.getLayer();
        let parallax = new Vec2_1.default(1, 1);
        if (layer instanceof ParallaxLayer_1.default) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    }
}
exports.default = WebGLRenderer;
},{"../DataTypes/Vec2":23,"../Nodes/Graphic":40,"../Nodes/Graphics/Point":43,"../Nodes/Graphics/Rect":44,"../Nodes/Sprites/AnimatedSprite":45,"../Nodes/Sprites/Sprite":46,"../Nodes/UIElement":49,"../Nodes/UIElements/Label":51,"../Registry/Registries/ShaderRegistry":62,"../Registry/RegistryManager":63,"../ResourceManager/ResourceManager":80,"../Scene/Layers/ParallaxLayer":88,"./RenderingManager":72}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
class ShaderType {
    constructor(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    getOptions(node) { return {}; }
}
exports.default = ShaderType;
},{"../../ResourceManager/ResourceManager":80}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
class LabelShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const backgroundColor = options.backgroundColor.toWebGL();
        const borderColor = options.borderColor.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = LabelShaderType;
},{"../../../DataTypes/Mat4x4":13,"../../../DataTypes/Vec2":23,"../../../ResourceManager/ResourceManager":80,"./QuadShaderType":77}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RenderingUtils_1 = require("../../../Utils/RenderingUtils");
const ShaderType_1 = require("../ShaderType");
class PointShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
    }
    initBufferObject() {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
        let color = RenderingUtils_1.default.toWebGLColor(options.color);
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = position;
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    }
    getOptions(point) {
        let options = {
            position: point.position,
            color: point.color,
            pointSize: point.size,
        };
        return options;
    }
}
exports.default = PointShaderType;
},{"../../../Utils/RenderingUtils":99,"../ShaderType":74}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const ShaderType_1 = require("../ShaderType");
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
class QuadShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.scale = Mat4x4_1.default.IDENTITY;
        this.rotation = Mat4x4_1.default.IDENTITY;
        this.translation = Mat4x4_1.default.IDENTITY;
    }
}
exports.default = QuadShaderType;
},{"../../../DataTypes/Mat4x4":13,"../ShaderType":74}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
class RectShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const color = options.color.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /*
        So as it turns out, WebGL has an issue with non-square quads.
        It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
        To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
        A diagram of the solution follows.

        There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
        The offset in the vertical direction is therefore 0.5, as it is normally.
        However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
        All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.

        So now we have our rect, in a space scaled with respect to the largest dimension.
        Rotations work as you would expect, even for long rectangles.

                    0.5
            __ __ __ __ __ __ __
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
        -0.5|_ _|88888888888|_ _|0.5
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
            |___|88888888888|___|
                    -0.5

        The getVertices function below does as described, and converts the range
    */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = RectShaderType;
},{"../../../DataTypes/Mat4x4":13,"../../../DataTypes/Vec2":23,"../../../ResourceManager/ResourceManager":80,"./QuadShaderType":77}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const AnimatedSprite_1 = require("../../../Nodes/Sprites/AnimatedSprite");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** A shader for sprites and animated sprites */
class SpriteShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        const texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        const u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        const u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h, scale) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x, y, 0.0, 0.0,
            -x, -y, 0.0, 1.0,
            x, y, 1.0, 0.0,
            x, -y, 1.0, 1.0
        ]);
    }
    getOptions(sprite) {
        let texShift;
        let texScale;
        if (sprite instanceof AnimatedSprite_1.default) {
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
            texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        let options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift,
            texScale
        };
        return options;
    }
}
exports.default = SpriteShaderType;
},{"../../../DataTypes/Mat4x4":13,"../../../DataTypes/Vec2":23,"../../../Nodes/Sprites/AnimatedSprite":45,"../../../ResourceManager/ResourceManager":80,"./QuadShaderType":77}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Queue_1 = require("../DataTypes/Queue");
const StringUtils_1 = require("../Utils/StringUtils");
const AudioManager_1 = require("../Sound/AudioManager");
const WebGLProgramType_1 = require("../DataTypes/Rendering/WebGLProgramType");
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
class ResourceManager {
    constructor() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1.default();
        this.images = new Map_1.default();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
        this.spritesheets = new Map_1.default();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1.default();
        this.tilemaps = new Map_1.default();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1.default();
        this.audioBuffers = new Map_1.default();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1.default();
        this.jsonObjects = new Map_1.default();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
        this.gl_ShaderPrograms = new Map_1.default();
        this.gl_Textures = new Map_1.default();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1.default();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    ;
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    }
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    useWebGL(flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    }
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    image(key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepImage(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    getImage(key) {
        let image = this.images.get(key);
        if (image === undefined) {
            console.log(this.images);
            throw `There is no image associated with key "${key}"`;
        }
        return image;
    }
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    spritesheet(key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepSpritesheet(key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    }
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    getSpritesheet(key) {
        return this.spritesheets.get(key);
    }
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    audio(key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepAudio(key) {
        this.keepResource(key, ResourceType.AUDIO);
    }
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    getAudio(key) {
        return this.audioBuffers.get(key);
    }
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param path The path to the tilemap to load
     */
    tilemap(key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepTilemap(key) {
        this.keepResource(key, ResourceType.TILEMAP);
    }
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    getTilemap(key) {
        return this.tilemaps.get(key);
    }
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    object(key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepObject(key) {
        this.keepResource(key, ResourceType.JSON);
    }
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    getObject(key) {
        return this.jsonObjects.get(key);
    }
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    loadResourcesFromQueue(callback) {
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(() => {
            console.log("Loaded Tilemaps");
            this.loadSpritesheetsFromQueue(() => {
                console.log("Loaded Spritesheets");
                this.loadImagesFromQueue(() => {
                    console.log("Loaded Images");
                    this.loadAudioFromQueue(() => {
                        console.log("Loaded Audio");
                        this.loadObjectsFromQueue(() => {
                            console.log("Loaded Objects");
                            if (this.gl_WebGLActive) {
                                this.gl_LoadShadersFromQueue(() => {
                                    console.log("Loaded Shaders");
                                    this.finishLoading(callback);
                                });
                            }
                            else {
                                this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    }
    finishLoading(callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    }
    /* ######################################## UNLOAD FUNCTION ########################################*/
    keepResource(key, type) {
        console.log("Keep resource...");
        for (let i = 0; i < this.resourcesToUnload.length; i++) {
            let resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                let resourceToMove = this.resourcesToUnload.splice(i, 1);
                this.resourcesToKeep.push(...resourceToMove);
                return;
            }
        }
    }
    /**
     * Deletes references to all resources in the resource manager
     */
    unloadAllResources() {
        this.loading = false;
        this.justLoaded = false;
        for (let resource of this.resourcesToUnload) {
            // Unload the resource
            this.unloadResource(resource);
        }
    }
    unloadResource(resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images.delete(resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures.delete(resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps.delete(resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets.delete(resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers.delete(resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects.delete(resource.key);
                break;
            case ResourceType.SHADER:
                this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                this.gl_ShaderPrograms.delete(resource.key);
                break;
        }
        // Delete any dependencies
        for (let dependency of resource.dependencies) {
            this.unloadResource(dependency);
        }
    }
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    loadTilemapsFromQueue(onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
        this.loadTextFile(pathToTilemapJSON, (fileText) => {
            let tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.tilemaps.add(key, tilemapObject);
            let resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (let tileset of tilemapObject.tilesets) {
                if (tileset.image) {
                    let key = tileset.image;
                    let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                    this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (let tile of tileset.tiles) {
                        let key = tile.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingTilemap(callbackIfLast);
        });
    }
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    finishLoadingTilemap(callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    }
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    loadSpritesheetsFromQueue(onFinishLoading) {
        this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
        this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
            let spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.spritesheets.add(key, spritesheet);
            let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
            this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingSpritesheet(callbackIfLast);
        });
    }
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    finishLoadingSpritesheet(callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    }
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    loadImagesFromQueue(onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            let image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    }
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    loadImage(key, path, isDependency, callbackIfLast) {
        var image = new Image();
        image.onload = () => {
            // Add to loaded images
            this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (this.gl_WebGLActive) {
                this.createWebGLTexture(key, image);
            }
            // Finish image load
            this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    }
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    finishLoadingImage(callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    }
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    loadAudioFromQueue(onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            let audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    }
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    loadAudio(key, path, callbackIfLast) {
        let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
        let request = new XMLHttpRequest();
        request.open('GET', path, true);
        request.responseType = 'arraybuffer';
        request.onload = () => {
            audioCtx.decodeAudioData(request.response, (buffer) => {
                // Add to list of audio buffers
                this.audioBuffers.add(key, buffer);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                this.finishLoadingAudio(callbackIfLast);
            }, (error) => {
                throw "Error loading sound";
            });
        };
        request.send();
    }
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    finishLoadingAudio(callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    }
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    loadObjectsFromQueue(onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            let obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    loadObject(key, path, callbackIfLast) {
        this.loadTextFile(path, (fileText) => {
            let obj = JSON.parse(fileText);
            this.jsonObjects.add(key, obj);
            this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            this.finishLoadingObject(callbackIfLast);
        });
    }
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    finishLoadingObject(callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    }
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    getTexture(key) {
        return this.gl_Textures.get(key);
    }
    getShaderProgram(key) {
        return this.gl_ShaderPrograms.get(key).program;
    }
    getBuffer(key) {
        return this.gl_Buffers.get(key);
    }
    createWebGLTexture(imageKey, image) {
        // Get the texture ID
        const textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        const texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    }
    getTextureID(id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0: return this.gl.TEXTURE0;
            case 1: return this.gl.TEXTURE1;
            case 2: return this.gl.TEXTURE2;
            case 3: return this.gl.TEXTURE3;
            case 4: return this.gl.TEXTURE4;
            case 5: return this.gl.TEXTURE5;
            case 6: return this.gl.TEXTURE6;
            case 7: return this.gl.TEXTURE7;
            case 8: return this.gl.TEXTURE8;
            default: return this.gl.TEXTURE9;
        }
    }
    createBuffer(key) {
        if (this.gl_WebGLActive) {
            let buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    }
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    shader(key, vShaderFilepath, fShaderFilepath) {
        let splitPath = vShaderFilepath.split(".");
        let end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
        }
        let paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepShader(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    gl_LoadShadersFromQueue(onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    }
    gl_LoadShader(key, vpath, fpath, callbackIfLast) {
        this.loadTextFile(vpath, (vFileText) => {
            const vShader = vFileText;
            this.loadTextFile(fpath, (fFileText) => {
                const fShader = fFileText;
                // Extract the program and shaders
                const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                // Create a wrapper type
                const programWrapper = new WebGLProgramType_1.default();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                this.gl_ShaderPrograms.add(key, programWrapper);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    }
    gl_FinishLoadingShader(callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    }
    createShaderProgram(vShaderSource, fShaderSource) {
        const vertexShader = this.loadVertexShader(vShaderSource);
        const fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        const program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            const error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    }
    loadVertexShader(shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    }
    loadFragmentShader(shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    }
    loadShader(type, shaderSource) {
        const shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            const error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    }
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    loadTextFile(textFilePath, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', textFilePath, true);
        xobj.onreadystatechange = function () {
            if ((xobj.readyState == 4) && (xobj.status == 200)) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
    /* ########## LOADING BAR INFO ########## */
    getLoadPercent() {
        return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
            + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
            + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
            + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
            / this.loadonly_typesToLoad;
    }
    update(deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    }
}
exports.default = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
class ResourceReference {
    constructor(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    addDependency(resource) {
        this.dependencies.push(resource);
    }
}
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
class KeyPathPair {
    constructor() {
        this.isDependency = false;
    }
}
class KeyPath_Shader {
}
},{"../DataTypes/Map":12,"../DataTypes/Queue":16,"../DataTypes/Rendering/WebGLProgramType":17,"../Sound/AudioManager":93,"../Utils/StringUtils":100}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
class SceneGraph {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    addNode(node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    }
    ;
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    removeNode(node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    }
    ;
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    getNode(id) {
        return this.nodeMap[id];
    }
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    getNodesAt(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    }
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    getAllNodes() {
        let arr = new Array();
        for (let i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    }
}
exports.default = SceneGraph;
},{"../DataTypes/Vec2":23}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SceneGraph_1 = require("./SceneGraph");
const Stats_1 = require("../Debug/Stats");
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
class SceneGraphArray extends SceneGraph_1.default {
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        super(viewport, scene);
        this.nodeList = new Array();
    }
    // @override
    addNodeSpecific(node, id) {
        this.nodeList.push(node);
    }
    // @override
    removeNodeSpecific(node, id) {
        let index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    }
    // @override
    getNodesAtCoords(x, y) {
        let results = [];
        for (let node of this.nodeList) {
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    }
    // @override
    getNodesInRegion(boundary) {
        let t0 = performance.now();
        let results = [];
        for (let node of this.nodeList) {
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgquery", (t1 - t0));
        return results;
    }
    update(deltaT) {
        let t0 = performance.now();
        for (let node of this.nodeList) {
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgupdate", (t1 - t0));
    }
    render(ctx) { }
    // @override
    getVisibleSet() {
        let visibleSet = new Array();
        for (let node of this.nodeList) {
            if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    }
}
exports.default = SceneGraphArray;
},{"../Debug/Stats":25,"./SceneGraph":81}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const MathUtils_1 = require("../Utils/MathUtils");
const Queue_1 = require("../DataTypes/Queue");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Input_1 = require("../Input/Input");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const UILayer_1 = require("../Scene/Layers/UILayer");
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
class Viewport {
    constructor(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        this.view = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.lastPositions = new Queue_1.default();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1.default.ZERO;
        this.focus = Vec2_1.default.ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    enableZoom() {
        this.scrollZoomEnabled = true;
    }
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    getCenter() {
        return this.view.center;
    }
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    getOrigin() {
        return new Vec2_1.default(this.view.left, this.view.top);
    }
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    getView() {
        return this.view;
    }
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    setCenter(vecOrX, y = null) {
        let pos;
        if (vecOrX instanceof Vec2_1.default) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1.default(vecOrX, y);
        }
        this.view.center = pos;
    }
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    getHalfSize() {
        return this.view.getHalfSize();
    }
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    setSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
        }
    }
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    setHalfSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
        }
    }
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    setCanvasSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1.default(vecOrX, y);
        }
    }
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    setZoomLevel(zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    }
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    getZoomLevel() {
        return this.canvasSize.x / this.view.hw / 2;
    }
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    setSmoothingFactor(smoothingFactor) {
        if (smoothingFactor < 1)
            smoothingFactor = 1;
        this.smoothingFactor = smoothingFactor;
    }
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    setFocus(focus) {
        this.focus.copy(focus);
    }
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    includes(node) {
        let parallax = node.getLayer() instanceof ParallaxLayer_1.default || node.getLayer() instanceof UILayer_1.default ? node.getLayer().parallax : new Vec2_1.default(1, 1);
        let center = this.view.center.clone();
        this.view.center.mult(parallax);
        let overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    }
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    setBounds(lowerX, lowerY, upperX, upperY) {
        let hwidth = (upperX - lowerX) / 2;
        let hheight = (upperY - lowerY) / 2;
        let x = lowerX + hwidth;
        let y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    }
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    follow(node) {
        this.following = node;
    }
    updateView() {
        if (this.lastPositions.getSize() > this.smoothingFactor) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        let pos = Vec2_1.default.ZERO;
        this.lastPositions.forEach(position => pos.add(position));
        pos.scale(1 / this.lastPositions.getSize());
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    }
    update(deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1.default.didJustScroll()) {
                let currentSize = this.view.getHalfSize().clone();
                if (Input_1.default.getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    let factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    let factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    }
}
exports.default = Viewport;
},{"../DataTypes/Queue":16,"../DataTypes/Shapes/AABB":18,"../DataTypes/Vec2":23,"../Input/Input":31,"../Scene/Layers/ParallaxLayer":88,"../Scene/Layers/UILayer":89,"../Utils/MathUtils":98}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("../../Nodes/Sprites/Sprite");
const AnimatedSprite_1 = require("../../Nodes/Sprites/AnimatedSprite");
const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
const Point_1 = require("../../Nodes/Graphics/Point");
const Vec2_1 = require("../../DataTypes/Vec2");
const Button_1 = require("../../Nodes/UIElements/Button");
const Label_1 = require("../../Nodes/UIElements/Label");
const Slider_1 = require("../../Nodes/UIElements/Slider");
const TextInput_1 = require("../../Nodes/UIElements/TextInput");
const Rect_1 = require("../../Nodes/Graphics/Rect");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Line_1 = require("../../Nodes/Graphics/Line");
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class CanvasNodeFactory {
    constructor() {
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = this.buildTextInput(options);
                    break;
                default:
                    throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
            }
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let instance = new Sprite_1.default(key);
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let spritesheet = this.resourceManager.getSpritesheet(key);
            let instance = new AnimatedSprite_1.default(spritesheet);
            // Add instance fo scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = this.buildRect(options);
                    break;
                default:
                    throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
            }
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    init(scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /* ---------- BUILDERS ---------- */
    buildButton(options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1.default(options.position, options.text);
    }
    buildLabel(options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1.default(options.position, options.text);
    }
    buildSlider(options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
        let initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1.default(options.position, initValue);
    }
    buildTextInput(options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
        return new TextInput_1.default(options.position);
    }
    buildPoint(options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
        return new Point_1.default(options.position);
    }
    buildLine(options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
        return new Line_1.default(options.start, options.end);
    }
    buildRect(options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
        return new Rect_1.default(options.position, options.size);
    }
    /* ---------- ERROR HANDLING ---------- */
    checkIfPropExists(objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
        }
        else {
            // Check that the property has the correct type
            if ((typeof type) === "string") {
                if (!(typeof options[prop] === type)) {
                    throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
            else {
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
            }
        }
    }
}
exports.default = CanvasNodeFactory;
},{"../../DataTypes/Vec2":23,"../../Nodes/Graphics/GraphicTypes":41,"../../Nodes/Graphics/Line":42,"../../Nodes/Graphics/Point":43,"../../Nodes/Graphics/Rect":44,"../../Nodes/Sprites/AnimatedSprite":45,"../../Nodes/Sprites/Sprite":46,"../../Nodes/UIElements/Button":50,"../../Nodes/UIElements/Label":51,"../../Nodes/UIElements/Slider":52,"../../Nodes/UIElements/TextInput":53,"../../Nodes/UIElements/UIElementTypes":54,"../../ResourceManager/ResourceManager":80}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNodeFactory_1 = require("./CanvasNodeFactory");
const TilemapFactory_1 = require("./TilemapFactory");
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
class FactoryManager {
    constructor(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1.default();
        this.tilemapFactory = new TilemapFactory_1.default();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    uiElement(type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    }
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    sprite(key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    }
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    animatedSprite(key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(key, layerName);
    }
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    graphic(type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    }
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    tilemap(key, scale) {
        return this.tilemapFactory.add(key, scale);
    }
}
exports.default = FactoryManager;
},{"./CanvasNodeFactory":84,"./TilemapFactory":86}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const OrthogonalTilemap_1 = require("../../Nodes/Tilemaps/OrthogonalTilemap");
const Tileset_1 = require("../../DataTypes/Tilesets/Tileset");
const Vec2_1 = require("../../DataTypes/Vec2");
const PositionGraph_1 = require("../../DataTypes/Graphs/PositionGraph");
const Navmesh_1 = require("../../Pathfinding/Navmesh");
// @ignorePage
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class TilemapFactory {
    constructor() {
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = (key, scale = new Vec2_1.default(1, 1)) => {
            // Get Tilemap Data
            let tilemapData = this.resourceManager.getTilemap(key);
            // Set the constructor for this tilemap to either be orthographic or isometric
            let constr;
            if (tilemapData.orientation === "orthographic") {
                constr = OrthogonalTilemap_1.default;
            }
            else {
                // No isometric tilemap support right now, so Orthographic tilemap
                constr = OrthogonalTilemap_1.default;
            }
            // Initialize the return value array
            let sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            let tilesets = new Array();
            let collectionTiles = new Array();
            for (let tileset of tilemapData.tilesets) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1.default(tileset));
                }
                else {
                    tileset.tiles.forEach(tile => tile.id += tileset.firstgid);
                    collectionTiles.push(...tileset.tiles);
                }
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (let layer of tilemapData.layers) {
                let sceneLayer;
                let isParallaxLayer = false;
                let depth = 0;
                if (layer.properties) {
                    for (let prop of layer.properties) {
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                }
                else {
                    sceneLayer = this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    let tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = this.scene.generateId();
                    tilemap.setScene(this.scene);
                    // Add tilemap to scene
                    this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (let item of layer.properties) {
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    let isNavmeshPoints = false;
                    let navmeshName;
                    let edges;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        let g = new PositionGraph_1.default();
                        for (let obj of layer.objects) {
                            g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                        }
                        for (let edge of edges) {
                            g.addEdge(edge.from, edge.to);
                        }
                        this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (let obj of layer.objects) {
                        // Check if obj is collidable
                        let hasPhysics = false;
                        let isCollidable = false;
                        let isTrigger = false;
                        let onEnter = null;
                        let onExit = null;
                        let triggerGroup = null;
                        let group = "";
                        if (obj.properties) {
                            for (let prop of obj.properties) {
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        let sprite;
                        // Check if obj is a tile from a tileset
                        for (let tileset of tilesets) {
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                let imageKey = tileset.getImageKey();
                                let offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = this.scene.add.sprite(imageKey, layer.name);
                                let size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (let tile of collectionTiles) {
                                if (obj.gid === tile.id) {
                                    let imageKey = tile.image;
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    init(scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
}
exports.default = TilemapFactory;
},{"../../DataTypes/Graphs/PositionGraph":10,"../../DataTypes/Tilesets/Tileset":22,"../../DataTypes/Vec2":23,"../../Nodes/Tilemaps/OrthogonalTilemap":48,"../../Pathfinding/Navmesh":57,"../../ResourceManager/ResourceManager":80}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
class Layer {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    getName() {
        return this.name;
    }
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    setPaused(pauseValue) {
        this.paused = pauseValue;
    }
    /**
     * Returns whether or not the layer is paused
     */
    isPaused() {
        return this.paused;
    }
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    setAlpha(alpha) {
        this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
    }
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    setHidden(hidden) {
        this.hidden = hidden;
    }
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    isHidden() {
        return this.hidden;
    }
    /** Pauses this scene and hides it */
    disable() {
        this.paused = true;
        this.hidden = true;
    }
    /** Unpauses this layer and makes it visible */
    enable() {
        this.paused = false;
        this.hidden = false;
    }
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    setYSort(ySort) {
        this.ySort = ySort;
    }
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    getYSort() {
        return this.ySort;
    }
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    setDepth(depth) {
        this.depth = depth;
    }
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    getDepth() {
        return this.depth;
    }
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    addNode(node) {
        this.items.push(node);
        node.setLayer(this);
    }
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    removeNode(node) {
        // Find and remove the node
        let index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    }
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    getItems() {
        return this.items;
    }
}
exports.default = Layer;
},{"../Utils/MathUtils":98}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("../Layer");
/**
 * An extension of a Layer that has a parallax value.
 */
class ParallaxLayer extends Layer_1.default {
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    constructor(scene, name, parallax) {
        super(scene, name);
        this.parallax = parallax;
    }
}
exports.default = ParallaxLayer;
},{"../Layer":87}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ParallaxLayer_1 = require("./ParallaxLayer");
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
class UILayer extends ParallaxLayer_1.default {
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    constructor(scene, name) {
        super(scene, name, Vec2_1.default.ZERO);
    }
}
exports.default = UILayer;
},{"../../DataTypes/Vec2":23,"./ParallaxLayer":88}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("./Layer");
const Vec2_1 = require("../DataTypes/Vec2");
const BasicPhysicsManager_1 = require("../Physics/BasicPhysicsManager");
const SceneGraphArray_1 = require("../SceneGraph/SceneGraphArray");
const FactoryManager_1 = require("./Factories/FactoryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const NavigationManager_1 = require("../Pathfinding/NavigationManager");
const AIManager_1 = require("../AI/AIManager");
const Map_1 = require("../DataTypes/Map");
const ParallaxLayer_1 = require("./Layers/ParallaxLayer");
const UILayer_1 = require("./Layers/UILayer");
const CanvasNode_1 = require("../Nodes/CanvasNode");
const SceneOptions_1 = require("./SceneOptions");
const Debug_1 = require("../Debug/Debug");
const TimerManager_1 = require("../Timing/TimerManager");
const TweenManager_1 = require("../Rendering/Animations/TweenManager");
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
class Scene {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    constructor(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1.default(500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
        this.layers = new Map_1.default();
        this.uiLayers = new Map_1.default();
        this.parallaxLayers = new Map_1.default();
        this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
        this.navManager = new NavigationManager_1.default();
        this.aiManager = new AIManager_1.default();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1.default(this, this.tilemaps);
        this.load = ResourceManager_1.default.getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1.default.getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    initScene(init) { }
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    loadScene() { }
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    startScene() { }
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    updateScene(deltaT) { }
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    unloadScene() { }
    update(deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1.default.getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(tilemap => {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1.default.getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    }
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    render() {
        // Get the visible set of nodes
        let visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(key => {
            let pLayer = this.parallaxLayers.get(key);
            for (let node of pLayer.getItems()) {
                if (node instanceof CanvasNode_1.default) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        let nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
        Debug_1.default.setNodes(nodes);
    }
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    setRunning(running) {
        this.running = running;
    }
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    isRunning() {
        return this.running;
    }
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    remove(node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1.default) {
            this.sceneGraph.removeNode(node);
        }
    }
    /** Destroys this scene and all nodes in it */
    destroy() {
        for (let node of this.sceneGraph.getAllNodes()) {
            node.destroy();
        }
        for (let tilemap of this.tilemaps) {
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    }
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    addLayer(name, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new Layer_1.default(this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    addParallaxLayer(name, parallax, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new ParallaxLayer_1.default(this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    addUILayer(name) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new UILayer_1.default(this, name);
        this.uiLayers.add(name, layer);
        return layer;
    }
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    getLayer(name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw `Requested layer ${name} does not exist.`;
        }
    }
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    isParallaxLayer(name) {
        return this.parallaxLayers.has(name);
    }
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    isUILayer(name) {
        return this.uiLayers.has(name);
    }
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    getViewTranslation(node) {
        let layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    }
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
    */
    getViewScale() {
        return this.viewport.getZoomLevel();
    }
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    getViewport() {
        return this.viewport;
    }
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    getWorldSize() {
        return this.worldSize;
    }
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    getSceneGraph() {
        return this.sceneGraph;
    }
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    getPhysicsManager() {
        return this.physicsManager;
    }
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    getNavigationManager() {
        return this.navManager;
    }
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    getAIManager() {
        return this.aiManager;
    }
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    generateId() {
        return this.sceneManager.generateId();
    }
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    getTilemap(name) {
        for (let tilemap of this.tilemaps) {
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    }
}
exports.default = Scene;
},{"../AI/AIManager":6,"../DataTypes/Map":12,"../DataTypes/Vec2":23,"../Debug/Debug":24,"../Events/Emitter":26,"../Events/Receiver":30,"../Nodes/CanvasNode":38,"../Pathfinding/NavigationManager":55,"../Physics/BasicPhysicsManager":58,"../Rendering/Animations/TweenManager":67,"../ResourceManager/ResourceManager":80,"../SceneGraph/SceneGraphArray":82,"../Timing/TimerManager":94,"./Factories/FactoryManager":85,"./Layer":87,"./Layers/ParallaxLayer":88,"./Layers/UILayer":89,"./SceneOptions":92}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
class SceneManager {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    constructor(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    changeToScene(constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    }
    doSceneChange() {
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(() => {
            console.log("Starting Scene");
            this.currentScene.startScene();
            this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    }
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    generateId() {
        return this.idCounter++;
    }
    /**
     * Renders the current Scene
     */
    render() {
        if (this.currentScene) {
            this.currentScene.render();
        }
    }
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    update(deltaT) {
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    }
}
exports.default = SceneManager;
},{"../ResourceManager/ResourceManager":80}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
class SceneOptions {
    static parse(options) {
        let sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    }
}
exports.default = SceneOptions;
},{}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
const Map_1 = require("../DataTypes/Map");
const Receiver_1 = require("../Events/Receiver");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
class AudioManager {
    constructor() {
        this.initAudio();
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL
        ]);
        this.currentSounds = new Map_1.default();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    }
    /**
     * Initializes the webAudio context
     */
    initAudio() {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
            this.audioCtx = new AudioContext();
            console.log('Web Audio API successfully loaded');
        }
        catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    }
    initGainNodes() {
        for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    }
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    getAudioContext() {
        return this.audioCtx;
    }
    /*
        According to the MDN, create a new sound for every call:

        An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
        if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
        actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
        "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
        hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
        until sometime after the sound has finished playing.
    */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    createSound(key, holdReference, channel, options) {
        // Get audio buffer
        let buffer = ResourceManager_1.default.getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        const nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (let i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    }
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    playSound(key, loop, holdReference, channel, options) {
        let sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    }
    /**
     * Stop the sound specified by the key
     */
    stopSound(key) {
        let sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds.delete(key);
        }
    }
    muteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    }
    unmuteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    }
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    static setVolume(channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        const am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    }
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    getChannelGainNode(channel) {
        return this.gainNodes[channel];
    }
    update(deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === GameEventType_1.GameEventType.PLAY_SOUND || event.type === GameEventType_1.GameEventType.PLAY_MUSIC || event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                let soundKey = event.data.get("key");
                let loop = event.data.get("loop");
                let holdReference = event.data.get("holdReference");
                let channel = AudioChannelType.DEFAULT;
                if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event.data.has("channel")) {
                    channel = event.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event.data);
            }
            if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                let soundKey = event.data.get("key");
                this.stopSound(soundKey);
            }
            if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event.data.get("channel"));
            }
            if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event.data.get("channel"));
            }
        }
    }
}
exports.default = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;
},{"../DataTypes/Map":12,"../Events/GameEventType":29,"../Events/Receiver":30,"../ResourceManager/ResourceManager":80}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TimerManager {
    constructor() {
        this.timers = new Array();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    }
    addTimer(timer) {
        this.timers.push(timer);
    }
    clearTimers() {
        this.timers = new Array();
    }
    update(deltaT) {
        this.timers.forEach(timer => timer.update(deltaT));
    }
}
exports.default = TimerManager;
},{}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
class Color {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Transparent color
     * @returns rgba(0, 0, 0, 0)
     */
    static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
    }
    /**
     * Red color
     * @returns rgb(255, 0, 0)
     */
    static get RED() {
        return new Color(255, 0, 0, 1);
    }
    /**
     * Green color
     * @returns rgb(0, 255, 0)
     */
    static get GREEN() {
        return new Color(0, 255, 0, 1);
    }
    /**
     * Blue color
     * @returns rgb(0, 0, 255)
     */
    static get BLUE() {
        return new Color(0, 0, 255, 1);
    }
    /**
     * Yellow color
     * @returns rgb(255, 255, 0)
     */
    static get YELLOW() {
        return new Color(255, 255, 0, 1);
    }
    /**
     * Magenta color
     * @returns rgb(255, 0, 255)
     */
    static get MAGENTA() {
        return new Color(255, 0, 255, 1);
    }
    /**
     * Cyan color
     * @returns rgb(0, 255, 255)
     */
    static get CYAN() {
        return new Color(0, 255, 255, 1);
    }
    /**
     * White color
     * @returns rgb(255, 255, 255)
     */
    static get WHITE() {
        return new Color(255, 255, 255, 1);
    }
    /**
     * Black color
     * @returns rgb(0, 0, 0)
     */
    static get BLACK() {
        return new Color(0, 0, 0, 1);
    }
    /**
     * Orange color
     * @returns rgb(255, 100, 0)
     */
    static get ORANGE() {
        return new Color(255, 100, 0, 1);
    }
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    set(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    lighten() {
        return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    darken() {
        return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    toString() {
        return "#" + MathUtils_1.default.toHex(this.r, 2) + MathUtils_1.default.toHex(this.g, 2) + MathUtils_1.default.toHex(this.b, 2);
    }
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    toStringRGB() {
        return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
    }
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    toStringRGBA() {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
    }
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    toWebGL() {
        return new Float32Array([
            this.r / 255,
            this.g / 255,
            this.b / 255,
            this.a
        ]);
    }
    static fromStringHex(str) {
        let i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
        let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
        let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    }
}
exports.default = Color;
},{"./MathUtils":98}],96:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseFunctionType = void 0;
class EaseFunctions {
    static easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }
    static easeOutInSine(x) {
        return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    }
    static easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    static easeInSine(x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    }
    static easeInOutQuint(x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    }
    static easeInOutQuad(x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    static easeOutInQuad(x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    }
    static easeOutIn_OutPow(x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    }
    static easeOutIn_InPow(x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    }
}
exports.default = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));
},{}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class to provides some utility functions for graphs */
class GraphUtils {
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    static djikstra(g, start) {
        let i; // Counter
        let p; // Pointer to edgenode
        let inTree = new Array(g.numVertices);
        let distance = new Array(g.numVertices);
        let parent = new Array(g.numVertices);
        let v; // Current vertex to process
        let w; // Candidate for next vertex
        let weight; // Edge weight
        let dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    }
}
exports.default = GraphUtils;
},{}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class containing some utility functions for math operations */
class MathUtils {
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    static sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    static between(a, b, x, exclusive) {
        if (exclusive) {
            return (a < x) && (x < b);
        }
        else {
            return (a <= x) && (x <= b);
        }
    }
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    static clamp(x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    }
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    static clamp01(x) {
        return MathUtils.clamp(x, 0, 1);
    }
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    static clampLow(x, min) {
        return x < min ? min : x;
    }
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    static clampLow0(x) {
        return MathUtils.clampLow(x, 0);
    }
    static clampMagnitude(v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    }
    static changeRange(x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    }
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    static lerp(a, b, t) {
        return a + t * (b - a);
    }
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    static invLerp(a, b, value) {
        return (value - a) / (b - a);
    }
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    static floorToPlace(num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        let factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    }
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    static fromHex(str) {
        return parseInt(str, 16);
    }
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    static toHex(num, minLength = null) {
        let factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        let hexStr = "";
        while (factor >= 1) {
            let digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    }
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    static toHexDigit(num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    }
}
exports.default = MathUtils;
},{}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
class RenderingUtils {
    static toWebGLCoords(point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
        ]);
    }
    static toWebGLScale(size, worldSize) {
        return new Float32Array([
            2 * size.x / worldSize.x,
            2 * size.y / worldSize.y,
        ]);
    }
    static toWebGLColor(color) {
        return new Float32Array([
            MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
            color.a
        ]);
    }
}
exports.default = RenderingUtils;
},{"./MathUtils":98}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Some utility functions for dealing with strings */
class StringUtils {
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    static getPathFromFilePath(filePath) {
        let splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    }
}
exports.default = StringUtils;
},{}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Game_1 = require("./Wolfie2D/Loop/Game");
const SplashScreen_1 = require("./Scenes/SplashScreen");
const RegistryManager_1 = require("./Wolfie2D/Registry/RegistryManager");
const WeaponRegistry_1 = require("./GameSystems/Registry/WeaponRegistry");
const WeaponTypeRegistry_1 = require("./GameSystems/Registry/WeaponTypeRegistry");
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    let options = {
        canvasSize: { x: 1280, y: 720 },
        clearColor: { r: 0, g: 0, b: 0 },
        inputs: [
            { name: "up", keys: ["w"] },
            { name: "down", keys: ["s"] },
            { name: "left", keys: ["a"] },
            { name: "right", keys: ["d"] },
            { name: "interact", keys: ["e"] },
            { name: "pause", keys: ["escape"] },
        ]
    };
    // setup custom weapon registry
    let weaponTemplateRegistry = new WeaponRegistry_1.default();
    RegistryManager_1.default.addCustomRegistry("weaponTemplates", weaponTemplateRegistry);
    let weaponTypeRegistry = new WeaponTypeRegistry_1.default();
    RegistryManager_1.default.addCustomRegistry("weaponTypes", weaponTypeRegistry);
    // Create a game with the options specified
    const game = new Game_1.default(options);
    // Start our game
    game.start(SplashScreen_1.default, {});
})();
function runTests() { }
;
},{"./GameSystems/Registry/WeaponRegistry":1,"./GameSystems/Registry/WeaponTypeRegistry":2,"./Scenes/SplashScreen":5,"./Wolfie2D/Loop/Game":35,"./Wolfie2D/Registry/RegistryManager":63}]},{},[101])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvR2FtZVN5c3RlbXMvUmVnaXN0cnkvV2VhcG9uUmVnaXN0cnkudHMiLCJzcmMvR2FtZVN5c3RlbXMvUmVnaXN0cnkvV2VhcG9uVHlwZVJlZ2lzdHJ5LnRzIiwic3JjL0dhbWVTeXN0ZW1zL1dlYXBvblR5cGVzL1B1bmNoLnRzIiwic3JjL1NjZW5lcy9TcGxhc2hTY3JlZW4udHMiLCJzcmMvV29sZmllMkQvQUkvQUlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9GdW5jdGlvbnMvTnVsbEZ1bmMudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9FZGdlTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL01hcC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvTWF0NHg0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1BoeXNpY3MvSGl0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9RdWV1ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1N0YWNrLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL0RlYnVnLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL1N0YXRzLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FdmVudFF1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnQudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFR5cGUudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL1JlY2VpdmVyLnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0LnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0SGFuZGxlci50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0Vudmlyb25tZW50SW5pdGlhbGl6ZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9GaXhlZFVwZGF0ZUdhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZS50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvQ2FudmFzTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BvaW50LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1JlY3QudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvbi50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXMudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGgudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaC50cyIsInNyYy9Xb2xmaWUyRC9QaHlzaWNzL0Jhc2ljUGh5c2ljc01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGh5c2ljcy9QaHlzaWNzTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QbGF5YmFjay9SZWNvcmRlci50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1JlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnkudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvQW5pbWF0aW9uVHlwZXMudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9HcmFwaGljUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9UaWxlbWFwUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvTGFiZWxTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9Qb2ludFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1F1YWRTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvU3ByaXRlU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1ZpZXdwb3J0LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9DYW52YXNOb2RlRmFjdG9yeS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL1RpbGVtYXBGYWN0b3J5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9VSUxheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvU291bmQvQXVkaW9NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1RpbWluZy9UaW1lck1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvQ29sb3IudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvRWFzZUZ1bmN0aW9ucy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9HcmFwaFV0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL01hdGhVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9SZW5kZXJpbmdVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9TdHJpbmdVdGlscy50cyIsInNyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQSwwRUFBbUU7QUFDbkUsb0ZBQTZFO0FBRTdFLGdEQUF5QztBQUV6QyxNQUFxQixjQUFlLFNBQVEsa0JBQTJCO0lBQzVELE9BQU87UUFDVixNQUFNLEVBQUUsR0FBRyx5QkFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXpDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxF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QUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFFBQWMsRUFBRSxZQUFtQixFQUFFLFFBQWU7UUFDdEQsSUFBRyxDQUFDLFlBQVksRUFBQztZQUNiLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsSUFBRyxDQUFDLFFBQVEsRUFBQztZQUNULFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1NBQzVCO1FBRUQsSUFBSSxPQUFPLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQztRQUM1QyxJQUFJLE9BQU8sR0FBRyxZQUFZLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDO1FBRTVDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0YsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUzRixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLElBQUksRUFBRSxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELFlBQVk7SUFDWixLQUFLO1FBQ0QsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUNoRSxD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QUksRUFDaEUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxVQUFVLENBQUMsSUFBVSxFQUFFLE1BQVksRUFBRSxJQUFZO1FBQzdDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDakQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUNwQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsSUFBVSxFQUFFLElBQVk7UUFDL0IsZ0NBQWdDO1FBQ2hDLElBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFDO1lBQ2xCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDOUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztTQUN2RztRQUVELHNEQUFzRDtRQUN0RCxJQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBQztZQUN4QixJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDM0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQzNDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7U0FDekc7SUFDTCxDQUFDO0NBQ0o7QUE3REQsa0NBNkRDOzs7O0FDdkVELDJFQUFvRTtBQUdwRSwrQ0FBd0M7QUFHeEM7O0dBRUc7QUFDSCxNQUFxQixlQUFlO0lBS2hDLFlBQVksR0FBNkI7UUFDckMsSUFBSSxDQUFDLGVBQWUsR0FBRyx5QkFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3JELElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRLENBQUMsS0FBWTtRQUNqQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztJQUN2QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsdUJBQXVCLENBQUMsT0FBMEI7UUFDOUMsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUM7UUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRXJELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNsRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3JDLElBQUksV0FBVyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUUxRCxJQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUM7WUFDZixJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzVDLElBQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7WUFFakQsS0FBSSxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFDO2dCQUMzQyxLQUFJLElBQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUM7b0JBQzNDLGdDQUFnQztvQkFDaEMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLGNBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFFbkQsbURBQW1EO29CQUNuRCxNQUFNLElBQUksR0FBRyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQztvQkFDekIsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7b0JBQzVDLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUM7b0JBRXBCLHdEQUF3RDtvQkFDeEQsS0FBSSxJQUFJLE9BQU8sSUFBSSxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUM7d0JBQ3JDLElBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBQzs0QkFDckIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO3lCQUM5RTtxQkFDSjtpQkFDSjthQUNKO1NBQ0o7UUFFRCxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxhQUFhLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNPLFVBQVUsQ0FBQyxPQUFnQixFQUFFLFNBQWlCLEVBQUUsVUFBa0IsRUFBRSxVQUFrQixFQUFFLE1BQVksRUFBRSxLQUFXLEVBQUUsSUFBWSxFQUFFLE9BQWU7UUFDdEosSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7UUFFakUscUJBQXFCO1FBQ3JCLElBQUksS0FBSyxHQUFHLFNBQVMsR0FBRyxPQUFPLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFaEQsaURBQWlEO1FBQ2pELElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELElBQUksR0FBRyxHQUFHLEtBQUssR0FBRyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXJDLDhEQUE4RDtRQUM5RCxJQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDO1FBQ3ZCLElBQUksR0FBRyxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7UUFFdkIseURBQXlEO1FBQ3pELElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVsRCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQ25ELElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFFckQsSUFBRyxPQUFPLEtBQUssQ0FBQyxFQUFDO1lBQ2IsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2YsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2YsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2YsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBRWYscUJBQXFCO1lBQ3JCLElBQUcsT0FBTyxHQUFHLENBQUMsRUFBQztnQkFDWCxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDZjtZQUVELHFCQUFxQjtZQUNyQixJQUFHLE9BQU8sR0FBRyxDQUFDLEVBQUM7Z0JBQ1gsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQ2Y7WUFFRCx5QkFBeUI7WUFDekIsSUFBRyxPQUFPLEdBQUcsQ0FBQyxFQUFDO2dCQUNYLE1BQU0sR0FBRyxNQUFNLENBQUM7Z0JBQ2hCLE1BQU0sR0FBRyxNQUFNLENBQUM7Z0JBQ2hCLE1BQU0sR0FBRyxDQUFDLENBQUM7Z0JBQ1gsTUFBTSxHQUFHLENBQUMsQ0FBQzthQUNkO1lBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sR0FBRyxVQUFVLEdBQUMsQ0FBQyxFQUFFLE1BQU0sR0FBRyxXQUFXLEdBQUMsQ0FBQyxDQUFDLENBQUM7WUFFckcsa0JBQWtCO1lBQ2xCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFDcEIsSUFBSSxFQUFFLEdBQUcsRUFDVCxLQUFLLEVBQUUsTUFBTSxFQUNiLENBQUMsVUFBVSxHQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsR0FBQyxDQUFDLEVBQzdCLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQztZQUU3QixJQUFHLE9BQU8sS0FBSyxDQUFDLEVBQUM7Z0JBQ2IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUMzQztTQUNKO2FBQU07WUFDSCxnRUFBZ0U7WUFDaEUsa0JBQWtCO1lBQ2xCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFDcEIsSUFBSSxFQUFFLEdBQUcsRUFDVCxLQUFLLEVBQUUsTUFBTSxFQUNiLE1BQU0sRUFBRSxNQUFNLEVBQ2QsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1NBQ2hDO0lBR0wsQ0FBQztDQUNKO0FBN0lELGtDQTZJQzs7OztBQ3RKRCwrQ0FBd0M7QUFLeEMsMkVBQW9FO0FBRXBFLHFEQUE4QztBQUU5Qzs7R0FFRztBQUNILE1BQXFCLGlCQUFpQjtJQUtsQyxZQUFZLEdBQTZCO1FBQ3JDLElBQUksQ0FBQyxlQUFlLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNyRCxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUNuQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxDQUFDLEtBQVk7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVcsQ0FBQyxLQUFZO1FBQ3BCLHFFQUFxRTtRQUNyRSxLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTFDLDREQUE0RDtRQUM1RCxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQztRQUVuQywwQ0FBMEM7UUFDaEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3RDLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFakQsa0RBQWtEO1FBQ2xELElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3JFLElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUN4RCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFakQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLG9CQUFvQixFQUFFLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDbkUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztRQUN2QyxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUMxRCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFFakQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDaEQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXBGLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLGFBQWEsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWSxDQUFDLE1BQWM7UUFDdkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWSxDQUFDLE1BQWM7UUFDN0IsNERBQTREO1FBQzVELElBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUU5Qyw2QkFBNkI7UUFDN0IsSUFBSSxVQUFVLEdBQUcsSUFBSSxjQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFNUMsa0JBQWtCO1FBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDbkQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUMvQyxVQUFVLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXJELHNDQUFzQztRQUN0QyxJQUFJLENBQUMsR0FBRyxtQkFBUyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFFN0UsZUFBZTtRQUNyQixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2hELElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQ3hELE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUU3RCxrQkFBa0I7UUFDbEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsYUFBYSxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxlQUFlLENBQUMsU0FBb0I7UUFDaEMsMEJBQTBCO1FBQzFCLElBQUcsU0FBUyxDQUFDLE9BQU8sSUFBSSxTQUFTLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUM7WUFDdEQsU0FBUyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUM7U0FDekI7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTVCLElBQUcsU0FBUyxDQUFDLE9BQU8sRUFBQztZQUNqQixJQUFHLFNBQVMsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBQztnQkFDakMsU0FBUyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDM0U7WUFFRCxTQUFTLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQztZQUM3QixJQUFHLFNBQVMsQ0FBQyxhQUFhLElBQUksRUFBRSxFQUFDO2dCQUM3QixTQUFTLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQzthQUMvQjtTQUNKO0lBQ0wsQ0FBQztDQUVKO0FBakhELG9DQWlIQzs7OztBQ3RIRCx3RUFBaUU7QUFLakU7O0dBRUc7QUFDSCxNQUE4QixnQkFBZ0I7SUFPMUM7UUFDSSxJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxLQUFZO1FBQ2pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7Q0FvREo7QUFyRUQsbUNBcUVDOzs7O0FDbEZELDRDQUFxQztBQUdyQyw4Q0FBdUM7QUFFdkMsbURBQTRDO0FBQzVDLGlEQUEwQztBQUMxQyxvRUFBNkQ7QUFDN0Qsb0RBQTZDO0FBRTdDLGtEQUEyQztBQUMzQyxxREFBOEM7QUFDOUMsMEVBQW1FO0FBQ25FLGlFQUEwRDtBQUMxRCx3RUFBaUU7QUFDakUsaUVBQTBEO0FBSTFELHlEQUFrRDtBQUdsRCxNQUFxQixhQUFjLFNBQVEsMEJBQWdCO0lBUzFELGdCQUFnQixDQUFDLE1BQXlCLEVBQUUsS0FBYSxFQUFFLE1BQWM7UUFDeEUsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDZixNQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUU3QixJQUFJLENBQUMsU0FBUyxHQUFHLGNBQUksQ0FBQyxJQUFJLENBQUM7UUFDM0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUUxQix3QkFBd0I7UUFDbEIsSUFBSSxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTNDLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFcEQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUNsRSxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXhDLDhDQUE4QztRQUM5Qyx5QkFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXRELDJDQUEyQztRQUMzQyxJQUFJLFVBQVUsR0FBc0IsUUFBUSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUMzRSxVQUFVLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUMxQixJQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFM0MseURBQXlEO1FBQ3pELFVBQVUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQzNCLFVBQVUsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBRW5CLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQsTUFBTSxDQUFDLFVBQXdCLEVBQUUsUUFBbUIsRUFBRSxRQUFzQjtRQUMzRSxLQUFJLElBQUksSUFBSSxJQUFJLFVBQVUsRUFBQztZQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3RCO1FBRUQsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN0QixJQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUU7Z0JBQy9CLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBYSxJQUFJLENBQUMsQ0FBQyxDQUFBO1FBQ2pGLENBQUMsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELEtBQUssQ0FBQyxLQUFZO1FBQ2pCLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RCxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUVuRSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVTLFVBQVUsQ0FBQyxJQUFnQjtRQUNwQyxnRUFBZ0U7UUFDMUQsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWxELGtDQUFrQztRQUNsQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFNUMsSUFBRyxJQUFJLENBQUMsZUFBZSxFQUFDO1lBQ3ZCLHFEQUFxRDtZQUNyRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3hCO2FBQU0sSUFBRyxJQUFJLFlBQVksaUJBQU8sRUFBQztZQUNqQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3pCO2FBQU0sSUFBRyxJQUFJLFlBQVksZ0JBQU0sRUFBQztZQUNoQyxJQUFHLElBQUksWUFBWSx3QkFBYyxFQUFDO2dCQUNqQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDaEM7aUJBQU07Z0JBQ04sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN4QjtTQUNEO2FBQU0sSUFBRyxJQUFJLFlBQVksbUJBQVMsRUFBQztZQUNuQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzNCO0lBQ0YsQ0FBQztJQUVTLFlBQVksQ0FBQyxNQUFjO1FBQ3BDLElBQUksTUFBTSxHQUFHLHlCQUFlLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNqRSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVTLG9CQUFvQixDQUFDLE1BQXNCO1FBQ3BELElBQUksTUFBTSxHQUFHLHlCQUFlLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNqRSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVTLGFBQWEsQ0FBQyxPQUFnQjtRQUV2QyxJQUFHLE9BQU8sWUFBWSxlQUFLLEVBQUM7WUFDM0IsSUFBSSxNQUFNLEdBQUcseUJBQWUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDdEUsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ25FLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNoQzthQUFNLElBQUcsT0FBTyxZQUFZLGNBQUksRUFBRTtZQUNsQyxJQUFJLE1BQU0sR0FBRyx5QkFBZSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNyRSxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDbkUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2hDO0lBQ0YsQ0FBQztJQUVTLGFBQWEsQ0FBQyxPQUFnQjtRQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVTLGVBQWUsQ0FBQyxTQUFvQjtRQUM3QyxJQUFHLFNBQVMsWUFBWSxlQUFLLEVBQUM7WUFDN0IsSUFBSSxNQUFNLEdBQUcseUJBQWUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDdEUsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ3ZFLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUVoQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMxSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN6QyxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQztZQUMzQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDO1lBRTNDLGNBQWM7WUFDZCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxTQUFTLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDOUMsSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN6RCxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUN4RCxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUNqRCxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7WUFFcEcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDbEQ7SUFDRixDQUFDO0lBRVMsWUFBWSxDQUFDLElBQWdCO1FBQ3RDLElBQUksTUFBTSxHQUFHLHlCQUFlLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDL0QsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzdELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRVMsVUFBVSxDQUFDLE9BQTRCLEVBQUUsSUFBZ0I7UUFDbEUsMkNBQTJDO1FBQzNDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUVuQyw2Q0FBNkM7UUFDN0MsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzVCLElBQUksUUFBUSxHQUFHLElBQUksY0FBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM5QixJQUFHLEtBQUssWUFBWSx1QkFBYSxFQUFDO1lBQ2pDLFFBQVEsR0FBbUIsS0FBTSxDQUFDLFFBQVEsQ0FBQztTQUMzQztRQUVELE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFcEQsT0FBTyxPQUFPLENBQUM7SUFDaEIsQ0FBQztDQUVEO0FBN0pELGdDQTZKQzs7OztBQ25MRCwyRUFBb0U7QUFFcEU7Ozs7R0FJRztBQUNILE1BQThCLFVBQVU7SUFVdkMsWUFBWSxVQUFrQjtRQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQWVEOzs7O09BSUc7SUFDSCxVQUFVLENBQUMsSUFBZ0IsSUFBd0IsT0FBTyxFQUFFLENBQUMsQ0FBQSxDQUFDO0NBQzlEO0FBbENELDZCQWtDQzs7OztBQzNDRCxzREFBK0M7QUFDL0Msa0RBQTJDO0FBSTNDLDhFQUF1RTtBQUN2RSxxREFBOEM7QUFFOUMsTUFBcUIsZUFBZ0IsU0FBUSx3QkFBYztJQUUxRCxZQUFZLFVBQWtCO1FBQzdCLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQUVELGdCQUFnQjtRQUNmLElBQUksQ0FBQyxlQUFlLEdBQUcsT0FBTyxDQUFDO1FBQy9CLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsTUFBTSxDQUFDLEVBQXlCLEVBQUUsT0FBNEI7UUFDN0QsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMxRCxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWxELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3ZFLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUVwRSxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXZCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVwRSxNQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsaUJBQWlCLENBQUM7UUFFM0Msa0JBQWtCO1FBQ2xCLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN2QyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsVUFBVSxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUUzRCxhQUFhO1FBQ2IsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUMvRCxFQUFFLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztRQUM3RSxFQUFFLENBQUMsdUJBQXVCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFdkMsV0FBVztRQUNYLE1BQU0saUJBQWlCLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBQzlFLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFFNUMsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztRQUM1RSxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUVwQyxNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlELEVBQUUsQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTdELDRCQUE0QjtRQUM1QixxRkFBcUY7UUFDckYsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXRELE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFDNUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLFdBQVcsR0FBQyxZQUFZLENBQUMsQ0FBQztRQUV4RCxNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDOUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsT0FBTyxDQUFDLFlBQVksR0FBQyxZQUFZLENBQUMsQ0FBQztRQUVoRSwrRUFBK0U7UUFDL0UsSUFBSSxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFcEcsd0NBQXdDO1FBQ3hDLE1BQU0sVUFBVSxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsWUFBWSxDQUFDO1FBQ2hHLE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxZQUFZLENBQUM7UUFFakcsbUNBQW1DO1FBQ25DLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdkMsSUFBSSxjQUFjLEdBQUcsZ0JBQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5RSw0Q0FBNEM7UUFDNUMsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQztRQUNsRSxFQUFFLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUVsRSxnQkFBZ0I7UUFDaEIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxXQUFXLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDL0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRVQsSUFBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQ1IsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNSLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjthQUFNO1lBQ04sQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNSLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjtRQUVELE9BQU8sSUFBSSxZQUFZLENBQUM7WUFDdkIsQ0FBQyxDQUFDLEVBQUcsQ0FBQztZQUNOLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNMLENBQUMsRUFBRyxDQUFDO1lBQ0wsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNOLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxVQUFVLENBQUMsSUFBVztRQUNyQixJQUFJLE9BQU8sR0FBd0I7WUFDbEMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLGVBQWUsRUFBRSxJQUFJLENBQUMsd0JBQXdCLEVBQUU7WUFDdkMsV0FBVyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUN4QyxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1lBQ3hDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNmLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtTQUN2QixDQUFBO1FBRUQsT0FBTyxPQUFPLENBQUM7SUFDaEIsQ0FBQztDQUNEO0FBakhELGtDQWlIQzs7OztBQ3RIRCxrRUFBMkQ7QUFDM0QsOENBQXVDO0FBRXZDLE1BQXFCLGVBQWdCLFNBQVEsb0JBQVU7SUFJdEQsWUFBWSxVQUFrQjtRQUM3QixLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVELGdCQUFnQjtRQUNmLElBQUksQ0FBQyxlQUFlLEdBQUcsT0FBTyxDQUFDO1FBQy9CLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsTUFBTSxDQUFDLEVBQXlCLEVBQUUsT0FBNEI7UUFDN0QsSUFBSSxRQUFRLEdBQUcsd0JBQWMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRyxJQUFJLEtBQUssR0FBRyx3QkFBYyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdkQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdkUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRXBFLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkIsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDO1FBRTVCLE1BQU0sS0FBSyxHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztRQUUzQyxrQkFBa0I7UUFDbEIsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3ZDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxVQUFVLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTNELGFBQWE7UUFDYixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQy9ELEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQzdFLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUV2QyxXQUFXO1FBQ1gsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztRQUMxRCxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU5QixNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2xFLEVBQUUsQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUU3QyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxVQUFVLENBQUMsS0FBWTtRQUN0QixJQUFJLE9BQU8sR0FBd0I7WUFDbEMsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO1lBQ3hCLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSztZQUNsQixTQUFTLEVBQUUsS0FBSyxDQUFDLElBQUk7U0FDckIsQ0FBQTtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2hCLENBQUM7Q0FDRDtBQXRERCxrQ0FzREM7Ozs7QUM1REQsc0RBQStDO0FBQy9DLDhDQUF1QztBQUV2Qyx5SEFBeUg7QUFDekgsTUFBOEIsY0FBZSxTQUFRLG9CQUFVO0lBYTlELFlBQVksVUFBa0I7UUFDN0IsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRWxCLElBQUksQ0FBQyxLQUFLLEdBQUcsZ0JBQU0sQ0FBQyxRQUFRLENBQUM7UUFDN0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxnQkFBTSxDQUFDLFFBQVEsQ0FBQztRQUNoQyxJQUFJLENBQUMsV0FBVyxHQUFHLGdCQUFNLENBQUMsUUFBUSxDQUFDO0lBQ3BDLENBQUM7Q0FDRDtBQXBCRCxpQ0FvQkM7Ozs7QUN4QkQsc0RBQStDO0FBQy9DLGtEQUEyQztBQUUzQyw4RUFBdUU7QUFDdkUscURBQThDO0FBRTlDLE1BQXFCLGNBQWUsU0FBUSx3QkFBYztJQUV6RCxZQUFZLFVBQWtCO1FBQzdCLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQUVELGdCQUFnQjtRQUNmLElBQUksQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDO1FBQzlCLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsTUFBTSxDQUFDLEVBQXlCLEVBQUUsT0FBNEI7UUFDN0QsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUV0QyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN2RSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFFcEUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV2QixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFcEUsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLGlCQUFpQixDQUFDO1FBRTNDLGtCQUFrQjtRQUNsQixFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDdkMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLFVBQVUsRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFM0QsYUFBYTtRQUNiLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDL0QsRUFBRSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDN0UsRUFBRSxDQUFDLHVCQUF1QixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXZDLFdBQVc7UUFDWCxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzFELEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTlCLDRCQUE0QjtRQUM1QixxRkFBcUY7UUFDckYsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTVELCtFQUErRTtRQUMvRSxJQUFJLElBQUksR0FBRyxJQUFJLGNBQUksQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVwRyx3Q0FBd0M7UUFDeEMsTUFBTSxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxZQUFZLENBQUM7UUFDaEcsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLFlBQVksQ0FBQztRQUVqRyxtQ0FBbUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN2QyxJQUFJLGNBQWMsR0FBRyxnQkFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTlFLDRDQUE0QztRQUM1QyxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2xFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRWxFLGdCQUFnQjtRQUNoQixFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BMkJFO0lBQ0Y7Ozs7O09BS0c7SUFDSCxXQUFXLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDL0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRVQsSUFBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQ1IsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNSLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjthQUFNO1lBQ04sQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNSLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjtRQUVELE9BQU8sSUFBSSxZQUFZLENBQUM7WUFDdkIsQ0FBQyxDQUFDLEVBQUcsQ0FBQztZQUNOLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNMLENBQUMsRUFBRyxDQUFDO1lBQ0wsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNOLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxVQUFVLENBQUMsSUFBVTtRQUNwQixJQUFJLE9BQU8sR0FBd0I7WUFDbEMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7U0FDdkIsQ0FBQTtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2hCLENBQUM7Q0FDRDtBQTlIRCxpQ0E4SEM7Ozs7QUNwSUQsc0RBQStDO0FBQy9DLGtEQUEyQztBQUUzQywwRUFBbUU7QUFFbkUsOEVBQXVFO0FBQ3ZFLHFEQUE4QztBQUU5QyxnREFBZ0Q7QUFDaEQsTUFBcUIsZ0JBQWlCLFNBQVEsd0JBQWM7SUFDM0QsWUFBWSxVQUFrQjtRQUM3QixLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbEIsSUFBSSxDQUFDLGVBQWUsR0FBRyx5QkFBZSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3RELENBQUM7SUFFRCxnQkFBZ0I7UUFDZixJQUFJLENBQUMsZUFBZSxHQUFHLFFBQVEsQ0FBQztRQUNoQyxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVELE1BQU0sQ0FBQyxFQUF5QixFQUFFLE9BQTRCO1FBQzdELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3ZFLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNwRSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFbEUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV2QixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVuRixNQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsaUJBQWlCLENBQUM7UUFFM0Msa0JBQWtCO1FBQ2xCLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN2QyxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsVUFBVSxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUUzRCxhQUFhO1FBQ2IsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUMvRCxFQUFFLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztRQUM3RSxFQUFFLENBQUMsdUJBQXVCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFdkMsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUMvRCxFQUFFLENBQUMsbUJBQW1CLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzRSxFQUFFLENBQUMsdUJBQXVCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFdkMsV0FBVztRQUNYLDRCQUE0QjtRQUM1QixxRkFBcUY7UUFDckYsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTVELCtFQUErRTtRQUMvRSxJQUFJLElBQUksR0FBRyxJQUFJLGNBQUksQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVwRyx3Q0FBd0M7UUFDeEMsTUFBTSxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBQyxZQUFZLENBQUM7UUFDaEcsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLFlBQVksQ0FBQztRQUVqRyxtQ0FBbUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN2QyxJQUFJLGNBQWMsR0FBRyxnQkFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTlFLDRDQUE0QztRQUM1QyxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ2xFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRWxFLG9EQUFvRDtRQUNwRCxNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlELEVBQUUsQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRWpDLG1CQUFtQjtRQUNuQixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ2hFLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU1QyxtQkFBbUI7UUFDbkIsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNoRSxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFNUMsZ0JBQWdCO1FBQ2hCLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsV0FBVyxDQUFDLENBQVMsRUFBRSxDQUFTLEVBQUUsS0FBbUI7UUFDcEQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRVQsSUFBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQ1IsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNSLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjthQUFNO1lBQ04sQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNSLENBQUMsR0FBRyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7U0FDWjtRQUVELHNDQUFzQztRQUN0QyxDQUFDLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2QsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVkLE9BQU8sSUFBSSxZQUFZLENBQUM7WUFDdkIsQ0FBQyxDQUFDLEVBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHO1lBQ2hCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHO1lBQ2YsQ0FBQyxFQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRztZQUNmLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRztTQUNoQixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsVUFBVSxDQUFDLE1BQWM7UUFDeEIsSUFBSSxRQUFRLENBQUM7UUFDYixJQUFJLFFBQVEsQ0FBQztRQUViLElBQUcsTUFBTSxZQUFZLHdCQUFjLEVBQUM7WUFDbkMsSUFBSSxjQUFjLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQywyQkFBMkIsRUFBRSxDQUFDO1lBQ3BFLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUN2RCxRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xILFFBQVEsR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2hFO2FBQU07WUFDTixRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwQztRQUVELElBQUksT0FBTyxHQUF3QjtZQUNsQyxRQUFRLEVBQUUsTUFBTSxDQUFDLFFBQVE7WUFDekIsUUFBUSxFQUFFLE1BQU0sQ0FBQyxRQUFRO1lBQ3pCLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtZQUNqQixLQUFLLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUU7WUFDN0IsUUFBUSxFQUFFLE1BQU0sQ0FBQyxPQUFPO1lBQ3hCLFFBQVE7WUFDUixRQUFRO1NBQ1IsQ0FBQTtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2hCLENBQUM7Q0FDRDtBQWhJRCxtQ0FnSUM7Ozs7QUN6SUQsMENBQW1DO0FBQ25DLDhDQUF1QztBQUV2QyxzREFBK0M7QUFDL0Msd0RBQWlEO0FBRWpELDhFQUF1RTtBQUV2RTs7Ozs7O0dBTUc7QUFDSCxNQUFxQixlQUFlO0lBbUZoQztRQUNJLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBRXhCLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLHFCQUFxQixHQUFHLENBQUMsQ0FBQztRQUMvQixJQUFJLENBQUMsMEJBQTBCLEdBQUcsSUFBSSxlQUFLLEVBQUUsQ0FBQztRQUM5QyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFFeEIsSUFBSSxDQUFDLDJCQUEyQixHQUFHLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsMkJBQTJCLEdBQUcsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxJQUFJLGVBQUssRUFBRSxDQUFDO1FBQ3BELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxhQUFHLEVBQUUsQ0FBQztRQUU5QixJQUFJLENBQUMsdUJBQXVCLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLDRCQUE0QixHQUFHLElBQUksZUFBSyxFQUFFLENBQUM7UUFDaEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBRTFCLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLG9CQUFvQixHQUFHLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsMEJBQTBCLEdBQUcsSUFBSSxlQUFLLEVBQUUsQ0FBQztRQUM5QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFFOUIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLENBQUMsQ0FBQztRQUM3QixJQUFJLENBQUMsbUJBQW1CLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyx5QkFBeUIsR0FBRyxJQUFJLGVBQUssRUFBRSxDQUFDO1FBQzdDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxhQUFHLEVBQUUsQ0FBQztRQUU3QixJQUFJLENBQUMsZ0NBQWdDLEdBQUcsQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxDQUFDLENBQUM7UUFDMUMsSUFBSSxDQUFDLDhCQUE4QixHQUFHLElBQUksZUFBSyxFQUFFLENBQUM7UUFFbEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFFbkMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBRTVCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBQUEsQ0FBQztJQUVGLGdHQUFnRztJQUNoRzs7O09BR0c7SUFDSCxNQUFNLENBQUMsV0FBVztRQUNkLElBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFDO1lBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO1NBQ3pDO1FBRUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxzR0FBc0c7SUFDdEc7Ozs7T0FJRztJQUNJLFFBQVEsQ0FBQyxJQUFhLEVBQUUsRUFBeUI7UUFDcEQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFFM0IsSUFBRyxJQUFJLENBQUMsY0FBYyxFQUFDO1lBQ25CLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1NBQ2hCO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsR0FBVyxFQUFFLElBQVk7UUFDbEMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sQ0FBQyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7SUFDcEUsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFNBQVMsQ0FBQyxHQUFXO1FBQ3hCLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMvQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLFFBQVEsQ0FBQyxHQUFXO1FBQ3ZCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLElBQUcsS0FBSyxLQUFLLFNBQVMsRUFBQztZQUNuQixPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN6QixNQUFNLDBDQUEwQyxHQUFHLEdBQUcsQ0FBQTtTQUN6RDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksV0FBVyxDQUFDLEdBQVcsRUFBRSxJQUFZO1FBQ3hDLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxPQUFPLENBQUMsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7O09BR0c7SUFDSSxlQUFlLENBQUMsR0FBVztRQUM5QixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxjQUFjLENBQUMsR0FBVztRQUM3QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLEdBQVcsRUFBRSxJQUFZO1FBQ2xDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUMsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7O09BR0c7SUFDSyxTQUFTLENBQUMsR0FBVztRQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxRQUFRLENBQUMsR0FBVztRQUN2QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksT0FBTyxDQUFDLEdBQVcsRUFBRSxJQUFZO1FBQ3BDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxPQUFPLENBQUMsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFFRDs7O09BR0c7SUFDSyxXQUFXLENBQUMsR0FBVztRQUMzQixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxVQUFVLENBQUMsR0FBVztRQUN6QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLEdBQVcsRUFBRSxJQUFZO1FBQ25DLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxPQUFPLENBQUMsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRDs7O09BR0c7SUFDSyxVQUFVLENBQUMsR0FBVztRQUMxQixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxTQUFTLENBQUMsR0FBVztRQUN4QixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxvR0FBb0c7SUFDcEc7OztPQUdHO0lBQ0gsc0JBQXNCLENBQUMsUUFBa0I7UUFDckMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLENBQUMsQ0FBQztRQUU5QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUVwQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsRUFBRTtZQUM1QixPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDL0IsSUFBSSxDQUFDLHlCQUF5QixDQUFDLEdBQUcsRUFBRTtnQkFDaEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO2dCQUNuQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxFQUFFO29CQUMxQixPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDO29CQUM3QixJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFO3dCQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO3dCQUM1QixJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxFQUFFOzRCQUMzQixPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7NEJBRTlCLElBQUcsSUFBSSxDQUFDLGNBQWMsRUFBQztnQ0FDbkIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsRUFBRTtvQ0FDOUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO29DQUM5QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dDQUNqQyxDQUFDLENBQUMsQ0FBQzs2QkFDTjtpQ0FBTTtnQ0FDSCxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzZCQUNoQzt3QkFDTCxDQUFDLENBQUMsQ0FBQTtvQkFDTixDQUFDLENBQUMsQ0FBQztnQkFDUCxDQUFDLENBQUMsQ0FBQztZQUNQLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU8sYUFBYSxDQUFDLFFBQWtCO1FBQ3BDLGVBQWU7UUFDZixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNyQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUN2QixRQUFRLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFFRCxzR0FBc0c7SUFFOUYsWUFBWSxDQUFDLEdBQVcsRUFBRSxJQUFrQjtRQUNoRCxPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDaEMsS0FBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUM7WUFDbEQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLElBQUcsUUFBUSxDQUFDLEdBQUcsS0FBSyxHQUFHLElBQUksUUFBUSxDQUFDLFlBQVksS0FBSyxJQUFJLEVBQUM7Z0JBQ3RELE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEdBQUcsR0FBRyxHQUFHLFdBQVcsR0FBRyxJQUFJLEdBQUcsWUFBWSxDQUFDLENBQUM7Z0JBQ3pFLElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUN6RCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDO2dCQUM3QyxPQUFPO2FBQ1Y7U0FDSjtJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNILGtCQUFrQjtRQUNkLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBRXhCLEtBQUksSUFBSSxRQUFRLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFDO1lBQ3ZDLHNCQUFzQjtZQUN0QixJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ2pDO0lBQ0wsQ0FBQztJQUVPLGNBQWMsQ0FBQyxRQUEyQjtRQUM5Qyw2QkFBNkI7UUFDN0IsUUFBTyxRQUFRLENBQUMsWUFBWSxFQUFDO1lBQ3pCLEtBQUssWUFBWSxDQUFDLEtBQUs7Z0JBQ25CLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDakMsSUFBRyxJQUFJLENBQUMsY0FBYyxFQUFDO29CQUNuQixJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ3pDO2dCQUNELE1BQU07WUFDVixLQUFLLFlBQVksQ0FBQyxPQUFPO2dCQUNyQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ25DLE1BQU07WUFDVixLQUFLLFlBQVksQ0FBQyxXQUFXO2dCQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZDLE1BQU07WUFDVixLQUFLLFlBQVksQ0FBQyxLQUFLO2dCQUNuQixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3ZDLE1BQU07WUFDVixLQUFLLFlBQVksQ0FBQyxJQUFJO2dCQUNsQixJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3RDLE1BQU07WUFDVixLQUFLLFlBQVksQ0FBQyxNQUFNO2dCQUNwQixJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUN6RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDNUMsTUFBTTtTQUNiO1FBRUQsMEJBQTBCO1FBQzFCLEtBQUksSUFBSSxVQUFVLElBQUksUUFBUSxDQUFDLFlBQVksRUFBQztZQUN4QyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ25DO0lBQ0wsQ0FBQztJQUVELHFHQUFxRztJQUNyRzs7O09BR0c7SUFDSyxxQkFBcUIsQ0FBQyxlQUF5QjtRQUNuRCxJQUFJLENBQUMsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLDRCQUE0QixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzNFLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLENBQUM7UUFFakMsc0NBQXNDO1FBQ3RDLElBQUcsSUFBSSxDQUFDLHVCQUF1QixLQUFLLENBQUMsRUFBQztZQUNsQyxlQUFlLEVBQUUsQ0FBQztZQUNsQixPQUFPO1NBQ1Y7UUFFRCxPQUFNLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxRQUFRLEVBQUUsRUFBQztZQUMvQyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsNEJBQTRCLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDMUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7U0FDaEU7SUFDTCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxXQUFXLENBQUMsR0FBVyxFQUFFLGlCQUF5QixFQUFFLGNBQXdCO1FBQ2hGLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxRQUFnQixFQUFFLEVBQUU7WUFDdEQsSUFBSSxhQUFhLEdBQXFCLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFM0QsZ0VBQWdFO1lBQ2hFLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUN0QyxJQUFJLFFBQVEsR0FBRyxJQUFJLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFaEUsaUZBQWlGO1lBQ2pGLEtBQUksSUFBSSxPQUFPLElBQUksYUFBYSxDQUFDLFFBQVEsRUFBQztnQkFDdEMsSUFBRyxPQUFPLENBQUMsS0FBSyxFQUFDO29CQUNiLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7b0JBQ3hCLElBQUksSUFBSSxHQUFHLHFCQUFXLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLENBQUMsR0FBRyxHQUFHLENBQUM7b0JBQ3BFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUMsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7b0JBRXBGLGdEQUFnRDtvQkFDaEQsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztpQkFDMUU7cUJBQU0sSUFBRyxPQUFPLENBQUMsS0FBSyxFQUFDO29CQUNwQixLQUFJLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUM7d0JBQzFCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7d0JBQ3JCLElBQUksSUFBSSxHQUFHLHFCQUFXLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLENBQUMsR0FBRyxHQUFHLENBQUM7d0JBQ3BFLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUMsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7d0JBRXBGLGdEQUFnRDt3QkFDaEQsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztxQkFDMUU7aUJBQ0o7YUFDSjtZQUVELCtEQUErRDtZQUMvRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXRDLGlCQUFpQjtZQUNqQixJQUFJLENBQUMsb0JBQW9CLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDOUMsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssb0JBQW9CLENBQUMsUUFBa0I7UUFDM0MsSUFBSSxDQUFDLHVCQUF1QixJQUFJLENBQUMsQ0FBQztRQUVsQyxJQUFHLElBQUksQ0FBQyx1QkFBdUIsS0FBSyxJQUFJLENBQUMsdUJBQXVCLEVBQUM7WUFDN0QsOEJBQThCO1lBQzlCLFFBQVEsRUFBRSxDQUFDO1NBQ2Q7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0sseUJBQXlCLENBQUMsZUFBeUI7UUFDdkQsSUFBSSxDQUFDLDJCQUEyQixHQUFHLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNuRixJQUFJLENBQUMsMkJBQTJCLEdBQUcsQ0FBQyxDQUFDO1FBRXJDLHNDQUFzQztRQUN0QyxJQUFHLElBQUksQ0FBQywyQkFBMkIsS0FBSyxDQUFDLEVBQUM7WUFDdEMsZUFBZSxFQUFFLENBQUM7WUFDbEIsT0FBTztTQUNWO1FBRUQsT0FBTSxJQUFJLENBQUMsZ0NBQWdDLENBQUMsUUFBUSxFQUFFLEVBQUM7WUFDbkQsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLGdDQUFnQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2xFLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1NBQzVFO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssZUFBZSxDQUFDLEdBQVcsRUFBRSxxQkFBNkIsRUFBRSxjQUF3QjtRQUN4RixJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixFQUFFLENBQUMsUUFBZ0IsRUFBRSxFQUFFO1lBQzFELElBQUksV0FBVyxHQUFnQixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXBELGdFQUFnRTtZQUNoRSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFFeEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBRXBFLHNFQUFzRTtZQUN0RSxJQUFJLElBQUksR0FBRyxxQkFBVyxDQUFDLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLEdBQUcsV0FBVyxDQUFDLGdCQUFnQixDQUFDO1lBQ2pHLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUMsRUFBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO1lBRWpHLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3BGLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFdEMsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNsRCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSyx3QkFBd0IsQ0FBQyxRQUFrQjtRQUMvQyxJQUFJLENBQUMsMkJBQTJCLElBQUksQ0FBQyxDQUFDO1FBRXRDLElBQUcsSUFBSSxDQUFDLDJCQUEyQixLQUFLLElBQUksQ0FBQywyQkFBMkIsRUFBQztZQUNyRSxrQ0FBa0M7WUFDbEMsUUFBUSxFQUFFLENBQUM7U0FDZDtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSyxtQkFBbUIsQ0FBQyxlQUF5QjtRQUNqRCxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxDQUFDLENBQUM7UUFFL0Isc0NBQXNDO1FBQ3RDLElBQUcsSUFBSSxDQUFDLHFCQUFxQixLQUFLLENBQUMsRUFBQztZQUNoQyxlQUFlLEVBQUUsQ0FBQztZQUNsQixPQUFPO1NBQ1Y7UUFFRCxPQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxRQUFRLEVBQUUsRUFBQztZQUM3QyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsMEJBQTBCLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDdEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxlQUFlLENBQUMsQ0FBQztTQUM5RTtJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLFNBQVMsQ0FBQyxHQUFXLEVBQUUsSUFBWSxFQUFFLFlBQXFCLEVBQUUsY0FBd0I7UUFDdkYsSUFBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUV4QixLQUFLLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRTtZQUNoQix1QkFBdUI7WUFDdkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRTVCLDRGQUE0RjtZQUM1RixJQUFHLENBQUMsWUFBWSxFQUFDO2dCQUNiLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDL0U7WUFFRCx1Q0FBdUM7WUFDdkMsSUFBRyxJQUFJLENBQUMsY0FBYyxFQUFDO2dCQUNuQixJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3ZDO1lBRUQsb0JBQW9CO1lBQ3BCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUE7UUFFRCxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztJQUNyQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssa0JBQWtCLENBQUMsUUFBa0I7UUFDekMsSUFBSSxDQUFDLHFCQUFxQixJQUFJLENBQUMsQ0FBQztRQUVoQyxJQUFHLElBQUksQ0FBQyxxQkFBcUIsS0FBSyxJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDMUQsNEJBQTRCO1lBQzVCLFFBQVEsRUFBRSxDQUFDO1NBQ2Q7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssa0JBQWtCLENBQUMsZUFBeUI7UUFDaEQsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0RSxJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxDQUFDO1FBRTlCLHNDQUFzQztRQUN0QyxJQUFHLElBQUksQ0FBQyxvQkFBb0IsS0FBSyxDQUFDLEVBQUM7WUFDL0IsZUFBZSxFQUFFLENBQUM7WUFDbEIsT0FBTztTQUNWO1FBRUQsT0FBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsUUFBUSxFQUFFLEVBQUM7WUFDN0MsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3RELElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1NBQzFEO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssU0FBUyxDQUFDLEdBQVcsRUFBRSxJQUFZLEVBQUUsY0FBd0I7UUFDakUsSUFBSSxRQUFRLEdBQUcsc0JBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUU1RCxJQUFJLE9BQU8sR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO1FBQ25DLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNoQyxPQUFPLENBQUMsWUFBWSxHQUFHLGFBQWEsQ0FBQztRQUVyQyxPQUFPLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRTtZQUNsQixRQUFRLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRTtnQkFDbEQsK0JBQStCO2dCQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBQ25DLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBRTVFLHVCQUF1QjtnQkFDdkIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzVDLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUNULE1BQU0scUJBQXFCLENBQUM7WUFDaEMsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUE7UUFDRCxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7T0FHRztJQUNLLGtCQUFrQixDQUFDLFFBQWtCO1FBQ3pDLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxDQUFDLENBQUM7UUFFL0IsSUFBRyxJQUFJLENBQUMsb0JBQW9CLEtBQUssSUFBSSxDQUFDLG9CQUFvQixFQUFDO1lBQ3ZELDJCQUEyQjtZQUMzQixRQUFRLEVBQUUsQ0FBQztTQUNkO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNLLG9CQUFvQixDQUFDLGVBQXlCO1FBQ2xELElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEUsSUFBSSxDQUFDLG1CQUFtQixHQUFHLENBQUMsQ0FBQztRQUU3QixzQ0FBc0M7UUFDdEMsSUFBRyxJQUFJLENBQUMsbUJBQW1CLEtBQUssQ0FBQyxFQUFDO1lBQzlCLGVBQWUsRUFBRSxDQUFDO1lBQ2xCLE9BQU87U0FDVjtRQUVELE9BQU0sSUFBSSxDQUFDLHlCQUF5QixDQUFDLFFBQVEsRUFBRSxFQUFDO1lBQzVDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNuRCxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztTQUN2RDtJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLFVBQVUsQ0FBQyxHQUFXLEVBQUUsSUFBWSxFQUFFLGNBQXdCO1FBQ2pFLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsUUFBZ0IsRUFBRSxFQUFFO1lBQ3pDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDL0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBRS9CLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFFM0UsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzdDLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOzs7T0FHRztJQUNLLG1CQUFtQixDQUFDLFFBQWtCO1FBQzFDLElBQUksQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLENBQUM7UUFFOUIsSUFBRyxJQUFJLENBQUMsbUJBQW1CLEtBQUssSUFBSSxDQUFDLG1CQUFtQixFQUFDO1lBQ3JELDZCQUE2QjtZQUM3QixRQUFRLEVBQUUsQ0FBQztTQUNkO0lBQ0wsQ0FBQztJQUVELG9EQUFvRDtJQUU3QyxVQUFVLENBQUMsR0FBVztRQUN6QixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFTSxnQkFBZ0IsQ0FBQyxHQUFXO1FBQy9CLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7SUFDbkQsQ0FBQztJQUVNLFNBQVMsQ0FBQyxHQUFXO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVPLGtCQUFrQixDQUFDLFFBQWdCLEVBQUUsS0FBdUI7UUFDaEUscUJBQXFCO1FBQ3JCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFM0QscUJBQXFCO1FBQ3JCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFeEMscUJBQXFCO1FBQ3JCLGtCQUFrQjtRQUNsQixJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUVqQyxnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFakQsNkJBQTZCO1FBQzdCLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0RixJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3pGLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFekYsd0JBQXdCO1FBQ3hCLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUVwRyw0REFBNEQ7UUFDNUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRXRELG9CQUFvQjtRQUNwQixJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFTyxZQUFZLENBQUMsRUFBVTtRQUMzQixxRkFBcUY7UUFDckYsNENBQTRDO1FBQzVDLFFBQU8sRUFBRSxFQUFDO1lBQ04sS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO1lBQ2hDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztZQUNoQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFDaEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO1lBQ2hDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztZQUNoQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFDaEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO1lBQ2hDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztZQUNoQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUM7WUFDaEMsT0FBTyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQztTQUNwQztJQUNMLENBQUM7SUFFTSxZQUFZLENBQUMsR0FBVztRQUMzQixJQUFHLElBQUksQ0FBQyxjQUFjLEVBQUM7WUFDbkIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUVwQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDcEM7SUFDTCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsR0FBVyxFQUFFLGVBQXVCLEVBQUUsZUFBdUI7UUFDdkUsSUFBSSxTQUFTLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMzQyxJQUFJLEdBQUcsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUUxQyxJQUFHLEdBQUcsS0FBSyxTQUFTLEVBQUM7WUFDakIsTUFBTSxHQUFHLGVBQWUsdURBQXVELENBQUM7U0FDbkY7UUFFRCxTQUFTLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QyxHQUFHLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFdEMsSUFBRyxHQUFHLEtBQUssU0FBUyxFQUFDO1lBQ2pCLE1BQU0sR0FBRyxlQUFlLHVEQUF1RCxDQUFDO1NBQ25GO1FBRUQsSUFBSSxLQUFLLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztRQUNqQyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNoQixLQUFLLENBQUMsS0FBSyxHQUFHLGVBQWUsQ0FBQztRQUM5QixLQUFLLENBQUMsS0FBSyxHQUFHLGVBQWUsQ0FBQztRQUU5QixJQUFJLENBQUMsOEJBQThCLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7O09BR0c7SUFDSyxVQUFVLENBQUMsR0FBVztRQUMxQixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVPLHVCQUF1QixDQUFDLGVBQXlCO1FBQ3JELElBQUksQ0FBQyxnQ0FBZ0MsR0FBRyxJQUFJLENBQUMsOEJBQThCLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEYsSUFBSSxDQUFDLGdDQUFnQyxHQUFHLENBQUMsQ0FBQztRQUUxQyxvRUFBb0U7UUFDcEUsSUFBRyxDQUFDLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLGdDQUFnQyxLQUFLLENBQUMsRUFBQztZQUNuRSxlQUFlLEVBQUUsQ0FBQztZQUNsQixPQUFPO1NBQ1Y7UUFFRCxPQUFNLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxRQUFRLEVBQUUsRUFBQztZQUNqRCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsOEJBQThCLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDM0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxlQUFlLENBQUMsQ0FBQztTQUMvRTtJQUNMLENBQUM7SUFFTyxhQUFhLENBQUMsR0FBVyxFQUFFLEtBQWEsRUFBRSxLQUFhLEVBQUUsY0FBd0I7UUFDckYsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxTQUFpQixFQUFFLEVBQUU7WUFDM0MsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDO1lBRTFCLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLENBQUMsU0FBaUIsRUFBRSxFQUFFO2dCQUMzQyxNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUE7Z0JBRXpCLGtDQUFrQztnQkFDbEMsTUFBTSxDQUFDLGFBQWEsRUFBRSxZQUFZLEVBQUUsY0FBYyxDQUFDLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFFakcsd0JBQXdCO2dCQUN4QixNQUFNLGNBQWMsR0FBRyxJQUFJLDBCQUFnQixFQUFFLENBQUM7Z0JBQzlDLGNBQWMsQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDO2dCQUN2QyxjQUFjLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztnQkFDM0MsY0FBYyxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7Z0JBRS9DLGlCQUFpQjtnQkFDakIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsY0FBYyxDQUFDLENBQUM7Z0JBRWhELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBRTdFLGlCQUFpQjtnQkFDakIsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ2hELENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU8sc0JBQXNCLENBQUMsUUFBa0I7UUFDN0MsSUFBSSxDQUFDLGdDQUFnQyxJQUFJLENBQUMsQ0FBQztRQUUzQyxJQUFHLElBQUksQ0FBQyxnQ0FBZ0MsS0FBSyxJQUFJLENBQUMsZ0NBQWdDLEVBQUM7WUFDL0UsNkJBQTZCO1lBQzdCLFFBQVEsRUFBRSxDQUFDO1NBQ2Q7SUFDTCxDQUFDO0lBRU8sbUJBQW1CLENBQUMsYUFBcUIsRUFBRSxhQUFxQjtRQUNwRSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDMUQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRTlELElBQUcsWUFBWSxLQUFLLElBQUksSUFBSSxjQUFjLEtBQUssSUFBSSxFQUFDO1lBQ2hELHVDQUF1QztZQUN2QyxPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsMEJBQTBCO1FBQzFCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDeEMsSUFBRyxDQUFDLE9BQU8sRUFBRTtZQUNULGlCQUFpQjtZQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7WUFDekMsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELHdDQUF3QztRQUN4QyxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRTlDLE9BQU87UUFDUCxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM3QixJQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsRUFBQztZQUMxRCxnQkFBZ0I7WUFDaEIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNqRCxPQUFPLENBQUMsSUFBSSxDQUFDLDBCQUEwQixHQUFHLEtBQUssQ0FBQyxDQUFDO1lBRWpELFdBQVc7WUFDWCxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNuQyxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNyQyxPQUFPLElBQUksQ0FBQztTQUNmO1FBRUQsbUNBQW1DO1FBQ25DLE9BQU8sQ0FBQyxPQUFPLEVBQUUsWUFBWSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFTyxnQkFBZ0IsQ0FBQyxZQUFvQjtRQUN6Qyw2QkFBNkI7UUFDN0IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxZQUFvQjtRQUMzQywrQkFBK0I7UUFDL0IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFTyxVQUFVLENBQUMsSUFBWSxFQUFFLFlBQW9CO1FBQ2pELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTFDLDBDQUEwQztRQUMxQyxJQUFHLE1BQU0sS0FBSyxJQUFJLEVBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQUM7WUFDeEMsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELDJDQUEyQztRQUMzQyxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFOUIscURBQXFEO1FBQ3JELElBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxFQUFDO1lBQzNELHVCQUF1QjtZQUN2QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQy9DLE9BQU8sQ0FBQyxJQUFJLENBQUMsNEJBQTRCLEdBQUcsS0FBSyxDQUFDLENBQUM7WUFFbkQsV0FBVztZQUNYLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzdCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCwrQkFBK0I7UUFDL0IsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVELHFEQUFxRDtJQUU3QyxZQUFZLENBQUMsWUFBb0IsRUFBRSxRQUFrQjtRQUN6RCxJQUFJLElBQUksR0FBbUIsSUFBSSxjQUFjLEVBQUUsQ0FBQztRQUNoRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLGtCQUFrQixHQUFHO1lBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsRUFBRTtnQkFDaEQsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUMvQjtRQUNMLENBQUMsQ0FBQztRQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVELDRDQUE0QztJQUVwQyxjQUFjO1FBQ2xCLE9BQU8sQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEdBQUMsSUFBSSxDQUFDLHVCQUF1QjtjQUMzRCxJQUFJLENBQUMsMkJBQTJCLEdBQUMsSUFBSSxDQUFDLDJCQUEyQjtjQUNqRSxJQUFJLENBQUMscUJBQXFCLEdBQUMsSUFBSSxDQUFDLHFCQUFxQjtjQUNyRCxJQUFJLENBQUMsb0JBQW9CLEdBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDO2NBQ3BELElBQUksQ0FBQyxvQkFBb0IsQ0FBQztJQUNwQyxDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQWM7UUFDakIsSUFBRyxJQUFJLENBQUMsT0FBTyxFQUFDO1lBQ1osSUFBRyxJQUFJLENBQUMsY0FBYyxFQUFDO2dCQUNuQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO2FBQzlDO1NBQ0o7YUFBTSxJQUFHLElBQUksQ0FBQyxVQUFVLEVBQUM7WUFDdEIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7WUFDeEIsSUFBRyxJQUFJLENBQUMsY0FBYyxFQUFDO2dCQUNuQixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7YUFDekI7U0FDSjtJQUNMLENBQUM7Q0FDSjtBQTk4QkQsa0NBODhCQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLGlCQUFpQjtJQUtuQixZQUFZLEdBQVcsRUFBRSxZQUEwQjtRQUMvQyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBRSxZQUFZLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBRUQsYUFBYSxDQUFDLFFBQTJCO1FBQ3JDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7Q0FDSjtBQUdELElBQUssWUFPSjtBQVBELFdBQUssWUFBWTtJQUNiLCtCQUFlLENBQUE7SUFDZixtQ0FBbUIsQ0FBQTtJQUNuQiwyQ0FBMkIsQ0FBQTtJQUMzQiwrQkFBZSxDQUFBO0lBQ2YsNkJBQWEsQ0FBQTtJQUNiLGlDQUFpQixDQUFBO0FBQ3JCLENBQUMsRUFQSSxZQUFZLEtBQVosWUFBWSxRQU9oQjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxXQUFXO0lBQWpCO1FBR0ksaUJBQVksR0FBYSxLQUFLLENBQUM7SUFDbkMsQ0FBQztDQUFBO0FBRUQsTUFBTSxjQUFjO0NBSW5COzs7O0FDeGdDRCw0Q0FBcUM7QUFJckM7Ozs7R0FJRztBQUNILE1BQThCLFVBQVU7SUFVdkM7Ozs7T0FJRztJQUNBLFlBQVksUUFBa0IsRUFBRSxLQUFZO1FBQzlDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUNqQixDQUFDO0lBRUo7Ozs7T0FJRztJQUNBLE9BQU8sQ0FBQyxJQUFnQjtRQUMxQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUFBLENBQUM7SUFTRjs7O09BR0c7SUFDQSxVQUFVLENBQUMsSUFBZ0I7UUFDN0IsK0JBQStCO1FBQy9CLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQztRQUNsQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBQUEsQ0FBQztJQVNGOzs7O09BSUc7SUFDSCxPQUFPLENBQUMsRUFBVTtRQUNqQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0EsVUFBVSxDQUFDLE1BQXFCLEVBQUUsSUFBWSxJQUFJO1FBQ3BELElBQUcsTUFBTSxZQUFZLGNBQUksRUFBQztZQUN6QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqRDthQUFNO1lBQ04sT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3hDO0lBQ0YsQ0FBQztJQVNEOzs7T0FHRztJQUNILFdBQVc7UUFDVixJQUFJLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO1FBQ2xDLEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztZQUMzQyxJQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxFQUFDO2dCQUNoQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMxQjtTQUNEO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDWixDQUFDO0NBa0JEO0FBdEhELDZCQXNIQzs7OztBQ2xJRCw2Q0FBc0M7QUFLdEMsMENBQW1DO0FBRW5DOztHQUVHO0FBQ0gsTUFBcUIsZUFBZ0IsU0FBUSxvQkFBVTtJQUluRDs7OztPQUlHO0lBQ0gsWUFBWSxRQUFrQixFQUFFLEtBQVk7UUFDeEMsS0FBSyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUV2QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksS0FBSyxFQUFjLENBQUM7SUFDNUMsQ0FBQztJQUVELFlBQVk7SUFDRixlQUFlLENBQUMsSUFBZ0IsRUFBRSxFQUFVO1FBQ2xELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxZQUFZO0lBQ0Ysa0JBQWtCLENBQUMsSUFBZ0IsRUFBRSxFQUFVO1FBQ3JELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hDLElBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFDO1lBQ1YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ2xDO0lBQ0wsQ0FBQztJQUVELFlBQVk7SUFDWixnQkFBZ0IsQ0FBQyxDQUFTLEVBQUUsQ0FBUztRQUNqQyxJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFFakIsS0FBSSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFDO1lBQzFCLElBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUM7Z0JBQ25CLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDdEI7U0FDSjtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7SUFFRCxZQUFZO0lBQ1osZ0JBQWdCLENBQUMsUUFBYztRQUMzQixJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDM0IsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBRWpCLEtBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBQztZQUMxQixJQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFDO2dCQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3RCO1NBQ0o7UUFDRCxJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDM0IsZUFBSyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLEdBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUU5QixPQUFPLE9BQU8sQ0FBQztJQUNuQixDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQWM7UUFDakIsSUFBSSxFQUFFLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNCLEtBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBQztZQUMxQixJQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxFQUFDO2dCQUMzQixJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3ZCO1NBQ0o7UUFDRCxJQUFJLEVBQUUsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDM0IsZUFBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEdBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQsTUFBTSxDQUFDLEdBQTZCLElBQVMsQ0FBQztJQUU5QyxZQUFZO0lBQ1osYUFBYTtRQUNULElBQUksVUFBVSxHQUFHLElBQUksS0FBSyxFQUFjLENBQUM7UUFFekMsS0FBSSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFDO1lBQzFCLElBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFFLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBQztnQkFDM0UsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN6QjtTQUNKO1FBRUQsT0FBTyxVQUFVLENBQUM7SUFDdEIsQ0FBQztDQUNKO0FBbEZELGtDQWtGQzs7OztBQzVGRCw0Q0FBcUM7QUFHckMsa0RBQTJDO0FBQzNDLDhDQUF1QztBQUN2QyxtREFBNEM7QUFDNUMsMENBQW1DO0FBQ25DLGlFQUEwRDtBQUMxRCxxREFBOEM7QUFFOUM7OztHQUdHO0FBQ0gsTUFBcUIsUUFBUTtJQXlCekIsWUFBWSxVQUFnQixFQUFFLFNBQWlCO1FBTi9DLDJDQUEyQztRQUNuQyxnQkFBVyxHQUFXLEdBQUcsQ0FBQztRQU05QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksY0FBSSxDQUFDLGNBQUksQ0FBQyxJQUFJLEVBQUUsY0FBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxjQUFJLENBQUMsY0FBSSxDQUFDLElBQUksRUFBRSxjQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLGVBQUssRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUM7UUFDL0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDO1FBQzVCLElBQUksQ0FBQyxLQUFLLEdBQUcsY0FBSSxDQUFDLElBQUksQ0FBQztRQUV2Qiw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUUvQiwrQkFBK0I7UUFDL0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTdCLG9EQUFvRDtRQUNwRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRCw4Q0FBOEM7SUFDOUMsVUFBVTtRQUNOLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzVCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTO1FBQ0wsT0FBTyxJQUFJLGNBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ0gsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsU0FBUyxDQUFDLE1BQXFCLEVBQUUsSUFBWSxJQUFJO1FBQzdDLElBQUksR0FBUyxDQUFDO1FBQ3BCLElBQUcsTUFBTSxZQUFZLGNBQUksRUFBQztZQUNoQixHQUFHLEdBQUcsTUFBTSxDQUFDO1NBQ2hCO2FBQU07WUFDSCxHQUFHLEdBQUcsSUFBSSxjQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQzdCO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsT0FBTyxDQUFDLE1BQXFCLEVBQUUsSUFBWSxJQUFJO1FBQ2pELElBQUcsTUFBTSxZQUFZLGNBQUksRUFBQztZQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFDO2FBQU07WUFDTixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGNBQUksQ0FBQyxNQUFNLEdBQUMsQ0FBQyxFQUFFLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQy9DO0lBQ0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxXQUFXLENBQUMsTUFBcUIsRUFBRSxJQUFZLElBQUk7UUFDckQsSUFBRyxNQUFNLFlBQVksY0FBSSxFQUFDO1lBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ3RDO2FBQU07WUFDTixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGNBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzQztJQUNDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsYUFBYSxDQUFDLE1BQXFCLEVBQUUsSUFBWSxJQUFJO1FBQ3ZELElBQUcsTUFBTSxZQUFZLGNBQUksRUFBQztZQUN6QixJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUNqQzthQUFNO1lBQ04sSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLGNBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDdEM7SUFDQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWSxDQUFDLElBQVk7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBQyxJQUFJLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWTtRQUNSLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFBO0lBQzNDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxrQkFBa0IsQ0FBQyxlQUF1QjtRQUN0QyxJQUFHLGVBQWUsR0FBRyxDQUFDO1lBQUUsZUFBZSxHQUFHLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxDQUFDLEtBQVc7UUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxRQUFRLENBQUMsSUFBZ0I7UUFDckIsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxZQUFZLHVCQUFhLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxZQUFZLGlCQUFPLENBQUMsQ0FBQyxDQUFpQixJQUFJLENBQUMsUUFBUSxFQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLGNBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0osSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hDLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7UUFDekIsT0FBTyxRQUFRLENBQUM7SUFDcEIsQ0FBQztJQUVKLGlHQUFpRztJQUM5RixxR0FBcUc7SUFDckc7Ozs7OztPQU1HO0lBQ0gsU0FBUyxDQUFDLE1BQWMsRUFBRSxNQUFjLEVBQUUsTUFBYyxFQUFFLE1BQWM7UUFDcEUsSUFBSSxNQUFNLEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksT0FBTyxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFDLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3hCLElBQUksQ0FBQyxHQUFHLE1BQU0sR0FBRyxPQUFPLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsSUFBYztRQUNqQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztJQUMxQixDQUFDO0lBRUQsVUFBVTtRQUNOLElBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFDO1lBQ25ELElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDaEM7UUFFRCwyQ0FBMkM7UUFDM0MsSUFBSSxHQUFHLEdBQUcsY0FBSSxDQUFDLElBQUksQ0FBQztRQUNwQixJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUMxRCxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFFMUMsMERBQTBEO1FBQzFELEdBQUcsQ0FBQyxDQUFDLEdBQUcsbUJBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsbUJBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXRHLDJDQUEyQztRQUMzQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFCLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRCxNQUFNLENBQUMsTUFBYztRQUNqQixxQkFBcUI7UUFDckIsSUFBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUM7WUFDdEIsSUFBRyxlQUFLLENBQUMsYUFBYSxFQUFFLEVBQUM7Z0JBQ3JCLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ2xELElBQUcsZUFBSyxDQUFDLGtCQUFrQixFQUFFLEdBQUcsQ0FBQyxFQUFDO29CQUM5QixVQUFVO29CQUNWLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztpQkFDekM7cUJBQU07b0JBQ0gsV0FBVztvQkFDWCxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztpQkFDdkM7Z0JBRUQsSUFBRyxXQUFXLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFDO29CQUNoQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsR0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO29CQUM1QyxXQUFXLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO29CQUNqQyxXQUFXLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztpQkFDM0I7Z0JBRUQsSUFBRyxXQUFXLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFDO29CQUNoQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsR0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO29CQUM1QyxXQUFXLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO29CQUNqQyxXQUFXLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQztpQkFDM0I7Z0JBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDdEM7U0FDSjtRQUVELHFDQUFxQztRQUNyQyxJQUFHLElBQUksQ0FBQyxTQUFTLEVBQUM7WUFDZCx3Q0FBd0M7WUFDeEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUMvRDthQUFNO1lBQ0gsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzFDO1FBRUQsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3RCLENBQUM7Q0FDSjtBQS9RRCwyQkErUUM7Ozs7QUMxUkQsdURBQWdEO0FBQ2hELHVFQUFnRTtBQUNoRSxvRUFBZ0U7QUFDaEUsMEVBQXNFO0FBQ3RFLHNEQUErQztBQUMvQywrQ0FBd0M7QUFDeEMsMERBQW1EO0FBQ25ELHdEQUFpRDtBQUNqRCwwREFBbUQ7QUFDbkQsZ0VBQXlEO0FBQ3pELG9EQUE2QztBQUM3QywyRUFBb0U7QUFDcEUsb0RBQTZDO0FBRTdDLGNBQWM7QUFFZDs7O0dBR0c7QUFDSCxNQUFxQixpQkFBaUI7SUFBdEM7UUFTQzs7Ozs7O1dBTUc7UUFDSCxpQkFBWSxHQUFHLENBQUMsSUFBNEIsRUFBRSxTQUFpQixFQUFFLE9BQTZCLEVBQWEsRUFBRTtZQUM1RyxnQkFBZ0I7WUFDaEIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFM0MsSUFBSSxRQUFtQixDQUFDO1lBRXhCLFFBQU8sSUFBSSxFQUFDO2dCQUNYLEtBQUssOEJBQWEsQ0FBQyxNQUFNO29CQUN4QixRQUFRLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDdEMsTUFBTTtnQkFDTixLQUFLLDhCQUFhLENBQUMsS0FBSztvQkFDdkIsUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3JDLE1BQU07Z0JBQ04sS0FBSyw4QkFBYSxDQUFDLE1BQU07b0JBQ3hCLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUN0QyxNQUFNO2dCQUNOLEtBQUssOEJBQWEsQ0FBQyxVQUFVO29CQUM1QixRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDekMsTUFBTTtnQkFDTjtvQkFDQyxNQUFNLGtCQUFrQixJQUFJLGlEQUFpRCxDQUFBO2FBQzlFO1lBRUQsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDOUIsUUFBUSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3RDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRTdDLHdCQUF3QjtZQUN4QixLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1lBRXZCLE9BQU8sUUFBUSxDQUFDO1FBQ2pCLENBQUMsQ0FBQTtRQUVEOzs7OztXQUtHO1FBQ0gsY0FBUyxHQUFHLENBQUMsR0FBVyxFQUFFLFNBQWlCLEVBQVUsRUFBRTtZQUN0RCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUUzQyxJQUFJLFFBQVEsR0FBRyxJQUFJLGdCQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFL0Isd0JBQXdCO1lBQ3hCLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlCLFFBQVEsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUV0QyxJQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFDO2dCQUM5RSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM3QztZQUVELHdCQUF3QjtZQUN4QixLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXhCLE9BQU8sUUFBUSxDQUFDO1FBQ2pCLENBQUMsQ0FBQTtRQUVEOzs7OztXQUtHO1FBQ0gsc0JBQWlCLEdBQUcsQ0FBQyxHQUFXLEVBQUUsU0FBaUIsRUFBa0IsRUFBRTtZQUN0RSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMzQyxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMzRCxJQUFJLFFBQVEsR0FBRyxJQUFJLHdCQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7WUFFL0Msd0JBQXdCO1lBQ3hCLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlCLFFBQVEsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUV0QyxJQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFDO2dCQUM5RSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM3QztZQUVELHdCQUF3QjtZQUN4QixLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXhCLE9BQU8sUUFBUSxDQUFDO1FBQ2pCLENBQUMsQ0FBQTtRQUVEOzs7Ozs7V0FNRztRQUNILGVBQVUsR0FBRyxDQUFDLElBQTBCLEVBQUUsU0FBaUIsRUFBRSxPQUE2QixFQUFXLEVBQUU7WUFDdEcsZ0JBQWdCO1lBQ2hCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRTNDLElBQUksUUFBaUIsQ0FBQztZQUV0QixRQUFPLElBQUksRUFBQztnQkFDWCxLQUFLLDBCQUFXLENBQUMsS0FBSztvQkFDckIsUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3BDLE1BQU07Z0JBQ1AsS0FBSywwQkFBVyxDQUFDLElBQUk7b0JBQ3BCLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUNuQyxNQUFNO2dCQUNQLEtBQUssMEJBQVcsQ0FBQyxJQUFJO29CQUNwQixRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDbkMsTUFBTTtnQkFDUDtvQkFDQyxNQUFNLGdCQUFnQixJQUFJLGlEQUFpRCxDQUFBO2FBQzVFO1lBRUQsd0JBQXdCO1lBQ3hCLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlCLFFBQVEsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUV0QyxJQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFDO2dCQUM5RSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM3QztZQUVELHdCQUF3QjtZQUN4QixLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXhCLE9BQU8sUUFBUSxDQUFDO1FBQ2pCLENBQUMsQ0FBQTtJQTZFRixDQUFDO0lBbk5BLElBQUksQ0FBQyxLQUFZO1FBQ2hCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxlQUFlLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBcUlELG9DQUFvQztJQUVwQyxXQUFXLENBQUMsT0FBNkI7UUFDeEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNwRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFNUQsT0FBTyxJQUFJLGdCQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELFVBQVUsQ0FBQyxPQUE2QjtRQUN2QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUUzRCxPQUFPLElBQUksZUFBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFBO0lBQ2pELENBQUM7SUFFRCxXQUFXLENBQUMsT0FBNEI7UUFDdkMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUVwRSxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDbEIsSUFBRyxPQUFPLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBQztZQUM5QixTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztTQUMxQjtRQUVELE9BQU8sSUFBSSxnQkFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELGNBQWMsQ0FBQyxPQUE0QjtRQUMxQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRXZFLE9BQU8sSUFBSSxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsVUFBVSxDQUFDLE9BQTZCO1FBQ3ZDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxjQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFbkUsT0FBTyxJQUFJLGVBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELFNBQVMsQ0FBQyxPQUE2QjtRQUN0QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsY0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQy9ELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxjQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFN0QsT0FBTyxJQUFJLGNBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsU0FBUyxDQUFDLE9BQTZCO1FBQ3RDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxjQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLGNBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUU5RCxPQUFPLElBQUksY0FBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRCwwQ0FBMEM7SUFFMUMsaUJBQWlCLENBQUksVUFBa0IsRUFBRSxPQUE0QixFQUFFLElBQVksRUFBRSxJQUF3QyxFQUFFLFFBQWlCO1FBQy9JLElBQUcsQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLFNBQVMsRUFBQztZQUMxQyxpREFBaUQ7WUFDakQsTUFBTSxHQUFHLFVBQVUsNkJBQTZCLElBQUksWUFBWSxRQUFRLDBCQUEwQixDQUFDO1NBQ25HO2FBQU07WUFDTiwrQ0FBK0M7WUFDL0MsSUFBRyxDQUFDLE9BQU8sSUFBSSxDQUFDLEtBQUssUUFBUSxFQUFDO2dCQUM3QixJQUFHLENBQUMsQ0FBQyxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsRUFBQztvQkFDbkMsTUFBTSxHQUFHLFVBQVUsNkJBQTZCLElBQUksWUFBWSxJQUFJLGtCQUFrQixJQUFJLG9CQUFvQixJQUFJLEdBQUcsQ0FBQztpQkFDdEg7YUFDRDtpQkFBTSxJQUFHLElBQUksWUFBWSxRQUFRLEVBQUM7Z0JBQ2xDLCtDQUErQztnQkFDL0MsSUFBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxFQUFDO29CQUNuQyxNQUFNLEdBQUcsVUFBVSw2QkFBNkIsSUFBSSxZQUFZLFFBQVEsa0JBQWtCLElBQUksb0JBQW9CLFFBQVEsR0FBRyxDQUFDO2lCQUM5SDthQUNEO2lCQUFNO2dCQUNOLE1BQU0sR0FBRyxVQUFVLDZCQUE2QixJQUFJLFlBQVksUUFBUSxrQkFBa0IsSUFBSSxvQkFBb0IsUUFBUSxHQUFHLENBQUM7YUFDOUg7U0FDRDtJQUNGLENBQUM7Q0FDRDtBQXZORCxvQ0F1TkM7Ozs7QUM3T0QsMkRBQW9EO0FBQ3BELHFEQUE4QztBQVc5Qzs7R0FFRztBQUNILE1BQXFCLGNBQWM7SUFNL0IsWUFBWSxLQUFZLEVBQUUsUUFBd0I7UUFKbEQsaUdBQWlHO1FBQ3pGLHNCQUFpQixHQUFzQixJQUFJLDJCQUFpQixFQUFFLENBQUM7UUFDL0QsbUJBQWMsR0FBbUIsSUFBSSx3QkFBYyxFQUFFLENBQUM7UUFHMUQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELDBEQUEwRDtJQUMxRDs7Ozs7O09BTUE7SUFDQSxTQUFTLENBQUMsSUFBNEIsRUFBRSxTQUFpQixFQUFFLE9BQTZCO1FBQ3BGLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7Ozs7T0FLQTtJQUNILE1BQU0sQ0FBQyxHQUFXLEVBQUUsU0FBaUI7UUFDOUIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7Ozs7O09BS0E7SUFDSCxjQUFjLENBQUMsR0FBVyxFQUFFLFNBQWlCO1FBQ3RDLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQ7Ozs7OztPQU1BO0lBQ0gsT0FBTyxDQUFDLElBQTBCLEVBQUUsU0FBaUIsRUFBRSxPQUE2QjtRQUM3RSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ04sT0FBTyxDQUFDLEdBQVcsRUFBRSxLQUFZO1FBQzFCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQy9DLENBQUM7Q0FDSjtBQWhFRCxpQ0FnRUM7Ozs7QUM5RUQsMkVBQW9FO0FBQ3BFLDhFQUF1RTtBQUV2RSw4REFBdUQ7QUFDdkQsK0NBQXdDO0FBR3hDLHdFQUFpRTtBQUNqRSx1REFBZ0Q7QUFFaEQsY0FBYztBQUVkOzs7R0FHRztBQUNILE1BQXFCLGNBQWM7SUFBbkM7UUFXSSxrRkFBa0Y7UUFDbEYsb0ZBQW9GO1FBQ3BGLGdGQUFnRjtRQUNoRix1REFBdUQ7UUFDdkQ7Ozs7OztXQU1HO1FBQ04sUUFBRyxHQUFHLENBQUMsR0FBVyxFQUFFLFFBQWMsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFnQixFQUFFO1lBQzNELG1CQUFtQjtZQUNuQixJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUV2RCw4RUFBOEU7WUFDOUUsSUFBSSxNQUFvQyxDQUFDO1lBQ3pDLElBQUcsV0FBVyxDQUFDLFdBQVcsS0FBSyxjQUFjLEVBQUM7Z0JBQzFDLE1BQU0sR0FBRywyQkFBaUIsQ0FBQzthQUM5QjtpQkFBTTtnQkFDSCxrRUFBa0U7Z0JBQ2xFLE1BQU0sR0FBRywyQkFBaUIsQ0FBQzthQUM5QjtZQUVELG9DQUFvQztZQUNwQyxJQUFJLFdBQVcsR0FBRyxJQUFJLEtBQUssRUFBUyxDQUFDO1lBRXJDLDhDQUE4QztZQUM5QyxJQUFJLFFBQVEsR0FBRyxJQUFJLEtBQUssRUFBVyxDQUFDO1lBRXBDLElBQUksZUFBZSxHQUFHLElBQUksS0FBSyxFQUF1QixDQUFDO1lBRXZELEtBQUksSUFBSSxPQUFPLElBQUksV0FBVyxDQUFDLFFBQVEsRUFBQztnQkFDcEMsSUFBRyxPQUFPLENBQUMsS0FBSyxFQUFDO29CQUNiLCtFQUErRTtvQkFDL0UsbUdBQW1HO29CQUNuRyxpR0FBaUc7b0JBQ2pHLGtEQUFrRDtvQkFDbEQsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLGlCQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztpQkFDdkM7cUJBQU07b0JBQ0gsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDM0QsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDMUM7YUFDSjtZQUVELDhFQUE4RTtZQUM5RSxLQUFJLElBQUksS0FBSyxJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUM7Z0JBRWhDLElBQUksVUFBVSxDQUFDO2dCQUNmLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQztnQkFDNUIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO2dCQUVkLElBQUcsS0FBSyxDQUFDLFVBQVUsRUFBQztvQkFDaEIsS0FBSSxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsVUFBVSxFQUFDO3dCQUM3QixJQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBVSxFQUFDOzRCQUN4QixlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQzt5QkFDaEM7NkJBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRTs0QkFDN0IsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7eUJBQ3RCO3FCQUNKO2lCQUNKO2dCQUVELElBQUcsZUFBZSxFQUFDO29CQUNmLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxjQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO2lCQUMvRTtxQkFBTTtvQkFDSCxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztpQkFDdkQ7Z0JBRUQsSUFBRyxLQUFLLENBQUMsSUFBSSxLQUFLLFdBQVcsRUFBQztvQkFDMUIsNENBQTRDO29CQUM1QyxJQUFJLE9BQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDOUQsT0FBTyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO29CQUNyQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFFN0IsdUJBQXVCO29CQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFFNUIsVUFBVSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFFNUIsbURBQW1EO29CQUNuRCxJQUFHLE9BQU8sQ0FBQyxZQUFZLEVBQUM7d0JBQ3BCLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQzt3QkFFckIsSUFBRyxLQUFLLENBQUMsVUFBVSxFQUFDOzRCQUNoQixLQUFJLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxVQUFVLEVBQUM7Z0NBQzdCLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUM7b0NBQ3JCLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2lDQUNoQzs2QkFDSjt5QkFDSjtxQkFDSjtpQkFDSjtxQkFBTTtvQkFFSCxJQUFJLGVBQWUsR0FBRyxLQUFLLENBQUM7b0JBQzVCLElBQUksV0FBVyxDQUFDO29CQUNoQixJQUFJLEtBQUssQ0FBQztvQkFDVixJQUFHLEtBQUssQ0FBQyxVQUFVLEVBQUM7d0JBQ2hCLEtBQUksSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLFVBQVUsRUFBQzs0QkFDN0IsSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLGVBQWUsRUFBQztnQ0FDN0IsZUFBZSxHQUFHLElBQUksQ0FBQzs2QkFDMUI7aUNBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBQztnQ0FDM0IsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7NkJBQzVCO2lDQUFNLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUM7Z0NBQzVCLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFBOzZCQUNyQjt5QkFDSjtxQkFDSjtvQkFFRCxJQUFHLGVBQWUsRUFBQzt3QkFDZixJQUFJLENBQUMsR0FBRyxJQUFJLHVCQUFhLEVBQUUsQ0FBQzt3QkFFNUIsS0FBSSxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFDOzRCQUN6QixDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxjQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDL0M7d0JBRUQsS0FBSSxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUM7NEJBQ2xCLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7eUJBQ2pDO3dCQUVELElBQUksQ0FBQyxLQUFLLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsSUFBSSxpQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBRWxGLFNBQVM7cUJBQ1o7b0JBRUQsMEVBQTBFO29CQUMxRSxLQUFJLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUM7d0JBQ3pCLDZCQUE2Qjt3QkFDN0IsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO3dCQUN2QixJQUFJLFlBQVksR0FBRyxLQUFLLENBQUM7d0JBQ3pCLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQzt3QkFDdEIsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDO3dCQUNuQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUM7d0JBQ2xCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQzt3QkFDeEIsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO3dCQUVmLElBQUcsR0FBRyxDQUFDLFVBQVUsRUFBQzs0QkFDZCxLQUFJLElBQUksSUFBSSxJQUFJLEdBQUcsQ0FBQyxVQUFVLEVBQUM7Z0NBQzNCLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxZQUFZLEVBQUM7b0NBQzFCLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2lDQUMzQjtxQ0FBTSxJQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxFQUFDO29DQUNqQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztpQ0FDN0I7cUNBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBQztvQ0FDNUIsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7aUNBQ3RCO3FDQUFNLElBQUcsSUFBSSxDQUFDLElBQUksS0FBSyxXQUFXLEVBQUM7b0NBQ2hDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2lDQUMxQjtxQ0FBTSxJQUFHLElBQUksQ0FBQyxJQUFJLEtBQUssY0FBYyxFQUFDO29DQUNuQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztpQ0FDN0I7cUNBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLGdCQUFnQixFQUFDO29DQUNyQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztpQ0FDeEI7cUNBQU0sSUFBRyxJQUFJLENBQUMsSUFBSSxLQUFLLGVBQWUsRUFBQztvQ0FDcEMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7aUNBQ3ZCOzZCQUNKO3lCQUNKO3dCQUVELElBQUksTUFBYyxDQUFDO3dCQUVuQix3Q0FBd0M7d0JBQ3hDLEtBQUksSUFBSSxPQUFPLElBQUksUUFBUSxFQUFDOzRCQUN4QixJQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFDO2dDQUN4QixxQ0FBcUM7Z0NBQ3JDLElBQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQ0FDckMsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQ0FDcEQsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2dDQUNyRCxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7Z0NBQ3pDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dDQUM1RSxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dDQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQ0FDdkIsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7NkJBQ3RDO3lCQUNKO3dCQUVELG9EQUFvRDt3QkFDcEQsSUFBRyxDQUFDLE1BQU0sRUFBQzs0QkFDUCxLQUFJLElBQUksSUFBSSxJQUFJLGVBQWUsRUFBQztnQ0FDNUIsSUFBRyxHQUFHLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQyxFQUFFLEVBQUM7b0NBQ25CLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7b0NBQzFCLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztvQ0FDckQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLEdBQUMsQ0FBQyxDQUFDLEdBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBQyxDQUFDLENBQUMsR0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0NBQy9GLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lDQUN0Qzs2QkFDSjt5QkFDSjt3QkFFRCwyRUFBMkU7d0JBQzNFLElBQUcsVUFBVSxFQUFDOzRCQUNWLDBDQUEwQzs0QkFDMUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLGNBQUksQ0FBQyxJQUFJLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDOzRCQUMxRSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUN2QixJQUFHLFNBQVMsSUFBSSxZQUFZLEtBQUssSUFBSSxFQUFDO2dDQUNsQyxNQUFNLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7NkJBQ3BEO3lCQUNKO3FCQUNKO2lCQUNKO2dCQUVELDBCQUEwQjtnQkFDMUIsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNoQztZQUVELE9BQU8sV0FBVyxDQUFDO1FBQzFCLENBQUMsQ0FBQTtJQUNGLENBQUM7SUFoTkcsSUFBSSxDQUFDLEtBQVksRUFBRSxRQUF3QjtRQUN2QyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLHlCQUFlLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDekQsQ0FBQztDQTRNSjtBQXJORCxpQ0FxTkM7Ozs7QUN0T0Qsa0RBQTJDO0FBSTNDOztHQUVHO0FBQ0gsTUFBcUIsS0FBSztJQXlCdEI7Ozs7T0FJRztJQUNILFlBQVksS0FBWSxFQUFFLElBQVk7UUFDbEMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDZixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILE9BQU87UUFDSCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVMsQ0FBQyxVQUFtQjtRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLFVBQVUsQ0FBQztJQUM3QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRLENBQUMsS0FBYTtRQUNsQixJQUFJLENBQUMsS0FBSyxHQUFHLG1CQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVE7UUFDSixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFNBQVMsQ0FBQyxNQUFlO1FBQ3JCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxxQ0FBcUM7SUFDckMsT0FBTztRQUNILElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCwrQ0FBK0M7SUFDL0MsTUFBTTtRQUNGLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsUUFBUSxDQUFDLEtBQWM7UUFDbkIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVE7UUFDSixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxLQUFhO1FBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPLENBQUMsSUFBYztRQUNsQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsVUFBVSxDQUFDLElBQWM7UUFDckIsMkJBQTJCO1FBQzNCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJDLElBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFDO1lBQ1osSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzVCLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDNUI7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN0QixDQUFDO0NBQ0o7QUEvS0Qsd0JBK0tDOzs7O0FDdkxELG9DQUE2QjtBQUk3Qjs7R0FFRztBQUNILE1BQXFCLGFBQWMsU0FBUSxlQUFLO0lBSS9DOzs7Ozs7T0FNRztJQUNILFlBQVksS0FBWSxFQUFFLElBQVksRUFBRSxRQUFjO1FBQ3JELEtBQUssQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDMUIsQ0FBQztDQUNEO0FBZkQsZ0NBZUM7Ozs7QUN0QkQsK0NBQXdDO0FBRXhDLG1EQUE0QztBQUU1Qzs7OztHQUlHO0FBQ0gsTUFBcUIsT0FBUSxTQUFRLHVCQUFhO0lBQ2pEOzs7OztPQUtHO0lBQ0gsWUFBWSxLQUFZLEVBQUUsSUFBWTtRQUNyQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxjQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0IsQ0FBQztDQUNEO0FBVkQsMEJBVUM7Ozs7QUNuQkQsbUNBQTRCO0FBRTVCLDRDQUFxQztBQUdyQyx3RUFBaUU7QUFDakUsbUVBQTREO0FBQzVELCtEQUF3RDtBQUV4RCx3RUFBaUU7QUFHakUsaURBQTBDO0FBQzFDLCtDQUF3QztBQUV4Qyx3RUFBaUU7QUFDakUsK0NBQXdDO0FBQ3hDLDBDQUFtQztBQUNuQywwREFBbUQ7QUFDbkQsOENBQXVDO0FBQ3ZDLG9EQUE2QztBQUU3QyxpREFBMEM7QUFFMUMsMENBQW1DO0FBQ25DLHlEQUFrRDtBQUNsRCx1RUFBZ0U7QUFFaEU7Ozs7O0dBS0c7QUFDSCxNQUFxQixLQUFLO0lBMER0Qjs7Ozs7OztPQU9HO0lBQ0gsWUFBWSxRQUFrQixFQUFFLFlBQTBCLEVBQUUsZ0JBQWtDLEVBQUUsT0FBNEI7UUFDeEgsSUFBSSxDQUFDLFlBQVksR0FBRyxzQkFBWSxDQUFDLEtBQUssQ0FBQyxPQUFPLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTdFLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxjQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxrQkFBUSxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGlCQUFPLEVBQUUsQ0FBQztRQUU3QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFDNUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLHlCQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUzRCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksYUFBRyxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxhQUFHLEVBQUUsQ0FBQztRQUVoQyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksNkJBQW1CLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN6RSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksMkJBQWlCLEVBQUUsQ0FBQztRQUMxQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksbUJBQVMsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztRQUV6QyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksd0JBQWMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRW5ELElBQUksQ0FBQyxJQUFJLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQTtRQUN6QyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFFakMsc0RBQXNEO1FBQ3RELHNCQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDN0MsQ0FBQztJQUVELDBHQUEwRztJQUMxRyxTQUFTLENBQUMsSUFBeUIsSUFBUyxDQUFDO0lBRTdDLDRIQUE0SDtJQUM1SCxTQUFTLEtBQVUsQ0FBQztJQUVwQix1SEFBdUg7SUFDdkgsVUFBVSxLQUFVLENBQUM7SUFFckI7OztPQUdHO0lBQ0gsV0FBVyxDQUFDLE1BQWMsSUFBUyxDQUFDO0lBRXBDLCtIQUErSDtJQUMvSCxXQUFXLEtBQVUsQ0FBQztJQUV0QixNQUFNLENBQUMsTUFBYztRQUNqQixJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXpCLGtCQUFrQjtRQUNsQixzQkFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUxQyxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFOUIsNkJBQTZCO1FBQzdCLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRW5DLDRCQUE0QjtRQUM1QixJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUvQixzQkFBc0I7UUFDdEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDNUIsSUFBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBQztnQkFDOUIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMxQjtRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsb0JBQW9CO1FBQ3BCLHNCQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTFDLGtCQUFrQjtRQUNsQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNO1FBQ0YsK0JBQStCO1FBQy9CLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUFFLENBQUM7UUFFakQsaUZBQWlGO1FBQ2pGLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzlCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzFDLEtBQUksSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFDO2dCQUM5QixJQUFHLElBQUksWUFBWSxvQkFBVSxFQUFDO29CQUMxQixVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN6QjthQUNKO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCwrREFBK0Q7UUFDL0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFdkUsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUMxQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVFLGVBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFVBQVUsQ0FBQyxPQUFnQjtRQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUMzQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN4QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLElBQWM7UUFDakIsOEJBQThCO1FBQzlCLElBQUcsSUFBSSxZQUFZLG9CQUFVLEVBQUM7WUFDMUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEM7SUFFTCxDQUFDO0lBRUQsOENBQThDO0lBQzlDLE9BQU87UUFDSCxLQUFJLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLEVBQUM7WUFDMUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ2xCO1FBRUQsS0FBSSxJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFDO1lBQzdCLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNyQjtRQUVELElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFeEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQztRQUMzQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDdkIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN6QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxRQUFRLENBQUMsSUFBWSxFQUFFLEtBQWM7UUFDakMsSUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBQztZQUNqRixNQUFNLG1CQUFtQixJQUFJLGlCQUFpQixDQUFDO1NBQ2xEO1FBRUQsSUFBSSxLQUFLLEdBQUcsSUFBSSxlQUFLLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRWxDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUU3QixJQUFHLEtBQUssRUFBQztZQUNMLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDekI7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsZ0JBQWdCLENBQUMsSUFBWSxFQUFFLFFBQWMsRUFBRSxLQUFjO1FBQ3pELElBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUM7WUFDakYsTUFBTSxtQkFBbUIsSUFBSSxpQkFBaUIsQ0FBQztTQUNsRDtRQUVELElBQUksS0FBSyxHQUFHLElBQUksdUJBQWEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRXBELElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUVyQyxJQUFHLEtBQUssRUFBQztZQUNMLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDekI7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxJQUFZO1FBQ25CLElBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUM7WUFDakYsTUFBTSxtQkFBbUIsSUFBSSxpQkFBaUIsQ0FBQztTQUNsRDtRQUVELElBQUksS0FBSyxHQUFHLElBQUksaUJBQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFcEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRS9CLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFFBQVEsQ0FBQyxJQUFZO1FBQ2pCLElBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUM7WUFDckIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNoQzthQUFNLElBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUM7WUFDcEMsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QzthQUFNLElBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUM7WUFDOUIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNsQzthQUFNO1lBQ0gsTUFBTSxtQkFBbUIsSUFBSSxrQkFBa0IsQ0FBQztTQUNuRDtJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsZUFBZSxDQUFDLElBQVk7UUFDeEIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFNBQVMsQ0FBQyxJQUFZO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsa0JBQWtCLENBQUMsSUFBYztRQUM3QixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFNUIsSUFBRyxLQUFLLFlBQVksdUJBQWEsSUFBSSxLQUFLLFlBQVksaUJBQU8sRUFBQztZQUMxRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN6RDthQUFNO1lBQ0gsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO1NBQ3BDO0lBQ1IsQ0FBQztJQUVFOzs7TUFHRTtJQUNMLFlBQVk7UUFDWCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDckMsQ0FBQztJQUVFOzs7T0FHRztJQUNILFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILGlCQUFpQjtRQUNiLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsb0JBQW9CO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUMzQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWTtRQUNSLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUMxQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxJQUFZO1FBQ25CLEtBQUksSUFBSSxPQUFPLElBQUksSUFBSSxDQUFFLFFBQVEsRUFBQztZQUM5QixJQUFHLE9BQU8sQ0FBQyxJQUFJLEtBQUssSUFBSSxFQUFDO2dCQUNyQixPQUFPLE9BQU8sQ0FBQzthQUNsQjtTQUNKO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztDQUNKO0FBelpELHdCQXlaQzs7OztBQzFiRCx3RUFBaUU7QUFLakU7OztHQUdHO0FBQ0gsTUFBcUIsWUFBWTtJQW9CaEM7Ozs7O09BS0c7SUFDSCxZQUFZLFFBQWtCLEVBQUUsZ0JBQWtDO1FBQ2pFLElBQUksQ0FBQyxlQUFlLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNyRCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7UUFDekMsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksYUFBYSxDQUFrQixNQUErQixFQUFFLElBQTBCLEVBQUUsT0FBNkI7UUFDL0gsT0FBTyxDQUFDLEdBQUcsQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO1FBQzVFLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3BGLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7SUFDOUIsQ0FBQztJQUVTLGFBQWE7UUFDdEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFdEYsSUFBRyxJQUFJLENBQUMsWUFBWSxFQUFDO1lBQ3BCLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQTtZQUNsQyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBRWhDLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUNwQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQzVCO1FBRUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FBQyxlQUFlLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUUxQyx5Q0FBeUM7UUFDekMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBRXRDLDhCQUE4QjtRQUM5QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUV6QixpQkFBaUI7UUFDakIsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFbkQsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUM7UUFFOUIsa0JBQWtCO1FBQ2xCLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsZUFBZSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsRUFBRTtZQUNoRCxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUMvQixJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwQyxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7O09BR0c7SUFDSSxVQUFVO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU07UUFDWixJQUFHLElBQUksQ0FBQyxZQUFZLEVBQUM7WUFDcEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUMzQjtJQUNGLENBQUM7SUFFRDs7O09BR0c7SUFDSSxNQUFNLENBQUMsTUFBYztRQUMzQixJQUFHLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxFQUFDO1lBQzdCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztTQUNyQjtRQUVELElBQUcsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxFQUFDO1lBQ3JELElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2pDO0lBQ0YsQ0FBQztDQUNEO0FBbEhELCtCQWtIQzs7OztBQzFIRCxjQUFjO0FBRWQ7O0dBRUc7QUFDSCxNQUFxQixZQUFZO0lBTTdCLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBNEI7UUFDckMsSUFBSSxJQUFJLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUU5QixJQUFHLE9BQU8sQ0FBQyxPQUFPLEtBQUssU0FBUyxFQUFDO1lBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUMsQ0FBQztTQUM3RDthQUFNO1lBQ0gsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO1NBQ2xDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztDQUNKO0FBakJELCtCQWlCQzs7Ozs7QUN4QkQsMENBQW1DO0FBQ25DLGlEQUEwQztBQUMxQyx3RUFBaUU7QUFDakUsMkRBQXdEO0FBRXhEOzs7O0dBSUc7QUFDSCxNQUFxQixZQUFZO0lBYTdCO1FBQ0ksSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxrQkFBUSxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUM7WUFDcEIsNkJBQWEsQ0FBQyxVQUFVO1lBQ3hCLDZCQUFhLENBQUMsVUFBVTtZQUN4Qiw2QkFBYSxDQUFDLFVBQVU7WUFDeEIsNkJBQWEsQ0FBQyxRQUFRO1lBQ3RCLDZCQUFhLENBQUMsWUFBWTtZQUMxQiw2QkFBYSxDQUFDLGNBQWM7U0FDL0IsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLGFBQUcsRUFBRSxDQUFDO1FBRS9CLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQVcsMEJBQWtCLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxXQUFXO1FBQ3JCLElBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFDO1lBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1NBQ3RDO1FBQ0QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7T0FFRztJQUNLLFNBQVM7UUFDYixJQUFJO1lBQ0EsTUFBTSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUEsaUNBQWlDO1lBQzNFLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztZQUNuQyxPQUFPLENBQUMsR0FBRyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7U0FDcEQ7UUFBQyxPQUFNLENBQUMsRUFBRTtZQUNQLE9BQU8sQ0FBQyxJQUFJLENBQUMsZ0RBQWdELENBQUMsQ0FBQztTQUNsRTtJQUNMLENBQUM7SUFFTyxhQUFhO1FBQ2pCLEtBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRywwQkFBa0IsRUFBRSxDQUFDLEVBQUUsRUFBQztZQUN2QyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7U0FDbEQ7SUFDTCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksZUFBZTtRQUNsQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7Ozs7Ozs7TUFTRTtJQUNGOzs7O09BSUc7SUFDTyxXQUFXLENBQUMsR0FBVyxFQUFFLGFBQXNCLEVBQUUsT0FBeUIsRUFBRSxPQUFpQjtRQUNuRyxtQkFBbUI7UUFDbkIsSUFBSSxNQUFNLEdBQUcseUJBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFekQsd0JBQXdCO1FBQ3hCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUVoRCxzQ0FBc0M7UUFDdEMsTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFFdkIsMkJBQTJCO1FBQzNCLE1BQU0sS0FBSyxHQUFxQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXpDLGdDQUFnQztRQUNoQywrQ0FBK0M7UUFFL0MscUNBQXFDO1FBQ3JDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBRXBDLG1DQUFtQztRQUNuQyxLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztZQUNqQyxLQUFLLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoQztRQUVELGtEQUFrRDtRQUNsRCxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUUzRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDTyxTQUFTLENBQUMsR0FBVyxFQUFFLElBQWEsRUFBRSxhQUFzQixFQUFFLE9BQXlCLEVBQUUsT0FBaUI7UUFDaEgsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVuRSxJQUFHLElBQUksRUFBQztZQUNKLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1NBQ3JCO1FBRUQsZ0hBQWdIO1FBQ2hILElBQUcsYUFBYSxFQUFDO1lBQ2IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNPLFNBQVMsQ0FBQyxHQUFXO1FBQzNCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hDLElBQUcsS0FBSyxFQUFDO1lBQ0wsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbEM7SUFDTCxDQUFDO0lBRVMsV0FBVyxDQUFDLE9BQXlCO1FBQzNDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRVMsYUFBYSxDQUFDLE9BQXlCO1FBQzdDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQXlCLEVBQUUsTUFBYztRQUN0RCxJQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUM7WUFDVixNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBQ2Q7UUFFRCxNQUFNLEVBQUUsR0FBRyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDdEMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxrQkFBa0IsQ0FBQyxPQUF5QjtRQUN4QyxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFjO1FBQ2pCLGlDQUFpQztRQUNqQyx5RUFBeUU7UUFDekUsT0FBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxFQUFDO1lBQy9CLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDekMsSUFBRyxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFhLENBQUMsVUFBVSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQWEsQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyw2QkFBYSxDQUFDLFFBQVEsRUFBQztnQkFDM0gsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3JDLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNsQyxJQUFJLGFBQWEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFFcEQsSUFBSSxPQUFPLEdBQUcsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUV2QyxJQUFHLEtBQUssQ0FBQyxJQUFJLEtBQUssNkJBQWEsQ0FBQyxVQUFVLEVBQUM7b0JBQ3ZDLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUM7aUJBQ3BDO3FCQUFNLElBQUcsNkJBQWEsQ0FBQyxRQUFRLEVBQUM7b0JBQzdCLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUM7aUJBQ2xDO3FCQUFNLElBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUM7b0JBQ2hDLE9BQU8sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztpQkFDdkM7Z0JBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3RFO1lBRUQsSUFBRyxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFhLENBQUMsVUFBVSxFQUFDO2dCQUN2QyxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDckMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUM1QjtZQUVELElBQUcsS0FBSyxDQUFDLElBQUksS0FBSyw2QkFBYSxDQUFDLFlBQVksRUFBQztnQkFDekMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2FBQy9DO1lBRUQsSUFBRyxLQUFLLENBQUMsSUFBSSxLQUFLLDZCQUFhLENBQUMsY0FBYyxFQUFDO2dCQUMzQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7YUFDakQ7U0FDSjtJQUNMLENBQUM7Q0FDSjtBQXhORCwrQkF3TkM7QUFFRCxJQUFZLGdCQWFYO0FBYkQsV0FBWSxnQkFBZ0I7SUFDeEIsNkRBQVcsQ0FBQTtJQUNYLHFEQUFPLENBQUE7SUFDUCx5REFBUyxDQUFBO0lBQ1QsK0RBQVksQ0FBQTtJQUNaLCtEQUFZLENBQUE7SUFDWiwrREFBWSxDQUFBO0lBQ1osK0RBQVksQ0FBQTtJQUNaLCtEQUFZLENBQUE7SUFDWiwrREFBWSxDQUFBO0lBQ1osK0RBQVksQ0FBQTtJQUNaLGdFQUFhLENBQUE7SUFDYixnRUFBYSxDQUFBO0FBQ2pCLENBQUMsRUFiVyxnQkFBZ0IsR0FBaEIsd0JBQWdCLEtBQWhCLHdCQUFnQixRQWEzQjtBQUVZLFFBQUEsa0JBQWtCLEdBQUcsRUFBRSxDQUFDOzs7O0FDaFByQyxNQUFxQixZQUFZO0lBSTdCO1FBQ0ksSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFJRCxNQUFNLENBQUMsV0FBVztRQUNkLElBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFDO1lBQ2QsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1NBQ3RDO1FBRUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxRQUFRLENBQUMsS0FBWTtRQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQsV0FBVztRQUNQLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQsTUFBTSxDQUFDLE1BQWM7UUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDdkQsQ0FBQztDQUNKO0FBN0JELCtCQTZCQzs7OztBQ2hDRCwyQ0FBb0M7QUFFcEMscURBQXFEO0FBQ3JEOztHQUVHO0FBQ0gsTUFBcUIsS0FBSztJQVV6Qjs7Ozs7O09BTUc7SUFDSCxZQUFZLElBQVksQ0FBQyxFQUFFLElBQVksQ0FBQyxFQUFFLElBQVksQ0FBQyxFQUFFLElBQVksQ0FBQztRQUMvRCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxLQUFLLFdBQVc7UUFDckIsT0FBTyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxLQUFLLEdBQUc7UUFDYixPQUFPLElBQUksS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLEtBQUssS0FBSztRQUNmLE9BQU8sSUFBSSxLQUFLLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sS0FBSyxJQUFJO1FBQ2QsT0FBTyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxLQUFLLE1BQU07UUFDaEIsT0FBTyxJQUFJLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxLQUFLLE9BQU87UUFDakIsT0FBTyxJQUFJLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxLQUFLLElBQUk7UUFDZCxPQUFPLElBQUksS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLEtBQUssS0FBSztRQUNmLE9BQU8sSUFBSSxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sS0FBSyxLQUFLO1FBQ2YsT0FBTyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxLQUFLLE1BQU07UUFDaEIsT0FBTyxJQUFJLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsR0FBRyxDQUFDLENBQVMsRUFBRSxDQUFTLEVBQUUsQ0FBUyxFQUFFLElBQVksQ0FBQztRQUNqRCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNYLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNaLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ04sT0FBTyxJQUFJLEtBQUssQ0FBQyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMxSyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTTtRQUNMLE9BQU8sSUFBSSxLQUFLLENBQUMsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUssQ0FBQztJQUVEOzs7T0FHRztJQUNILE9BQU87UUFDTixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxRQUFRO1FBQ1AsT0FBTyxHQUFHLEdBQUcsbUJBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxtQkFBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLG1CQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkcsQ0FBQztJQUVEOzs7T0FHRztJQUNILFdBQVc7UUFDVixPQUFPLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxHQUFHLEdBQUcsQ0FBQztJQUMvRixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsWUFBWTtRQUNYLElBQUcsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUM7WUFDZixPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUMxQjtRQUNELE9BQU8sT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUUsR0FBRyxDQUFBO0lBQ3pILENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPO1FBQ04sT0FBTyxJQUFJLFlBQVksQ0FBQztZQUN2QixJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUc7WUFDVixJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUc7WUFDVixJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUc7WUFDVixJQUFJLENBQUMsQ0FBQztTQUNOLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLEdBQVc7UUFDL0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUc7WUFBRSxDQUFDLElBQUcsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxHQUFHLG1CQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxHQUFHLG1CQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuRCxJQUFJLENBQUMsR0FBRyxtQkFBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkQsT0FBTyxJQUFJLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7Q0FDRDtBQTlMRCx3QkE4TEM7OztBQ3BNRCxjQUFjOzs7QUFFZCxNQUFxQixhQUFhO0lBRTlCLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBUztRQUMxQixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQVM7UUFDMUIsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDLENBQVM7UUFDeEIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFTO1FBQ3ZCLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLENBQVM7UUFDM0IsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVELE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBUztRQUMxQixPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqRSxDQUFDO0lBRUQsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFTO1FBQzFCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUUsQ0FBQztJQUVPLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFTLEVBQUUsR0FBVztRQUNsRCxPQUFPLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFTyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQVMsRUFBRSxHQUFXO1FBQ2pELE9BQU8sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlDLENBQUM7Q0FDSjtBQXJDRCxnQ0FxQ0M7QUFFRCxJQUFZLGdCQWFYO0FBYkQsV0FBWSxnQkFBZ0I7SUFDeEIsT0FBTztJQUNQLGlEQUE2QixDQUFBO0lBQzdCLGlEQUE2QixDQUFBO0lBQzdCLDBDQUFzQixDQUFBO0lBQ3RCLDRDQUF3QixDQUFBO0lBRXhCLE9BQU87SUFDUCxpREFBNkIsQ0FBQTtJQUM3QixpREFBNkIsQ0FBQTtJQUU3QixRQUFRO0lBQ1IsbURBQStCLENBQUE7QUFDbkMsQ0FBQyxFQWJXLGdCQUFnQixHQUFoQix3QkFBZ0IsS0FBaEIsd0JBQWdCLFFBYTNCOzs7O0FDbkRELDREQUE0RDtBQUM1RCxNQUFxQixVQUFVO0lBRTlCOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFRLEVBQUUsS0FBYTtRQUN0QyxJQUFJLENBQVMsQ0FBQyxDQUFFLFVBQVU7UUFDMUIsSUFBSSxDQUFXLENBQUMsQ0FBQyxzQkFBc0I7UUFDdkMsSUFBSSxNQUFNLEdBQW1CLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN0RCxJQUFJLFFBQVEsR0FBa0IsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3ZELElBQUksTUFBTSxHQUFrQixJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFTLENBQUMsQ0FBRSw0QkFBNEI7UUFDNUMsSUFBSSxDQUFTLENBQUMsQ0FBRyw0QkFBNEI7UUFDN0MsSUFBSSxNQUFjLENBQUMsQ0FBQyxjQUFjO1FBQ2xDLElBQUksSUFBSSxDQUFDLENBQUcsbUNBQW1DO1FBRS9DLEtBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBQztZQUNqQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUM7WUFDdkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2Y7UUFFRCxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLENBQUMsR0FBRyxLQUFLLENBQUM7UUFFVixPQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFDO1lBQ2hCLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDakIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFZixPQUFNLENBQUMsS0FBSyxJQUFJLEVBQUM7Z0JBQ2hCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNSLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO2dCQUVsQixJQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxFQUFDO29CQUNyQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQztvQkFDbkMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDZDtnQkFFRCxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQzthQUNYO1lBRUQsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVOLElBQUksR0FBRyxRQUFRLENBQUM7WUFFaEIsS0FBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFDO2dCQUNsQyxJQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUM7b0JBQ25DLElBQUksR0FBRyxRQUFRLENBQUM7b0JBQ2hCLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ047YUFDRDtTQUNEO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFFZixDQUFDO0NBQ0Q7QUEzREQsNkJBMkRDOzs7O0FDN0RELG9FQUFvRTtBQUNwRSxNQUFxQixTQUFTO0lBQzFCOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQVM7UUFDakIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxTQUFtQjtRQUMvRCxJQUFHLFNBQVMsRUFBQztZQUNULE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDN0I7YUFBTTtZQUNILE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDL0I7SUFDTCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFTLEVBQUUsR0FBVyxFQUFFLEdBQVc7UUFDNUMsSUFBRyxDQUFDLEdBQUcsR0FBRztZQUFFLE9BQU8sR0FBRyxDQUFDO1FBQ3ZCLElBQUcsQ0FBQyxHQUFHLEdBQUc7WUFBRSxPQUFPLEdBQUcsQ0FBQztRQUN2QixPQUFPLENBQUMsQ0FBQztJQUNiLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFTO1FBQ3BCLE9BQU8sU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBUyxFQUFFLEdBQVc7UUFDbEMsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBUztRQUN0QixPQUFPLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLENBQU8sRUFBRSxDQUFTO1FBQ3BDLElBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsR0FBQyxDQUFDLEVBQUM7WUFDZixPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkI7YUFBSztZQUNGLE9BQU8sQ0FBQyxDQUFDO1NBQ1o7SUFDTCxDQUFDO0lBRUQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFTLEVBQUUsR0FBVyxFQUFFLEdBQVcsRUFBRSxNQUFjLEVBQUUsTUFBYztRQUNsRixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQ7Ozs7OztPQU1BO0lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDcEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsT0FBTyxDQUFDLENBQVMsRUFBRSxDQUFTLEVBQUUsS0FBYTtRQUM5QyxPQUFPLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBVyxFQUFFLEtBQWE7UUFDMUMsSUFBRyxLQUFLLEtBQUssQ0FBQyxFQUFDO1lBQ1gsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzFCO1FBRUQsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLE9BQU0sS0FBSyxHQUFHLENBQUMsRUFBQztZQUNaLE1BQU0sSUFBSSxFQUFFLENBQUM7WUFDYixLQUFLLEVBQUUsQ0FBQztTQUNYO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBQyxNQUFNLENBQUMsR0FBQyxNQUFNLENBQUM7SUFFekMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQVc7UUFDdEIsT0FBTyxRQUFRLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBVyxFQUFFLFlBQW9CLElBQUk7UUFDOUMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsT0FBTSxNQUFNLEdBQUMsRUFBRSxHQUFHLEdBQUcsRUFBQztZQUNsQixNQUFNLElBQUksRUFBRSxDQUFDO1NBQ2hCO1FBQ0QsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLE9BQU0sTUFBTSxJQUFJLENBQUMsRUFBQztZQUNkLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ25DLE1BQU0sSUFBSSxTQUFTLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RDLEdBQUcsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDO1lBQ3RCLE1BQU0sSUFBSSxFQUFFLENBQUM7U0FDdEI7UUFFRCxJQUFHLFNBQVMsS0FBSyxJQUFJLEVBQUM7WUFDckIsT0FBTSxNQUFNLENBQUMsTUFBTSxHQUFHLFNBQVMsRUFBQztnQkFDL0IsTUFBTSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7YUFDdEI7U0FDRDtRQUVLLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFXO1FBQ3pCLElBQUcsR0FBRyxHQUFHLEVBQUUsRUFBQztZQUNSLE9BQU8sRUFBRSxHQUFHLEdBQUcsQ0FBQztTQUNuQjthQUFNO1lBQ0gsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLENBQUM7U0FDN0M7SUFDTCxDQUFDO0NBQ0o7QUEzS0QsNEJBMktDOzs7O0FDNUtELDJDQUFvQztBQUVwQyxNQUFxQixjQUFjO0lBQ2xDLE1BQU0sQ0FBQyxhQUFhLENBQUMsS0FBVyxFQUFFLE1BQVksRUFBRSxTQUFlO1FBQzlELE9BQU8sSUFBSSxZQUFZLENBQUM7WUFDdkIsbUJBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDdkUsbUJBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDdkUsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBVSxFQUFFLFNBQWU7UUFDOUMsT0FBTyxJQUFJLFlBQVksQ0FBQztZQUN2QixDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxTQUFTLENBQUMsQ0FBQztZQUNwQixDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxTQUFTLENBQUMsQ0FBQztTQUNwQixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFZO1FBQy9CLE9BQU8sSUFBSSxZQUFZLENBQUM7WUFDdkIsbUJBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDNUMsbUJBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDNUMsbUJBQVMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDNUMsS0FBSyxDQUFDLENBQUM7U0FDUCxDQUFDLENBQUM7SUFDSixDQUFDO0NBQ0Q7QUF2QkQsaUNBdUJDOzs7O0FDM0JELHNEQUFzRDtBQUN0RCxNQUFxQixXQUFXO0lBQzVCOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBZ0I7UUFDdkMsSUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNwQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDaEIsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNuQixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztDQUNKO0FBWkQsOEJBWUM7Ozs7QUNiRCwrQ0FBd0M7QUFDeEMsd0RBQWlEO0FBQ2pELHlFQUFrRTtBQUNsRSwwRUFBbUU7QUFDbkUsa0ZBQTJFO0FBRTNFLHFHQUFxRztBQUNyRyxDQUFDLFNBQVMsSUFBSTtJQUNWLGdCQUFnQjtJQUNoQixRQUFRLEVBQUUsQ0FBQztJQUVYLDhCQUE4QjtJQUM5QixJQUFJLE9BQU8sR0FBRztRQUNWLFVBQVUsRUFBRSxFQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBQztRQUM3QixVQUFVLEVBQUUsRUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBQztRQUM5QixNQUFNLEVBQUU7WUFDSixFQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDekIsRUFBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQzNCLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUMzQixFQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDNUIsRUFBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQy9CLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBQztTQUNwQztLQUNKLENBQUE7SUFFRCwrQkFBK0I7SUFDL0IsSUFBSSxzQkFBc0IsR0FBRyxJQUFJLHdCQUFjLEVBQUUsQ0FBQztJQUNsRCx5QkFBZSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixFQUFFLHNCQUFzQixDQUFDLENBQUM7SUFFN0UsSUFBSSxrQkFBa0IsR0FBRyxJQUFJLDRCQUFrQixFQUFFLENBQUM7SUFDbEQseUJBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUVyRSwyQ0FBMkM7SUFDM0MsTUFBTSxJQUFJLEdBQUcsSUFBSSxjQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFL0IsaUJBQWlCO0lBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsc0JBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNqQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBRUwsU0FBUyxRQUFRLEtBQUcsQ0FBQztBQUFBLENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJpbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvUmVnaXN0cnlcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vV29sZmllMkQvUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi4vV2VhcG9uVHlwZXMvV2VhcG9uVHlwZVwiO1xyXG5pbXBvcnQgUHVuY2ggZnJvbSBcIi4uL1dlYXBvblR5cGVzL1B1bmNoXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWFwb25SZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5PFdlYXBvbkNvbnN0cnVjdG9yPiB7XHJcbiAgICBwdWJsaWMgcHJlbG9hZCgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBybSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cclxuICAgICAgICBybS5pbWFnZShcImZpc3RcIiwgXCJnYW1lX2Fzc2V0cy9pbWFnZXMvc3BsYXNoX3NjcmVlbi5wbmdcIik7XHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvLyBsb2FkIHNwcml0ZXNoZWV0c1xyXG4gICAgICAgIC8vIFRPRE8gUFJPSkVDVCAtIGltcG9ydCBwdW5jaCBzcHJpdGVzaGVldFxyXG4gICAgICAgIHJtLnNwcml0ZXNoZWV0KFwiZmlzdFwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXNoZWV0cy9pbXBhY3QuanNvblwiKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJsb2FkZWQgc3ByaXRlXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnJlZ2lzdGVySXRlbShcImZpc3RcIiwgUHVuY2gpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7fVxyXG5cclxuICAgIHB1YmxpYyByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIGNvbnN0cjogV2VhcG9uQ29uc3RydWN0b3IpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFkZChrZXksIGNvbnN0cik7XHJcbiAgICB9XHJcbn1cclxuXHJcbnR5cGUgV2VhcG9uQ29uc3RydWN0b3IgPSBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gV2VhcG9uVHlwZTsiLCJpbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvUmVnaXN0cnlcIjtcclxuaW1wb3J0IFdlYXBvblR5cGUgZnJvbSBcIi4uL1dlYXBvblR5cGVzL1dlYXBvblR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYXBvblR5cGVSZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5PFdlYXBvblR5cGU+IHtcclxuICAgIFxyXG4gICAgcHVibGljIHByZWxvYWQoKTogdm9pZCB7fVxyXG5cclxuICAgIC8vIFdlIGRvbid0IG5lZWQgdGhpcyBmb3IgdGhpcyBhc3NpZ25tZW50XHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge31cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJJdGVtKGtleTogc3RyaW5nLCB0eXBlOiBXZWFwb25UeXBlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hZGQoa2V5LCB0eXBlKTtcclxuICAgIH1cclxufSIsIiIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9NYWluTWVudVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsYXNoU2NyZWVuIGV4dGVuZHMgU2NlbmUge1xyXG4gICAgcHJpdmF0ZSBzcGxhc2g6IExheWVyO1xyXG4gICAgcHJpdmF0ZSBzcGxhc2hfYmFja2dyb3VuZDogTGF5ZXI7XHJcblxyXG4gICAgbG9hZFNjZW5lKCkge1xyXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcInNwbGFzaEltYWdlXCIsIFwiZ2FtZV9hc3NldHMvaW1hZ2VzL3NwbGFzaF9zY3JlZW4ucG5nXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0U2NlbmUoKSB7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNwbGFzaCBzY3JlZW5cclxuICAgICAgICB0aGlzLnNwbGFzaCA9IHRoaXMuYWRkVUlMYXllcihcInNwbGFzaFNjcmVlblwiKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGEgYmFja2dyb3VuZCB0byB0aGUgc2NlbmVcclxuICAgICAgICB0aGlzLnNwbGFzaF9iYWNrZ3JvdW5kID0gdGhpcy5hZGRQYXJhbGxheExheWVyKFwic3BsYXNoX2JhY2tncm91bmRcIiwgbmV3IFZlYzIoMC41LCAxKSwgLTEpO1xyXG4gICAgICAgIGxldCBzYiA9IHRoaXMuYWRkLnNwcml0ZShcInNwbGFzaEltYWdlXCIsIFwic3BsYXNoX2JhY2tncm91bmRcIik7XHJcbiAgICAgICAgc2IucG9zaXRpb24uc2V0KHNiLnNpemUueC8yLCBzYi5zaXplLnkvMik7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0cmFuc3BhcmVudCBidXR0b25cclxuICAgICAgICBjb25zdCBjb25maXJtID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcInNwbGFzaFNjcmVlblwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBjb25maXJtLnNpemUuc2V0KDEyODAsIDcyMCk7XHJcbiAgICAgICAgY29uZmlybS5ib3JkZXJXaWR0aCA9IDA7XHJcbiAgICAgICAgY29uZmlybS5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGNvbmZpcm0uYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgY29uZmlybS5vbkNsaWNrRXZlbnRJZCA9IFwiY29uZmlybVwiO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgYnV0dG9uIGV2ZW50c1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiY29uZmlybVwiKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY2VuZSgpIHtcclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XHJcbiAgICAgICAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImNvbmZpcm1cIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGxhc2hfYmFja2dyb3VuZC5kaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKE1haW5NZW51LCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCBBY3RvciBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcblxyXG4vKipcclxuICogQSBtYW5hZ2VyIGNsYXNzIGZvciBhbGwgb2YgdGhlIEFJIGluIGEgc2NlbmUuXHJcbiAqIEtlZXBzIGEgbGlzdCBvZiByZWdpc3RlcmVkIGFjdG9ycyBhbmQgaGFuZGxlcyBBSSBnZW5lcmF0aW9uIGZvciBhY3RvcnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBSU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHQvKiogVGhlIGFycmF5IG9mIHJlZ2lzdGVyZWQgYWN0b3JzICovXHJcblx0YWN0b3JzOiBBcnJheTxBY3Rvcj47XHJcblx0LyoqIE1hcHMgQUkgbmFtZXMgdG8gdGhlaXIgY29uc3RydWN0b3JzICovXHJcblx0cmVnaXN0ZXJlZEFJOiBNYXA8QUlDb25zdHJ1Y3Rvcj47XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLmFjdG9ycyA9IG5ldyBBcnJheSgpO1xyXG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkgPSBuZXcgTWFwKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgYW4gYWN0b3Igd2l0aCB0aGUgQUlNYW5hZ2VyXHJcblx0ICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byByZWdpc3RlclxyXG5cdCAqL1xyXG5cdHJlZ2lzdGVyQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLmFjdG9ycy5wdXNoKGFjdG9yKTtcclxuXHR9XHJcblxyXG5cdHJlbW92ZUFjdG9yKGFjdG9yOiBBY3Rvcik6IHZvaWQge1xyXG5cdFx0bGV0IGluZGV4ID0gdGhpcy5hY3RvcnMuaW5kZXhPZihhY3Rvcik7XHJcblxyXG5cdFx0aWYoaW5kZXggIT09IC0xKXtcclxuXHRcdFx0dGhpcy5hY3RvcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhbiBBSSB3aXRoIHRoZSBBSU1hbmFnZXIgZm9yIHVzZSBsYXRlciBvblxyXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byByZWdpc3RlclxyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgQUlcclxuXHQgKi9cclxuXHRyZWdpc3RlckFJKG5hbWU6IHN0cmluZywgY29uc3RyOiBuZXcgPFQgZXh0ZW5kcyBBST4oKSA9PiBUICk6IHZvaWQge1xyXG5cdFx0dGhpcy5yZWdpc3RlcmVkQUkuYWRkKG5hbWUsIGNvbnN0cik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYW4gQUkgaW5zdGFuY2UgZnJvbSBpdHMgbmFtZVxyXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBBSSB0byBhZGRcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBBSSBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlQUkobmFtZTogc3RyaW5nKTogQUkge1xyXG5cdFx0aWYodGhpcy5yZWdpc3RlcmVkQUkuaGFzKG5hbWUpKXtcclxuXHRcdFx0cmV0dXJuIG5ldyAodGhpcy5yZWdpc3RlcmVkQUkuZ2V0KG5hbWUpKSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhyb3cgYENhbm5vdCBjcmVhdGUgQUkgd2l0aCBuYW1lICR7bmFtZX0sIG5vIEFJIHdpdGggdGhhdCBuYW1lIGlzIHJlZ2lzdGVyZWRgO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBSdW4gdGhlIGFpIGZvciBldmVyeSBhY3RpdmUgYWN0b3JcclxuXHRcdHRoaXMuYWN0b3JzLmZvckVhY2goYWN0b3IgPT4geyBpZihhY3Rvci5haUFjdGl2ZSkgYWN0b3IuYWkudXBkYXRlKGRlbHRhVCkgfSk7XHJcblx0fVxyXG59XHJcblxyXG50eXBlIEFJQ29uc3RydWN0b3IgPSBuZXcgPFQgZXh0ZW5kcyBBST4oKSA9PiBUOyIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogQSBwbGFjZWhvbGRlciBmdW5jdGlvbiBmb3IgTm8gT3BlcmF0aW9uLiBEb2VzIG5vdGhpbmdcclxuICovXHJcbmNvbnN0IE51bGxGdW5jID0gKCkgPT4ge307XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOdWxsRnVuYzsiLCIvKipcclxuICogQSBsaW5rZWQtbGlzdCBmb3IgdGhlIGVkZ2VzIGluIGEgQHJlZmVyZW5jZVtHcmFwaF0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFZGdlTm9kZSB7XHJcbiAgICAvKiogVGhlIG5vZGUgaW4gdGhlIEdyYXBoIHRoaXMgZWRnZSBjb25uZWN0cyB0byAqL1xyXG4gICAgeTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSB3ZWlnaHQgb2YgdGhpcyBFZGdlTm9kZSAqL1xyXG5cdHdlaWdodDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBuZXh0IEVkZ2VOb2RlIGluIHRoZSBsaW5rZWQtbGlzdCAqL1xyXG4gICAgbmV4dDogRWRnZU5vZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEVkZ2VOb2RlXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRoaXMgZWRnZSBjb25uZWN0cyB0b1xyXG4gICAgICogQHBhcmFtIHdlaWdodCBUaGUgd2VpZ2h0IG9mIHRoaXMgZWRnZVxyXG4gICAgICovXHJcblx0Y29uc3RydWN0b3IoaW5kZXg6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKXtcclxuXHRcdHRoaXMueSA9IGluZGV4O1xyXG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcclxuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0ID8gd2VpZ2h0IDogMTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgRWRnZU5vZGUgZnJvbSBcIi4vRWRnZU5vZGVcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBNQVhfViA9IDEwMDtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIGdyYXBoIGRhdGEgc3RydWN0dXJlIHVzaW5nIGVkZ2UgbGlzdHMuIEluc3BpcmVkIGJ5IFRoZSBBbGdvcml0aG0gRGVzaWduIE1hbnVhbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoIHtcclxuXHQvKiogQW4gYXJyYXkgb2YgZWRnZXMgYXQgdGhlIG5vZGUgc3BlY2lmaWVkIGJ5IHRoZSBpbmRleCAqL1xyXG5cdGVkZ2VzOiBBcnJheTxFZGdlTm9kZT47XHJcblx0LyoqIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgZGVncmVlIG9mIHRoZSBub2RlIHNwZWNpZmllZCBieSB0aGUgaW5kZXggKi9cclxuXHRkZWdyZWU6IEFycmF5PG51bWJlcj47XHJcblx0LyoqIFRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGdyYXBoICovXHJcblx0bnVtVmVydGljZXM6IG51bWJlcjtcclxuXHQvKiogVGhlIG51bWJlciBvZiBlZGdlcyBpbiB0aGUgZ3JhcGggKi9cclxuXHRudW1FZGdlczogbnVtYmVyO1xyXG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgZGlyZWN0ZWQgKi9cclxuXHRkaXJlY3RlZDogYm9vbGVhbjtcclxuXHQvKiogV2hldGhlciBvciBub3QgdGhlIGdyYXBoIGlzIHdlaWdodGVkICovXHJcblx0d2VpZ2h0ZWQ6IGJvb2xlYW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGhcclxuXHQgKiBAcGFyYW0gZGlyZWN0ZWQgV2hldGhlciBvciBub3QgdGhpcyBncmFwaCBpcyBkaXJlY3RlZFxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGRpcmVjdGVkOiBib29sZWFuID0gZmFsc2Upe1xyXG5cdFx0dGhpcy5kaXJlY3RlZCA9IGRpcmVjdGVkO1xyXG5cdFx0dGhpcy53ZWlnaHRlZCA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMubnVtVmVydGljZXMgPSAwO1xyXG5cdFx0dGhpcy5udW1FZGdlcyA9IDA7XHJcblxyXG5cdFx0dGhpcy5lZGdlcyA9IG5ldyBBcnJheShNQVhfVik7XHJcblx0XHR0aGlzLmRlZ3JlZSA9IG5ldyBBcnJheShNQVhfVik7XHJcblx0fVxyXG5cclxuXHQvKiogQWRkcyBhIG5vZGUgdG8gdGhpcyBncmFwaCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgaXRcclxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIG5ldyBub2RlXHJcblx0Ki9cclxuXHRhZGROb2RlKCk6IG51bWJlciB7XHJcblx0XHR0aGlzLm51bVZlcnRpY2VzKys7XHJcblx0XHRyZXR1cm4gdGhpcy5udW1WZXJ0aWNlcztcclxuXHR9XHJcblxyXG5cdC8qKiBBZGRzIGFuIGVkZ2UgYmV0d2VlbiBub2RlIHggYW5kIHksIHdpdGggYW4gb3B0aW9uYWwgd2VpZ2h0XHJcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBzdGFydCBvZiB0aGUgZWRnZVxyXG5cdCAqIEBwYXJhbSB5IFRoZSBpbmRleCBvZiB0aGUgZW5kIG9mIHRoZSBlZGdlXHJcblx0ICogQHBhcmFtIHdlaWdodCBUaGUgb3B0aW9uYWwgd2VpZ2h0IG9mIHRoZSBuZXcgZWRnZVxyXG5cdCovXHJcblx0YWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlciwgd2VpZ2h0PzogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRsZXQgZWRnZSA9IG5ldyBFZGdlTm9kZSh5LCB3ZWlnaHQpO1xyXG5cclxuXHJcblxyXG5cdFx0aWYodGhpcy5lZGdlc1t4XSl7XHJcblx0XHRcdGVkZ2UubmV4dCA9IHRoaXMuZWRnZXNbeF07XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHRoaXMuZWRnZXNbeF0gPSBlZGdlO1xyXG5cclxuXHRcdGlmKCF0aGlzLmRpcmVjdGVkKXtcclxuXHRcdFx0ZWRnZSA9IG5ldyBFZGdlTm9kZSh4LCB3ZWlnaHQpO1xyXG5cclxuXHRcdFx0aWYodGhpcy5lZGdlc1t5XSl7XHJcblx0XHRcdFx0ZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t5XTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5lZGdlc1t5XSA9IGVkZ2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5udW1FZGdlcyArPSAxO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGFuIGVkZ2UgZXhpc3RzIGJldHdlZW4gdHdvIG5vZGVzLlxyXG5cdCAqIFRoaXMgY2hlY2sgaXMgZGlyZWN0aW9uYWwgaWYgdGhpcyBpcyBhIGRpcmVjdGVkIGdyYXBoLlxyXG5cdCAqIEBwYXJhbSB4IFRoZSBmaXJzdCBub2RlXHJcblx0ICogQHBhcmFtIHkgVGhlIHNlY29uZCBub2RlXHJcblx0ICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlZGdlIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0ZWRnZUV4aXN0cyh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW3hdO1xyXG5cclxuXHRcdHdoaWxlKGVkZ2UgIT09IG51bGwpe1xyXG5cdFx0XHRpZihlZGdlLnkgPT09IHkpe1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBlZGdlIGxpc3QgYXNzb2NpYXRlZCB3aXRoIG5vZGUgeFxyXG5cdCAqIEBwYXJhbSB4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBoZWFkIG9mIGEgbGlua2VkLWxpc3Qgb2YgZWRnZXNcclxuXHQgKi9cclxuXHRnZXRFZGdlcyh4OiBudW1iZXIpOiBFZGdlTm9kZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lZGdlc1t4XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGRlZ3JlZSBhc3NvY2lhdGVkIHdpdGggbm9kZSB4XHJcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXHJcblx0ICovXHJcblx0Z2V0RGVncmVlKHg6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5kZWdyZWVbeF07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyB0aGUgc3BlY2lmZWQgbm9kZSBpbnRvIGEgc3RyaW5nXHJcblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBjb252ZXJ0IHRvIGEgc3RyaW5nXHJcblx0ICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZTogXCJOb2RlIHhcIlxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBub2RlVG9TdHJpbmcoaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCJOb2RlIFwiICsgaW5kZXg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyB0aGUgR3JhcGggaW50byBhIHN0cmluZyBmb3JtYXRcclxuXHQgKiBAcmV0dXJucyBUaGUgZ3JhcGggYXMgYSBzdHJpbmdcclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmVydGljZXM7IGkrKyl7XHJcblx0XHRcdGxldCBlZGdlID0gdGhpcy5lZGdlc1tpXTtcclxuXHRcdFx0bGV0IGVkZ2VTdHIgPSBcIlwiO1xyXG5cdFx0XHR3aGlsZShlZGdlICE9PSBudWxsKXtcclxuXHRcdFx0XHRlZGdlU3RyICs9IGVkZ2UueS50b1N0cmluZygpO1xyXG5cdFx0XHRcdGlmKHRoaXMud2VpZ2h0ZWQpe1xyXG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiAoXCIgKyBlZGdlLndlaWdodCArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihlZGdlLm5leHQgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiwgXCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRlZGdlID0gZWRnZS5uZXh0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR2YWwgKz0gdGhpcy5ub2RlVG9TdHJpbmcoaSkgKyBcIjogXCIgKyBlZGdlU3RyICsgXCJcXG5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmV0dmFsO1xyXG5cdH1cclxufSIsImltcG9ydCBHcmFwaCwgeyBNQVhfViB9IGZyb20gXCIuL0dyYXBoXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBEZWJ1Z1JlbmRlcmFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvRGVidWdSZW5kZXJhYmxlXCI7XHJcblxyXG4vKipcclxuICogQW4gZXh0ZW5zaW9uIG9mIEdyYXBoIHRoYXQgaGFzIG5vZGVzIHdpdGggcG9zaXRpb25zIGluIDJEIHNwYWNlLlxyXG4gKiBUaGlzIGlzIGEgd2VpZ2h0ZWQgZ3JhcGggKHRob3VnaCBub3QgaW5oZXJlbnRseSBkaXJlY3RkKVxyXG4qL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbkdyYXBoIGV4dGVuZHMgR3JhcGggaW1wbGVtZW50cyBEZWJ1Z1JlbmRlcmFibGUge1xyXG5cdC8qKiBBbiBhcnJheSBvZiB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBpbiB0aGlzIGdyYXBoICovXHJcblx0cG9zaXRpb25zOiBBcnJheTxWZWMyPjtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlZXMgYSBuZXcgUG9zaXRpb25HcmFwaFxyXG5cdCAqIEBwYXJhbSBkaXJlY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIGdyYXBoIGlzIGRpcmVjdGVkXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSl7XHJcblx0XHRzdXBlcihkaXJlY3RlZCk7XHJcblx0XHR0aGlzLnBvc2l0aW9ucyA9IG5ldyBBcnJheShNQVhfVik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgcG9zaXRpb25lZCBub2RlIHRvIHRoaXMgZ3JhcGhcclxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIHRvIGFkZFxyXG5cdCAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYWRkZWQgbm9kZVxyXG5cdCAqL1xyXG5cdGFkZFBvc2l0aW9uZWROb2RlKHBvc2l0aW9uOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdHRoaXMucG9zaXRpb25zW3RoaXMubnVtVmVydGljZXNdID0gcG9zaXRpb247XHJcblx0XHRyZXR1cm4gdGhpcy5hZGROb2RlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiBhIG5vZGUuXHJcblx0ICogQXV0b21hdGljYWxseSBhZGp1c3RzIHRoZSB3ZWlnaHRzIG9mIHRoZSBncmFwaCB0aWVkIHRvIHRoaXMgbm9kZS5cclxuXHQgKiBBcyBzdWNoLCBiZSB3YXJuZWQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBhbiBPKG4gKyBtKSBydW5uaW5nIHRpbWUsIGFuZCB1c2UgaXQgc3BhcmluZ2x5LlxyXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgbm9kZVxyXG5cdCAqL1xyXG5cdHNldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyLCBwb3NpdGlvbjogVmVjMik6IHZvaWQge1xyXG5cdFx0dGhpcy5wb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247XHJcblxyXG5cdFx0Ly8gUmVjYWxjdWxhdGUgYWxsIHdlaWdodHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5kZXhcclxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUVkZ2VzOyBpKyspe1xyXG5cclxuXHRcdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xyXG5cclxuXHRcdFx0d2hpbGUoZWRnZSAhPT0gbnVsbCl7XHJcblx0XHRcdFx0Ly8gSWYgdGhpcyBub2RlIGlzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBlZGdlLCByZWNhbGN1bGF0ZSB3ZWlnaHRcclxuXHRcdFx0XHRpZihpID09PSBpbmRleCB8fCBlZGdlLnkgPT09IGluZGV4KXtcclxuXHRcdFx0XHRcdGVkZ2Uud2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbaV0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1tlZGdlLnldKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZVxyXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuXHQgKiBAcmV0dXJucyBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGVcclxuXHQgKi9cclxuXHRnZXROb2RlUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMucG9zaXRpb25zW2luZGV4XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gZWRnZSB0byB0aGlzIGdyYXBoIGJldHdlZW4gbm9kZSB4IGFuZCB5LlxyXG5cdCAqIEF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlcyB0aGUgd2VpZ2h0IG9mIHRoZSBlZGdlIGFzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBub2Rlcy5cclxuXHQgKiBAcGFyYW0geCBUaGUgYmVnaW5uaW5nIG9mIHRoZSBlZGdlXHJcblx0ICogQHBhcmFtIHkgVGhlIGVuZCBvZiB0aGUgZWRnZVxyXG5cdCAqL1xyXG5cdGFkZEVkZ2UoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmKCF0aGlzLnBvc2l0aW9uc1t4XSB8fCAhdGhpcy5wb3NpdGlvbnNbeV0pe1xyXG5cdFx0XHR0aHJvdyBcIkNhbid0IGFkZCBlZGdlIHRvIHVuLXBvc2l0aW9uZWQgbm9kZSFcIjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXZWlnaHQgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vZGVzXHJcblx0XHRsZXQgd2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbeF0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1t5XSk7XHJcblxyXG5cdFx0c3VwZXIuYWRkRWRnZSh4LCB5LCB3ZWlnaHQpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIG5vZGVUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleCArIFwiIC0gXCIgKyB0aGlzLnBvc2l0aW9uc1tpbmRleF0udG9TdHJpbmcoKTtcclxuXHR9XHJcblxyXG5cdGRlYnVnUmVuZGVyID0gKCk6IHZvaWQgPT4ge1xyXG5cdFx0Ly8gZm9yKGxldCBwb2ludCBvZiB0aGlzLnBvc2l0aW9ucyl7XHJcblx0XHQvLyBcdGN0eC5maWxsUmVjdCgocG9pbnQueCAtIG9yaWdpbi54IC0gNCkqem9vbSwgKHBvaW50LnkgLSBvcmlnaW4ueSAtIDQpKnpvb20sIDgsIDgpO1xyXG5cdFx0Ly8gfVxyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xyXG5cclxuLyoqIEFuIG9iamVjdCB0aGF0IGlzIGEgcmVnaW9uLCB3aXRoIGEgc2l6ZSwgc2NhbGUsIGFuZCBib3VuZGFyeS4gKi9cclxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIFJlZ2lvbiB7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhpcyBvYmplY3QuICovXHJcbiAgICBzaXplOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgc2NhbGUgb2YgdGhpcyBvYmplY3QuICovXHJcbiAgICBzY2FsZTogVmVjMjtcclxuXHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG9iamVjdCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB6b29tIGFuZCBzY2FsZSAqL1xyXG4gICAgcmVhZG9ubHkgc2l6ZVdpdGhab29tOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgYm91bmRpbmcgYm94IG9mIHRoaXMgb2JqZWN0LiAqL1xyXG4gICAgYm91bmRhcnk6IEFBQkI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ2lvbihhcmc6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGFyZyAmJiBhcmcuc2l6ZSAmJiBhcmcuc2NhbGUgJiYgYXJnLmJvdW5kYXJ5O1xyXG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEFzc29jaWF0ZXMgc3RyaW5ncyB3aXRoIGVsZW1lbnRzIG9mIHR5cGUgVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XHJcblx0cHJpdmF0ZSBtYXA6IFJlY29yZDxzdHJpbmcsIFQ+O1xyXG5cclxuXHQvKiogQ3JlYXRlcyBhIG5ldyBtYXAgKi9cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5tYXAgPSB7fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSB2YWx1ZSBUIHN0b3JlZCBhdCBhIGtleS5cclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gYmUgc3RvcmVkXHJcblx0ICogQHBhcmFtIHZhbHVlIFRoZSBpdGVtIHRvIGJlIHN0b3JlZFxyXG5cdCAqL1xyXG5cdGFkZChrZXk6IHN0cmluZywgdmFsdWU6IFQpOiB2b2lkIHtcclxuXHRcdHRoaXMubWFwW2tleV0gPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEga2V5LlxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbVxyXG5cdCAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBrZXkgb3IgdW5kZWZpbmVkXHJcblx0ICovXHJcblx0Z2V0KGtleTogc3RyaW5nKTogVCB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGFsaWFzIG9mIGFkZC4gU2V0cyB0aGUgdmFsdWUgc3RvcmVkIGF0IGtleSB0byB0aGUgbmV3IHNwZWNpZmllZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBiZSBzdG9yZWRcclxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXHJcblx0ICovXHJcblx0c2V0KGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xyXG5cdFx0dGhpcy5hZGQoa2V5LCB2YWx1ZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYSB2YWx1ZSBzdG9yZWQgYXQgdGhlIHNwZWNpZmllZCBrZXksIGZhbHNlIG90aGVyd2lzZS5cclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gY2hlY2tcclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhlIGdpdmVuIGtleS5cclxuXHQgKi9cclxuXHRoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldICE9PSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUga2V5cyBpbiB0aGlzIG1hcC5cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCBrZXlzIGluIHRoZSBtYXAuXHJcblx0ICovXHJcblx0a2V5cygpOiBBcnJheTxzdHJpbmc+IHtcclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XHJcblx0fVxyXG5cdFxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGZvckVhY2goZnVuYzogKGtleTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLm1hcCkuZm9yRWFjaChrZXkgPT4gZnVuYyhrZXkpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlbGV0ZXMgYW4gaXRlbSBhc3NvY2lhdGVkIHdpdGggYSBrZXlcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgYXQgd2hpY2ggdG8gZGVsZXRlIGFuIGl0ZW1cclxuXHQgKi9cclxuXHRkZWxldGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGRlbGV0ZSB0aGlzLm1hcFtrZXldO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0Y2xlYXIoKTogdm9pZCB7XHJcblx0XHR0aGlzLmZvckVhY2goa2V5ID0+IGRlbGV0ZSB0aGlzLm1hcFtrZXldKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXAuXHJcblx0ICovXHJcblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGxldCBzdHIgPSBcIlwiO1xyXG5cclxuXHRcdHRoaXMuZm9yRWFjaCgoa2V5KSA9PiBzdHIgKz0ga2V5ICsgXCIgLT4gXCIgKyB0aGlzLmdldChrZXkpLnRvU3RyaW5nKCkgKyBcIlxcblwiKTtcclxuXHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuL1ZlYzJcIjtcclxuXHJcbi8qKiBBIDR4NCBtYXRyaXgwICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdDR4NCB7XHJcblx0cHJpdmF0ZSBtYXQ6IEZsb2F0MzJBcnJheTtcclxuXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMubWF0ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDBcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0Ly8gU3RhdGljIG1lbWJlcnNcclxuXHRzdGF0aWMgZ2V0IElERU5USVRZKCk6IE1hdDR4NCB7XHJcblx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLmlkZW50aXR5KCk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IFpFUk8oKTogTWF0NHg0IHtcclxuXHRcdHJldHVybiBuZXcgTWF0NHg0KCkuemVybygpO1xyXG5cdH1cclxuXHJcblx0Ly8gQWNjZXNzb3JzXHJcblx0c2V0IF8wMCh4OiBudW1iZXIpIHtcclxuXHRcdHRoaXMubWF0WzBdID0geDtcclxuXHR9XHJcblxyXG5cdHNldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0aWYoY29sIDwgMCB8fCBjb2wgPiAzIHx8IHJvdyA8IDAgfHwgcm93ID4gMyl7XHJcblx0XHRcdHRocm93IGBFcnJvciAtIGluZGV4ICgke2NvbH0sICR7cm93fSkgaXMgb3V0IG9mIGJvdW5kcyBmb3IgTWF0NHg0YFxyXG5cdFx0fVxyXG5cdFx0dGhpcy5tYXRbcm93KjQgKyBjb2xdID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRnZXQoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLm1hdFtyb3cqNCArIGNvbF07XHJcblx0fVxyXG5cclxuXHRzZXRBbGwoLi4uaXRlbXM6IEFycmF5PG51bWJlcj4pOiBNYXQ0eDQge1xyXG5cdFx0dGhpcy5tYXQuc2V0KGl0ZW1zKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0aWRlbnRpdHkoKTogTWF0NHg0IHtcclxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcclxuXHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cdFx0KVxyXG5cdH1cclxuXHJcblx0emVybygpOiBNYXQ0eDQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWFrZXMgdGhpcyBNYXQ0eDQgYSByb3RhdGlvbiBtYXRyaXggb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgcmFkaWFucyBjY3dcclxuXHQgKiBAcGFyYW0gelJhZGlhbnMgVGhlIG51bWJlciBvZiByYWRpYW5zIHRvIHJvdGF0ZVxyXG5cdCAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XHJcblx0ICovXHJcblx0cm90YXRlKHpSYWRpYW5zOiBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHRNYXRoLmNvcyh6UmFkaWFucyksIC1NYXRoLnNpbih6UmFkaWFucyksIFx0MCwgMCxcclxuXHRcdFx0TWF0aC5zaW4oelJhZGlhbnMpLCBNYXRoLmNvcyh6UmFkaWFucyksIFx0MCwgMCxcclxuXHRcdFx0MCwgXHRcdFx0XHRcdDAsIFx0XHRcdFx0XHRcdDEsIDAsXHJcblx0XHRcdDAsIFx0XHRcdFx0XHQwLCBcdFx0XHRcdFx0XHQwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVHVybnMgdGhpcyBNYXQ0eDQgaW50byBhIHRyYW5zbGF0aW9uIG1hdHJpeCBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zbGF0aW9uXHJcblx0ICogQHBhcmFtIHRyYW5zbGF0aW9uIFRoZSB0cmFuc2xhdGlvbiBpbiB4IGFuZCB5XHJcblx0ICogQHJldHVybnMgdGhpcyBNYXQ0eDRcclxuXHQgKi9cclxuXHR0cmFuc2xhdGUodHJhbnNsYXRpb246IFZlYzIgfCBGbG9hdDMyQXJyYXkpOiBNYXQ0eDQge1xyXG5cdFx0Ly8gSWYgdHJhbnNsYXRpb24gaXMgYSB2ZWMsIGdldCBpdHMgYXJyYXlcclxuXHRcdGlmKHRyYW5zbGF0aW9uIGluc3RhbmNlb2YgVmVjMil7XHJcblx0XHRcdHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb24udG9BcnJheSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcclxuXHRcdFx0MSwgMCwgMCwgdHJhbnNsYXRpb25bMF0sXHJcblx0XHRcdDAsIDEsIDAsIHRyYW5zbGF0aW9uWzFdLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0c2NhbGUoc2NhbGU6IFZlYzIgfCBGbG9hdDMyQXJyYXkgfCBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlIGlzIGEgZmxvYXQzMkFycmF5XHJcblx0XHRpZihzY2FsZSBpbnN0YW5jZW9mIFZlYzIpe1xyXG5cdFx0XHRzY2FsZSA9IHNjYWxlLnRvQXJyYXkoKTtcclxuXHRcdH0gZWxzZSBpZighKHNjYWxlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSl7XHJcblx0XHRcdHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbc2NhbGUsIHNjYWxlXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHRzY2FsZVswXSwgMCwgXHRcdDAsIDAsXHJcblx0XHRcdDAsIFx0XHQgIHNjYWxlWzFdLCAwLCAwLFxyXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQxLCAwLFxyXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG5ldyBNYXQ0eDQgdGhhdCByZXByZXNlbnRzIHRoZSByaWdodCBzaWRlIG11bHRpcGxpY2F0aW9uIFRISVMgeCBPVEhFUlxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgTWF0NHg0IHRvIG11bHRpcGx5IGJ5XHJcblx0ICogQHJldHVybnMgYSBuZXcgTWF0NHg0IGNvbnRhaW5pbmcgdGhlIHByb2R1Y3Qgb2YgdGhlc2UgdHdvIE1hdDR4NHNcclxuXHQgKi9cclxuXHRtdWx0KG90aGVyOiBNYXQ0eDQsIG91dD86IE1hdDR4NCk6IE1hdDR4NCB7XHJcblx0XHRsZXQgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspe1xyXG5cdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgNDsgaisrKXtcclxuXHRcdFx0XHRsZXQgdmFsdWUgPSAwO1xyXG5cdFx0XHRcdGZvcihsZXQgayA9IDA7IGsgPCA0OyBrKyspe1xyXG5cdFx0XHRcdFx0dmFsdWUgKz0gdGhpcy5nZXQoaywgaSkgKiBvdGhlci5nZXQoaiwgayk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRlbXBbaio0ICsgaV0gID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZihvdXQgIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdHJldHVybiBvdXQuc2V0QWxsKC4uLnRlbXApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBNYXQ0eDQoKS5zZXRBbGwoLi4udGVtcCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNdWx0aXBsaWVzIGFsbCBnaXZlbiBtYXRyaWNpZXMgaW4gb3JkZXIuIGUuZy4gTVVMVChBLCBCLCBDKSAtPiBBKkIqQ1xyXG5cdCAqIEBwYXJhbSBtYXRzIEEgbGlzdCBvZiBNYXQ0eDRzIHRvIG11bHRpcGx5IGluIG9yZGVyXHJcblx0ICogQHJldHVybnMgQSBuZXcgTWF0NHg0IGhvbGRpbmcgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXHJcblx0ICovXHJcblx0c3RhdGljIE1VTFQoLi4ubWF0czogQXJyYXk8TWF0NHg0Pik6IE1hdDR4NCB7XHJcblx0XHQvLyBDcmVhdGUgYSBuZXcgYXJyYXlcclxuXHRcdGxldCB0ZW1wID0gTWF0NHg0LklERU5USVRZO1xyXG5cclxuXHRcdC8vIE11bHRpcGx5IGJ5IGV2ZXJ5IGFycmF5IGluIG9yZGVyLCBpbiBwbGFjZVxyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IG1hdHMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHR0ZW1wLm11bHQobWF0c1tpXSwgdGVtcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRlbXA7XHJcblx0fVxyXG5cclxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXQ7XHJcblx0fVxyXG5cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICBgfCR7dGhpcy5tYXRbMF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbM10udG9GaXhlZCgyKX18XFxuYCArIFxyXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFs0XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs1XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs2XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs3XS50b0ZpeGVkKDIpfXxcXG5gICtcclxuXHRcdFx0XHRgfCR7dGhpcy5tYXRbOF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbOV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTBdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzExXS50b0ZpeGVkKDIpfXxcXG5gICtcclxuXHRcdFx0XHRgfCR7dGhpcy5tYXRbMTJdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzEzXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxNF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTVdLnRvRml4ZWQoMil9fGA7XHJcblx0fVxyXG59IiwiaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5pbXBvcnQgSGl0IGZyb20gXCIuL0hpdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyB0aGUgYXJlYSBvZiBvdmVybGFwIG9mIHR3byBjb2xsaWRpbmcgb2JqZWN0cyB0byBhbGxvdyBmb3Igc29ydGluZyBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmVhQ29sbGlzaW9uIHtcclxuICAgIC8qKiBUaGUgYXJlYSBvZiB0aGUgb3ZlcmxhcCBmb3IgdGhlIGNvbGxpZGluZyBvYmplY3RzICovXHJcbiAgICBhcmVhOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBBQUJCIG9mIHRoZSBvdGhlciBjb2xsaWRlciBpbiB0aGlzIGNvbGxpc2lvbiAqL1xyXG4gICAgY29sbGlkZXI6IEFBQkI7XHJcblxyXG4gICAgLyoqIFR5cGUgb2YgdGhlIGNvbGxpc2lvbiAqL1xyXG4gICAgdHlwZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBUaGVyIG90aGVyIG9iamVjdCBpbiB0aGUgY29sbGlzaW9uICovXHJcbiAgICBvdGhlcjogUGh5c2ljYWw7XHJcblxyXG4gICAgLyoqIFRoZSB0aWxlLCBpZiB0aGlzIHdhcyBhIHRpbGVtYXAgY29sbGlzaW9uICovXHJcbiAgICB0aWxlOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgcGh5c2ljcyBoaXQgZm9yIHRoaXMgb2JqZWN0ICovXHJcbiAgICBoaXQ6IEhpdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgQXJlYUNvbGxpc2lvbiBvYmplY3RcclxuICAgICAqIEBwYXJhbSBhcmVhIFRoZSBhcmVhIG9mIHRoZSBjb2xsaXNpb25cclxuICAgICAqIEBwYXJhbSBjb2xsaWRlciBUaGUgb3RoZXIgY29sbGlkZXJcclxuICAgICAqL1xyXG5cdGNvbnN0cnVjdG9yKGFyZWE6IG51bWJlciwgY29sbGlkZXI6IEFBQkIsIG90aGVyOiBQaHlzaWNhbCwgdHlwZTogc3RyaW5nLCB0aWxlOiBWZWMyKXtcclxuXHRcdHRoaXMuYXJlYSA9IGFyZWE7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IGNvbGxpZGVyO1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudGlsZSA9IHRpbGU7XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRhIGNvbGxlY3RlZCBmcm9tIGEgcGh5c2ljcyBoaXQgYmV0d2VlbiB0d28gZ2VvbWV0cmljIG9iamVjdHMuXHJcbiAqIEluc3BpcmVkIGJ5IHRoZSBoZWxwZnVsIGNvbGxpc2lvbiBkb2N1bWVudGF0aW9uIEBsaW5rKGhlcmUpKGh0dHBzOi8vbm9vbmF0LmdpdGh1Yi5pby9pbnRlcnNlY3QvKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpdCB7XHJcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGNvbGxpc2lvbi4gT25seSBudW1iZXJzIDAgdGhyb3VnaCAxIGhhcHBlbiBpbiB0aGlzIGZyYW1lLiAqL1xyXG4gICAgdGltZTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBuZWFyIHRpbWVzIG9mIHRoZSBjb2xsaXNpb24gKi9cclxuICAgIG5lYXJUaW1lczogVmVjMiA9IFZlYzIuWkVSTztcclxuICAgIC8qKiBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbGxpc2lvbiAqL1xyXG4gICAgcG9zOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gICAgLyoqIFRoZSBvdmVybGFwIGRpc3RhbmNlIG9mIHRoZSBoaXQgKi9cclxuICAgIGRlbHRhOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gICAgLyoqIFRoZSBub3JtYWwgdmVjdG9yIG9mIHRoZSBoaXQgKi9cclxuICAgIG5vcm1hbDogVmVjMiA9IFZlYzIuWkVSTztcclxufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBBIEZJRk8gcXVldWUgd2l0aCBlbGVtZW50cyBvZiB0eXBlIFRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XHJcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBRdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBNQVhfRUxFTUVOVFM6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSBxOiBBcnJheTxUPjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBoZWFkIG9mIHRoZSBxdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSBoZWFkOiBudW1iZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgdGFpbCBvZiB0aGUgcXVldWUgKi9cclxuICAgIHByaXZhdGUgdGFpbDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgY3VycmVudCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHF1ZXVlICovXHJcbiAgICBwcml2YXRlIHNpemU6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcXVldWVcclxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKXtcclxuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMucSA9IG5ldyBBcnJheSh0aGlzLk1BWF9FTEVNRU5UUyk7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gMDtcclxuICAgICAgICB0aGlzLnRhaWwgPSAwO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXHJcbiAgICAgKi9cclxuICAgIGVucXVldWUoaXRlbTogVCk6IHZvaWR7XHJcbiAgICAgICAgaWYoKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFMgPT09IHRoaXMuaGVhZCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNpemUgKz0gMTtcclxuICAgICAgICB0aGlzLnFbdGhpcy50YWlsXSA9IGl0ZW07XHJcbiAgICAgICAgdGhpcy50YWlsID0gKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgICAqL1xyXG4gICAgZGVxdWV1ZSgpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IHJlbW92ZSBlbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRoaXMuc2l6ZSAtPSAxO1xyXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5xW3RoaXMuaGVhZF07XHJcbiAgICAgICAgLy8gTm93IGRlbGV0ZSB0aGUgaXRlbVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnFbdGhpcy5oZWFkXTtcclxuICAgICAgICB0aGlzLmhlYWQgPSAodGhpcy5oZWFkICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZSwgYnV0IGRvZXMgbm90IHJlbW92ZSBpdFxyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxyXG4gICAgICovXHJcbiAgICBwZWVrTmV4dCgpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XHJcbiAgICAgICAgICAgIHRocm93IFwiUXVldWUgZW1wdHkgLSBjYW5ub3QgZ2V0IGVsZW1lbnRcIlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVldWUgaGFzIGl0ZW1zIGluIGl0LCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBxdWV1ZSBoYXMgaXRlbXNcclxuICAgICAqL1xyXG4gICAgaGFzSXRlbXMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCAhPT0gdGhpcy50YWlsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBxdWV1ZVxyXG4gICAgICovXHJcbiAgICBnZXRTaXplKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnFbaW5kZXhdKTtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgd2hpbGUoaSAhPT0gdGhpcy50YWlsKXtcclxuICAgICAgICAgICAgZnVuYyh0aGlzLnFbaV0sIGkpO1xyXG4gICAgICAgICAgICBpID0gKGkgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgcXVldWUgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHF1ZXVlXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgaWYoaW5kZXggIT09IDApe1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dmFsID0gc3RyICsgcmV0dmFsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XHJcbiAgICB9XHJcbn0iLCIvKiogQSBjb250YWluZXIgZm9yIGluZm8gYWJvdXQgYSB3ZWJHTCBzaGFkZXIgcHJvZ3JhbSAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFByb2dyYW1UeXBlIHtcclxuXHQvKiogQSB3ZWJHTCBwcm9ncmFtICovXHJcblx0cHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG5cdFxyXG5cdC8qKiBBIHZlcnRleCBzaGFkZXIgKi9cclxuXHR2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xyXG5cclxuXHQvKiogQSBmcmFnbWVudCBzaGFkZXIgKi9cclxuXHRmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlbGV0ZXMgdGhpcyBzaGFkZXIgcHJvZ3JhbVxyXG5cdCAqL1xyXG5cdGRlbGV0ZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XHJcblx0XHQvLyBDbGVhbiB1cCBhbGwgYXNwZWN0cyBvZiB0aGlzIHByb2dyYW1cclxuXHRcdGlmKHRoaXMucHJvZ3JhbSl7XHJcblx0XHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuXHRcdH1cclxuXHRcdFx0XHJcblx0XHRpZih0aGlzLnZlcnRleFNoYWRlcil7XHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5mcmFnbWVudFNoYWRlcil7XHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4vQ2lyY2xlXCI7XHJcbmltcG9ydCBIaXQgZnJvbSBcIi4uL1BoeXNpY3MvSGl0XCI7XHJcblxyXG4vKipcclxuICogQW4gQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveC4gSW4gb3RoZXIgd29yZHMsIGEgcmVjdGFuZ2xlIHRoYXQgaXMgYWx3YXlzIGFsaWduZWQgdG8gdGhlIHgteSBncmlkLlxyXG4gKiBJbnNwaXJlZCBieSB0aGUgaGVscGZ1bCBjb2xsaXNpb24gZG9jdW1lbnRhdGlvbiBAbGluayhoZXJlKShodHRwczovL25vb25hdC5naXRodWIuaW8vaW50ZXJzZWN0LykuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBQUJCIGV4dGVuZHMgU2hhcGUge1xyXG4gICAgY2VudGVyOiBWZWMyO1xyXG4gICAgaGFsZlNpemU6IFZlYzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFBQkJcclxuICAgICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgQUFCQlxyXG4gICAgICogQHBhcmFtIGhhbGZTaXplIFRoZSBoYWxmIHNpemUgb2YgdGhlIEFBQkIgLSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHRvIGFuIGVkZ2UgaW4geCBhbmQgeVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjZW50ZXI/OiBWZWMyLCBoYWxmU2l6ZT86IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBjZW50ZXIgPyBjZW50ZXIgOiBuZXcgVmVjMigwLCAwKTtcclxuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemUgPyBoYWxmU2l6ZSA6IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICAgIGdldCB0b3BMZWZ0KCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMudG9wKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXHJcbiAgICBnZXQgdG9wUmlnaHQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMudG9wKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICAgIGdldCBib3R0b21MZWZ0KCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXHJcbiAgICBnZXQgYm90dG9tUmlnaHQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCk6IEFBQkIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xyXG4gICAgICAgIGxldCByID0gTWF0aC5tYXgodGhpcy5odywgdGhpcy5oaClcclxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLmNlbnRlci5jbG9uZSgpLCByKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgZ2V0SGFsZlNpemUoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgIHNldEhhbGZTaXplKGhhbGZTaXplOiBWZWMyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5oYWxmU2l6ZSA9IGhhbGZTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gLSBtb3ZlIHRoZXNlIGFsbCB0byB0aGUgU2hhcGUgY2xhc3NcclxuICAgIC8qKlxyXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBwb2ludC54ID49IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XHJcbiAgICAgICAgICAgICYmIHBvaW50LnkgPj0gdGhpcy55IC0gdGhpcy5oaCAmJiBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3RQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBkeCA9IHBvaW50LnggLSB0aGlzLng7XHJcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyAtIE1hdGguYWJzKGR4KTtcclxuICAgICAgICBcclxuICAgICAgICBpZihweCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGR5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoIC0gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgICAgICBpZihweSA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludCB3aXRoIHNvZnQgbGVmdCBhbmQgdG9wIGJvdW5kYXJpZXMuXHJcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgaWYgdGhlIHRvcCBsZWZ0IGlzICgwLCAwKSwgdGhlIHBvaW50ICgwLCAwKSBpcyBub3QgaW4gdGhlIEFBQkJcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBjb250YWluc1BvaW50U29mdChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBwb2ludC54ID4gdGhpcy54IC0gdGhpcy5odyAmJiBwb2ludC54IDw9IHRoaXMueCArIHRoaXMuaHdcclxuICAgICAgICAgICAgJiYgcG9pbnQueSA+IHRoaXMueSAtIHRoaXMuaGggJiYgcG9pbnQueSA8PSB0aGlzLnkgKyB0aGlzLmhoXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBmcm9tIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBBQUJCIHdpdGggYSBsaW5lIHNlZ21lbnQgZnJvbSBhIHBvaW50IGluIGEgZGlyZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRoYXQgdGhlIGxpbmUgc2VnbWVudCBzdGFydHMgZnJvbVxyXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgKiBAcGFyYW0gcGFkZGluZyBQYWRzIHRoZSBBQUJCIHRvIG1ha2UgaXQgd2lkZXIgZm9yIHRoZSBpbnRlcnNlY3Rpb24gdGVzdFxyXG4gICAgICogQHJldHVybnMgVGhlIEhpdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24sIG9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIGludGVyc2VjdGlvblxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3RTZWdtZW50KHBvaW50OiBWZWMyLCBkZWx0YTogVmVjMiwgcGFkZGluZz86IFZlYzIpOiBIaXQge1xyXG4gICAgICAgIGxldCBwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nLnggOiAwO1xyXG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nLnkgOiAwO1xyXG5cclxuICAgICAgICBsZXQgc2NhbGVYID0gMS9kZWx0YS54O1xyXG4gICAgICAgIGxldCBzY2FsZVkgPSAxL2RlbHRhLnk7XHJcblxyXG4gICAgICAgIGxldCBzaWduWCA9IE1hdGhVdGlscy5zaWduKHNjYWxlWCk7XHJcbiAgICAgICAgbGV0IHNpZ25ZID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVZKTtcclxuXHJcbiAgICAgICAgbGV0IHRuZWFyeCA9IHNjYWxlWCoodGhpcy54IC0gc2lnblgqKHRoaXMuaHcgKyBwYWRkaW5nWCkgLSBwb2ludC54KTtcclxuICAgICAgICBsZXQgdG5lYXJ5ID0gc2NhbGVZKih0aGlzLnkgLSBzaWduWSoodGhpcy5oaCArIHBhZGRpbmdZKSAtIHBvaW50LnkpO1xyXG4gICAgICAgIGxldCB0ZmFyeCA9IHNjYWxlWCoodGhpcy54ICsgc2lnblgqKHRoaXMuaHcgKyBwYWRkaW5nWCkgLSBwb2ludC54KTtcclxuICAgICAgICBsZXQgdGZhcnkgPSBzY2FsZVkqKHRoaXMueSArIHNpZ25ZKih0aGlzLmhoICsgcGFkZGluZ1kpIC0gcG9pbnQueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodG5lYXJ4ID4gdGZhcnkgfHwgdG5lYXJ5ID4gdGZhcngpe1xyXG4gICAgICAgICAgICAvLyBXZSBhcmVuJ3QgY29sbGlkaW5nIC0gd2UgY2xlYXIgb25lIGF4aXMgYmVmb3JlIGludGVyc2VjdGluZyBhbm90aGVyXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRuZWFyID0gTWF0aC5tYXgodG5lYXJ4LCB0bmVhcnkpO1xyXG5cclxuICAgICAgICAvLyBEb3VibGUgY2hlY2sgZm9yIE5hTnNcclxuICAgICAgICBpZih0bmVhcnggIT09IHRuZWFyeCl7XHJcbiAgICAgICAgICAgIHRuZWFyID0gdG5lYXJ5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodG5lYXJ5ICE9PSB0bmVhcnkpe1xyXG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB0ZmFyID0gTWF0aC5taW4odGZhcngsIHRmYXJ5KTtcclxuXHJcbiAgICAgICAgaWYodG5lYXIgPT09IC1JbmZpbml0eSl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodG5lYXIgPj0gMSB8fCB0ZmFyIDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGFyZSBjb2xsaWRpbmdcclxuICAgICAgICBsZXQgaGl0ID0gbmV3IEhpdCgpO1xyXG4gICAgICAgIGhpdC50aW1lID0gTWF0aFV0aWxzLmNsYW1wMDEodG5lYXIpO1xyXG4gICAgICAgIGhpdC5uZWFyVGltZXMueCA9IHRuZWFyeDtcclxuICAgICAgICBoaXQubmVhclRpbWVzLnkgPSB0bmVhcnk7XHJcblxyXG4gICAgICAgIGlmKHRuZWFyeCA+IHRuZWFyeSl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgbGVmdCBvciByaWdodCBzaXplXHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gMDtcclxuICAgICAgICB9IGVsc2UgaWYoTWF0aC5hYnModG5lYXJ4IC0gdG5lYXJ5KSA8IDAuMDAwMSl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgY29ybmVyXHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gLXNpZ25ZO1xyXG4gICAgICAgICAgICBoaXQubm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgdG9wIG9yIGJvdHRvbVxyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAwO1xyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoaXQuZGVsdGEueCA9ICgxLjAgLSBoaXQudGltZSkgKiAtZGVsdGEueDtcclxuICAgICAgICBoaXQuZGVsdGEueSA9ICgxLjAgLSBoaXQudGltZSkgKiAtZGVsdGEueTtcclxuICAgICAgICBoaXQucG9zLnggPSBwb2ludC54ICsgZGVsdGEueCAqIGhpdC50aW1lO1xyXG4gICAgICAgIGhpdC5wb3MueSA9IHBvaW50LnkgKyBkZWx0YS55ICogaGl0LnRpbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBoaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuIHtcclxuICAgICAgICBpZihvdGhlciBpbnN0YW5jZW9mIEFBQkIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwc0FBQkIob3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBcIk92ZXJsYXAgbm90IGRlZmluZWQgYmV0d2VlbiB0aGVzZSBzaGFwZXMuXCJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgb3ZlcmxhcHMgYW5vdGhlclxyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrIGFnYWluc3RcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBBQUJCIG92ZXJsYXBzIHRoZSBvdGhlciwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvdmVybGFwc0FBQkIob3RoZXI6IEFBQkIpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgZHggPSBvdGhlci54IC0gdGhpcy54O1xyXG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcclxuICAgICAgICBcclxuICAgICAgICBpZihweCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcclxuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XHJcblxyXG4gICAgICAgIGlmKHB5IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGVzZSBBQUJCcyBhcmUgSlVTVCB0b3VjaGluZyAtIG5vdCBvdmVybGFwcGluZy5cclxuICAgICAqIFZlYzIueCBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgdG8gdGhlIGxlZnQsIDEgaWYgdG8gdGhlIHJpZ2h0LlxyXG4gICAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQiB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgVGhlIGNvbGxpc2lvbiBzaWRlcyBzdG9yZWQgaW4gYSBWZWMyIGlmIHRoZSBBQUJCcyBhcmUgdG91Y2hpbmcsIG51bGwgb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHRvdWNoZXNBQUJCKG90aGVyOiBBQUJCKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcclxuICAgICAgICBsZXQgcHggPSB0aGlzLmh3ICsgb3RoZXIuaHcgLSBNYXRoLmFicyhkeCk7XHJcblxyXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XHJcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgICAgICAvLyBJZiBvbmUgYXhpcyBpcyBqdXN0IHRvdWNoaW5nIGFuZCB0aGUgb3RoZXIgaXMgb3ZlcmxhcHBpbmcsIHRydWVcclxuICAgICAgICBpZigocHggPT09IDAgJiYgcHkgPj0gMCkgfHwgKHB5ID09PSAwICYmIHB4ID49IDApKXtcclxuICAgICAgICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XHJcblxyXG4gICAgICAgICAgICBpZihweCA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHB5ID09PSAwKXtcclxuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlc2UgQUFCQnMgYXJlIEpVU1QgdG91Y2hpbmcgLSBub3Qgb3ZlcmxhcHBpbmcuXHJcbiAgICAgKiBBbHNvLCBpZiB0aGV5IGFyZSBvbmx5IHRvdWNoaW5nIGNvcm5lcnMsIHRoZXkgYXJlIGNvbnNpZGVyZWQgbm90IHRvdWNoaW5nLlxyXG4gICAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXHJcbiAgICAgKiBMaWtld2lzZSwgVmVjMi55IGlzIC0xIGlmIHRoZSBvdGhlciBpcyBvbiB0b3AsIDEgaWYgb24gYm90dG9tLlxyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lkZSBvZiB0aGUgdG91Y2gsIHN0b3JlZCBhcyBhIFZlYzIsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gdG91Y2hcclxuICAgICAqL1xyXG4gICAgdG91Y2hlc0FBQkJXaXRob3V0Q29ybmVycyhvdGhlcjogQUFCQik6IFZlYzIge1xyXG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XHJcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xyXG5cclxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xyXG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcclxuXHJcbiAgICAgICAgLy8gSWYgb25lIGF4aXMgaXMgdG91Y2hpbmcsIGFuZCB0aGUgb3RoZXIgaXMgc3RyaWN0bHkgb3ZlcmxhcHBpbmdcclxuICAgICAgICBpZigocHggPT09IDAgJiYgcHkgPiAwKSB8fCAocHkgPT09IDAgJiYgcHggPiAwKSl7XHJcbiAgICAgICAgICAgIGxldCByZXQgPSBuZXcgVmVjMigpO1xyXG5cclxuICAgICAgICAgICAgaWYocHggPT09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0LnggPSBvdGhlci54IDwgdGhpcy54ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0LnkgPSBvdGhlci55IDwgdGhpcy55ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhpcyBBQUJCIGFuZCBhbm90aGVyXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkJcclxuICAgICAqIEByZXR1cm5zIFRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhlIEFBQkJzXHJcbiAgICAgKi9cclxuICAgIG92ZXJsYXBBcmVhKG90aGVyOiBBQUJCKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgbGVmdHggPSBNYXRoLm1heCh0aGlzLnggLSB0aGlzLmh3LCBvdGhlci54IC0gb3RoZXIuaHcpO1xyXG4gICAgICAgIGxldCByaWdodHggPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLmh3LCBvdGhlci54ICsgb3RoZXIuaHcpO1xyXG4gICAgICAgIGxldCBkeCA9IHJpZ2h0eCAtIGxlZnR4O1xyXG5cclxuICAgICAgICBsZXQgbGVmdHkgPSBNYXRoLm1heCh0aGlzLnkgLSB0aGlzLmhoLCBvdGhlci55IC0gb3RoZXIuaGgpO1xyXG4gICAgICAgIGxldCByaWdodHkgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhoLCBvdGhlci55ICsgb3RoZXIuaGgpO1xyXG4gICAgICAgIGxldCBkeSA9IHJpZ2h0eSAtIGxlZnR5O1xyXG5cclxuICAgICAgICBpZihkeCA8IDAgfHwgZHkgPCAwKSByZXR1cm4gMDtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gZHgqZHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBhbmQgcmVzaXplcyB0aGlzIHJlY3QgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiB0byB0aGUgcG9zaXRpb24gc3BlY2lmaWVkXHJcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIG1vdmVtZW50IG9mIHRoZSByZWN0IGZyb20gaXRzIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIEEgcG9zaXRpb24gc3BlY2lmaWVkIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBvZiBzd2VlcGluZ1xyXG4gICAgICogQHBhcmFtIGhhbGZTaXplIFRoZSBoYWxmU2l6ZSBvZiB0aGUgc3dlZXBpbmcgcmVjdCBcclxuICAgICAqL1xyXG4gICAgc3dlZXAodmVsb2NpdHk6IFZlYzIsIGZyb21Qb3NpdGlvbj86IFZlYzIsIGhhbGZTaXplPzogVmVjMik6IHZvaWQge1xyXG4gICAgICAgIGlmKCFmcm9tUG9zaXRpb24pe1xyXG4gICAgICAgICAgICBmcm9tUG9zaXRpb24gPSB0aGlzLmNlbnRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFoYWxmU2l6ZSl7XHJcbiAgICAgICAgICAgIGhhbGZTaXplID0gdGhpcy5oYWxmU2l6ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjZW50ZXJYID0gZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54LzI7XHJcbiAgICAgICAgbGV0IGNlbnRlclkgPSBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkvMjtcclxuXHJcbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihmcm9tUG9zaXRpb24ueCAtIGhhbGZTaXplLngsIGZyb21Qb3NpdGlvbi54ICsgdmVsb2NpdHkueCAtIGhhbGZTaXplLngpO1xyXG4gICAgICAgIGxldCBtaW5ZID0gTWF0aC5taW4oZnJvbVBvc2l0aW9uLnkgLSBoYWxmU2l6ZS55LCBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkgLSBoYWxmU2l6ZS55KTtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXIuc2V0KGNlbnRlclgsIGNlbnRlclkpO1xyXG4gICAgICAgIHRoaXMuaGFsZlNpemUuc2V0KGNlbnRlclggLSBtaW5YLCBjZW50ZXJZIC0gbWluWSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgY2xvbmUoKTogQUFCQiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBQUJCKHRoaXMuY2VudGVyLmNsb25lKCksIHRoaXMuaGFsZlNpemUuY2xvbmUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIEFBQkIgdG8gYSBzdHJpbmcgZm9ybWF0XHJcbiAgICAgKiBAcmV0dXJucyAoY2VudGVyOiAoeCwgeSksIGhhbGZTaXplOiAoeCwgeSkpXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiKGNlbnRlcjogXCIgKyB0aGlzLmNlbnRlci50b1N0cmluZygpICsgXCIsIGhhbGYtc2l6ZTogXCIgKyB0aGlzLmhhbGZTaXplLnRvU3RyaW5nKCkgKyBcIilcIlxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIENpcmNsZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2hhcGUge1xyXG5cdHByaXZhdGUgX2NlbnRlcjogVmVjMjtcclxuXHRyYWRpdXM6IG51bWJlcjtcclxuXHRcclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IENpcmNsZVxyXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihjZW50ZXI6IFZlYzIsIHJhZGl1czogbnVtYmVyKSB7XHJcblx0XHRzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzID8gcmFkaXVzIDogMDtcclxuXHR9XHJcblxyXG5cdGdldCBjZW50ZXIoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2VudGVyO1xyXG5cdH1cclxuXHJcblx0c2V0IGNlbnRlcihjZW50ZXI6IFZlYzIpIHtcclxuXHRcdHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcclxuXHR9XHJcblxyXG5cdGdldCBoYWxmU2l6ZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHIoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnJhZGl1cztcclxuXHR9XHJcblxyXG5cdHNldCByKHJhZGl1czogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdC8qKlxyXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci5kaXN0YW5jZVNxVG8ocG9pbnQpIDw9IHRoaXMucmFkaXVzKnRoaXMucmFkaXVzO1xyXG4gICAgfVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRnZXRCb3VuZGluZ1JlY3QoKTogQUFCQiB7XHJcblx0XHRyZXR1cm4gbmV3IEFBQkIodGhpcy5fY2VudGVyLmNsb25lKCksIG5ldyBWZWMyKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cykpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0Z2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0Y2xvbmUoKTogQ2lyY2xlIHtcclxuXHRcdHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuX2NlbnRlci5jbG9uZSgpLCB0aGlzLnJhZGl1cyk7XHJcblx0fVxyXG5cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiKGNlbnRlcjogXCIgKyB0aGlzLmNlbnRlci50b1N0cmluZygpICsgXCIsIHJhZGl1czogXCIgKyB0aGlzLnJhZGl1cyArIFwiKVwiO1xyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuL0FBQkJcIjtcclxuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBTaGFwZSBjbGFzcyB0aGF0IGFjdHMgYXMgYW4gaW50ZXJmYWNlIGZvciBiZXR0ZXIgaW50ZXJhY3Rpb25zIHdpdGggc3ViY2xhc3Nlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNoYXBlIHtcclxuICAgIGFic3RyYWN0IGdldCBjZW50ZXIoKTogVmVjMjtcclxuXHJcbiAgICBhYnN0cmFjdCBzZXQgY2VudGVyKGNlbnRlcjogVmVjMik7XHJcblxyXG4gICAgYWJzdHJhY3QgZ2V0IGhhbGZTaXplKCk6IFZlYzI7XHJcblxyXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIueDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci55O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBodygpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLng7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGhoKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemUueTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdG9wKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueSAtIHRoaXMuaGg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGJvdHRvbSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhoO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBsZWZ0KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAtIHRoaXMuaHc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHJpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMuaHc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgYm91bmRpbmcgcmVjdGFuZ2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXHJcbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRoZSBib3VuZGluZyBjaXJjbGUgb2YgYW4gQUFCQiBpcyBpdHNlbGYuIFVzZSBjbG9uZSgpIGlmIHlvdSBuZWVkIGEgbmV3IHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgQW4gQUFCQiB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGJvdW5kaW5nIGNpcmNsZSBmb3IgdGhpcyBzaGFwZS4gV2FybmluZyAtIG1heSBiZSB0aGUgc2FtZSBhcyB0aGlzIFNoYXBlLlxyXG4gICAgICogRm9yIGluc3RhbmNlLCB0aGUgYm91bmRpbmcgY2lyY2xlIG9mIGEgQ2lyY2xlIGlzIGl0c2VsZi4gVXNlIGNsb25lKCkgaWYgeW91IG5lZWQgYSBuZXcgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBBIENpcmNsZSB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgU2hhcGVcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGNvcHkgb2YgdGhpcyBzaGFwZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjbG9uZSgpOiBTaGFwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGlzIHNoYXBlIG92ZXJsYXBzIGFub3RoZXJcclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgc2hhcGUgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMgYSBib29sZWFuIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgU2hhcGUgb3ZlcmxhcHMgdGhlIG90aGVyIG9uZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuO1xyXG5cclxuICAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW47XHJcblxyXG4gICAgc3RhdGljIGdldFRpbWVPZkNvbGxpc2lvbihBOiBTaGFwZSwgdmVsQTogVmVjMiwgQjogU2hhcGUsIHZlbEI6IFZlYzIpOiBbVmVjMiwgVmVjMiwgYm9vbGVhbiwgYm9vbGVhbl0ge1xyXG5cdFx0aWYoQSBpbnN0YW5jZW9mIEFBQkIgJiYgQiBpbnN0YW5jZW9mIEFBQkIpe1xyXG5cdFx0XHRyZXR1cm4gU2hhcGUuZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBLCB2ZWxBLCBCLCB2ZWxCKTtcclxuXHRcdH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBOiBBQUJCLCB2ZWxBOiBWZWMyLCBCOiBTaGFwZSwgdmVsQjogVmVjMik6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XHJcbiAgICAgICAgbGV0IHBvc1NtYWxsZXIgPSBBLmNlbnRlcjtcclxuICAgICAgICBsZXQgcG9zTGFyZ2VyID0gQi5jZW50ZXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHNpemVTbWFsbGVyID0gQS5oYWxmU2l6ZTtcclxuICAgICAgICBsZXQgc2l6ZUxhcmdlciA9IEIuaGFsZlNpemU7XHJcbiAgICBcclxuICAgICAgICBsZXQgZmlyc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XHJcbiAgICAgICAgbGV0IGxhc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XHJcbiAgICBcclxuICAgICAgICBsZXQgY29sbGlkaW5nWCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjb2xsaWRpbmdZID0gZmFsc2U7XHJcbiAgICBcclxuICAgICAgICAvLyBTb3J0IGJ5IHBvc2l0aW9uXHJcbiAgICAgICAgaWYocG9zTGFyZ2VyLnggPCBwb3NTbWFsbGVyLngpe1xyXG4gICAgICAgICAgICAvLyBTd2FwLCBiZWNhdXNlIHNtYWxsZXIgaXMgZnVydGhlciByaWdodCB0aGFuIGxhcmdlclxyXG4gICAgICAgICAgICBsZXQgdGVtcDogVmVjMjtcclxuICAgICAgICAgICAgdGVtcCA9IHNpemVTbWFsbGVyO1xyXG4gICAgICAgICAgICBzaXplU21hbGxlciA9IHNpemVMYXJnZXI7XHJcbiAgICAgICAgICAgIHNpemVMYXJnZXIgPSB0ZW1wO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xyXG4gICAgICAgICAgICBwb3NTbWFsbGVyID0gcG9zTGFyZ2VyO1xyXG4gICAgICAgICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRlbXAgPSB2ZWxBO1xyXG4gICAgICAgICAgICB2ZWxBID0gdmVsQjtcclxuICAgICAgICAgICAgdmVsQiA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gQSBpcyBsZWZ0LCBCIGlzIHJpZ2h0XHJcbiAgICAgICAgZmlyc3RDb250YWN0LnggPSBJbmZpbml0eTtcclxuICAgICAgICBsYXN0Q29udGFjdC54ID0gSW5maW5pdHk7XHJcbiAgICBcclxuICAgICAgICBpZiAocG9zTGFyZ2VyLnggLSBzaXplTGFyZ2VyLnggPj0gcG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCl7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXHJcbiAgICAgICAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnggLSB2ZWxCLng7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihyZWxWZWwgPiAwKXtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgICAgIGZpcnN0Q29udGFjdC54ID0gKChwb3NMYXJnZXIueCAtIHNpemVMYXJnZXIueCkgLSAocG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCkpLyhyZWxWZWwpO1xyXG4gICAgICAgICAgICAgICAgbGFzdENvbnRhY3QueCA9ICgocG9zTGFyZ2VyLnggKyBzaXplTGFyZ2VyLngpIC0gKHBvc1NtYWxsZXIueCAtIHNpemVTbWFsbGVyLngpKS8ocmVsVmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGluZ1ggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGlmKHBvc0xhcmdlci55IDwgcG9zU21hbGxlci55KXtcclxuICAgICAgICAgICAgLy8gU3dhcCwgYmVjYXVzZSBzbWFsbGVyIGlzIGZ1cnRoZXIgdXAgdGhhbiBsYXJnZXJcclxuICAgICAgICAgICAgbGV0IHRlbXA6IFZlYzI7XHJcbiAgICAgICAgICAgIHRlbXAgPSBzaXplU21hbGxlcjtcclxuICAgICAgICAgICAgc2l6ZVNtYWxsZXIgPSBzaXplTGFyZ2VyO1xyXG4gICAgICAgICAgICBzaXplTGFyZ2VyID0gdGVtcDtcclxuICAgIFxyXG4gICAgICAgICAgICB0ZW1wID0gcG9zU21hbGxlcjtcclxuICAgICAgICAgICAgcG9zU21hbGxlciA9IHBvc0xhcmdlcjtcclxuICAgICAgICAgICAgcG9zTGFyZ2VyID0gdGVtcDtcclxuICAgIFxyXG4gICAgICAgICAgICB0ZW1wID0gdmVsQTtcclxuICAgICAgICAgICAgdmVsQSA9IHZlbEI7XHJcbiAgICAgICAgICAgIHZlbEIgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIEEgaXMgdG9wLCBCIGlzIGJvdHRvbVxyXG4gICAgICAgIGZpcnN0Q29udGFjdC55ID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGFzdENvbnRhY3QueSA9IEluZmluaXR5O1xyXG4gICAgXHJcbiAgICAgICAgaWYgKHBvc0xhcmdlci55IC0gc2l6ZUxhcmdlci55ID49IHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpe1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgY3VycmVudGx5IGNvbGxpZGluZ1xyXG4gICAgICAgICAgICBsZXQgcmVsVmVsID0gdmVsQS55IC0gdmVsQi55O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYocmVsVmVsID4gMCl7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBtb3ZpbmcgdG93YXJkcyBlYWNoIG90aGVyXHJcbiAgICAgICAgICAgICAgICBmaXJzdENvbnRhY3QueSA9ICgocG9zTGFyZ2VyLnkgLSBzaXplTGFyZ2VyLnkpIC0gKHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpKS8ocmVsVmVsKTtcclxuICAgICAgICAgICAgICAgIGxhc3RDb250YWN0LnkgPSAoKHBvc0xhcmdlci55ICsgc2l6ZUxhcmdlci55KSAtIChwb3NTbWFsbGVyLnkgLSBzaXplU21hbGxlci55KSkvKHJlbFZlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xsaWRpbmdZID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gW2ZpcnN0Q29udGFjdCwgbGFzdENvbnRhY3QsIGNvbGxpZGluZ1gsIGNvbGxpZGluZ1ldO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgTElGTyBzdGFjayB3aXRoIGl0ZW1zIG9mIHR5cGUgVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhY2s8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcclxuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIFN0YWNrICovXHJcbiAgICBwcml2YXRlIE1BWF9FTEVNRU5UUzogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGFjayAqL1xyXG4gICAgcHJpdmF0ZSBzdGFjazogQXJyYXk8VD47XHJcbiAgICBcclxuICAgIC8qKiBUaGUgaGVhZCBvZiB0aGUgc3RhY2sgKi9cclxuXHRwcml2YXRlIGhlYWQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgc3RhY2tcclxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKXtcclxuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgQXJyYXk8VD4odGhpcy5NQVhfRUxFTUVOVFMpO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IC0xO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIG5ldyBpdGVtIHRvIGFkZCB0byB0aGUgc3RhY2tcclxuICAgICAqL1xyXG4gICAgcHVzaChpdGVtOiBUKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5oZWFkICsgMSA9PT0gdGhpcy5NQVhfRUxFTUVOVFMpe1xyXG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWFkICs9IDE7XHJcbiAgICAgICAgdGhpcy5zdGFja1t0aGlzLmhlYWRdID0gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBwb3AoKTogVCB7XHJcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSAtMSl7XHJcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZW1wdHkgLSBjYW5ub3QgcmVtb3ZlIGVsZW1lbnRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWFkIC09IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5oZWFkICsgMV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAqL1xyXG4gICAgcGVlaygpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IC0xKXtcclxuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCBnZXQgZWxlbWVudFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzdGFjayBpcyBlbXB0eVxyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RhY2sgaXMgZW1wdHlcclxuICAgICovXHJcbiAgICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgPT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gZGVsZXRlIHRoaXMuc3RhY2tbaW5kZXhdKTtcclxuICAgICAgICB0aGlzLmhlYWQgPSAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBpdGVtcyBjdXJyZW50bHkgaW4gdGhlIHN0YWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBzaXplKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGltcGxlbWVudGVkXHJcbiAgICBmb3JFYWNoKGZ1bmM6IChpdGVtOiBULCBpbmRleD86IG51bWJlcikgPT4gdm9pZCk6IHZvaWR7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlKGkgPD0gdGhpcy5oZWFkKXtcclxuICAgICAgICAgICAgZnVuYyh0aGlzLnN0YWNrW2ldLCBpKTtcclxuICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgc3RhY2sgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHN0YWNrXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgaWYoaW5kZXggIT09IDApe1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dmFsID0gc3RyICsgcmV0dmFsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZXNldERhdGEgfSBmcm9tIFwiLi9UaWxlZERhdGFcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSByZXByZXNlbnRhdGlvbiBvZiBhIFRpbGVzZXQgZm9yIHRoZSBnYW1lIGVuZ2luZS4gVGhpcyByZXByZXNlbnRzIG9uZSBpbWFnZSxcclxuICogd2l0aCBhIHN0YXJ0SW5kZXggaWYgcmVxdWlyZWQgKGFzIGl0IGlzIHdpdGggVGlsZWQgdXNpbmcgdHdvIGltYWdlcyBpbiBvbmUgdGlsc2V0KS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVzZXQge1xyXG4gICAgLyoqIFRoZSBrZXkgb2YgdGhlIGltYWdlIHVzZWQgYnkgdGhpcyB0aWxlc2V0ICovXHJcbiAgICBwcm90ZWN0ZWQgaW1hZ2VLZXk6IHN0cmluZztcclxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdGlsZXNldCBpbWFnZSAqL1xyXG4gICAgcHJvdGVjdGVkIGltYWdlU2l6ZTogVmVjMjtcclxuICAgIC8qKiBUaGUgaW5kZXggb2YgMHRoIGltYWdlIG9mIHRoaXMgdGlsZXNldCAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXJ0SW5kZXg6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaW1hZ2Ugb2YgdGhpcyB0aWxzZXQgKi9cclxuICAgIHByb3RlY3RlZCBlbmRJbmRleDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlcyBpbiB0aGlzIHRpbGVzZXQgKi9cclxuICAgIHByb3RlY3RlZCB0aWxlU2l6ZTogVmVjMjtcclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhpcyB0aWxlc2V0ICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGlzIHRpbGVzZXQgKi9cclxuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XHJcblxyXG4gICAgLy8gVE9ETzogQ2hhbmdlIHRoaXMgdG8gYmUgbW9yZSBnZW5lcmFsIGFuZCB3b3JrIHdpdGggb3RoZXIgdGlsZXNldCBmb3JtYXRzXHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlc2V0RGF0YTogVGlsZWRUaWxlc2V0RGF0YSl7XHJcbiAgICAgICAgLy8gRGVmZXIgaGFuZGxpbmcgb2YgdGhlIGRhdGEgdG8gYSBoZWxwZXIgY2xhc3NcclxuICAgICAgICB0aGlzLmluaXRGcm9tVGlsZWREYXRhKHRpbGVzZXREYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgdGhlIHRpbGVzZXQgZnJvbSB0aGUgZGF0YSBmcm9tIGEgVGlsZWQganNvbiBmaWxlXHJcbiAgICAgKiBAcGFyYW0gdGlsZWREYXRhIFRoZSBwYXJzZWQgb2JqZWN0IGZyb20gYSBUaWxlZCBqc29uIGZpbGVcclxuICAgICAqL1xyXG4gICAgaW5pdEZyb21UaWxlZERhdGEodGlsZWREYXRhOiBUaWxlZFRpbGVzZXREYXRhKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZWREYXRhLnRpbGVjb3VudC90aWxlZERhdGEuY29sdW1ucztcclxuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlZERhdGEuY29sdW1ucztcclxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aWxlZERhdGEuZmlyc3RnaWQ7XHJcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCArIHRpbGVkRGF0YS50aWxlY291bnQgLSAxO1xyXG4gICAgICAgIHRoaXMudGlsZVNpemUgPSBuZXcgVmVjMih0aWxlZERhdGEudGlsZXdpZHRoLCB0aWxlZERhdGEudGlsZXdpZHRoKTtcclxuICAgICAgICB0aGlzLmltYWdlS2V5ID0gdGlsZWREYXRhLmltYWdlO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLmltYWdld2lkdGgsIHRpbGVkRGF0YS5pbWFnZWhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogR2V0cyB0aGUgaW1hZ2Uga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRpbGVtYXBcclxuICAgICAqIEByZXR1cm5zIFRoZSBpbWFnZSBrZXkgb2YgdGhpcyB0aWxlbWFwXHJcbiAgICAgKi9cclxuICAgIGdldEltYWdlS2V5KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VLZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgVmVjMiBjb250YWluaW5nIHRoZSBsZWZ0IGFuZCB0b3Agb2Zmc2V0IGZyb20gdGhlIGltYWdlIG9yaWdpbiBmb3IgdGhpcyB0aWxlLlxyXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgZnJvbSBzdGFydEluZGV4IHRvIGVuZEluZGV4IG9mIHRoaXMgdGlsZXNldFxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIG9mZnNldCBmb3IgdGhlIHNwZWNpZmllZCB0aWxlLlxyXG4gICAgICovXHJcbiAgICBnZXRJbWFnZU9mZnNldEZvclRpbGUodGlsZUluZGV4OiBudW1iZXIpOiBWZWMyIHtcclxuICAgICAgICAvLyBHZXQgdGhlIHRydWUgaW5kZXhcclxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xyXG4gICAgICAgIGxldCBjb2wgPSBpbmRleCAlIHRoaXMubnVtQ29scztcclxuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudGlsZVNpemUueTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcclxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xyXG4gICAgICAgIGxldCB0b3AgPSByb3cgKiBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMihsZWZ0LCB0b3ApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgc3RhcnQgaW5kZXhcclxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFydCBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRTdGFydEluZGV4KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHRpbGUgc2V0XHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgdGlsZSBzaXplXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVTaXplKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVzZXRcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygcm93c1xyXG4gICAgICovXHJcbiAgICBnZXROdW1Sb3dzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUm93cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0aWxzZXRcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY29sdW1uc1xyXG4gICAgICovXHJcbiAgICBnZXROdW1Db2xzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQ29scztcclxuICAgIH1cclxuXHJcbiAgICBnZXRUaWxlQ291bnQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRJbmRleCAtIHRoaXMuc3RhcnRJbmRleCArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyB0aWxzZXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCB0aWxlIGluZGV4LiBUaGlzIGlzIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgdGlsc2V0IHVzZXMgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICovXHJcbiAgICBoYXNUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRpbGVJbmRleCA+PSB0aGlzLnN0YXJ0SW5kZXggJiYgdGlsZUluZGV4IDw9IHRoaXMuZW5kSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgYSBzaW5ndWxhciB0aWxlIHdpdGggaW5kZXggdGlsZUluZGV4IGZyb20gdGhlIHRpbGVzZXQgbG9jYXRlZCBhdCBwb3NpdGlvbiBkYXRhSW5kZXhcclxuICAgICAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gdGlsZUluZGV4IFRoZSB2YWx1ZSBvZiB0aGUgdGlsZSB0byByZW5kZXJcclxuICAgICAqIEBwYXJhbSBkYXRhSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGluIHRoZSBkYXRhIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gd29ybGRTaXplIFRoZSBzaXplIG9mIHRoZSB3b3JsZFxyXG4gICAgICogQHBhcmFtIG9yaWdpbiBUaGUgdmlld3BvcnQgb3JpZ2luIGluIHRoZSBjdXJyZW50IGxheWVyXHJcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSB0aWxlbWFwXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclRpbGUoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHRpbGVJbmRleDogbnVtYmVyLCBkYXRhSW5kZXg6IG51bWJlciwgbWF4Q29sczogbnVtYmVyLCBvcmlnaW46IFZlYzIsIHNjYWxlOiBWZWMyLCB6b29tOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaW1hZ2UgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRJbWFnZSh0aGlzLmltYWdlS2V5KTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB0cnVlIGluZGV4XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGlsZUluZGV4IC0gdGhpcy5zdGFydEluZGV4O1xyXG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcclxuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy50aWxlU2l6ZS54O1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gdG8gc3RhcnQgYSBjcm9wIGluIHRoZSB0aWxlc2V0IGltYWdlXHJcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcclxuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGluIHRoZSB3b3JsZCB0byByZW5kZXIgdGhlIHRpbGVcclxuICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IoKGRhdGFJbmRleCAlIG1heENvbHMpICogd2lkdGggKiBzY2FsZS54KTtcclxuICAgICAgICBsZXQgeSA9IE1hdGguZmxvb3IoTWF0aC5mbG9vcihkYXRhSW5kZXggLyBtYXhDb2xzKSAqIGhlaWdodCAqIHNjYWxlLnkpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgTWF0aC5mbG9vcigoeCAtIG9yaWdpbi54KSp6b29tKSwgTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSp6b29tKSwgTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pLCBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pKTtcclxuICAgIH1cclxufSIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgdHdvLWRpbWVuc2lvbmFsIHZlY3RvciAoeCwgeSlcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlYzIge1xyXG5cclxuXHQvLyBTdG9yZSB4IGFuZCB5IGluIGFuIGFycmF5XHJcblx0LyoqIFRoZSBhcnJheSB0aGF0IHN0b3JlcyB0aGUgYWN0dWFsIHZlY3RvciB2YWx1ZXMgeCBhbmQgeSAqL1xyXG5cdHByaXZhdGUgdmVjOiBGbG9hdDMyQXJyYXk7XHJcblxyXG5cdC8qKlx0XHJcblx0ICogV2hlbiB0aGlzIHZlY3RvciBjaGFuZ2VzIGl0cyB2YWx1ZSwgZG8gc29tZXRoaW5nXHJcblx0ICovXHJcblx0cHJpdmF0ZSBvbkNoYW5nZTogRnVuY3Rpb24gPSAoKSA9PiB7fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBWZWMyXHJcblx0ICogQHBhcmFtIHggVGhlIHggdmFsdWUgb2YgdGhlIHZlY3RvclxyXG5cdCAqIEBwYXJhbSB5IFRoZSB5IHZhbHVlIG9mIHRoZSB2ZWN0b3JcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih4OiBudW1iZXIgPSAwLCB5OiBudW1iZXIgPSAwKSB7XHJcblx0XHR0aGlzLnZlYyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcblx0XHR0aGlzLnZlY1swXSA9IHg7XHJcblx0XHR0aGlzLnZlY1sxXSA9IHk7XHJcblx0fVxyXG5cclxuXHQvLyBFeHBvc2UgeCBhbmQgeSB3aXRoIGdldHRlcnMgYW5kIHNldHRlcnNcclxuXHRnZXQgeCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnZlY1swXTtcclxuXHR9XHJcblxyXG5cdHNldCB4KHg6IG51bWJlcikge1xyXG5cdFx0dGhpcy52ZWNbMF0gPSB4O1xyXG5cclxuXHRcdGlmKHRoaXMub25DaGFuZ2Upe1xyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgeSgpIHtcclxuXHRcdHJldHVybiB0aGlzLnZlY1sxXTtcclxuXHR9XHJcblxyXG5cdHNldCB5KHk6IG51bWJlcikge1xyXG5cdFx0dGhpcy52ZWNbMV0gPSB5O1xyXG5cclxuXHRcdGlmKHRoaXMub25DaGFuZ2Upe1xyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IFpFUk8oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoMCwgMCk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgcmVhZG9ubHkgWkVST19TVEFUSUMgPSBuZXcgVmVjMigwLCAwKTtcclxuXHJcblx0c3RhdGljIGdldCBJTkYoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoSW5maW5pdHksIEluZmluaXR5KTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXQgVVAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoMCwgLTEpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldCBET1dOKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDEpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldCBMRUZUKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKC0xLCAwKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXQgUklHSFQoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoMSwgMCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci4gVGhpcyB0ZW5kcyB0byBiZSBmYXN0ZXIsIHNvIHVzZSBpdCBpbiBzaXR1YXRpb25zIHdoZXJlIHRha2luZyB0aGVcclxuXHQgKiBzcXVhcmUgcm9vdCBkb2Vzbid0IG1hdHRlciwgbGlrZSBmb3IgY29tcGFyaW5nIGRpc3RhbmNlcy5cclxuXHQgKiBAcmV0dXJucyBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvclxyXG5cdCAqL1xyXG5cdG1hZ1NxKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy54KnRoaXMueCArIHRoaXMueSp0aGlzLnk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXHJcblx0ICogQHJldHVybnMgVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLlxyXG5cdCAqL1xyXG5cdG1hZygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLm1hZ1NxKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGl2ZGVzIHggYW5kIHkgYnkgdGhlIG1hZ25pdHVkZSB0byBvYnRhaW4gdGhlIHVuaXQgdmVjdG9yIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhpcyB2ZWN0b3IuXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSB1bml0IHZlY3Rvci5cclxuXHQgKi9cclxuXHRub3JtYWxpemUoKTogVmVjMiB7XHJcblx0XHRpZih0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwKSByZXR1cm4gdGhpcztcclxuXHRcdGxldCBtYWcgPSB0aGlzLm1hZygpO1xyXG5cdFx0dGhpcy54IC89IG1hZztcclxuXHRcdHRoaXMueSAvPSBtYWc7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdvcmtzIGxpa2Ugbm9ybWFsaXplKCksIGJ1dCByZXR1cm5zIGEgbmV3IFZlYzJcclxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBpcyB0aGUgdW5pdCB2ZWN0b3IgZm9yIHRoaXMgb25lXHJcblx0ICovXHJcblx0bm9ybWFsaXplZCgpOiBWZWMyIHtcclxuXHRcdGlmKHRoaXMuaXNaZXJvKCkpe1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0bGV0IG1hZyA9IHRoaXMubWFnKCk7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIodGhpcy54L21hZywgdGhpcy55L21hZyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSB4IGFuZCB5IGVsZW1lbnRzIG9mIHRoaXMgdmVjdG9yIHRvIHplcm8uXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IsIHdpdGggeCBhbmQgeSBzZXQgdG8gemVyby5cclxuXHQgKi9cclxuXHR6ZXJvKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KDAsIDApO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgeCBhbmQgeSBiYXNlZCBvbiB0aGUgYW5nbGUgcHJvdmlkZWQuIEdvZXMgY291bnRlciBjbG9ja3dpc2UuXHJcblx0ICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IgYXQgdGhlIHNwZWNpZmllZCBhbmdsZVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yLlxyXG5cdCAqL1xyXG5cdHNldFRvQW5nbGUoYW5nbGU6IG51bWJlciwgcmFkaXVzOiBudW1iZXIgPSAxKTogVmVjMiB7XHJcblx0XHR0aGlzLnggPSBNYXRoVXRpbHMuZmxvb3JUb1BsYWNlKE1hdGguY29zKGFuZ2xlKSpyYWRpdXMsIDUpO1xyXG5cdFx0dGhpcy55ID0gTWF0aFV0aWxzLmZsb29yVG9QbGFjZSgtTWF0aC5zaW4oYW5nbGUpKnJhZGl1cywgNSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSB2ZWN0b3IgdGhhdCBwb2ludCBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXIgb25lXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gcG9pbnQgdG9cclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHRoYXQgcG9pbnRzIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdHZlY1RvKG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIob3RoZXIueCAtIHRoaXMueCwgb3RoZXIueSAtIHRoaXMueSk7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSB2ZWN0b3IgY29udGFpbmluZyB0aGUgZGlyZWN0aW9uIGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIHBvaW50IHRvXHJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB0aGF0IHBvaW50cyBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvbmUgcHJvdmlkZWQuIFRoaXMgbmV3IFZlYzIgd2lsbCBiZSBhIHVuaXQgdmVjdG9yLlxyXG5cdCAqL1xyXG5cdGRpclRvKG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy52ZWNUbyhvdGhlcikubm9ybWFsaXplKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBLZWVwcyB0aGUgdmVjdG9yJ3MgZGlyZWN0aW9uLCBidXQgc2V0cyBpdHMgbWFnbml0dWRlIHRvIGJlIHRoZSBwcm92aWRlZCBtYWduaXR1ZGVcclxuXHQgKiBAcGFyYW0gbWFnbml0dWRlIFRoZSBtYWduaXR1ZGUgdGhlIHZlY3RvciBzaG91bGQgYmVcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciB3aXRoIGl0cyBtYWduaXR1ZGUgc2V0IHRvIHRoZSBuZXcgbWFnbml0dWRlXHJcblx0ICovXHJcblx0c2NhbGVUbyhtYWduaXR1ZGU6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkuc2NhbGUobWFnbml0dWRlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNjYWxlcyB4IGFuZCB5IGJ5IHRoZSBudW1iZXIgcHJvdmlkZWQsIG9yIGlmIHR3byBudW1iZXIgYXJlIHByb3ZpZGVkLCBzY2FsZXMgdGhlbSBpbmRpdmlkdWFsbHkuXHJcblx0ICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXHJcblx0ICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIHNjYWxpbmdcclxuXHQgKi9cclxuXHRzY2FsZShmYWN0b3I6IG51bWJlciwgeUZhY3RvcjogbnVtYmVyID0gbnVsbCk6IFZlYzIge1xyXG5cdFx0aWYoeUZhY3RvciAhPT0gbnVsbCl7XHJcblx0XHRcdHRoaXMueCAqPSBmYWN0b3I7XHJcblx0XHRcdHRoaXMueSAqPSB5RmFjdG9yO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHRoaXMueCAqPSBmYWN0b3I7XHJcblx0XHR0aGlzLnkgKj0gZmFjdG9yO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc2NhbGVkIHZlcnNpb24gb2YgdGhpcyB2ZWN0b3Igd2l0aG91dCBtb2RpZnlpbmcgaXQuXHJcblx0ICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXHJcblx0ICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB0aGF0IGhhcyB0aGUgdmFsdWVzIG9mIHRoaXMgdmVjdG9yIGFmdGVyIHNjYWxpbmdcclxuXHQgKi9cclxuXHRzY2FsZWQoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuc2NhbGUoZmFjdG9yLCB5RmFjdG9yKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJvdGF0ZXMgdGhlIHZlY3RvciBjb3VudGVyLWNsb2Nrd2lzZSBieSB0aGUgYW5nbGUgYW1vdW50IHNwZWNpZmllZFxyXG5cdCAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5IGluIHJhZGlhbnNcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciByb3RhdGlvbi5cclxuXHQgKi9cclxuXHRyb3RhdGVDQ1coYW5nbGU6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0bGV0IGNzID0gTWF0aC5jb3MoYW5nbGUpO1xyXG5cdFx0bGV0IHNuID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cdFx0bGV0IHRlbXBYID0gdGhpcy54KmNzIC0gdGhpcy55KnNuO1xyXG5cdFx0bGV0IHRlbXBZID0gdGhpcy54KnNuICsgdGhpcy55KmNzO1xyXG5cdFx0dGhpcy54ID0gdGVtcFg7XHJcblx0XHR0aGlzLnkgPSB0ZW1wWTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgdmVjdG9ycyBjb29yZGluYXRlcyB0byBiZSB0aGUgb25lcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSB4IFRoZSBuZXcgeCB2YWx1ZSBmb3IgdGhpcyB2ZWN0b3JcclxuXHQgKiBAcGFyYW0geSBUaGUgbmV3IHkgdmFsdWUgZm9yIHRoaXMgdmVjdG9yXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3JcclxuXHQgKi9cclxuXHRzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBWZWMyIHtcclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgb3RoZXIgVmVjMiBpbnRvIHRoaXMgb25lLlxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBjb3B5XHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3Igd2l0aCBpdHMgdmFsdWVzIHNldCB0byB0aGUgdmVjdG9yIHByb3ZpZGVkXHJcblx0ICovXHJcblx0Y29weShvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KG90aGVyLngsIG90aGVyLnkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGlzIHZlY3RvciB0aGUgYW5vdGhlciB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gYWRkIHRvIHRoaXMgb25lXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgYWRkaW5nIHRoZSBvbmUgcHJvdmlkZWRcclxuXHQgKi9cclxuXHRhZGQob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHRoaXMueCArPSBvdGhlci54O1xyXG5cdFx0dGhpcy55ICs9IG90aGVyLnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluY3JlbWVudHMgdGhlIGZpZWxkcyBvZiB0aGlzIHZlY3Rvci4gQm90aCBhcmUgaW5jcmVtZW50ZWQgd2l0aCBhLCBpZiBvbmx5IGEgaXMgcHJvdmlkZWQuXHJcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IG51bWJlciB0byBpbmNyZW1lbnQgYnlcclxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIG51bWJlciB0byBpbmNyZW1lbnQgYnlcclxuXHQgKiBAcmV0dXJuc3MgVGhpcyB2ZWN0b3IgYWZ0ZXIgaW5jcmVtZW50aW5nXHJcblx0ICovXHJcblx0aW5jKGE6IG51bWJlciwgYj86IG51bWJlcik6IFZlYzIge1xyXG5cdFx0aWYoYiA9PT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0dGhpcy54ICs9IGE7XHJcblx0XHRcdHRoaXMueSArPSBhO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy54ICs9IGE7XHJcblx0XHRcdHRoaXMueSArPSBiO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTdWJ0cmFjdHMgYW5vdGhlciB2ZWN0b3IgZnJvbSB0aGlzIHZlY3RvclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBzdWJ0cmFjdCBmcm9tIHRoaXMgb25lXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgc3VidHJhY3RpbmcgdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdHN1YihvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0dGhpcy54IC09IG90aGVyLng7XHJcblx0XHR0aGlzLnkgLT0gb3RoZXIueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTXVsdGlwbGllcyB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIgdmVjdG9yIGVsZW1lbnQtd2lzZS4gSW4gb3RoZXIgd29yZHMsIHRoaXMueCAqPSBvdGhlci54IGFuZCB0aGlzLnkgKj0gb3RoZXIueVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBtdWx0aXBseSB0aGlzIG9uZSBieVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIG11bHRpcGx5aW5nIGl0cyBjb21wb25lbnRzIGJ5IHRoaXMgb25lXHJcblx0ICovXHJcblx0bXVsdChvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0dGhpcy54ICo9IG90aGVyLng7XHJcblx0XHR0aGlzLnkgKj0gb3RoZXIueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGl2aWRlcyB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIgdmVjdG9yIGVsZW1lbnQtd2lzZS4gSW4gb3RoZXIgd29yZHMsIHRoaXMueCAvPSBvdGhlci54IGFuZCB0aGlzLnkgLz0gb3RoZXIueVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGRpdmlkZSB0aGlzIG9uZSBieVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGRpdmlzaW9uXHJcblx0ICovXHJcblx0ZGl2KG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHRpZihvdGhlci54ID09PSAwIHx8IG90aGVyLnkgPT09IDApIHRocm93IFwiRGl2aWRlIGJ5IHplcm8gZXJyb3JcIjtcclxuXHRcdHRoaXMueCAvPSBvdGhlci54O1xyXG5cdFx0dGhpcy55IC89IG90aGVyLnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERvZXMgYW4gZWxlbWVudCB3aXNlIHJlbWFpbmRlciBvcGVyYXRpb24gb24gdGhpcyB2ZWN0b3IuIHRoaXMueCAlPSBvdGhlci54IGFuZCB0aGlzLnkgJT0gb3RoZXIueVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgdmVjdG9yXHJcblx0ICogQHJldHVybnMgdGhpcyB2ZWN0b3JcclxuXHQgKi9cclxuXHRyZW1haW5kZXIob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHRoaXMueCA9IHRoaXMueCAlIG90aGVyLng7XHJcblx0XHR0aGlzLnkgPSB0aGlzLnkgJSBvdGhlci55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSBkaXN0YW5jZSBzcXVhcmVkIHRvXHJcblx0ICogQHJldHVybnMgVGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdGRpc3RhbmNlU3FUbyhvdGhlcjogVmVjMik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gKHRoaXMueCAtIG90aGVyLngpKih0aGlzLnggLSBvdGhlci54KSArICh0aGlzLnkgLSBvdGhlci55KSoodGhpcy55IC0gb3RoZXIueSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyIHZlY3RvclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgZGlzdGFuY2UgdG9cclxuXHQgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdGRpc3RhbmNlVG8ob3RoZXI6IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3FUbyhvdGhlcikpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXJcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBkb3QgcHJvZHVjdCB3aXRoXHJcblx0ICogQHJldHVybnMgVGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkLlxyXG5cdCAqL1xyXG5cdGRvdChvdGhlcjogVmVjMik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy54Km90aGVyLnggKyB0aGlzLnkqb3RoZXIueTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGFuZ2xlIGNvdW50ZXItY2xvY2t3aXNlIGluIHJhZGlhbnMgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyIHZlY3RvclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGFuZ2xlIHRvXHJcblx0ICogQHJldHVybnMgVGhlIGFuZ2xlLCByb3RhdGluZyBDQ1csIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG90aGVyIHZlY3RvclxyXG5cdCAqL1xyXG5cdGFuZ2xlVG9DQ1cob3RoZXI6IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0bGV0IGRvdCA9IHRoaXMuZG90KG90aGVyKTtcclxuXHRcdGxldCBkZXQgPSB0aGlzLngqb3RoZXIueSAtIHRoaXMueSpvdGhlci54O1xyXG5cdFx0bGV0IGFuZ2xlID0gLU1hdGguYXRhbjIoZGV0LCBkb3QpO1xyXG5cclxuXHRcdGlmKGFuZ2xlIDwgMCl7XHJcblx0XHRcdGFuZ2xlICs9IDIqTWF0aC5QSTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYW5nbGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yIHJvdW5kZWQgdG8gMSBkZWNpbWFsIHBvaW50XHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSBzdHJpbmdcclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMudG9GaXhlZCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvciByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzXHJcblx0ICogQHBhcmFtIG51bURlY2ltYWxQb2ludHMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cyB0byBjcmVhdGUgYSBzdHJpbmcgdG9cclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHN0cmluZ1xyXG5cdCAqL1xyXG5cdHRvRml4ZWQobnVtRGVjaW1hbFBvaW50czogbnVtYmVyID0gMSk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCIoXCIgKyB0aGlzLngudG9GaXhlZChudW1EZWNpbWFsUG9pbnRzKSArIFwiLCBcIiArIHRoaXMueS50b0ZpeGVkKG51bURlY2ltYWxQb2ludHMpICsgXCIpXCI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIHRoZSBzYW1lIGNvb3JkaW5hdGVzIGFzIHRoaXMgb25lLlxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmVcclxuXHQgKi9cclxuXHRjbG9uZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLngsIHRoaXMueSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgYW5kIG90aGVyIGhhdmUgdGhlIEVYQUNUIHNhbWUgeCBhbmQgeSAobm90IGFzc3VyZWQgdG8gYmUgc2FmZSBmb3IgZmxvYXRzKVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNoZWNrIGFnYWluc3RcclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGUgdHdvIHZlY3RvcnNcclxuXHQgKi9cclxuXHRzdHJpY3RFcXVhbHMob3RoZXI6IFZlYzIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGFuZCBvdGhlciBoYXZlIHRoZSBzYW1lIHggYW5kIHlcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjaGVjayBhZ2FpbnN0XHJcblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhlIHR3byB2ZWN0b3JzXHJcblx0ICovXHJcblx0ZXF1YWxzKG90aGVyOiBWZWMyKTogYm9vbGVhbiB7XHJcblx0XHRsZXQgeEVxID0gTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCAwLjAwMDAwMDE7XHJcblx0XHRsZXQgeUVxID0gTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCAwLjAwMDAwMDE7XHJcblxyXG5cdFx0cmV0dXJuIHhFcSAmJiB5RXE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgaXMgdGhlIHplcm8gdmVjdG9yIGV4YWN0bHkgKG5vdCBhc3N1cmVkIHRvIGJlIHNhZmUgZm9yIGZsb2F0cykuXHJcblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSB6ZXJvIHZlY3RvclxyXG5cdCAqL1xyXG5cdHN0cmljdElzWmVybygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgeCBhbmQgeSBmb3IgdGhpcyB2ZWN0b3IgYXJlIGJvdGggemVyby5cclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIHplcm8gdmVjdG9yXHJcblx0ICovXHJcblx0aXNaZXJvKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCkgPCAwLjAwMDAwMDEgJiYgTWF0aC5hYnModGhpcy55KSA8IDAuMDAwMDAwMTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhpcyB2ZWN0b3IgaXMgY2hhbmdlZC5cclxuXHQgKiBAcGFyYW0gZiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcblx0ICovXHJcblx0c2V0T25DaGFuZ2UoZjogRnVuY3Rpb24pOiB2b2lkIHtcclxuXHRcdHRoaXMub25DaGFuZ2UgPSBmO1xyXG5cdH1cclxuXHJcblx0dG9BcnJheSgpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIHRoaXMudmVjO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xyXG5cdCAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3RvclxyXG5cdCAqIEBwYXJhbSB0IFRoZSB0aW1lIG9mIHRoZSBsZXJwLCB3aXRoIDAgYmVpbmcgdmVjdG9yIEEsIGFuZCAxIGJlaW5nIHZlY3RvciBCXHJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiByZXByZXNlbnRpbmcgdGhlIGxlcnAgYmV0d2VlbiB2ZWN0b3IgYSBhbmQgYi5cclxuXHQgKi9cclxuXHRzdGF0aWMgbGVycChhOiBWZWMyLCBiOiBWZWMyLCB0OiBudW1iZXIpOiBWZWMyIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMihNYXRoVXRpbHMubGVycChhLngsIGIueCwgdCksIE1hdGhVdGlscy5sZXJwKGEueSwgYi55LCB0KSk7XHJcblx0fVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogQSB1dGlsIGNsYXNzIGZvciByZW5kZXJpbmcgRGVidWcgbWVzc2FnZXMgdG8gdGhlIGNhbnZhcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnIHtcclxuXHJcblx0LyoqIEEgbWFwIG9mIGxvZyBtZXNzYWdlcyB0byBkaXNwbGF5IG9uIHRoZSBzY3JlZW4gKi8gXHJcblx0cHJpdmF0ZSBzdGF0aWMgbG9nTWVzc2FnZXM6IE1hcDxzdHJpbmc+ID0gbmV3IE1hcCgpO1xyXG5cclxuXHQvKiogQW4gYXJyYXkgb2YgZ2FtZSBub2RlcyB0byByZW5kZXIgZGVidWcgaW5mbyBmb3IgKi9cclxuXHRwcml2YXRlIHN0YXRpYyBub2RlczogQXJyYXk8R2FtZU5vZGU+O1xyXG5cclxuXHQvKiogVGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciBhbnkgZGVidWcgbWVzc2FnZXMgKi9cclxuXHRwcml2YXRlIHN0YXRpYyBkZWJ1Z1JlbmRlcmluZ0NvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcblx0LyoqXHRUaGUgc2l6ZSBvZiB0aGUgZGVidWcgY2FudmFzICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgZGVidWdDYW52YXNTaXplOiBWZWMyO1xyXG5cclxuXHQvKiogVGhlIHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCAqL1xyXG5cdHByaXZhdGUgc3RhdGljIGRlZmF1bHRUZXh0Q29sb3I6IENvbG9yID0gQ29sb3IuV0hJVEU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZCBhIG1lc3NhZ2UgdG8gZGlzcGxheSBvbiB0aGUgZGVidWcgc2NyZWVuXHJcblx0ICogQHBhcmFtIGlkIEEgdW5pcXVlIElEIGZvciB0aGlzIG1lc3NhZ2VcclxuXHQgKiBAcGFyYW0gbWVzc2FnZXMgVGhlIG1lc3NhZ2VzIHRvIHByaW50IHRvIHRoZSBkZWJ1ZyBzY3JlZW5cclxuXHQgKi9cclxuXHRzdGF0aWMgbG9nKGlkOiBzdHJpbmcsIC4uLm1lc3NhZ2VzOiBhbnkpOiB2b2lkIHtcclxuXHRcdC8vIGxldCBtZXNzYWdlID0gXCJcIjtcclxuXHRcdC8vIGZvcihsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKyl7XHJcblx0XHQvLyBcdG1lc3NhZ2UgKz0gbWVzc2FnZXNbaV0udG9TdHJpbmcoKTtcclxuXHRcdC8vIH1cclxuXHRcdC8vIEpvaW4gYWxsIG1lc3NhZ2VzIHdpdGggc3BhY2VzXHJcblx0XHRsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzLm1hcCgobTogYW55KSA9PiBtLnRvU3RyaW5nKCkpLmpvaW4oXCIgXCIpO1xyXG5cdFx0dGhpcy5sb2dNZXNzYWdlcy5hZGQoaWQsIG1lc3NhZ2UpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVsZXRlcyBhIGEga2V5IGZyb20gdGhlIGxvZyBhbmQgc3RvcHMgaXQgZnJvbSBrZWVwaW5nIHVwIHNwYWNlIG9uIHRoZSBzY3JlZW5cclxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBsb2cgaXRlbSB0byBjbGVhclxyXG5cdCAqL1xyXG5cdHN0YXRpYyBjbGVhckxvZ0l0ZW0oaWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy5sb2dNZXNzYWdlcy5kZWxldGUoaWQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgbGlzdCBvZiBub2RlcyB0byByZW5kZXIgd2l0aCB0aGUgZGVidWdnZXJcclxuXHQgKiBAcGFyYW0gbm9kZXMgVGhlIG5ldyBsaXN0IG9mIG5vZGVzXHJcblx0ICovXHJcblx0c3RhdGljIHNldE5vZGVzKG5vZGVzOiBBcnJheTxHYW1lTm9kZT4pOiB2b2lkIHtcclxuXHRcdHRoaXMubm9kZXMgPSBub2RlcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIGEgYm94IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGJveFxyXG5cdCAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgZGltZW5zaW9ucyBvZiB0aGUgYm94XHJcblx0ICogQHBhcmFtIGZpbGxlZCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBib3ggaXMgZmlsbGVkXHJcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgYm94IHRvIGRyYXdcclxuXHQgKi9cclxuXHRzdGF0aWMgZHJhd0JveChjZW50ZXI6IFZlYzIsIGhhbGZTaXplOiBWZWMyLCBmaWxsZWQ6IGJvb2xlYW4sIGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0bGV0IGFscGhhID0gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGE7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XHJcblxyXG5cdFx0aWYoZmlsbGVkKXtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFJlY3QoY2VudGVyLnggLSBoYWxmU2l6ZS54LCBjZW50ZXIueSAtIGhhbGZTaXplLnksIGhhbGZTaXplLngqMiwgaGFsZlNpemUueSoyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBsaW5lV2lkdGggPSAyO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlUmVjdChjZW50ZXIueCAtIGhhbGZTaXplLngsIGNlbnRlci55IC0gaGFsZlNpemUueSwgaGFsZlNpemUueCoyLCBoYWxmU2l6ZS55KjIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyBhIGNpcmNsZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcclxuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3hcclxuXHQgKiBAcGFyYW0gZmlsbGVkIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdGhlIGNpcmNsZSBpcyBmaWxsZWRcclxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBjaXJjbGVcclxuXHQgKi9cclxuXHRzdGF0aWMgZHJhd0NpcmNsZShjZW50ZXI6IFZlYzIsIHJhZGl1czogbnVtYmVyLCBmaWxsZWQ6IGJvb2xlYW4sIGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0bGV0IGFscGhhID0gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGE7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XHJcblxyXG5cdFx0aWYoZmlsbGVkKXtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGxpbmVXaWR0aCA9IDI7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYXJjKGNlbnRlci54LCBjZW50ZXIueSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgYSByYXkgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBmcm9tIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgcmF5XHJcblx0ICogQHBhcmFtIHRvIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIHJheVxyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHJheVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBkcmF3UmF5KGZyb206IFZlYzIsIHRvOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IDI7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVRvKHRvLngsIHRvLnkpO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIGEgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBwb3MgVGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHBvaW50XHJcblx0ICovXHJcblx0c3RhdGljIGRyYXdQb2ludChwb3M6IFZlYzIsIGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0bGV0IHBvaW50U2l6ZSA9IDY7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFJlY3QocG9zLnggLSBwb2ludFNpemUvMiwgcG9zLnkgLSBwb2ludFNpemUvMiwgcG9pbnRTaXplLCBwb2ludFNpemUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgZGVmYXVsdCByZW5kZXJpbmcgY29sb3IgZm9yIHRleHQgZm9yIHRoZSBkZWJ1Z2dlclxyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3IgdG8gcmVuZGVyIHRoZSB0ZXh0XHJcblx0ICovXHJcblx0c3RhdGljIHNldERlZmF1bHRUZXh0Q29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLmRlZmF1bHRUZXh0Q29sb3IgPSBjb2xvcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGFueSBuZWNlc3Nhcnkgc2V0dXAgb3BlcmF0aW9ucyBvbiB0aGUgRGVidWcgY2FudmFzXHJcblx0ICogQHBhcmFtIGNhbnZhcyBUaGUgZGVidWcgY2FudmFzXHJcblx0ICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcclxuXHQgKiBAcGFyYW0gaGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcblx0ICogQHJldHVybnMgVGhlIHJlbmRlcmluZyBjb250ZXh0IGV4dHJhY3RlZCBmcm9tIHRoZSBjYW52YXNcclxuXHQgKi9cclxuXHRzdGF0aWMgaW5pdGlhbGl6ZURlYnVnQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHRcclxuXHRcdHRoaXMuZGVidWdDYW52YXNTaXplID0gbmV3IFZlYzIod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0O1xyXG5cdH1cclxuXHJcblx0LyoqIENsZWFycyB0aGUgZGVidWcgY2FudmFzICovXHJcblx0c3RhdGljIGNsZWFyQ2FudmFzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuZGVidWdDYW52YXNTaXplLngsIHRoaXMuZGVidWdDYW52YXNTaXplLnkpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlbmRlcnMgdGhlIHRleHQgYW5kIG5vZGVzIHNlbnQgdG8gdGhlIERlYnVnIHN5c3RlbSAqL1xyXG5cdHN0YXRpYyByZW5kZXIoKTogdm9pZCB7XHJcblx0XHR0aGlzLnJlbmRlclRleHQoKTtcclxuXHRcdHRoaXMucmVuZGVyTm9kZXMoKTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZW5kZXJzIHRoZSB0ZXh0IHNlbnQgdG8gdGhlIERlYnVnIGNhbnZhcyAqL1xyXG5cdHN0YXRpYyByZW5kZXJUZXh0KCk6IHZvaWQge1xyXG5cdFx0bGV0IHkgPSAyMDtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZvbnQgPSBcIjIwcHggQXJpYWxcIjtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZGVmYXVsdFRleHRDb2xvci50b1N0cmluZygpO1xyXG5cclxuXHRcdC8vIERyYXcgYWxsIG9mIHRoZSB0ZXh0XHJcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxUZXh0KHRoaXMubG9nTWVzc2FnZXMuZ2V0KGtleSksIDEwLCB5KVxyXG5cdFx0XHR5ICs9IDMwO1x0XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZW5kZXJzIHRoZSBub2RlcyByZWdpc3RlcmVkIHdpdGggdGhlIGRlYnVnIGNhbnZhcyAqL1xyXG5cdHN0YXRpYyByZW5kZXJOb2RlcygpOiB2b2lkIHtcclxuXHRcdGlmKHRoaXMubm9kZXMpe1xyXG5cdFx0XHR0aGlzLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcblx0XHRcdFx0bm9kZS5kZWJ1Z1JlbmRlcigpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0cyBleHRlbmRzIE9iamVjdCB7XHJcbiAgICAvLyBUaGUgZnBzIG9mIHRoZSBnYW1lLlxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldmZwczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE5VTV9QT0lOVFM6IG51bWJlciA9IDYwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBDQU5WQVNfV0lEVEg6IG51bWJlciA9IDMwMDtcclxuICAgIHByaXZhdGUgc3RhdGljIENBTlZBU19IRUlHSFQ6IG51bWJlciA9IDMwMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHN0YXRzRGl2OiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHByaXZhdGUgc3RhdGljIGdyYXBoQ2hvaWNlczogSFRNTFNlbGVjdEVsZW1lbnQ7XHJcblxyXG4gICAgLy8gUXVhZHRyZWUgc3RhdHNcclxuICAgIHByaXZhdGUgc3RhdGljIHByZXZDbGVhclRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dDbGVhclRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dDbGVhclRpbWU6IG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2RmlsbFRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR0ZpbGxUaW1lOiBudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldlVwZGF0ZVRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dVcGRhdGVUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHVXBkYXRlVGltZTogbnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByZXZRdWVyeVRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dRdWVyeVRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dRdWVyeVRpbWU6IG51bWJlcjtcclxuXHJcbiAgICBzdGF0aWMgaW5pdFN0YXRzKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBjYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1jYW52YXNcIik7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5DQU5WQVNfV0lEVEg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuQ0FOVkFTX0hFSUdIVDtcclxuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdHNEaXYgPSA8SFRNTERpdkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1kaXNwbGF5XCIpO1xyXG5cclxuICAgICAgICB0aGlzLnByZXZmcHMgPSBuZXcgQXJyYXkoKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuU0dDbGVhclRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5hdmdTR0NsZWFyVGltZSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucHJldkZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuU0dGaWxsVGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLmF2Z1NHRmlsbFRpbWUgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuYXZnU0dVcGRhdGVUaW1lID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuU0dRdWVyeVRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5hdmdTR1F1ZXJ5VGltZSA9IDA7XHJcblxyXG4gICAgICAgIGxldCBjbGVhclRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICBjbGVhclRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ2NsZWFyXCIpO1xyXG4gICAgICAgIGxldCBmaWxsVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIGZpbGxUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2dmaWxsXCIpO1xyXG4gICAgICAgIGxldCB1cGRhdGVUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgdXBkYXRlVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNndXBkYXRlXCIpO1xyXG4gICAgICAgIGxldCBxdWVyeVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICBxdWVyeVRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ3F1ZXJ5XCIpO1xyXG4gICAgICAgIGxldCBicjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XHJcbiAgICAgICAgbGV0IGJyMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcclxuICAgICAgICBsZXQgYnIzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRzRGl2LmFwcGVuZChjbGVhclRpbWUsIGJyMSwgZmlsbFRpbWUsIGJyMiwgdXBkYXRlVGltZSwgYnIzLCBxdWVyeVRpbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmdyYXBoQ2hvaWNlcyA9IDxIVE1MU2VsZWN0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0LW9wdGlvblwiKTtcclxuICAgICAgICBsZXQgb3B0aW9uMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uMS52YWx1ZSA9IFwicHJldmZwc1wiO1xyXG4gICAgICAgIG9wdGlvbjEubGFiZWwgPSBcIkZQU1wiO1xyXG4gICAgICAgIGxldCBvcHRpb24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb24yLnZhbHVlID0gXCJwcmV2Q2xlYXJUaW1lc1wiO1xyXG4gICAgICAgIG9wdGlvbjIubGFiZWwgPSBcIkNsZWFyIFRpbWVcIjtcclxuICAgICAgICBsZXQgb3B0aW9uMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uMy52YWx1ZSA9IFwicHJldkZpbGxUaW1lc1wiO1xyXG4gICAgICAgIG9wdGlvbjMubGFiZWwgPSBcIkZpbGwgdGltZVwiO1xyXG4gICAgICAgIGxldCBvcHRpb240ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb240LnZhbHVlID0gXCJwcmV2VXBkYXRlVGltZXNcIjtcclxuICAgICAgICBvcHRpb240LmxhYmVsID0gXCJVcGRhdGUgdGltZVwiO1xyXG4gICAgICAgIGxldCBvcHRpb241ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb241LnZhbHVlID0gXCJwcmV2UXVlcnlUaW1lc1wiO1xyXG4gICAgICAgIG9wdGlvbjUubGFiZWwgPSBcIlF1ZXJ5IFRpbWVcIjtcclxuICAgICAgICBsZXQgb3B0aW9uQWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb25BbGwudmFsdWUgPSBcImFsbFwiO1xyXG4gICAgICAgIG9wdGlvbkFsbC5sYWJlbCA9IFwiQWxsXCI7XHJcbiAgICAgICAgdGhpcy5ncmFwaENob2ljZXMuYXBwZW5kKG9wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIG9wdGlvbjQsIG9wdGlvbjUsIG9wdGlvbkFsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHVwZGF0ZUZQUyhmcHM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucHJldmZwcy5wdXNoKGZwcyk7XHJcbiAgICAgICAgaWYodGhpcy5wcmV2ZnBzLmxlbmd0aCA+IFN0YXRzLk5VTV9QT0lOVFMpe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZmcHMuc2hpZnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzLnB1c2godGhpcy5hdmdTR0NsZWFyVGltZSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJldkNsZWFyVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLlNHRmlsbFRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMucHVzaCh0aGlzLmF2Z1NHRmlsbFRpbWUpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnByZXZGaWxsVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldkZpbGxUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMucHVzaCh0aGlzLmF2Z1NHVXBkYXRlVGltZSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlVwZGF0ZVRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzLnB1c2godGhpcy5hdmdTR1F1ZXJ5VGltZSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlF1ZXJ5VGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVTR1N0YXRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGxvZyhrZXk6IHN0cmluZywgZGF0YTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgaWYoa2V5ID09PSBcInNnY2xlYXJcIil7XHJcbiAgICAgICAgICAgIHRoaXMuU0dDbGVhclRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDEwMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKGtleSA9PT0gXCJzZ2ZpbGxcIil7XHJcbiAgICAgICAgICAgIHRoaXMuU0dGaWxsVGltZXMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAxMDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKGtleSA9PT0gXCJzZ3VwZGF0ZVwiKXtcclxuICAgICAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAxMDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNncXVlcnlcIil7XHJcbiAgICAgICAgICAgIHRoaXMuU0dRdWVyeVRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDEwMDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHJlbmRlcigpOiB2b2lkIHtcclxuICAgICAgICAvLyBEaXNwbGF5IHN0YXRzXHJcbiAgICAgICAgdGhpcy5kcmF3Q2hhcnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRyYXdDaGFydHMoKXtcclxuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5DQU5WQVNfV0lEVEgsIHRoaXMuQ0FOVkFTX0hFSUdIVCk7XHJcblxyXG4gICAgICAgIGxldCBwYXJhbVN0cmluZyA9IHRoaXMuZ3JhcGhDaG9pY2VzLnZhbHVlO1xyXG5cclxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2ZnBzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xyXG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZmcHM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkJMVUUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldkNsZWFyVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldkNsZWFyVGltZXM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLlJFRC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2RmlsbFRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xyXG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZGaWxsVGltZXM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkdSRUVOLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZVcGRhdGVUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2VXBkYXRlVGltZXM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkNZQU4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldlF1ZXJ5VGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldlF1ZXJ5VGltZXM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLk9SQU5HRS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZHJhd0NoYXJ0KHBhcmFtOiBBcnJheTxudW1iZXI+LCBjb2xvcjogc3RyaW5nKXtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IENvbG9yLkJMQUNLLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDEwLCAxMCk7XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XHJcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMuQ0FOVkFTX1dJRFRIIC0gMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcclxuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4KC4uLnBhcmFtKTtcclxuICAgICAgICBsZXQgcHJldlggPSAxMDtcclxuICAgICAgICBsZXQgcHJldlkgPSB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCAtIHBhcmFtWzBdL21heCoodGhpcy5DQU5WQVNfSEVJR0hULTIwKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG5cclxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgcGFyYW0ubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBsZXQgZnBzID0gcGFyYW1baV07XHJcbiAgICAgICAgICAgIGxldCB4ID0gMTAgKyBpKih0aGlzLkNBTlZBU19XSURUSCAtIDIwKS90aGlzLk5VTV9QT0lOVFM7XHJcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTAgLSBmcHMvbWF4Kih0aGlzLkNBTlZBU19IRUlHSFQtMjApXHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocHJldlgsIHByZXZZKTtcclxuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgICAgICBwcmV2WCA9IHg7XHJcbiAgICAgICAgICAgIHByZXZZID0geTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHVwZGF0ZVNHU3RhdHMoKXtcclxuICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5hdmdTR0NsZWFyVGltZSA9IHRoaXMuU0dDbGVhclRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5hdmdTR0ZpbGxUaW1lID0gdGhpcy5TR0ZpbGxUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dGaWxsVGltZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgIHRoaXMuYXZnU0dVcGRhdGVUaW1lID0gdGhpcy5TR1VwZGF0ZVRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gdGhpcy5TR1F1ZXJ5VGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnY2xlYXJcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgY2xlYXIgdGltZTogXCIgKyB0aGlzLmF2Z1NHQ2xlYXJUaW1lO1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2dmaWxsXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIGZpbGwgdGltZTogXCIgKyB0aGlzLmF2Z1NHRmlsbFRpbWU7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ3VwZGF0ZVwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyB1cGRhdGUgdGltZTogXCIgKyB0aGlzLmF2Z1NHVXBkYXRlVGltZTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNncXVlcnlcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgcXVlcnkgdGltZTogXCIgKyB0aGlzLmF2Z1NHUXVlcnlUaW1lO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XHJcblxyXG4vKipcclxuICogQW4gZXZlbnQgZW1pdHRlciBvYmplY3Qgb3RoZXIgc3lzdGVtcyBjYW4gdXNlIHRvIGhvb2sgaW50byB0aGUgRXZlbnRRdWV1ZS5cclxuICogUHJvdmlkZXMgYW4gZWFzeSBpbnRlcmZhY2UgZm9yIGZpcmluZyBvZmYgZXZlbnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1pdHRlciB7XHJcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBFdmVudFF1ZXVlICovXHJcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xyXG5cclxuXHQvKiogQ3JlYXRlcyBhIG5ldyBFbWl0dGVyICovXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXQgYW5kIGV2ZW50IG9mIHR5cGUgZXZlbnRUeXBlIHdpdGggdGhlIGRhdGEgcGFja2V0IGRhdGFcclxuXHQgKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIG9mZlxyXG5cdCAqIEBwYXJhbSBkYXRhIEEgQHJlZmVyZW5jZVtNYXBdIG9yIHJlY29yZCBjb250YWluaW5nIGFueSBkYXRhIGFib3V0IHRoZSBldmVudFxyXG5cdCAqL1xyXG5cdGZpcmVFdmVudChldmVudFR5cGU6IHN0cmluZywgZGF0YTogTWFwPGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbCk6IHZvaWQge1xyXG5cdFx0dGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KG5ldyBHYW1lRXZlbnQoZXZlbnRUeXBlLCBkYXRhKSk7XHJcblx0fVxyXG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4vUmVjZWl2ZXJcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFpbiBldmVudCBzeXN0ZW0gb2YgdGhlIGdhbWUgZW5naW5lLlxyXG4gKiBFdmVudHMgYXJlIHNlbnQgdG8gdGhlIEV2ZW50UXVldWUsIHdoaWNoIGhhbmRsZXMgZGlzdHJpYnV0aW9uIHRvIGFueSBzeXN0ZW1zIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgdGhvc2UgZXZlbnRzLlxyXG4gKiBUaGlzIGFsbG93cyBmb3IgaGFuZGxpbmcgb2YgaW5wdXQgd2l0aG91dCBoYXZpbmcgY2xhc3NlcyBkaXJlY3RseSBob29rIGludG8gamF2YXNjcmlwdCBldmVudCBoYW5kbGVzLCBcclxuICogYW5kIGFsbG93cyBvdGhlcndpc2Ugc2VwYXJhdGUgY2xhc3NlcyB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIgY2xlYW5seSwgc3VjaCBhcyBhIFBsYXllciBvYmplY3QgXHJcbiAqIHJlcXVlc3RpbmcgYSBzb3VuZCBiZSBwbGF5ZWQgYnkgdGhlIGF1ZGlvIHN5c3RlbS5cclxuICogXHJcbiAqIFRoZSBkaXN0cmlidXRpb24gb2YgQHJlZmVyZW5jZVtHYW1lRXZlbnRdcyBoYXBwZW5zIGFzIGZvbGxvd3M6XHJcbiAqIFxyXG4gKiBFdmVudHMgYXJlIHJlY2lldmVkIHRocm91Z2hvdXQgYSBmcmFtZSBhbmQgYXJlIHF1ZXVlZCB1cCBieSB0aGUgRXZlbnRRdWV1ZS5cclxuICogQXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBmcmFtZSwgZXZlbnRzIGFyZSBzZW50IG91dCB0byBhbnkgcmVjZWl2ZXJzIHRoYXQgYXJlIGhvb2tlZCBpbnRvIHRoZSBldmVudCB0eXBlLlxyXG4gKiBAcmVmZXJlbmNlW1JlY2VpdmVyXXMgYXJlIHRoZW4gZnJlZSB0byBwcm9jZXNzIGV2ZW50cyBhcyB0aGV5IHNlZSBmaXQuXHJcbiAqIFxyXG4gKiBPdmVyYWxsLCB0aGUgRXZlbnRRdWV1ZSBjYW4gYmUgY29uc2lkZXJlZCBhcyBzb21ldGhpbmcgc2ltaWxhciB0byBhbiBlbWFpbCBzZXJ2ZXIsXHJcbiAqIGFuZCB0aGUgQHJlZmVyZW5jZVtSZWNlaXZlcl1zIGNhbiBiZSBjb25zaWRlcmVkIGFzIHRoZSBjbGllbnQgaW5ib3hlcy5cclxuICogXHJcbiAqIFNlZSBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9ldmVudC1xdWV1ZS5odG1sKSBmb3IgbW9yZSBkaXNjdXNzaW9uIG9uIEV2ZW50UXVldWVzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFF1ZXVlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBFdmVudFF1ZXVlID0gbnVsbDtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgdmlzaWJsZSAqL1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBNQVhfU0laRTogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGFjdHVhbCBxdWV1ZSBvZiBldmVudHMgKi9cclxuICAgIHByaXZhdGUgcTogUXVldWU8R2FtZUV2ZW50PjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBtYXAgb2YgcmVjZWl2ZXJzIHJlZ2lzdGVyZWQgZm9yIGFuIGV2ZW50IG5hbWUgKi9cclxuXHRwcml2YXRlIHJlY2VpdmVyczogTWFwPEFycmF5PFJlY2VpdmVyPj47XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuTUFYX1NJWkUgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5xID0gbmV3IFF1ZXVlPEdhbWVFdmVudD4odGhpcy5NQVhfU0laRSk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlcnMgPSBuZXcgTWFwPEFycmF5PFJlY2VpdmVyPj4oKTtcclxuXHR9XHJcbiAgICBcclxuICAgIC8qKiBSZXRyaWV2ZXMgdGhlIGluc3RhbmNlIG9mIHRoZSBTaW5nbGV0b24gRXZlbnRRdWV1ZSAqL1xyXG5cdHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBFdmVudFF1ZXVlIHtcclxuXHRcdGlmKHRoaXMuaW5zdGFuY2UgPT09IG51bGwpe1xyXG5cdFx0XHR0aGlzLmluc3RhbmNlID0gbmV3IEV2ZW50UXVldWUoKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuICAgIC8qKiBBZGRzIGFuIGV2ZW50IHRvIHRoZSBFdmVudFF1ZXVlLlxyXG4gICAgICogVGhpcyBpcyBleHBvc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBnYW1lIGVuZ2luZSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0VtaXR0ZXJdIGNsYXNzICovXHJcbiAgICBhZGRFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5xLmVucXVldWUoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXNzb2NpYXRlcyBhIHJlY2VpdmVyIHdpdGggYSB0eXBlIG9mIGV2ZW50LiBFdmVyeSB0aW1lIHRoaXMgZXZlbnQgYXBwZWFycyBpbiB0aGUgZnV0dXJlLFxyXG4gICAgICogaXQgd2lsbCBiZSBnaXZlbiB0byB0aGUgcmVjZWl2ZXIgKGFuZCBhbnkgb3RoZXJzIHdhdGNoaW5nIHRoYXQgdHlwZSkuXHJcbiAgICAgKiBUaGlzIGlzIGV4cG9zZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIGdhbWUgZW5naW5lIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbUmVjZWl2ZXJdIGNsYXNzXHJcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXIgVGhlIGV2ZW50IHJlY2VpdmVyXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvciB0eXBlcyBvZiBldmVudHMgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICAgKi9cclxuICAgIHN1YnNjcmliZShyZWNlaXZlcjogUmVjZWl2ZXIsIHR5cGU6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuICAgICAgICBpZih0eXBlIGluc3RhbmNlb2YgQXJyYXkpe1xyXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbiBhcnJheSwgc3Vic2NyaWJlIHRvIGFsbCBldmVudCB0eXBlc1xyXG4gICAgICAgICAgICBmb3IobGV0IHQgb2YgdHlwZSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RlbmVyKHJlY2VpdmVyLCB0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdGVuZXIocmVjZWl2ZXIsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgdGhlIHNwZWNpZmllZCByZWNlaXZlciBmcm9tIGFsbCBldmVudHMsIG9yIGZyb20gd2hhdGV2ZXIgZXZlbnRzIGFyZSBwcm92aWRlZFxyXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIFRoZSByZWNlaXZlciB0byB1bnN1YnNjcmliZVxyXG4gICAgICogQHBhcmFtIGtleXMgVGhlIGV2ZW50cyB0byB1bnN1YnNjcmliZSBmcm9tLiBJZiBub25lIGFyZSBwcm92aWRlZCwgdW5zdWJzY3JpYmUgZnJvbSBhbGxcclxuICAgICAqL1xyXG4gICAgdW5zdWJzY3JpYmUocmVjZWl2ZXI6IFJlY2VpdmVyLCAuLi5ldmVudHM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnJlY2VpdmVycy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIGtleXMgd2VyZSBwcm92aWRlZCwgb25seSBjb250aW51ZSBpZiB0aGlzIGtleSBpcyBvbmUgb2YgdGhlbVxyXG4gICAgICAgICAgICBpZihldmVudHMubGVuZ3RoID4gMCAmJiBldmVudHMuaW5kZXhPZihldmVudE5hbWUpID09PSAtMSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5kZXggb2Ygb3VyIHJlY2VpdmVyIGZvciB0aGlzIGtleVxyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnJlY2VpdmVycy5nZXQoZXZlbnROYW1lKS5pbmRleE9mKHJlY2VpdmVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGFuIGluZGV4IHdhcyBmb3VuZCwgcmVtb3ZlIHRoZSByZWNlaXZlclxyXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50TmFtZSkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVjZWl2ZXIgYW5kIHRoZSB0eXBlXHJcblx0cHJpdmF0ZSBhZGRMaXN0ZW5lcihyZWNlaXZlcjogUmVjZWl2ZXIsIHR5cGU6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5yZWNlaXZlcnMuaGFzKHR5cGUpKXtcclxuXHRcdFx0dGhpcy5yZWNlaXZlcnMuZ2V0KHR5cGUpLnB1c2gocmVjZWl2ZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5yZWNlaXZlcnMuYWRkKHR5cGUsIFtyZWNlaXZlcl0pO1xyXG5cdFx0fVxyXG5cdH1cclxuICAgIFxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgd2hpbGUodGhpcy5xLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBlYWNoIGV2ZW50XHJcblx0XHRcdGxldCBldmVudCA9IHRoaXMucS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiBhIHJlY2VpdmVyIGhhcyB0aGlzIGV2ZW50IHR5cGUsIHNlbmQgaXQgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgIGlmKHRoaXMucmVjZWl2ZXJzLmhhcyhldmVudC50eXBlKSl7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChldmVudC50eXBlKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblx0XHRcdH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElmIGEgcmVjZWl2ZXIgaXMgc3Vic2NyaWJlZCB0byBhbGwgZXZlbnRzLCBzZW5kIGl0IHRoZSBldmVudFxyXG4gICAgICAgICAgICBpZih0aGlzLnJlY2VpdmVycy5oYXMoR2FtZUV2ZW50VHlwZS5BTEwpKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcmVjZWl2ZXIgb2YgdGhpcy5yZWNlaXZlcnMuZ2V0KEdhbWVFdmVudFR5cGUuQUxMKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCJcclxuXHJcbi8qKlxyXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluLWdhbWUgZXZlbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZUV2ZW50IHtcclxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKi9cclxuICAgIHB1YmxpYyB0eXBlOiBzdHJpbmc7XHJcbiAgICAvKiogVGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBldmVudCAqL1xyXG4gICAgcHVibGljIGRhdGE6IE1hcDxhbnk+O1xyXG4gICAgLyoqIFRoZSB0aW1lIG9mIHRoZSBldmVudCBpbiBtcyAqL1xyXG5cdHB1YmxpYyB0aW1lOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVFdmVudC5cclxuICAgICAqIFRoaXMgaXMgaGFuZGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRW1pdHRlcl0gY2xhc3NcclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBHYW1lRXZlbnRcclxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgR2FtZUV2ZW50XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgZGF0YTogTWFwPGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbCkge1xyXG4gICAgICAgIC8vIFBhcnNlIHRoZSBnYW1lIGV2ZW50IGRhdGFcclxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwPGFueT4oKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIE1hcCkpe1xyXG4gICAgICAgICAgICAvLyBkYXRhIGlzIGEgcmF3IG9iamVjdCwgdW5wYWNrXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXA8YW55PigpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiBkYXRhKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hZGQoa2V5LCBkYXRhW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgdHlwZSBvZiB0aGUgR2FtZUV2ZW50XHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgR2FtZUV2ZW50IGlzIHRoZSBzcGVjaWZpZWQgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc1R5cGUodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBHYW1lRXZlbnQgYXMgYSBzdHJpbmdcclxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdhbWVFdmVudFxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyBcIjogQFwiICsgdGhpcy50aW1lO1xyXG4gICAgfVxyXG59IiwiLy8gQGlnbm9yZVBhZ2VcclxuXHJcbmV4cG9ydCBlbnVtIEdhbWVFdmVudFR5cGUge1xyXG5cdC8qKlxyXG5cdCAqIE1vdXNlIERvd24gZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cclxuXHQgKi9cclxuXHRNT1VTRV9ET1dOID0gXCJtb3VzZV9kb3duXCIsXHJcblx0LyoqXHJcblx0ICogTW91c2UgVXAgZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cclxuXHQgKi9cclxuXHRNT1VTRV9VUCA9IFwibW91c2VfdXBcIixcclxuXHQvKipcclxuXHQgKiBNb3VzZSBNb3ZlIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XHJcblx0ICovXHJcblx0TU9VU0VfTU9WRSA9IFwibW91c2VfbW92ZVwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBLZXkgRG93biBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZyAtIFRoZSBrZXkgdGhhdCBpcyBkb3dufVxyXG5cdCAqL1xyXG5cdEtFWV9ET1dOID0gXCJrZXlfZG93blwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBLZXkgVXAgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcgLSBUaGUga2V5IHRoYXQgaXMgdXB9XHJcblx0ICovXHJcblx0S0VZX1VQID0gXCJrZXlfdXBcIixcclxuXHJcblx0LyoqXHJcblx0ICogQ2FudmFzIEJsdXIgZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdENBTlZBU19CTFVSID0gXCJjYW52YXNfYmx1clwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBNb3VzZSB3aGVlbCB1cCBldmVudC4gSGFzIGRhdGE6IHt9XHJcblx0ICovXHJcblx0V0hFRUxfVVAgPSBcIndoZWVsX3VwXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1vdXNlIHdoZWVsIGRvd24gZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdFdIRUVMX0RPV04gPSBcIndoZWVsX2Rvd25cIixcclxuXHJcblx0LyoqXHJcblx0ICogU3RhcnQgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cclxuXHQgKi9cclxuXHRTVEFSVF9SRUNPUkRJTkcgPSBcInN0YXJ0X3JlY29yZGluZ1wiLFxyXG5cclxuXHQvKipcclxuXHQgKiBTdG9wIFJlY29yZGluZyBldmVudC4gSGFzIGRhdGE6IHt9XHJcblx0ICovXHJcblx0U1RPUF9SRUNPUkRJTkcgPSBcInN0b3BfcmVjb3JkaW5nXCIsXHJcblx0XHJcblx0LyoqXHJcblx0ICogUGxheSBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdFBMQVlfUkVDT1JESU5HID0gXCJwbGF5X3JlY29yZGluZ1wiLFxyXG5cclxuXHQvKipcclxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuIH1cclxuXHQgKi9cclxuXHRQTEFZX1NPVU5EID0gXCJwbGF5X3NvdW5kXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmd9XHJcblx0ICovXHJcblx0U1RPUF9TT1VORCA9IFwic3RvcF9zb3VuZFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlIH1cclxuXHQgKi9cclxuIFx0UExBWV9TRlggPSBcInBsYXlfc2Z4XCIsXHJcblxyXG4gXHQvKipcclxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuIH1cclxuXHQgKi9cclxuICBcdFBMQVlfTVVTSUMgPSBcInBsYXlfbXVzaWNcIixcclxuXHJcblx0LyoqXHJcblx0ICogTXV0ZSBhdWRpbyBjaGFubmVsIGV2ZW50LiBIYXMgZGF0YToge2NoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGV9XHJcblx0ICovXHJcblx0TVVURV9DSEFOTkVMID0gXCJtdXRlX2NoYW5uZWxcIixcclxuXHJcblx0LyoqXHJcblx0ICogVW5tdXRlIGF1ZGlvIGNoYW5uZWwgZXZlbnQuIEhhcyBkYXRhOiB7Y2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZX1cclxuXHQgKi9cclxuXHRVTk1VVEVfQ0hBTk5FTCA9IFwidW5tdXRlX2NoYW5uZWxcIixcclxuXHJcblx0LyoqXHJcblx0ICogRW5jb21wYXNzZXMgYWxsIGV2ZW50IHR5cGVzLiBVc2VkIGZvciByZWNlaXZlcnMgb25seS5cclxuXHQgKi9cclxuXHRBTEwgPSBcImFsbFwiLFxyXG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4vRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIFJlY2VpdmVzIHN1YnNjcmliZWQgZXZlbnRzIGZyb20gdGhlIEV2ZW50UXVldWUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNlaXZlciB7XHJcblx0LyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgdGhpcyBSZWNlaXZlciBjYW4gaG9sZCBhdCBvbmUgdGltZSAqL1xyXG5cdHJlYWRvbmx5IE1BWF9TSVpFOiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgaW5ib3ggb2YgdGhlIFJlY2VpdmVyICovXHJcblx0cHJpdmF0ZSBxOiBRdWV1ZTxHYW1lRXZlbnQ+O1xyXG5cclxuXHQvKiogQ3JlYXRlcyBhIG5ldyBSZWNlaXZlciAqL1xyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLk1BWF9TSVpFID0gMTAwO1xyXG4gICAgICAgIHRoaXMucSA9IG5ldyBRdWV1ZSh0aGlzLk1BWF9TSVpFKTtcclxuXHR9XHJcblxyXG5cdGRlc3Ryb3koKXtcclxuXHRcdEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKS51bnN1YnNjcmliZSh0aGlzKTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGVzZSB0eXBlcyBvZiBldmVudHMgdG8gdGhpcyByZWNlaXZlcidzIHF1ZXVlIGV2ZXJ5IHVwZGF0ZS5cclxuXHQgKiBAcGFyYW0gZXZlbnRUeXBlcyBUaGUgdHlwZXMgb2YgZXZlbnRzIHRoaXMgcmVjZWl2ZXIgd2lsbCBiZSBzdWJzY3JpYmVkIHRvXHJcblx0ICovXHJcblx0c3Vic2NyaWJlKGV2ZW50VHlwZXM6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuXHRcdEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKS5zdWJzY3JpYmUodGhpcywgZXZlbnRUeXBlcyk7XHJcblx0XHR0aGlzLnEuY2xlYXIoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gZXZlbnQgdG8gdGhlIHF1ZXVlIG9mIHRoaXMgcmVjaWV2ZXIuIFRoaXMgaXMgdXNlZCBieSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSB0byBkaXN0cmlidXRlIGV2ZW50c1xyXG5cdCAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gcmVjZWl2ZVxyXG5cdCAqL1xyXG5cdHJlY2VpdmUoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG5cdFx0dHJ5e1xyXG5cdFx0dGhpcy5xLmVucXVldWUoZXZlbnQpO1xyXG5cdFx0fSBjYXRjaChlKXtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiUmVjZWl2ZXIgb3ZlcmZsb3cgZm9yIGV2ZW50IFwiICsgZXZlbnQudG9TdHJpbmcoKSk7XHJcblx0XHRcdHRocm93IGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXRyaWV2ZXMgdGhlIG5leHQgZXZlbnQgZnJvbSB0aGUgcmVjZWl2ZXIncyBxdWV1ZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBuZXh0IEdhbWVFdmVudFxyXG5cdCAqL1xyXG5cdGdldE5leHRFdmVudCgpOiBHYW1lRXZlbnQge1xyXG5cdFx0cmV0dXJuIHRoaXMucS5kZXF1ZXVlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBMb29rcyBhdCB0aGUgbmV4dCBldmVudCBpbiB0aGUgcmVjZWl2ZXIncyBxdWV1ZSwgYnV0IGRvZXNuJ3QgcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXVlXHJcblx0ICogQHJldHVybnMgVGhlIG5leHQgR2FtZUV2ZW50XHJcblx0ICovXHJcblx0cGVla05leHRFdmVudCgpOiBHYW1lRXZlbnQge1xyXG5cdFx0cmV0dXJuIHRoaXMucS5wZWVrTmV4dCgpXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbnkgZXZlbnRzIGluIGl0cyBxdWV1ZVxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbm90aGVyIGV2ZW50LCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRoYXNOZXh0RXZlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5xLmhhc0l0ZW1zKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJZ25vcmUgYWxsIGV2ZW50cyB0aGlzIGZyYW1lXHJcblx0ICovXHJcblx0aWdub3JlRXZlbnRzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5xLmNsZWFyKCk7XHJcblx0fVxyXG59IiwiaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBSZWNlaXZlcyBpbnB1dCBldmVudHMgZnJvbSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSBhbmQgYWxsb3dzIGZvciBlYXN5IGFjY2VzcyBvZiBpbmZvcm1hdGlvbiBhYm91dCBpbnB1dCBieSBvdGhlciBzeXN0ZW1zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCB7XHJcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQcmVzc2VkOiBib29sZWFuO1xyXG5cdHByaXZhdGUgc3RhdGljIG1vdXNlSnVzdFByZXNzZWQ6IGJvb2xlYW47XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGtleUp1c3RQcmVzc2VkOiBNYXA8Ym9vbGVhbj47XHJcblx0cHJpdmF0ZSBzdGF0aWMga2V5UHJlc3NlZDogTWFwPGJvb2xlYW4+O1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBtb3VzZVBvc2l0aW9uOiBWZWMyO1xyXG5cdHByaXZhdGUgc3RhdGljIG1vdXNlUHJlc3NQb3NpdGlvbjogVmVjMjtcclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgc2Nyb2xsRGlyZWN0aW9uOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBzdGF0aWMganVzdFNjcm9sbGVkOiBib29sZWFuO1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xyXG5cdHByaXZhdGUgc3RhdGljIHJlY2VpdmVyOiBSZWNlaXZlcjtcclxuXHRwcml2YXRlIHN0YXRpYyB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGtleU1hcDogTWFwPEFycmF5PHN0cmluZz4+O1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBrZXlzRGlzYWJsZWQ6IGJvb2xlYW47XHJcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VEaXNhYmxlZDogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIElucHV0IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBBIHJlZmVyZW5jZSB0byB0aGUgdmlld3BvcnQgb2YgdGhlIGdhbWVcclxuXHQgKi9cclxuXHRzdGF0aWMgaW5pdGlhbGl6ZSh2aWV3cG9ydDogVmlld3BvcnQsIGtleU1hcDogQXJyYXk8UmVjb3JkPHN0cmluZywgYW55Pj4pe1xyXG5cdFx0SW5wdXQudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuXHRcdElucHV0Lm1vdXNlUHJlc3NlZCA9IGZhbHNlO1xyXG5cdFx0SW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IGZhbHNlO1xyXG5cdFx0SW5wdXQucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkID0gbmV3IE1hcDxib29sZWFuPigpO1xyXG5cdFx0SW5wdXQua2V5UHJlc3NlZCA9IG5ldyBNYXA8Ym9vbGVhbj4oKTtcclxuXHRcdElucHV0Lm1vdXNlUG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcclxuXHRcdElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xyXG5cdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcclxuXHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IGZhbHNlO1xyXG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUga2V5bWFwXHJcblx0XHRJbnB1dC5rZXlNYXAgPSBuZXcgTWFwKCk7XHJcblxyXG5cdFx0Ly8gQWRkIGFsbCBrZXlzIHRvIHRoZSBrZXltYXBcclxuXHRcdGZvcihsZXQgZW50cnkgaW4ga2V5TWFwKXtcclxuXHRcdFx0bGV0IG5hbWUgPSBrZXlNYXBbZW50cnldLm5hbWU7XHJcblx0XHRcdGxldCBrZXlzID0ga2V5TWFwW2VudHJ5XS5rZXlzO1xyXG5cdFx0XHRJbnB1dC5rZXlNYXAuYWRkKG5hbWUsIGtleXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdElucHV0LmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcblx0XHQvLyBTdWJzY3JpYmUgdG8gYWxsIGlucHV0IGV2ZW50c1xyXG5cdFx0SW5wdXQuZXZlbnRRdWV1ZS5zdWJzY3JpYmUoSW5wdXQucmVjZWl2ZXIsIFtHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04sIEdhbWVFdmVudFR5cGUuTU9VU0VfVVAsIEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSxcclxuXHRcdFx0IEdhbWVFdmVudFR5cGUuS0VZX0RPV04sIEdhbWVFdmVudFR5cGUuS0VZX1VQLCBHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSLCBHYW1lRXZlbnRUeXBlLldIRUVMX1VQLCBHYW1lRXZlbnRUeXBlLldIRUVMX0RPV05dKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIFJlc2V0IHRoZSBqdXN0UHJlc3NlZCB2YWx1ZXMgdG8gZmFsc2VcclxuXHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSBmYWxzZTtcclxuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xyXG5cdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gZmFsc2U7XHJcblx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAwO1xyXG5cclxuXHRcdHdoaWxlKElucHV0LnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcdFx0XHRcclxuXHRcdFx0bGV0IGV2ZW50ID0gSW5wdXQucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBIYW5kbGUgZWFjaCBldmVudCB0eXBlXHJcblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfRE9XTil7XHJcblx0XHRcdFx0SW5wdXQubW91c2VKdXN0UHJlc3NlZCA9IHRydWU7XHJcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc2VkID0gdHJ1ZTtcclxuXHRcdFx0XHRJbnB1dC5tb3VzZVByZXNzUG9zaXRpb24gPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uXCIpO1x0XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfVVApe1xyXG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NlZCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUpe1xyXG5cdFx0XHRcdElucHV0Lm1vdXNlUG9zaXRpb24gPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uXCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLktFWV9ET1dOKXtcclxuXHRcdFx0XHRsZXQga2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XHJcblx0XHRcdFx0Ly8gSGFuZGxlIHNwYWNlIGJhclxyXG5cdFx0XHRcdGlmKGtleSA9PT0gXCIgXCIpe1xyXG5cdFx0XHRcdFx0a2V5ID0gXCJzcGFjZVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighSW5wdXQua2V5UHJlc3NlZC5nZXQoa2V5KSl7XHJcblx0XHRcdFx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCB0cnVlKTtcclxuXHRcdFx0XHRcdElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgdHJ1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLktFWV9VUCl7XHJcblx0XHRcdFx0bGV0IGtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xyXG5cdFx0XHRcdC8vIEhhbmRsZSBzcGFjZSBiYXJcclxuXHRcdFx0XHRpZihrZXkgPT09IFwiIFwiKXtcclxuXHRcdFx0XHRcdGtleSA9IFwic3BhY2VcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0SW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIpe1xyXG5cdFx0XHRcdElucHV0LmNsZWFyS2V5UHJlc3NlcygpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuV0hFRUxfVVApe1xyXG5cdFx0XHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IC0xO1xyXG5cdFx0XHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IHRydWU7XHJcblx0XHRcdH0gZWxzZSBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLldIRUVMX0RPV04pe1xyXG5cdFx0XHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IDE7XHJcblx0XHRcdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgY2xlYXJLZXlQcmVzc2VzKCk6IHZvaWQge1xyXG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IElucHV0LmtleUp1c3RQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XHJcblx0XHRJbnB1dC5rZXlQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIGZhbHNlKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEga2V5IHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxyXG5cdCAqIElmIHRoZSBrZXkgaXMgc3RpbGwgcHJlc3NlZCBmcm9tIGxhc3QgZnJhbWUgYW5kIHdhc24ndCByZS1wcmVzc2VkLCBJbnB1dCB3aWxsIHJldHVybiBmYWxzZS5cclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXlcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXkgd2FzIGp1c3QgcHJlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0c3RhdGljIGlzS2V5SnVzdFByZXNzZWQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdGlmKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGlmKElucHV0LmtleUp1c3RQcmVzc2VkLmhhcyhrZXkpKXtcclxuXHRcdFx0cmV0dXJuIElucHV0LmtleUp1c3RQcmVzc2VkLmdldChrZXkpXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUga2V5cyB0aGF0IGFyZSBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxyXG5cdCAqIElmIGEga2V5IGlzIHN0aWxsIHByZXNzZWQgZnJvbSBsYXN0IGZyYW1lIGFuZCB3YXNuJ3QgcmUtcHJlc3NlZCwgaXQgd2lsbCBub3QgYmUgaW4gSW5wdXQgbGlzdC5cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgb2YgdGhlIG5ld2x5IHByZXNzZWQga2V5cy5cclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0S2V5c0p1c3RQcmVzc2VkKCk6IEFycmF5PHN0cmluZz4ge1xyXG5cdFx0aWYoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gW107XHJcblxyXG5cdFx0bGV0IGtleXMgPSBBcnJheTxzdHJpbmc+KCk7XHJcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdGlmKElucHV0LmtleUp1c3RQcmVzc2VkLmdldChrZXkpKXtcclxuXHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4ga2V5cztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYSBrZXkgaXMgYmVpbmcgcHJlc3NlZC5cclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXlcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBrZXkgaXMgY3VycmVudGx5IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBpc0tleVByZXNzZWQoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdGlmKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGlmKElucHV0LmtleVByZXNzZWQuaGFzKGtleSkpe1xyXG5cdFx0XHRyZXR1cm4gSW5wdXQua2V5UHJlc3NlZC5nZXQoa2V5KVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2hhbmdlcyB0aGUgYmluZGluZyBvZiBhbiBpbnB1dCBuYW1lIHRvIGtleXNcclxuXHQgKiBAcGFyYW0gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxyXG5cdCAqIEBwYXJhbSBrZXlzIFRoZSBjb3JyZXNwb25kaW5nIGtleXNcclxuXHQgKi9cclxuXHRzdGF0aWMgY2hhbmdlS2V5QmluZGluZyhpbnB1dE5hbWU6IHN0cmluZywga2V5czogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG5cdFx0SW5wdXQua2V5TWFwLnNldChpbnB1dE5hbWUsIGtleXMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXJzIGFsbCBrZXkgYmluZGluZ3NcclxuXHQgKi9cclxuXHRzdGF0aWMgY2xlYXJBbGxLZXlCaW5kaW5ncygpOiB2b2lkIHtcclxuXHRcdElucHV0LmtleU1hcC5jbGVhcigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBpbnB1dCB3YXMganVzdCBwcmVzc2VkIHRoaXMgZnJhbWVcclxuXHQgKiBAcGFyYW0gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGlucHV0IHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBpc0p1c3RQcmVzc2VkKGlucHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRpZihJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRpZihJbnB1dC5rZXlNYXAuaGFzKGlucHV0TmFtZSkpe1xyXG5cdFx0XHRjb25zdCBrZXlzID0gSW5wdXQua2V5TWFwLmdldChpbnB1dE5hbWUpO1xyXG5cdFx0XHRsZXQganVzdFByZXNzZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdGZvcihsZXQga2V5IG9mIGtleXMpe1xyXG5cdFx0XHRcdGp1c3RQcmVzc2VkID0ganVzdFByZXNzZWQgfHwgSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChrZXkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4ganVzdFByZXNzZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHRcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gaW5wdXQgaXMgY3VycmVudGx5IHByZXNzZWRcclxuXHQgKiBAcGFyYW0gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dFxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGlucHV0IGlzIHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBpc1ByZXNzZWQoaW5wdXROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdGlmKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGlmKElucHV0LmtleU1hcC5oYXMoaW5wdXROYW1lKSl7XHJcblx0XHRcdGNvbnN0IGtleXMgPSBJbnB1dC5rZXlNYXAuZ2V0KGlucHV0TmFtZSk7XHJcblx0XHRcdGxldCBwcmVzc2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IobGV0IGtleSBvZiBrZXlzKXtcclxuXHRcdFx0XHRwcmVzc2VkID0gcHJlc3NlZCB8fCBJbnB1dC5pc0tleVByZXNzZWQoa2V5KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHByZXNzZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtb3VzZSB3YXMgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZVxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1vdXNlIHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBpc01vdXNlSnVzdFByZXNzZWQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VKdXN0UHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBwcmVzc2VkXHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbW91c2UgaXMgY3VycmVudGx5IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBpc01vdXNlUHJlc3NlZCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVzZXIgc2Nyb2xsZWQgb3Igbm90XHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdXNlciBqdXN0IHNjcm9sbGVkIElucHV0IGZyYW1lLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgZGlkSnVzdFNjcm9sbCgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBJbnB1dC5qdXN0U2Nyb2xsZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNjcm9sbFxyXG5cdCAqIEByZXR1cm5zIC0xIGlmIHRoZSB1c2VyIHNjcm9sbGVkIHVwLCAxIGlmIHRoZXkgc2Nyb2xsZWQgZG93blxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRTY3JvbGxEaXJlY3Rpb24oKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBJbnB1dC5zY3JvbGxEaXJlY3Rpb247XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWVyJ3MgbW91c2VcclxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUG9zaXRpb24uc2NhbGVkKDEvdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxheWVyJ3MgbW91c2UgaW4gdGhlIGdhbWUgd29ybGQsXHJcblx0ICogdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgc2Nyb2xsaW5nIG9mIHRoZSB2aWV3cG9ydFxyXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXHJcblx0ICovXHJcblx0c3RhdGljIGdldEdsb2JhbE1vdXNlUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQb3NpdGlvbi5jbG9uZSgpLnNjYWxlKDEvdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKSkuYWRkKElucHV0LnZpZXdwb3J0LmdldE9yaWdpbigpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzXHJcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzIGluIHRoZSBnYW1lIHdvcmxkLFxyXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcclxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uLmNsb25lKCkuYWRkKElucHV0LnZpZXdwb3J0LmdldE9yaWdpbigpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc2FibGVzIGFsbCBrZXlwcmVzcyBhbmQgbW91c2UgY2xpY2sgaW5wdXRzXHJcblx0ICovXHJcblx0c3RhdGljIGRpc2FibGVJbnB1dCgpOiB2b2lkIHtcclxuXHRcdElucHV0LmtleXNEaXNhYmxlZCA9IHRydWU7XHJcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEVuYWJsZXMgYWxsIGtleXByZXNzIGFuZCBtb3VzZSBjbGljayBpbnB1dHNcclxuXHQgKi9cclxuXHRzdGF0aWMgZW5hYmxlSW5wdXQoKTogdm9pZCB7XHJcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdElucHV0Lm1vdXNlRGlzYWJsZWQgPSBmYWxzZTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSB3ZWIgYnJvd3NlciB0byByZWNlaXZlIGFzeW5jaHJvbm91cyBldmVudHMgYW5kIHNlbmQgdGhlbSB0byB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRIYW5kbGVyIHtcclxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcbiAgICAgXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5wdXRIYW5kbGVyXHJcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBnYW1lIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KXtcclxuXHRcdHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuXHRcdFxyXG4gICAgICAgIGNhbnZhcy5vbm1vdXNlZG93biA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZURvd24oZXZlbnQsIGNhbnZhcyk7XHJcbiAgICAgICAgY2FudmFzLm9ubW91c2V1cCA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZVVwKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgICAgIGNhbnZhcy5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVDb250ZXh0TWVudTtcclxuICAgICAgICBjYW52YXMub25tb3VzZW1vdmUgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgICAgIGRvY3VtZW50Lm9ua2V5ZG93biA9IHRoaXMuaGFuZGxlS2V5RG93bjtcclxuICAgICAgICBkb2N1bWVudC5vbmtleXVwID0gdGhpcy5oYW5kbGVLZXlVcDtcclxuICAgICAgICBkb2N1bWVudC5vbmJsdXIgPSB0aGlzLmhhbmRsZUJsdXI7XHJcbiAgICAgICAgZG9jdW1lbnQub25jb250ZXh0bWVudSA9IHRoaXMuaGFuZGxlQmx1cjtcclxuICAgICAgICBkb2N1bWVudC5vbndoZWVsID0gdGhpcy5oYW5kbGVXaGVlbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZU1vdXNlRG93biA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xyXG5cdFx0bGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04sIHtwb3NpdGlvbjogcG9zfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZVVwID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX1VQLCB7cG9zaXRpb246IHBvc30pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VNb3ZlID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsIHtwb3NpdGlvbjogcG9zfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuZ2V0S2V5KGV2ZW50KTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLktFWV9ET1dOLCB7a2V5OiBrZXl9KTtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZUtleVVwID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuZ2V0S2V5KGV2ZW50KTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLktFWV9VUCwge2tleToga2V5fSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVCbHVyID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIsIHt9KTtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZUNvbnRleHRNZW51ID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVXaGVlbCA9IChldmVudDogV2hlZWxFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGdhbWVFdmVudDogR2FtZUV2ZW50O1xyXG4gICAgICAgIGlmKGV2ZW50LmRlbHRhWSA8IDApe1xyXG4gICAgICAgICAgICBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuV0hFRUxfVVAsIHt9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTiwge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEtleShrZXlFdmVudDogS2V5Ym9hcmRFdmVudCl7XHJcbiAgICAgICAgcmV0dXJuIGtleUV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogVmVjMiB7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgbGV0IHggPSBtb3VzZUV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XHJcbiAgICAgICAgbGV0IHkgPSBtb3VzZUV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge30gZnJvbSBcIi4uLy4uL2luZGV4XCI7ICAvLyBUaGlzIGltcG9ydCBhbGxvd3MgdXMgdG8gbW9kaWZ5IHRoZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgdG8gYWRkIGV4dHJhIGZ1bmN0aW9uYWxpdHlcclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHVwIHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgZ2FtZSBlbmdpbmVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudmlyb25tZW50SW5pdGlhbGl6ZXIge1xyXG4gICAgc3RhdGljIHNldHVwKCl7XHJcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlciwgcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgICAgIC8vIENsYW1wIHRoZSByYWRpdXMgYmV0d2VlbiAwIGFuZCB0aGUgbWluIG9mIHRoZSB3aWR0aCBvciBoZWlnaHRcclxuICAgICAgICAgICAgaWYociA8IDApIHIgPSAwO1xyXG4gICAgICAgICAgICBpZihyID4gTWF0aC5taW4odywgaCkpIHIgPSBNYXRoLm1pbih3LCBoKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgcm91bmRlZCByZWN0XHJcbiAgICAgICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFRvcFxyXG4gICAgICAgICAgICB0aGlzLm1vdmVUbyh4ICsgciwgeSk7XHJcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyB3IC0gciwgeSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCArIHcsIHksIHggKyB3LCB5ICsgciwgcik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFJpZ2h0XHJcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyB3LCB5ICsgaCAtIHIpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY1RvKHggKyB3LCB5ICsgaCwgeCArIHcgLSByLCB5ICsgaCwgcik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEJvdHRvbVxyXG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgciwgeSArIGgpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHIsIHIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBMZWZ0XHJcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkgKyByKTtcclxuICAgICAgICAgICAgdGhpcy5hcmNUbyh4LCB5LCB4ICsgciwgeSwgcilcclxuICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2VSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHIpe1xyXG4gICAgICAgICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmZpbGxSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHIpe1xyXG4gICAgICAgICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR2FtZUxvb3AgZnJvbSBcIi4vR2FtZUxvb3BcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XHJcblxyXG4vKipcclxuICogQSBnYW1lIGxvb3Agd2l0aCBhIGZpeGVkIHVwZGF0ZSB0aW1lIGFuZCBhIHZhcmlhYmxlIHJlbmRlciB0aW1lLlxyXG4gKiBFdmVyeSBmcmFtZSwgdGhlIGdhbWUgdXBkYXRlcyB1bnRpbCBhbGwgdGltZSBzaW5jZSB0aGUgbGFzdCBmcmFtZSBoYXMgYmVlbiBwcm9jZXNzZWQuXHJcbiAqIElmIHRvbyBtdWNoIHRpbWUgaGFzIHBhc3NlZCwgc3VjaCBhcyBpZiB0aGUgbGFzdCB1cGRhdGUgd2FzIHRvbyBzbG93LCBcclxuICogb3IgaWYgdGhlIGJyb3dzZXIgd2FzIHB1dCBpbnRvIHRoZSBiYWNrZ3JvdW5kLCB0aGUgbG9vcCB3aWxsIHBhbmljIGFuZCBkaXNjYXJkIHRpbWUuXHJcbiAqIEEgcmVuZGVyIGhhcHBlbnMgYXQgdGhlIGVuZCBvZiBldmVyeSBmcmFtZS4gVGhpcyBoYXBwZW5zIGFzIGZhc3QgYXMgcG9zc2libGUgdW5sZXNzIHNwZWNpZmllZC5cclxuICogQSBsb29wIG9mIHRoaXMgdHlwZSBhbGxvd3MgZm9yIGRldGVybWluaXN0aWMgYmVoYXZpb3IgLSBObyBtYXR0ZXIgd2hhdCB0aGUgZnJhbWUgcmF0ZSBpcywgdGhlIHVwZGF0ZSBzaG91bGQgYmVoYXZlIHRoZSBzYW1lLCBcclxuICogYXMgaXQgaXMgb2NjdXJpbmcgaW4gYSBmaXhlZCBpbnRlcnZhbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkVXBkYXRlR2FtZUxvb3AgZXh0ZW5kcyBHYW1lTG9vcCB7XHJcblxyXG5cdC8qKiBUaGUgbWF4IGFsbG93ZWQgdXBkYXRlIGZwcy4qL1xyXG4gICAgcHJpdmF0ZSBtYXhVcGRhdGVGUFM6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSB0aW1lc3RlcCBmb3IgZWFjaCB1cGRhdGUuIFRoaXMgaXMgdGhlIGRlbHRhVCBwYXNzZWQgdG8gdXBkYXRlIGNhbGxzLiAqL1xyXG5cdHByaXZhdGUgdXBkYXRlVGltZXN0ZXA6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIHdlIGFyZSB5ZXQgdG8gc2ltdWxhdGUuICovXHJcbiAgICBwcml2YXRlIGZyYW1lRGVsdGE6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIHRpbWUgd2hlbiB0aGUgbGFzdCBmcmFtZSB3YXMgZHJhd24uICovXHJcbiAgICBwcml2YXRlIGxhc3RGcmFtZVRpbWU6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBtaW5pbXVtIHRpbWUgd2Ugd2FudCB0byB3YWl0IGJldHdlZW4gZ2FtZSBmcmFtZXMuICovXHJcbiAgICBwcml2YXRlIG1pbkZyYW1lRGVsYXk6IG51bWJlcjtcclxuXHJcblx0LyoqIFRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSBnYW1lLiAqL1xyXG5cdHByaXZhdGUgZnJhbWU6IG51bWJlcjtcclxuXHJcblx0LyoqIFRoZSBhY3R1YWwgZnBzIG9mIHRoZSBnYW1lLiAqL1xyXG4gICAgcHJpdmF0ZSBmcHM6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSB0aW1lIGJldHdlZW4gZnBzIG1lYXN1cmVtZW50IHVwZGF0ZXMuICovXHJcbiAgICBwcml2YXRlIGZwc1VwZGF0ZUludGVydmFsOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSB0aW1lIG9mIHRoZSBsYXN0IGZwcyB1cGRhdGUuICovXHJcbiAgICBwcml2YXRlIGxhc3RGcHNVcGRhdGU6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBmcmFtZXMgc2luY2UgdGhlIGxhc3QgZnBzIHVwZGF0ZSB3YXMgZG9uZS4gKi9cclxuICAgIHByaXZhdGUgZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBoYXMgc3RhcnRlZC4gKi9cclxuICAgIHByaXZhdGUgc3RhcnRlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGlzIHBhdXNlZCAqL1xyXG4gICAgcHJpdmF0ZSBwYXVzZWQ6IGJvb2xlYW47XHJcbiAgICBcclxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaXMgY3VycmVudGx5IHJ1bm5pbmcuICovXHJcbiAgICBwcml2YXRlIHJ1bm5pbmc6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgdXBkYXRlIHN0ZXBzIHRoaXMgaXRlcmF0aW9uIG9mIHRoZSBnYW1lIGxvb3AuICovXHJcbiAgICBwcml2YXRlIG51bVVwZGF0ZVN0ZXBzOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0c3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1heFVwZGF0ZUZQUyA9IDYwO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZXN0ZXAgPSBNYXRoLmZsb29yKDEwMDAvdGhpcy5tYXhVcGRhdGVGUFMpO1xyXG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gMDtcclxuICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnBzID0gdGhpcy5tYXhVcGRhdGVGUFM7ICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnBzIHRvIHRoZSBtYXggYWxsb3dlZCBmcHNcclxuICAgICAgICB0aGlzLmZwc1VwZGF0ZUludGVydmFsID0gMTAwMDtcclxuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xyXG5cdH1cclxuXHJcblx0Z2V0RlBTKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgZnJhbWUgY291bnQgYW5kIHN1bSBvZiB0aW1lIGZvciB0aGUgZnJhbWVyYXRlIG9mIHRoZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gdGltZXN0ZXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdXBkYXRlRlBTKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mcHMgPSAwLjkgKiB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSAqIDEwMDAgLyAodGltZXN0YW1wIC0gdGhpcy5sYXN0RnBzVXBkYXRlKSArKDEgLSAwLjkpICogdGhpcy5mcHM7XHJcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcclxuXHJcbiAgICAgICAgRGVidWcubG9nKFwiZnBzXCIsIFwiRlBTOiBcIiArIHRoaXMuZnBzLnRvRml4ZWQoMSkpO1xyXG4gICAgICAgIFN0YXRzLnVwZGF0ZUZQUyh0aGlzLmZwcyk7XHJcbiAgICB9XHJcblxyXG5cdCAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIG1heGltdW0gYWxsb3dlZCBwaHlzaWNzIGZyYW1lcmF0ZSBvZiB0aGUgZ2FtZVxyXG4gICAgICogQHBhcmFtIGluaXRNYXggVGhlIG1heCBmcmFtZXJhdGVcclxuICAgICAqL1xyXG4gICAgc2V0TWF4VXBkYXRlRlBTKGluaXRNYXg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubWF4VXBkYXRlRlBTID0gaW5pdE1heDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1heGltdW0gcmVuZGVyaW5nIGZyYW1lcmF0ZVxyXG4gICAgICogQHBhcmFtIG1heEZQUyBUaGUgbWF4IGZyYW1lcmF0ZVxyXG4gICAgICovXHJcbiAgICBzZXRNYXhGUFMobWF4RlBTOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAxMDAwL21heEZQUztcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgZ2FtZSBsb29wIHBhbmljcywgaS5lLiBpdCB0cmllcyB0byBwcm9jZXNzIHRvbyBtdWNoIHRpbWUgaW4gYW4gZW50aXJlIGZyYW1lLlxyXG5cdCAqIFRoaXMgd2lsbCByZXNldCB0aGUgYW1vdW50IG9mIHRpbWUgYmFjayB0byB6ZXJvLlxyXG5cdCAqIEByZXR1cm5zIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBhcmUgZGlzY2FyZGluZyBmcm9tIHByb2Nlc3NpbmcuXHJcblx0ICovXHJcblx0cmVzZXRGcmFtZURlbHRhKCkgOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBvbGRGcmFtZURlbHRhID0gdGhpcy5mcmFtZURlbHRhO1xyXG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG9sZEZyYW1lRGVsdGE7XHJcbiAgICB9XHJcblxyXG5cdC8qKlxyXG4gICAgICogU3RhcnRzIHVwIHRoZSBnYW1lIGxvb3AgYW5kIGNhbGxzIHRoZSBmaXJzdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAqL1xyXG5cdHN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0ZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB0aGlzLmRvRmlyc3RGcmFtZSh0aW1lc3RhbXApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcGF1c2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VtZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuICAgICAqIFRoZSBmaXJzdCBnYW1lIGZyYW1lIC0gaW5pdGlhbGl6ZXMgdGhlIGZpcnN0IGZyYW1lIHRpbWUgYW5kIGJlZ2lucyB0aGUgcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQgIHtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9kb1JlbmRlcigpO1xyXG5cclxuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodCkgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcblx0ICogSGFuZGxlcyBhbnkgcHJvY2Vzc2luZyB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZVxyXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWUgb2YgdGhlIGZyYW1lIGluIG1zXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHN0YXJ0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIFVwZGF0ZSB0aGUgYW1vdW50IG9mIHRpbWUgd2UgbmVlZCBvdXIgdXBkYXRlIHRvIHByb2Nlc3NcclxuXHRcdHRoaXMuZnJhbWVEZWx0YSArPSB0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcmFtZVRpbWU7XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBuZXcgdGltZSBvZiB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlc3RpbWF0ZSBvZiB0aGUgZnJhbWVyYXRlXHJcbiAgICAgICAgaWYodGltZXN0YW1wID4gdGhpcy5sYXN0RnBzVXBkYXRlICsgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCl7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRlBTKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHRcdC8vIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGZyYW1lc1xyXG4gICAgICAgIHRoaXMuZnJhbWUrKztcclxuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSsrO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBUaGUgbWFpbiBsb29wIG9mIHRoZSBnYW1lLiBVcGRhdGVzIHVudGlsIHRoZSBjdXJyZW50IHRpbWUgaXMgcmVhY2hlZC4gUmVuZGVycyBvbmNlXHJcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGRvRnJhbWUgPSAodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkID0+IHtcclxuICAgICAgICAvLyBJZiBhIHBhdXNlIHdhcyBleGVjdXRlZCwgc3RvcCBkb2luZyB0aGUgbG9vcC5cclxuICAgICAgICBpZih0aGlzLnBhdXNlZCl7IFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZSB0byBwcmVwYXJlIGZvciBhbm90aGVyIHVwZGF0ZSBvciByZW5kZXJcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0KSA9PiB0aGlzLmRvRnJhbWUodCkpO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSBhcmUgdHJ5aW5nIHRvIHJlbmRlciB0b28gc29vbiwgZG8gbm90aGluZy5cclxuICAgICAgICBpZih0aW1lc3RhbXAgPCB0aGlzLmxhc3RGcmFtZVRpbWUgKyB0aGlzLm1pbkZyYW1lRGVsYXkpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIEEgZnJhbWUgaXMgYWN0dWFsbHkgaGFwcGVuaW5nXHJcblx0XHR0aGlzLnN0YXJ0RnJhbWUodGltZXN0YW1wKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgd2hpbGUgdGhlcmUgaXMgc3RpbGwgdGltZSB0byBtYWtlIHVwLiBJZiB3ZSBkbyB0b28gbWFueSB1cGRhdGUgc3RlcHMsIHBhbmljIGFuZCBleGl0IHRoZSBsb29wLlxyXG5cdFx0dGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XHJcblx0XHRsZXQgcGFuaWMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgd2hpbGUodGhpcy5mcmFtZURlbHRhID49IHRoaXMudXBkYXRlVGltZXN0ZXApe1xyXG5cdFx0XHQvLyBEbyBhbiB1cGRhdGVcclxuXHRcdFx0dGhpcy5fZG9VcGRhdGUodGhpcy51cGRhdGVUaW1lc3RlcC8xMDAwKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIFJlbW92ZSB0aGUgdXBkYXRlIHN0ZXAgdGltZSBmcm9tIHRoZSB0aW1lIHdlIGhhdmUgdG8gcHJvY2Vzc1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lRGVsdGEgLT0gdGhpcy51cGRhdGVUaW1lc3RlcDtcclxuXHJcblx0XHRcdC8vIEluY3JlbWVudCBzdGVwcyBhbmQgY2hlY2sgaWYgd2UndmUgZG9uZSB0b28gbWFueVxyXG4gICAgICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzKys7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubnVtVXBkYXRlU3RlcHMgPiAxMDApe1xyXG4gICAgICAgICAgICAgICAgcGFuaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZXMgYXJlIGRvbmUsIHJlbmRlclxyXG4gICAgICAgIHRoaXMuX2RvUmVuZGVyKCk7XHJcblxyXG4gICAgICAgIC8vIFdyYXAgdXAgdGhlIGZyYW1lXHJcbiAgICAgICAgdGhpcy5maW5pc2hGcmFtZShwYW5pYyk7XHJcbiAgICB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZSBhbmQgaGFuZGxlcyB0aGUgcGFuaWMgc3RhdGUgaWYgdGhlcmUgaXMgb25lXHJcblx0ICogQHBhcmFtIHBhbmljIFdoZXRoZXIgb3Igbm90IHRoZSBsb29wIHBhbmlja2VkXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGZpbmlzaEZyYW1lKHBhbmljOiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRpZihwYW5pYykge1xyXG4gICAgICAgICAgICB2YXIgZGlzY2FyZGVkVGltZSA9IE1hdGgucm91bmQodGhpcy5yZXNldEZyYW1lRGVsdGEoKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFpbiBsb29wIHBhbmlja2VkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBicm93c2VyIHRhYiB3YXMgcHV0IGluIHRoZSBiYWNrZ3JvdW5kLiBEaXNjYXJkaW5nICcgKyBkaXNjYXJkZWRUaW1lICsgJ21zJyk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcbn0iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgSW5wdXRIYW5kbGVyIGZyb20gXCIuLi9JbnB1dC9JbnB1dEhhbmRsZXJcIjtcclxuaW1wb3J0IFJlY29yZGVyIGZyb20gXCIuLi9QbGF5YmFjay9SZWNvcmRlclwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XHJcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSBcIi4uL1NjZW5lL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgQXVkaW9NYW5hZ2VyIGZyb20gXCIuLi9Tb3VuZC9BdWRpb01hbmFnZXJcIjtcclxuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcclxuaW1wb3J0IENhbnZhc1JlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgR2FtZU9wdGlvbnMgZnJvbSBcIi4vR2FtZU9wdGlvbnNcIjtcclxuaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XHJcbmltcG9ydCBGaXhlZFVwZGF0ZUdhbWVMb29wIGZyb20gXCIuL0ZpeGVkVXBkYXRlR2FtZUxvb3BcIjtcclxuaW1wb3J0IEVudmlyb25tZW50SW5pdGlhbGl6ZXIgZnJvbSBcIi4vRW52aXJvbm1lbnRJbml0aWFsaXplclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcblxyXG4vKipcclxuICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZSBlbmdpbmUuXHJcbiAqIEhhbmRsZXMgdGhlIHVwZGF0ZSBvcmRlciwgYW5kIGluaXRpYWxpemVzIGFsbCBzdWJzeXN0ZW1zLlxyXG4gKiBUaGUgR2FtZSBtYW5hZ2VzIHRoZSB1cGRhdGUgY3ljbGUsIGFuZCByZXF1ZXN0cyBhbmltYXRpb24gZnJhbWVzIHRvIHJlbmRlciB0byB0aGUgYnJvd3Nlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWUge1xyXG4gICAgZ2FtZU9wdGlvbnM6IEdhbWVPcHRpb25zO1xyXG4gICAgcHJpdmF0ZSBzaG93RGVidWc6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIHNob3dTdGF0czogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBUaGUgZ2FtZSBsb29wXHJcbiAgICBwcml2YXRlIGxvb3A6IEdhbWVMb29wO1xyXG5cclxuICAgIC8vIEdhbWUgY2FudmFzIGFuZCBpdHMgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgcmVhZG9ubHkgR0FNRV9DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xyXG4gICAgcmVhZG9ubHkgREVCVUdfQ0FOVkFTOiBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHRyZWFkb25seSBXSURUSDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgSEVJR0hUOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHZpZXdwb3J0OiBWaWV3cG9ydDtcclxuICAgIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBwcml2YXRlIGNsZWFyQ29sb3I6IENvbG9yO1xyXG4gICAgXHJcbiAgICAvLyBBbGwgb2YgdGhlIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIHRoYXQgbmVlZCB0byBydW4gaGVyZVxyXG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuXHRwcml2YXRlIGlucHV0SGFuZGxlcjogSW5wdXRIYW5kbGVyO1xyXG5cdHByaXZhdGUgcmVjb3JkZXI6IFJlY29yZGVyO1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIHByaXZhdGUgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXI7XHJcbiAgICBwcml2YXRlIGF1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyO1xyXG4gICAgcHJpdmF0ZSByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHYW1lXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgR2FtZSBpbml0aWFsaXphdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pil7XHJcbiAgICAgICAgLy8gQmVmb3JlIGFueXRoaW5nIGVsc2UsIGJ1aWxkIHRoZSBlbnZpcm9ubWVudFxyXG4gICAgICAgIEVudmlyb25tZW50SW5pdGlhbGl6ZXIuc2V0dXAoKTtcclxuXHJcbiAgICAgICAgLy8gVHlwZWNhc3QgdGhlIGNvbmZpZyBvYmplY3QgdG8gYSBHYW1lQ29uZmlnIG9iamVjdFxyXG4gICAgICAgIHRoaXMuZ2FtZU9wdGlvbnMgPSBHYW1lT3B0aW9ucy5wYXJzZShvcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaG93RGVidWcgPSB0aGlzLmdhbWVPcHRpb25zLnNob3dEZWJ1ZztcclxuICAgICAgICB0aGlzLnNob3dTdGF0cyA9IHRoaXMuZ2FtZU9wdGlvbnMuc2hvd1N0YXRzO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBnYW1lIGxvb3BcclxuICAgICAgICB0aGlzLmxvb3AgPSBuZXcgRml4ZWRVcGRhdGVHYW1lTG9vcCgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGdhbWUgY2FudmFzIGFuZCBnaXZlIGl0IGEgYmFja2dyb3VuZCBjb2xvclxyXG4gICAgICAgIHRoaXMuR0FNRV9DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLWNhbnZhc1wiKTtcclxuICAgICAgICB0aGlzLkRFQlVHX0NBTlZBUyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlYnVnLWNhbnZhc1wiKTtcclxuICAgIFxyXG4gICAgICAgIC8vIEdpdmUgdGhlIGNhbnZhcyBhIHNpemUgYW5kIGdldCB0aGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICB0aGlzLldJRFRIID0gdGhpcy5nYW1lT3B0aW9ucy5jYW52YXNTaXplLng7XHJcbiAgICAgICAgdGhpcy5IRUlHSFQgPSB0aGlzLmdhbWVPcHRpb25zLmNhbnZhc1NpemUueTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBzdGVwIE1VU1QgaGFwcGVuIGJlZm9yZSB0aGUgcmVzb3VyY2UgbWFuYWdlciBkb2VzIGFueXRoaW5nXHJcbiAgICAgICAgaWYodGhpcy5nYW1lT3B0aW9ucy51c2VXZWJHTCl7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IG5ldyBXZWJHTFJlbmRlcmVyKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gbmV3IENhbnZhc1JlbmRlcmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUdhbWVXaW5kb3coKTtcclxuICAgICAgICB0aGlzLmN0eCA9IHRoaXMucmVuZGVyaW5nTWFuYWdlci5pbml0aWFsaXplQ2FudmFzKHRoaXMuR0FNRV9DQU5WQVMsIHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcclxuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBuZXcgQ29sb3IodGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLnIsIHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5nLCB0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuYik7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgZGVidWdnaW5nIGFuZCBzdGF0c1xyXG4gICAgICAgIERlYnVnLmluaXRpYWxpemVEZWJ1Z0NhbnZhcyh0aGlzLkRFQlVHX0NBTlZBUywgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xyXG4gICAgICAgIFN0YXRzLmluaXRTdGF0cygpO1xyXG5cclxuICAgICAgICBpZih0aGlzLmdhbWVPcHRpb25zLnNob3dTdGF0cykge1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzdGF0cyBvdXRwdXQgYW5kIG1ha2UgaXQgbm8gbG9uZ2VyIGhpZGRlblxyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzXCIpLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2l6ZSB0aGUgdmlld3BvcnQgdG8gdGhlIGdhbWUgY2FudmFzXHJcbiAgICAgICAgY29uc3QgY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KGNhbnZhc1NpemUsIHRoaXMuZ2FtZU9wdGlvbnMuem9vbUxldmVsKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgbmVjZXNzYXJ5IGdhbWUgc3Vic3lzdGVtc1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmlucHV0SGFuZGxlciA9IG5ldyBJbnB1dEhhbmRsZXIodGhpcy5HQU1FX0NBTlZBUyk7XHJcbiAgICAgICAgSW5wdXQuaW5pdGlhbGl6ZSh0aGlzLnZpZXdwb3J0LCB0aGlzLmdhbWVPcHRpb25zLmlucHV0cyk7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRlciA9IG5ldyBSZWNvcmRlcigpO1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIgPSBuZXcgU2NlbmVNYW5hZ2VyKHRoaXMudmlld3BvcnQsIHRoaXMucmVuZGVyaW5nTWFuYWdlcik7XHJcbiAgICAgICAgdGhpcy5hdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB1cCB0aGUgZ2FtZSB3aW5kb3cgdGhhdCBob2xkcyB0aGUgY2FudmFzZXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplR2FtZVdpbmRvdygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBnYW1lV2luZG93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLXdpbmRvd1wiKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZXQgdGhlIGhlaWdodCBvZiB0aGUgZ2FtZSB3aW5kb3dcclxuICAgICAgICBnYW1lV2luZG93LnN0eWxlLndpZHRoID0gdGhpcy5XSURUSCArIFwicHhcIjtcclxuICAgICAgICBnYW1lV2luZG93LnN0eWxlLmhlaWdodCA9IHRoaXMuSEVJR0hUICsgXCJweFwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmVpdmVzIHRoZSBTY2VuZU1hbmFnZXIgZnJvbSB0aGUgR2FtZVxyXG4gICAgICogQHJldHVybnMgVGhlIFNjZW5lTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXRTY2VuZU1hbmFnZXIoKTogU2NlbmVNYW5hZ2VyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZU1hbmFnZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGdhbWVcclxuICAgICAqL1xyXG4gICAgc3RhcnQoSW5pdGlhbFNjZW5lOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gU2NlbmUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICAvLyBTZXQgdGhlIHVwZGF0ZSBmdW5jdGlvbiBvZiB0aGUgbG9vcFxyXG4gICAgICAgIHRoaXMubG9vcC5kb1VwZGF0ZSA9IChkZWx0YVQ6IG51bWJlcikgPT4gdGhpcy51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgdGhlIGxvb3BcclxuICAgICAgICB0aGlzLmxvb3AuZG9SZW5kZXIgPSAoKSA9PiB0aGlzLnJlbmRlcigpO1xyXG5cclxuICAgICAgICAvLyBQcmVsb2FkIHJlZ2lzdHJ5IGl0ZW1zXHJcbiAgICAgICAgUmVnaXN0cnlNYW5hZ2VyLnByZWxvYWQoKTtcclxuXHJcbiAgICAgICAgLy8gTG9hZCB0aGUgaXRlbXMgd2l0aCB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLmxvYWRSZXNvdXJjZXNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIGRvbmUgbG9hZGluZywgc3RhcnQgdGhlIGxvb3BcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGaW5pc2hlZCBQcmVsb2FkIC0gbG9hZGluZyBmaXJzdCBzY2VuZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShJbml0aWFsU2NlbmUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmxvb3Auc3RhcnQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYWxsIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIG9mIHRoZSBnYW1lLiBEZWZlcnMgc2NlbmUgdXBkYXRlcyB0byB0aGUgc2NlbmVNYW5hZ2VyXHJcbiAgICAgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lIHNpbmUgdGhlIGxhc3QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgLy8gSGFuZGxlIGFsbCBldmVudHMgdGhhdCBoYXBwZW5lZCBzaW5jZSB0aGUgc3RhcnQgb2YgdGhlIGxhc3QgbG9vcFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UXVldWUudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0IGRhdGEgc3RydWN0dXJlcyBzbyBnYW1lIG9iamVjdHMgY2FuIHNlZSB0aGUgaW5wdXRcclxuICAgICAgICAgICAgSW5wdXQudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlY29yZGluZyBvZiB0aGUgZ2FtZVxyXG4gICAgICAgICAgICB0aGlzLnJlY29yZGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBzY2VuZXNcclxuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxsIHNvdW5kc1xyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIExvYWQgb3IgdW5sb2FkIGFueSByZXNvdXJjZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcC5wYXVzZSgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmNhdWdodCBFcnJvciBpbiBVcGRhdGUgLSBDcmFzaGluZyBncmFjZWZ1bGx5XCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY2FudmFzIGFuZCBkZWZlcnMgc2NlbmUgcmVuZGVyaW5nIHRvIHRoZSBzY2VuZU1hbmFnZXIuIFJlbmRlcnMgdGhlIGRlYnVnIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICByZW5kZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgY2FudmFzZXNcclxuICAgICAgICAgICAgRGVidWcuY2xlYXJDYW52YXMoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5jbGVhcih0aGlzLmNsZWFyQ29sb3IpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIucmVuZGVyKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYWNreSBkZWJ1ZyBtb2RlXHJcbiAgICAgICAgICAgIGlmKElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJnXCIpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0RlYnVnID0gIXRoaXMuc2hvd0RlYnVnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZWJ1ZyByZW5kZXJcclxuICAgICAgICAgICAgaWYodGhpcy5zaG93RGVidWcpe1xyXG4gICAgICAgICAgICAgICAgRGVidWcucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc2hvd1N0YXRzKXtcclxuICAgICAgICAgICAgICAgIFN0YXRzLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICAgICAgdGhpcy5sb29wLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuY2F1Z2h0IEVycm9yIGluIFJlbmRlciAtIENyYXNoaW5nIGdyYWNlZnVsbHlcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IE51bGxGdW5jIGZyb20gXCIuLi9EYXRhVHlwZXMvRnVuY3Rpb25zL051bGxGdW5jXCI7XHJcblxyXG4vKipcclxuICogVGhlIG1haW4gZ2FtZSBsb29wIG9mIHRoZSBnYW1lLiBLZWVwcyB0cmFjayBvZiBmcHMgYW5kIGhhbmRsZXMgc2NoZWR1bGluZyBvZiB1cGRhdGVzIGFuZCByZW5kZXJpbmcuXHJcbiAqIFRoaXMgY2xhc3MgaXMgbGVmdCBhYnN0cmFjdCwgc28gdGhhdCBhIHN1YmNsYXNzIGNhbiBoYW5kbGUgZXhhY3RseSBob3cgdGhlIGxvb3AgaXMgc2NoZWR1bGVkLlxyXG4gKiBGb3IgYW4gZXhhbXBsZSBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgZ2FtZSBsb29wIHNjaGVkdWxpbmcsIGNoZWNrIG91dCBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9nYW1lLWxvb3AuaHRtbClcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEdhbWVMb29wIHtcclxuXHJcblx0LyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYW4gdXBkYXRlIG9jY3VycyAqL1xyXG5cdHByb3RlY3RlZCBfZG9VcGRhdGU6IEZ1bmN0aW9uID0gTnVsbEZ1bmM7XHJcblxyXG5cdHNldCBkb1VwZGF0ZSh1cGRhdGU6IEZ1bmN0aW9uKXtcclxuXHRcdHRoaXMuX2RvVXBkYXRlID0gdXBkYXRlO1xyXG5cdH1cclxuXHJcblx0LyoqIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSByZW5kZXIgb2NjdXJzICovXHJcblx0cHJvdGVjdGVkIF9kb1JlbmRlcjogRnVuY3Rpb24gPSBOdWxsRnVuYztcclxuXHJcblxyXG5cdHNldCBkb1JlbmRlcihyZW5kZXI6IEZ1bmN0aW9uKXtcclxuXHRcdHRoaXMuX2RvUmVuZGVyID0gcmVuZGVyO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgRlBTIG9mIHRoZSBnYW1lXHJcblx0ICovXHJcblx0YWJzdHJhY3QgZ2V0RlBTKCk6IG51bWJlcjtcclxuXHJcblx0LyoqXHJcbiAgICAgKiBTdGFydHMgdXAgdGhlIGdhbWUgbG9vcFxyXG4gICAgICovXHJcblx0YWJzdHJhY3Qgc3RhcnQoKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUGF1c2VzIHRoZSBnYW1lIGxvb3AsIHVzdWFsbHkgZm9yIGFuIGVycm9yIGNvbmRpdGlvbi5cclxuXHQgKi9cclxuXHRhYnN0cmFjdCBwYXVzZSgpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXN1bWVzIHRoZSBnYW1lIGxvb3AuXHJcblx0ICovXHJcblx0YWJzdHJhY3QgcmVzdW1lKCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJ1bnMgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBnYW1lLiBObyB1cGRhdGUgb2NjdXJzIGhlcmUsIG9ubHkgYSByZW5kZXIuXHJcblx0ICogVGhpcyBpcyBuZWVkZWQgdG8gaW5pdGlhbGl6ZSBkZWx0YSB0aW1lIHZhbHVlc1xyXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBkb0ZpcnN0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSdW4gYmVmb3JlIGFueSB1cGRhdGVzIG9yIHRoZSByZW5kZXIgb2YgYSBmcmFtZS5cclxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3Qgc3RhcnRGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBjb3JlIG9mIHRoZSBmcmFtZSwgd2hlcmUgYW55IG5lY2Vzc2FyeSB1cGRhdGVzIG9jY3VyLCBhbmQgd2hlcmUgYSByZW5kZXIgaGFwcGVuc1xyXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZnJhbWUuIFRoaXMgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBkb0ZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogV3JhcHMgdXAgdGhlIGZyYW1lXHJcblx0ICogQHBhcmFtIHBhbmljIFdoZXRoZXIgb3Igbm90IHRoZSB1cGRhdGUgY3ljbGUgcGFuaWNrZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRvbyBtYW55IHVwZGF0ZXMgdHJ5IHRvIGhhcHBlbiBpbiBhIHNpbmdsZSBmcmFtZVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBmaW5pc2hGcmFtZShwYW5pYzogYm9vbGVhbik6IHZvaWQ7XHJcbn0iLCIvLyBAaWdub3JlUGFnZVxyXG5cclxuLyoqIFRoZSBvcHRpb25zIGZvciBpbml0aWFsaXppbmcgdGhlIEByZWZlcmVuY2VbR2FtZUxvb3BdICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVPcHRpb25zIHtcclxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQgKi9cclxuICAgIGNhbnZhc1NpemU6IHt4OiBudW1iZXIsIHk6IG51bWJlcn07XHJcblxyXG4gICAgLyogVGhlIGRlZmF1bHQgbGV2ZWwgb2Ygem9vbSAqL1xyXG4gICAgem9vbUxldmVsOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBjb2xvciB0byBjbGVhciB0aGUgY2FudmFzIHRvIGVhY2ggZnJhbWUgKi9cclxuICAgIGNsZWFyQ29sb3I6IHtyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyfVxyXG5cclxuICAgIC8qIEEgbGlzdCBvZiBpbnB1dCBiaW5kaW5ncyAqL1xyXG4gICAgaW5wdXRzOiBBcnJheTx7bmFtZTogc3RyaW5nLCBrZXlzOiBBcnJheTxzdHJpbmc+fT47XHJcblxyXG4gICAgLyogV2hldGhlciBvciBub3QgdGhlIGRlYnVnIHJlbmRlcmluZyBzaG91bGQgb2NjdXIgKi9cclxuICAgIHNob3dEZWJ1ZzogYm9vbGVhbjtcclxuXHJcbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0aGUgc3RhdHMgcmVuZGVyaW5nIHNob3VsZCBvY2N1ciAqL1xyXG4gICAgc2hvd1N0YXRzOiBib29sZWFuO1xyXG5cclxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRvIHVzZSB3ZWJHTCAqL1xyXG4gICAgdXNlV2ViR0w6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgdGhlIGRhdGEgaW4gdGhlIHJhdyBvcHRpb25zIG9iamVjdFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGdhbWUgb3B0aW9ucyBhcyBhIFJlY29yZFxyXG4gICAgICogQHJldHVybnMgQSB2ZXJzaW9uIG9mIHRoZSBvcHRpb25zIGNvbnZlcnRlZCB0byBhIEdhbWVPcHRpb25zIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcGFyc2Uob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IEdhbWVPcHRpb25zIHtcclxuICAgICAgICBsZXQgZ09wdCA9IG5ldyBHYW1lT3B0aW9ucygpO1xyXG5cclxuICAgICAgICBnT3B0LmNhbnZhc1NpemUgPSBvcHRpb25zLmNhbnZhc1NpemUgPyBvcHRpb25zLmNhbnZhc1NpemUgOiB7eDogODAwLCB5OiA2MDB9O1xyXG4gICAgICAgIGdPcHQuem9vbUxldmVsID0gb3B0aW9ucy56b29tTGV2ZWwgPyBvcHRpb25zLnpvb21MZXZlbCA6IDE7XHJcbiAgICAgICAgZ09wdC5jbGVhckNvbG9yID0gb3B0aW9ucy5jbGVhckNvbG9yID8gb3B0aW9ucy5jbGVhckNvbG9yIDoge3I6IDI1NSwgZzogMjU1LCBiOiAyNTV9O1xyXG4gICAgICAgIGdPcHQuaW5wdXRzID0gb3B0aW9ucy5pbnB1dHMgPyBvcHRpb25zLmlucHV0cyA6IFtdO1xyXG4gICAgICAgIGdPcHQuc2hvd0RlYnVnID0gISFvcHRpb25zLnNob3dEZWJ1ZztcclxuICAgICAgICBnT3B0LnNob3dTdGF0cyA9ICEhb3B0aW9ucy5zaG93U3RhdHM7XHJcbiAgICAgICAgZ09wdC51c2VXZWJHTCA9ICEhb3B0aW9ucy51c2VXZWJHTDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGdPcHQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4vR2FtZU5vZGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBSZWdpb24gZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1JlZ2lvblwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW4gdGhlIGdhbWUgd29ybGQgdGhhdCBjYW4gYmUgZHJhd24gdG8gdGhlIHNjcmVlblxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQ2FudmFzTm9kZSBleHRlbmRzIEdhbWVOb2RlIGltcGxlbWVudHMgUmVnaW9uIHtcclxuXHRwcml2YXRlIF9zaXplOiBWZWMyO1xyXG5cdHByaXZhdGUgX3NjYWxlOiBWZWMyO1xyXG5cdHByaXZhdGUgX2JvdW5kYXJ5OiBBQUJCO1xyXG5cdHByaXZhdGUgX2hhc0N1c3RvbVNoYWRlcjogYm9vbGVhbjtcclxuXHRwcml2YXRlIF9jdXN0b21TaGFkZXJLZXk6IHN0cmluZztcclxuXHRwcml2YXRlIF9hbHBoYTogbnVtYmVyO1xyXG5cclxuXHQvKiogQSBmbGFnIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgQ2FudmFzTm9kZSBpcyB2aXNpYmxlICovXHJcblx0dmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XHJcblx0XHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzLl9zaXplID0gbmV3IFZlYzIoMCwgMCk7XHJcblx0XHR0aGlzLl9zaXplLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2l6ZUNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLl9zY2FsZSA9IG5ldyBWZWMyKDEsIDEpO1xyXG5cdFx0dGhpcy5fc2NhbGUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zY2FsZUNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLl9ib3VuZGFyeSA9IG5ldyBBQUJCKCk7XHJcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XHJcblxyXG5cdFx0dGhpcy5faGFzQ3VzdG9tU2hhZGVyID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRnZXQgYWxwaGEoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9hbHBoYTtcclxuXHR9XHJcblxyXG5cdHNldCBhbHBoYShhOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuX2FscGhhID0gYTtcclxuXHR9XHJcblxyXG5cdGdldCBzaXplKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NpemU7XHJcblx0fVxyXG5cclxuXHRzZXQgc2l6ZShzaXplOiBWZWMyKXtcclxuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xyXG5cdFx0Ly8gRW50ZXIgYXMgYSBsYW1iZGEgdG8gYmluZCBcInRoaXNcIlxyXG5cdFx0dGhpcy5fc2l6ZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNpemVDaGFuZ2VkKCkpO1xyXG5cdFx0dGhpcy5zaXplQ2hhbmdlZCgpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHNjYWxlKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NjYWxlO1xyXG5cdH1cclxuXHJcblx0c2V0IHNjYWxlKHNjYWxlOiBWZWMyKXtcclxuXHRcdHRoaXMuX3NjYWxlID0gc2NhbGU7XHJcblx0XHQvLyBFbnRlciBhcyBhIGxhbWJkYSB0byBiaW5kIFwidGhpc1wiXHJcblx0XHR0aGlzLl9zY2FsZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNjYWxlQ2hhbmdlZCgpKTtcclxuXHRcdHRoaXMuc2NhbGVDaGFuZ2VkKCk7XHJcblx0fVxyXG5cclxuXHRzZXQgc2NhbGVYKHZhbHVlOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuc2NhbGUueCA9IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0c2V0IHNjYWxlWSh2YWx1ZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnNjYWxlLnkgPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdGdldCBoYXNDdXN0b21TaGFkZXIoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5faGFzQ3VzdG9tU2hhZGVyO1xyXG5cdH1cclxuXHJcblx0Z2V0IGN1c3RvbVNoYWRlcktleSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2N1c3RvbVNoYWRlcktleTtcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdHByb3RlY3RlZCBwb3NpdGlvbkNoYW5nZWQoKTogdm9pZCB7XHJcblx0XHRzdXBlci5wb3NpdGlvbkNoYW5nZWQoKTtcclxuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcclxuXHR9XHJcblxyXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHNpemUgdmVjdG9yIGlzIGNoYW5nZWQgb3IgcmVwbGFjZWQuICovXHJcblx0cHJvdGVjdGVkIHNpemVDaGFuZ2VkKCk6IHZvaWQge1xyXG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xyXG5cdH1cclxuXHJcblx0LyoqIENhbGxlZCBpZiB0aGUgc2NhbGUgdmVjdG9yIGlzIGNoYW5nZWQgb3IgcmVwbGFjZWQgKi9cclxuXHRwcm90ZWN0ZWQgc2NhbGVDaGFuZ2VkKCk6IHZvaWQge1xyXG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xyXG5cdH1cclxuXHJcblx0Ly8gQGRvY0lnbm9yZVxyXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHBvc2l0aW9uLCBzaXplLCBvciBzY2FsZSBvZiB0aGUgQ2FudmFzTm9kZSBpcyBjaGFuZ2VkLiBVcGRhdGVzIHRoZSBib3VuZGFyeS4gKi9cclxuXHRwcml2YXRlIHVwZGF0ZUJvdW5kYXJ5KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5fYm91bmRhcnkuY2VudGVyLnNldCh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XHJcblx0XHR0aGlzLl9ib3VuZGFyeS5oYWxmU2l6ZS5zZXQodGhpcy5zaXplLngqdGhpcy5zY2FsZS54LzIsIHRoaXMuc2l6ZS55KnRoaXMuc2NhbGUueS8yKTtcclxuXHR9XHJcblxyXG5cdGdldCBib3VuZGFyeSgpOiBBQUJCIHtcclxuXHRcdHJldHVybiB0aGlzLl9ib3VuZGFyeTtcclxuXHR9XHJcblxyXG5cdGdldCBzaXplV2l0aFpvb20oKTogVmVjMiB7XHJcblx0XHRsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYm91bmRhcnkuaGFsZlNpemUuY2xvbmUoKS5zY2FsZWQoem9vbSwgem9vbSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgY3VzdG9tIHNoYWRlciB0byB0aGlzIENhbnZhc05vZGVcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSByZWdpc3RyeSBrZXkgb2YgdGhlIFNoYWRlclR5cGVcclxuXHQgKi9cclxuXHR1c2VDdXN0b21TaGFkZXIoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdHRoaXMuX2hhc0N1c3RvbVNoYWRlciA9IHRydWU7XHJcblx0XHR0aGlzLl9jdXN0b21TaGFkZXJLZXkgPSBrZXk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50ICh4LCB5KSBpcyBpbnNpZGUgb2YgdGhpcyBjYW52YXMgb2JqZWN0XHJcblx0ICogQHBhcmFtIHggVGhlIHggcG9zaXRpb24gb2YgdGhlIHBvaW50XHJcblx0ICogQHBhcmFtIHkgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBvaW50XHJcblx0ICogQHJldHVybnMgQSBmbGFnIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgY29udGFpbnMgdGhlIHBvaW50LlxyXG5cdCAqL1xyXG5cdGNvbnRhaW5zKHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRhcnkuY29udGFpbnNQb2ludChuZXcgVmVjMih4LCB5KSk7XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcclxuXHRcdERlYnVnLmRyYXdCb3godGhpcy5yZWxhdGl2ZVBvc2l0aW9uLCB0aGlzLnNpemVXaXRoWm9vbSwgZmFsc2UsIENvbG9yLkJMVUUpO1xyXG5cdFx0c3VwZXIuZGVidWdSZW5kZXIoKTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllclwiO1xyXG5pbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XHJcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcclxuaW1wb3J0IFBvc2l0aW9uZWQgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1Bvc2l0aW9uZWRcIjtcclxuaW1wb3J0IHsgaXNSZWdpb24gfSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUmVnaW9uXCI7XHJcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xyXG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5pbXBvcnQgRGVidWdSZW5kZXJhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9EZWJ1Z1JlbmRlcmFibGVcIjtcclxuaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGVcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4uL1BhdGhmaW5kaW5nL05hdmlnYXRpb25QYXRoXCI7XHJcbmltcG9ydCBUd2VlbkNvbnRyb2xsZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuQ29udHJvbGxlclwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9DaXJjbGVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGluIHRoZSBnYW1lIHdvcmxkLlxyXG4gKiBUbyBjb25zdHJ1Y3QgR2FtZU5vZGVzLCBzZWUgdGhlIEByZWZlcmVuY2VbU2NlbmVdIGRvY3VtZW50YXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTm9kZSBpbXBsZW1lbnRzIFBvc2l0aW9uZWQsIFVuaXF1ZSwgVXBkYXRlYWJsZSwgUGh5c2ljYWwsIEFjdG9yLCBEZWJ1Z1JlbmRlcmFibGUge1xyXG5cdC8qLS0tLS0tLS0tLSBQT1NJVElPTkVEIC0tLS0tLS0tLS0qL1xyXG5cdHByaXZhdGUgX3Bvc2l0aW9uOiBWZWMyO1xyXG5cclxuXHQvKi0tLS0tLS0tLS0gVU5JUVVFIC0tLS0tLS0tLS0qL1xyXG5cdHByaXZhdGUgX2lkOiBudW1iZXI7XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBQSFlTSUNBTCAtLS0tLS0tLS0tKi9cclxuXHRoYXNQaHlzaWNzOiBib29sZWFuID0gZmFsc2U7XHJcblx0bW92aW5nOiBib29sZWFuID0gZmFsc2U7XHJcblx0ZnJvemVuOiBib29sZWFuID0gZmFsc2U7XHJcblx0b25Hcm91bmQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRvbldhbGw6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRvbkNlaWxpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRhY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRjb2xsaXNpb25TaGFwZTogU2hhcGU7XHJcblx0Y29sbGlkZXJPZmZzZXQ6IFZlYzI7XHJcblx0aXNTdGF0aWM6IGJvb2xlYW47XHJcblx0aXNDb2xsaWRhYmxlOiBib29sZWFuO1xyXG5cdGlzVHJpZ2dlcjogYm9vbGVhbjtcclxuXHR0cmlnZ2VyTWFzazogbnVtYmVyO1xyXG5cdHRyaWdnZXJFbnRlcnM6IEFycmF5PHN0cmluZz47XHJcblx0dHJpZ2dlckV4aXRzOiBBcnJheTxzdHJpbmc+O1xyXG5cdF92ZWxvY2l0eTogVmVjMjtcclxuXHRzd2VwdFJlY3Q6IEFBQkI7XHJcblx0Y29sbGlkZWRXaXRoVGlsZW1hcDogYm9vbGVhbjtcclxuXHRncm91cDogbnVtYmVyO1xyXG5cdGlzUGxheWVyOiBib29sZWFuO1xyXG5cdGlzQ29sbGlkaW5nOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBBQ1RPUiAtLS0tLS0tLS0tKi9cclxuXHRfYWk6IEFJO1xyXG5cdGFpQWN0aXZlOiBib29sZWFuO1xyXG5cdHBhdGg6IE5hdmlnYXRpb25QYXRoO1xyXG5cdHBhdGhmaW5kaW5nOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBHRU5FUkFMIC0tLS0tLS0tLS0qL1xyXG5cdC8qKiBBbiBldmVudCByZWNlaXZlci4gKi9cclxuXHRwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cdC8qKiBBbiBldmVudCBlbWl0dGVyLiAqL1xyXG5cdHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgc2NlbmUgdGhpcyBHYW1lTm9kZSBpcyBhIHBhcnQgb2YuICovXHJcblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuXHQvKiogVGhlIHZpc3VhbCBsYXllciB0aGlzIEdhbWVOb2RlIHJlc2lkZXMgaW4uICovXHJcblx0cHJvdGVjdGVkIGxheWVyOiBMYXllcjtcclxuXHQvKiogQSB1dGlsaXR5IHRoYXQgYWxsb3dzIHRoZSB1c2Ugb2YgdHdlZW5zIG9uIHRoaXMgR2FtZU5vZGUgKi9cclxuXHR0d2VlbnM6IFR3ZWVuQ29udHJvbGxlcjtcclxuXHQvKiogQSB0d2VlbmFibGUgcHJvcGVydHkgZm9yIHJvdGF0aW9uLiBEb2VzIG5vdCBhZmZlY3QgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGlzIEdhbWVOb2RlIC0gT25seSByZW5kZXJpbmcuICovXHJcblx0cm90YXRpb246IG51bWJlcjtcclxuXHRhdHRhY2tfZGlyZWN0aW9uOiBudW1iZXI7IFxyXG5cdC8qKiBUaGUgb3BhY2l0eSB2YWx1ZSBvZiB0aGlzIEdhbWVOb2RlICovXHJcblx0YWJzdHJhY3Qgc2V0IGFscGhhKGE6IG51bWJlcik7XHJcblxyXG5cdGFic3RyYWN0IGdldCBhbHBoYSgpOiBudW1iZXI7XHJcblxyXG5cdC8vIENvbnN0cnVjdG9yIGRvY3MgYXJlIGlnbm9yZWQsIGFzIHRoZSB1c2VyIHNob3VsZCBOT1QgY3JlYXRlIG5ldyBHYW1lTm9kZXMgd2l0aCBhIHJhdyBjb25zdHJ1Y3RvclxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xyXG5cdFx0dGhpcy5fcG9zaXRpb24uc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cdFx0dGhpcy50d2VlbnMgPSBuZXcgVHdlZW5Db250cm9sbGVyKHRoaXMpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XHJcblx0fVxyXG5cclxuXHRkZXN0cm95KCl7XHJcblx0XHR0aGlzLnR3ZWVucy5kZXN0cm95KCk7XHJcblx0XHR0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcclxuXHJcblx0XHRpZih0aGlzLmhhc1BoeXNpY3Mpe1xyXG5cdFx0XHR0aGlzLnJlbW92ZVBoeXNpY3MoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLl9haSl7XHJcblx0XHRcdHRoaXMuX2FpLmRlc3Ryb3koKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2FpO1xyXG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlbW92ZUFjdG9yKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTm9kZSh0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBQT1NJVElPTkVEIC0tLS0tLS0tLS0qL1xyXG5cdGdldCBwb3NpdGlvbigpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3NpdGlvbjtcclxuXHR9XHJcblxyXG5cdHNldCBwb3NpdGlvbihwb3M6IFZlYzIpIHtcclxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gcG9zO1xyXG5cdFx0dGhpcy5fcG9zaXRpb24uc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBhIHBvaW50IHRvIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB6b29tIGFuZCBvcmlnaW4gb2YgdGhpcyBub2RlXHJcblx0ICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjb252ZXJcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcclxuXHQgKi9cclxuXHRpblJlbGF0aXZlQ29vcmRpbmF0ZXMocG9pbnQ6IFZlYzIpOiBWZWMyIHtcclxuXHRcdGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aGlzKTtcclxuXHRcdGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuXHRcdHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihvcmlnaW4pLnNjYWxlKHpvb20pO1xyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cclxuXHRnZXQgaWQoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9pZDtcclxuXHR9XHJcblxyXG5cdHNldCBpZChpZDogbnVtYmVyKSB7XHJcblx0XHQvLyBpZCBjYW4gb25seSBiZSBzZXQgb25jZVxyXG5cdFx0aWYodGhpcy5faWQgPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdHRoaXMuX2lkID0gaWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBcIkF0dGVtcHRlZCB0byBhc3NpZ24gaWQgdG8gb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgaWQuXCJcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBQSFlTSUNBTCAtLS0tLS0tLS0tKi9cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgdmVsb2NpdHkgd2l0aCB3aGljaCB0byBtb3ZlIHRoZSBvYmplY3QuXHJcbiAgICAgKi9cclxuXHRtb3ZlKHZlbG9jaXR5OiBWZWMyKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLmZyb3plbikgcmV0dXJuO1xyXG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcclxuXHR9O1xyXG5cclxuXHRtb3ZlT25QYXRoKHNwZWVkOiBudW1iZXIsIHBhdGg6IE5hdmlnYXRpb25QYXRoKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLmZyb3plbikgcmV0dXJuO1xyXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHRcdGxldCBkaXIgPSBwYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcyk7XHJcblx0XHR0aGlzLm1vdmluZyA9IHRydWU7XHJcblx0XHR0aGlzLnBhdGhmaW5kaW5nID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gZGlyLnNjYWxlKHNwZWVkKTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdGhlIG9iamVjdCB3aWxsIG1vdmUuXHJcbiAgICAgKi9cclxuXHRmaW5pc2hNb3ZlKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMucG9zaXRpb24uYWRkKHRoaXMuX3ZlbG9jaXR5KTtcclxuXHRcdGlmKHRoaXMucGF0aGZpbmRpbmcpe1xyXG5cdFx0XHR0aGlzLnBhdGguaGFuZGxlUGF0aFByb2dyZXNzKHRoaXMpO1xyXG5cdFx0XHR0aGlzLnBhdGggPSBudWxsO1xyXG5cdFx0XHR0aGlzLnBhdGhmaW5kaW5nID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuXHQgKiBAcGFyYW0gY29sbGlzaW9uU2hhcGUgVGhlIGNvbGxpZGVyIGZvciB0aGlzIG9iamVjdC4gSWYgdGhpcyBoYXMgYSByZWdpb24gKGltcGxlbWVudHMgUmVnaW9uKSxcclxuXHQgKiBpdCB3aWxsIGJlIHVzZWQgd2hlbiBubyBjb2xsaXNpb24gc2hhcGUgaXMgc3BlY2lmaWVkIChvciBpZiBjb2xsaXNpb24gc2hhcGUgaXMgbnVsbCkuXHJcblx0ICogQHBhcmFtIGlzQ29sbGlkYWJsZSBXaGV0aGVyIHRoaXMgaXMgY29sbGlkYWJsZSBvciBub3QuIFRydWUgYnkgZGVmYXVsdC5cclxuXHQgKiBAcGFyYW0gaXNTdGF0aWMgV2hldGhlciB0aGlzIGlzIHN0YXRpYyBvciBub3QuIEZhbHNlIGJ5IGRlZmF1bHRcclxuXHQgKi9cclxuXHRhZGRQaHlzaWNzKGNvbGxpc2lvblNoYXBlPzogU2hhcGUsIGNvbGxpZGVyT2Zmc2V0PzogVmVjMiwgaXNDb2xsaWRhYmxlOiBib29sZWFuID0gdHJ1ZSwgaXNTdGF0aWM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgcGh5c2ljcyB2YXJpYWJsZXNcclxuXHRcdHRoaXMuaGFzUGh5c2ljcyA9IHRydWU7XHJcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbldhbGwgPSBmYWxzZTtcclxuXHRcdHRoaXMub25DZWlsaW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0XHR0aGlzLmlzQ29sbGlkYWJsZSA9IGlzQ29sbGlkYWJsZTtcclxuXHRcdHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcclxuXHRcdHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XHJcblx0XHR0aGlzLnRyaWdnZXJNYXNrID0gMDtcclxuXHRcdHRoaXMudHJpZ2dlckVudGVycyA9IG5ldyBBcnJheSgzMik7XHJcblx0XHR0aGlzLnRyaWdnZXJFeGl0cyA9IG5ldyBBcnJheSgzMik7XHJcblx0XHR0aGlzLl92ZWxvY2l0eSA9IFZlYzIuWkVSTztcclxuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbmV3IEFBQkIoKTtcclxuXHRcdHRoaXMuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5ncm91cCA9IC0xO1x0XHRcdFx0XHQvLyBUaGUgZGVmYXVsdCBncm91cCwgY29sbGlkZXMgd2l0aCBldmVyeXRoaW5nXHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBjb2xsaXNpb24gc2hhcGUgaWYgcHJvdmlkZWQsIG9yIHNpbXBseSB1c2UgdGhlIHRoZSByZWdpb24gaWYgdGhlcmUgaXMgb25lLlxyXG5cdFx0aWYoY29sbGlzaW9uU2hhcGUpe1xyXG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlzaW9uU2hhcGU7XHJcblx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbjtcclxuXHRcdH0gZWxzZSBpZiAoaXNSZWdpb24odGhpcykpIHtcclxuXHRcdFx0Ly8gSWYgdGhlIGdhbWVub2RlIGhhcyBhIHJlZ2lvbiBhbmQgbm8gb3RoZXIgaXMgc3BlY2lmaWVkLCB1c2UgdGhhdFxyXG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gKDxhbnk+dGhpcykuYm91bmRhcnkuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRocm93IFwiTm8gY29sbGlzaW9uIHNoYXBlIHNwZWNpZmllZCBmb3IgcGh5c2ljcyBvYmplY3QuXCJcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB3ZSB3ZXJlIHByb3ZpZGVkIHdpdGggYSBjb2xsaWRlciBvZmZzZXQsIHNldCBpdC4gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIG9mZnNldCwgc28gdXNlIHRoZSB6ZXJvIHZlY3RvclxyXG5cdFx0aWYoY29sbGlkZXJPZmZzZXQpe1xyXG5cdFx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gY29sbGlkZXJPZmZzZXQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gVmVjMi5aRVJPO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN3ZXB0IHJlY3RcclxuXHRcdHRoaXMuc3dlcHRSZWN0ID0gdGhpcy5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHJcblx0XHQvLyBSZWdpc3RlciB0aGUgb2JqZWN0IHdpdGggcGh5c2ljc1xyXG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLnJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlbW92ZXMgdGhpcyBvYmplY3QgZnJvbSB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cclxuICAgIHJlbW92ZVBoeXNpY3MoKTogdm9pZCB7XHJcblx0XHQvLyBSZW1vdmUgdGhpcyBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJcclxuXHRcdHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5kZXJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xyXG5cclxuXHRcdC8vIE51bGxpZnkgYWxsIHBoeXNpY3MgZmllbGRzXHJcblx0XHR0aGlzLmhhc1BoeXNpY3MgPSBmYWxzZTtcclxuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLm9uR3JvdW5kID0gZmFsc2U7XHJcblx0XHR0aGlzLm9uV2FsbCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbkNlaWxpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHR0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcclxuXHRcdHRoaXMudHJpZ2dlck1hc2sgPSAwO1xyXG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzID0gbnVsbDtcclxuXHRcdHRoaXMudHJpZ2dlckV4aXRzID0gbnVsbDtcclxuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gVmVjMi5aRVJPO1xyXG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBudWxsO1xyXG5cdFx0dGhpcy5jb2xsaWRlZFdpdGhUaWxlbWFwID0gZmFsc2U7XHJcblx0XHR0aGlzLmdyb3VwID0gLTE7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gbnVsbDtcclxuXHRcdHRoaXMuY29sbGlkZXJPZmZzZXQgPSBWZWMyLlpFUk87XHJcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKiogRGlzYWJsZXMgcGh5c2ljcyBtb3ZlbWVudCBmb3IgdGhpcyBub2RlICovXHJcblx0ZnJlZXplKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5mcm96ZW4gPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlZW5hYmxlcyBwaHlzaWNzIG1vdmVtZW50IGZvciB0aGlzIG5vZGUgKi9cclxuXHR1bmZyZWV6ZSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuZnJvemVuID0gZmFsc2U7XHJcblx0fVxyXG5cclxuICAgIC8qKiBQcmV2ZW50cyB0aGlzIG9iamVjdCBmcm9tIHBhcnRpY2lwYXRpbmcgaW4gYWxsIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBJdCBjYW4gc3RpbGwgbW92ZS4gKi9cclxuICAgIGRpc2FibGVQaHlzaWNzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHR9XHJcblxyXG4gICAgLyoqIEVuYWJsZXMgdGhpcyBvYmplY3QgdG8gcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucyBhbmQgdHJpZ2dlcnMuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgZGlzYWJsZVBoeXNpY3Mgd2FzIGNhbGxlZCAqL1xyXG4gICAgZW5hYmxlUGh5c2ljcygpOiB2b2lkIHtcclxuXHRcdHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGNvbGxpZGVyIGZvciB0aGlzIEdhbWVOb2RlXHJcblx0ICogQHBhcmFtIGNvbGxpZGVyIFRoZSBuZXcgY29sbGlkZXIgdG8gdXNlXHJcblx0ICovXHJcblx0c2V0Q29sbGlzaW9uU2hhcGUoY29sbGlkZXI6IFNoYXBlKTogdm9pZCB7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlkZXI7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlci5jb3B5KHRoaXMucG9zaXRpb24pO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0LyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgb2JqZWN0IHRvIGJlIGEgdHJpZ2dlciBmb3IgYSBzcGVjaWZpYyBncm91cFxyXG4gICAgICogQHBhcmFtIGdyb3VwIFRoZSBuYW1lIG9mIHRoZSBncm91cCB0aGF0IGFjdGl2YXRlcyB0aGUgdHJpZ2dlclxyXG4gICAgICogQHBhcmFtIG9uRW50ZXIgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIHRyaWdnZXIgaXMgYWN0aXZhdGVkXHJcbiAgICAgKiBAcGFyYW0gb25FeGl0IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIHdoZW4gdGhpcyB0cmlnZ2VyIHN0b3BzIGJlaW5nIGFjdGl2YXRlZFxyXG4gICAgICovXHJcbiAgICBzZXRUcmlnZ2VyKGdyb3VwOiBzdHJpbmcsIG9uRW50ZXI6IHN0cmluZywgb25FeGl0OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdC8vIE1ha2UgdGhpcyBvYmplY3QgYSB0cmlnZ2VyXHJcblx0XHR0aGlzLmlzVHJpZ2dlciA9IHRydWU7XHJcblxyXG5cdFx0Ly8gR2V0IHRoZSBudW1iZXIgb2YgdGhlIHBoeXNpY3MgbGF5ZXJcclxuXHRcdGxldCBsYXllck51bWJlciA9IHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5nZXRHcm91cE51bWJlcihncm91cCk7XHJcblxyXG5cdFx0aWYobGF5ZXJOdW1iZXIgPT09IDApe1xyXG5cdFx0XHRjb25zb2xlLndhcm4oYFRyaWdnZXIgZm9yIEdhbWVOb2RlICR7dGhpcy5pZH0gbm90IHNldCAtIGdyb3VwIFwiJHtncm91cH1cIiB3YXMgbm90IHJlY29nbml6ZWQgYnkgdGhlIHBoeXNpY3MgbWFuYWdlci5gKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCB0aGlzIHRvIHRoZSB0cmlnZ2VyIG1hc2tcclxuXHRcdHRoaXMudHJpZ2dlck1hc2sgfD0gbGF5ZXJOdW1iZXI7XHJcblxyXG5cdFx0Ly8gTGF5ZXIgbnVtYmVycyBhcmUgYml0cywgc28gZ2V0IHdoaWNoIGJpdCBpdCBpc1xyXG5cdFx0bGV0IGluZGV4ID0gTWF0aC5sb2cyKGxheWVyTnVtYmVyKTtcclxuXHJcblx0XHQvLyBTZXQgdGhlIGV2ZW50IG5hbWVzXHJcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnNbaW5kZXhdID0gb25FbnRlcjtcclxuXHRcdHRoaXMudHJpZ2dlckV4aXRzW2luZGV4XSA9IG9uRXhpdDtcclxuXHR9O1xyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIHBoeXNpY3MgZ3JvdXAgdGhpcyBub2RlIHNob3VsZCBiZWxvbmcgdG9cclxuXHQgKi9cclxuXHRzZXRHcm91cChncm91cDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuc2V0R3JvdXAodGhpcywgZ3JvdXApO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVuZWRcclxuXHRnZXRMYXN0VmVsb2NpdHkoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdmVsb2NpdHk7XHJcblx0fVxyXG5cclxuXHQvKi0tLS0tLS0tLS0gQUNUT1IgLS0tLS0tLS0tLSovXHJcblx0Z2V0IGFpKCk6IEFJIHtcclxuXHRcdHJldHVybiB0aGlzLl9haTtcclxuXHR9XHJcblxyXG5cdHNldCBhaShhaTogQUkpIHtcclxuXHRcdGlmKCF0aGlzLl9haSl7XHJcblx0XHRcdC8vIElmIHdlIGhhdmVuJ3QgYmVlbiBwcmV2aW91c2x5IGhhZCBhbiBhaSwgcmVnaXN0ZXIgdXMgd2l0aCB0aGUgYWkgbWFuYWdlclxyXG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlZ2lzdGVyQWN0b3IodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWkgPSBhaTtcclxuXHRcdHRoaXMuYWlBY3RpdmUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0YWRkQUk8VCBleHRlbmRzIEFJPihhaTogc3RyaW5nIHwgKG5ldyAoKSA9PiBUKSwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuXHRcdGlmKCF0aGlzLl9haSl7XHJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVnaXN0ZXJBY3Rvcih0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0eXBlb2YgYWkgPT09IFwic3RyaW5nXCIpe1xyXG5cdFx0XHR0aGlzLl9haSA9IHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkuZ2VuZXJhdGVBSShhaSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9haSA9IG5ldyBhaSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FpLmluaXRpYWxpemVBSSh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLmFpQWN0aXZlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdHNldEFJQWN0aXZlKGFjdGl2ZTogYm9vbGVhbiwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG5cdFx0dGhpcy5haUFjdGl2ZSA9IGFjdGl2ZTtcclxuXHRcdGlmKHRoaXMuYWlBY3RpdmUpe1xyXG5cdFx0XHR0aGlzLmFpLmFjdGl2YXRlKG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tIFRXRUVOQUJMRSBQUk9QRVJUSUVTIC0tLS0tLS0tLS0qL1xyXG5cdHNldCBwb3NpdGlvblgodmFsdWU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5wb3NpdGlvbi54ID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRzZXQgcG9zaXRpb25ZKHZhbHVlOiBudW1iZXIpIHtcclxuXHRcdHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0YWJzdHJhY3Qgc2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKTtcclxuXHJcblx0YWJzdHJhY3Qgc2V0IHNjYWxlWSh2YWx1ZTogbnVtYmVyKTtcclxuXHJcblx0LyotLS0tLS0tLS0tIEdBTUUgTk9ERSAtLS0tLS0tLS0tKi9cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBzY2VuZSBmb3IgdGhpcyBvYmplY3QuXHJcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvLlxyXG5cdCAqL1xyXG5cdHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgc2NlbmUgdGhpcyBvYmplY3QgaXMgaW4uIFxyXG5cdCAqIEByZXR1cm5zIFRoZSBzY2VuZSB0aGlzIG9iamVjdCBiZWxvbmdzIHRvXHJcblx0Ki9cclxuXHRnZXRTY2VuZSgpOiBTY2VuZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zY2VuZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGxheWVyIG9mIHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIgdGhpcyBvYmplY3Qgd2lsbCBiZSBvbi5cclxuXHQgKi9cclxuXHRzZXRMYXllcihsYXllcjogTGF5ZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMubGF5ZXIgPSBsYXllcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxyXG5cdCAqIEByZXR1cm5zIFRoaXMgbGF5ZXIgdGhpcyBvYmplY3QgaXMgb24uXHJcblx0Ki9cclxuXHRnZXRMYXllcigpOiBMYXllciB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXllcjtcclxuXHR9XHJcblxyXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHBvc2l0aW9uIHZlY3RvciBpcyBtb2RpZmllZCBvciByZXBsYWNlZCAqL1xyXG5cdHByb3RlY3RlZCBwb3NpdGlvbkNoYW5nZWQoKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcclxuXHRcdFx0aWYodGhpcy5jb2xsaWRlck9mZnNldCl7XHJcblx0XHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIgPSB0aGlzLnBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMuY29sbGlkZXJPZmZzZXQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBHYW1lTm9kZVxyXG5cdCAqIEBwYXJhbSBkZWx0YVQgVGhlIHRpbWVzdGVwIG9mIHRoZSB1cGRhdGUuXHJcblx0ICovXHJcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBEZWZlciBldmVudCBoYW5kbGluZyB0byBBSS5cclxuXHRcdHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG5cdFx0XHR0aGlzLl9haS5oYW5kbGVFdmVudCh0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGRlYnVnUmVuZGVyKCk6IHZvaWQge1xyXG5cdFx0Ly8gRHJhdyB0aGUgcG9zaXRpb24gb2YgdGhpcyBHYW1lTm9kZVxyXG5cdFx0RGVidWcuZHJhd1BvaW50KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgQ29sb3IuQkxVRSk7XHJcblxyXG5cdFx0Ly8gSWYgdmVsb2NpdHkgaXMgbm90IHplcm8sIGRyYXcgYSB2ZWN0b3IgZm9yIGl0XHJcblx0XHRpZih0aGlzLl92ZWxvY2l0eSAmJiAhdGhpcy5fdmVsb2NpdHkuaXNaZXJvKCkpe1xyXG5cdFx0XHREZWJ1Zy5kcmF3UmF5KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgdGhpcy5fdmVsb2NpdHkuY2xvbmUoKS5zY2FsZVRvKDIwKS5hZGQodGhpcy5yZWxhdGl2ZVBvc2l0aW9uKSwgQ29sb3IuQkxVRSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgdGhpcyBoYXMgYSBjb2xsaWRlciwgZHJhdyBpdFxyXG5cdFx0aWYodGhpcy5jb2xsaXNpb25TaGFwZSl7XHJcblx0XHRcdGxldCBjb2xvciA9IHRoaXMuaXNDb2xsaWRpbmcgPyBDb2xvci5SRUQgOiBDb2xvci5HUkVFTjtcclxuXHJcblx0XHRcdGlmKHRoaXMuaXNUcmlnZ2VyKXtcclxuXHRcdFx0XHRjb2xvciA9IENvbG9yLk1BR0VOVEE7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGNvbG9yLmEgPSAwLjI7XHJcblxyXG5cdFx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlIGluc3RhbmNlb2YgQUFCQil7XHJcblx0XHRcdFx0RGVidWcuZHJhd0JveCh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyh0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciksIHRoaXMuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUuc2NhbGVkKHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCkpLCB0cnVlLCBjb2xvcik7XHJcblx0XHRcdH0gZWxzZSBpZih0aGlzLmNvbGxpc2lvblNoYXBlIGluc3RhbmNlb2YgQ2lyY2xlKXtcclxuXHRcdFx0XHREZWJ1Zy5kcmF3Q2lyY2xlKHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyKSwgdGhpcy5jb2xsaXNpb25TaGFwZS5odyp0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpLCB0cnVlLCBjb2xvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIFR3ZWVuYWJsZVByb3BlcnRpZXN7XHJcblx0cG9zWCA9IFwicG9zaXRpb25YXCIsXHJcblx0cG9zWSA9IFwicG9zaXRpb25ZXCIsXHJcblx0c2NhbGVYID0gXCJzY2FsZVhcIixcclxuXHRzY2FsZVkgPSBcInNjYWxlWVwiLFxyXG5cdHJvdGF0aW9uID0gXCJyb3RhdGlvblwiLFxyXG5cdGFscGhhID0gXCJhbHBoYVwiXHJcbn0iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBnYW1lIG9iamVjdCB0aGF0IGRvZXNuJ3QgcmVseSBvbiBhbnkgcmVzb3VyY2VzIHRvIHJlbmRlciAtIGl0IGlzIGRyYXduIHRvIHRoZSBzY3JlZW4gYnkgdGhlIGNhbnZhc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR3JhcGhpYyBleHRlbmRzIENhbnZhc05vZGUge1xyXG4gICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgR3JhcGhpYyAqL1xyXG4gICAgY29sb3I6IENvbG9yO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuUkVEO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBhbHBoYSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29sb3IuYTtcclxuXHR9XHJcblxyXG5cdHNldCBhbHBoYShhOiBudW1iZXIpIHtcclxuXHRcdHRoaXMuY29sb3IuYSA9IGE7XHJcblx0fVxyXG5cclxuICAgIC8vIEBkZXByZWNhdGVkXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoZSBHcmFwaGljLiBERVBSRUNBVEVEXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgVGhlIG5ldyBjb2xvciBvZiB0aGUgR3JhcGhpYy5cclxuICAgICAqL1xyXG4gICAgc2V0Q29sb3IoY29sb3I6IENvbG9yKXtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZW51bSBHcmFwaGljVHlwZSB7XHJcblx0UE9JTlQgPSBcIlBPSU5UXCIsXHJcblx0UkVDVCA9IFwiUkVDVFwiLFxyXG5cdExJTkUgPSBcIkxJTkVcIixcclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZSBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgcHJvdGVjdGVkIF9lbmQ6IFZlYzI7XHJcbiAgICB0aGlja25lc3M6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydDogVmVjMiwgZW5kOiBWZWMyKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IDI7XHJcblxyXG4gICAgICAgIC8vIERvZXMgdGhpcyByZWFsbHkgaGF2ZSBhIG1lYW5pbmcgZm9yIGxpbmVzP1xyXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoNSwgNSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHN0YXJ0KHBvczogVmVjMil7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvcztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc3RhcnQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGVuZChwb3M6IFZlYzIpe1xyXG4gICAgICAgIHRoaXMuX2VuZCA9IHBvcztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgZW5kKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbmQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKiBBIGJhc2ljIHBvaW50IHRvIGJlIGRyYXduIG9uIHRoZSBzY3JlZW4uICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50IGV4dGVuZHMgR3JhcGhpYyB7XHJcblxyXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuc2l6ZS5zZXQoNSwgNSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vR3JhcGhpY1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xyXG5cclxuLyoqIEEgYmFzaWMgcmVjdGFuZ2xlIHRvIGJlIGRyYXduIG9uIHRoZSBzY3JlZW4uICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3QgZXh0ZW5kcyBHcmFwaGljIHtcclxuXHJcbiAgICAvKiogVGhlIGJvcmRlciBjb2xvciBvZiB0aGUgUmVjdCAqL1xyXG4gICAgYm9yZGVyQ29sb3I6IENvbG9yO1xyXG5cclxuICAgIC8qKiBUaGUgd2lkdGggb2YgdGhlIGJvcmRlciAqL1xyXG4gICAgYm9yZGVyV2lkdGg6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgc2l6ZTogVmVjMil7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBib3JkZXIgY29sb3Igb2YgdGhpcyByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgYm9yZGVyIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHNldEJvcmRlckNvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBjb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgZ2V0Qm9yZGVyQ29sb3IoKTogQ29sb3Ige1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvcmRlckNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIHdpZHRoIG9mIHRoaXMgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIHNldEJvcmRlcldpZHRoKHdpZHRoOiBudW1iZXIpe1xyXG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSB3aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRCb3JkZXJXaWR0aCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvcmRlcldpZHRoO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi9TcHJpdGVcIjtcclxuaW1wb3J0IEFuaW1hdGlvbk1hbmFnZXIgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvbk1hbmFnZXJcIjtcclxuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvU3ByaXRlc2hlZXRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG4vKiogQW4gc3ByaXRlIHdpdGggc3BlY2lmaWVkIGFuaW1hdGlvbiBmcmFtZXMuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlIHtcclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhpcyBzcHJpdGUgc2hlZXQgKi9cclxuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XHJcblxyXG4gICAgZ2V0IGNvbHMoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1Db2xzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhpcyBzcHJpdGUgc2hlZXQgKi9cclxuICAgIHByb3RlY3RlZCBudW1Sb3dzOiBudW1iZXI7XHJcblxyXG4gICAgZ2V0IHJvd3MoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1Sb3dzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgYW5pbWF0aW9uTWFuYWdlciBmb3IgdGhpcyBzcHJpdGUgKi9cclxuICAgIGFuaW1hdGlvbjogQW5pbWF0aW9uTWFuYWdlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGVzaGVldDogU3ByaXRlc2hlZXQpe1xyXG4gICAgICAgIHN1cGVyKHNwcml0ZXNoZWV0Lm5hbWUpO1xyXG4gICAgICAgIHRoaXMubnVtQ29scyA9IHNwcml0ZXNoZWV0LmNvbHVtbnM7XHJcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gc3ByaXRlc2hlZXQucm93cztcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSBzcHJpdGUgdG8gdGhlIHNwcml0ZSBzaXplIHNwZWNpZmllZCBieSB0aGUgc3ByaXRlc2hlZXRcclxuICAgICAgICB0aGlzLnNpemUuc2V0KHNwcml0ZXNoZWV0LnNwcml0ZVdpZHRoLCBzcHJpdGVzaGVldC5zcHJpdGVIZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb25NYW5hZ2VyKHRoaXMpO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIGFuaW1hdGlvbnMgdG8gdGhlIGFuaW1hdGVkIHNwcml0ZVxyXG4gICAgICAgIGZvcihsZXQgYW5pbWF0aW9uIG9mIHNwcml0ZXNoZWV0LmFuaW1hdGlvbnMpe1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoYW5pbWF0aW9uLm5hbWUsIGFuaW1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaW1hZ2Ugb2Zmc2V0IGZvciB0aGUgY3VycmVudCBpbmRleCBvZiBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggd2UncmUgYXQgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIGltYWdlIG9mZnNldFxyXG4gICAgICovXHJcbiAgICBnZXRBbmltYXRpb25PZmZzZXQoaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMigoaW5kZXggJSB0aGlzLm51bUNvbHMpICogdGhpcy5zaXplLngsIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpICogdGhpcy5zaXplLnkpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBzcHJpdGUgLSBhbiBpbi1nYW1lIGltYWdlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGUgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuICAgIC8qKiBUaGUgaWQgb2YgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlTWFuYWdlciAqL1xyXG4gICAgaW1hZ2VJZDogc3RyaW5nO1xyXG4gICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBpbiBhbiBhdGxhcyBpbWFnZSAqL1xyXG4gICAgaW1hZ2VPZmZzZXQ6IFZlYzI7XHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHgtYXhpcyBzaG91bGQgYmUgaW52ZXJ0ZWQgb24gcmVuZGVyICovXHJcbiAgICBpbnZlcnRYOiBib29sZWFuO1xyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB5LWF4aXMgc2hvdWxkIGJlIGludmVydGVkIG9uIHJlbmRlciAqL1xyXG4gICAgaW52ZXJ0WTogYm9vbGVhbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZUlkOiBzdHJpbmcpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbWFnZUlkID0gaW1hZ2VJZDtcclxuICAgICAgICBsZXQgaW1hZ2UgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRJbWFnZSh0aGlzLmltYWdlSWQpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ldyBWZWMyKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5pbnZlcnRYID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnZlcnRZID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvZmZzZXQgb2YgdGhlIHNwcml0ZSBmcm9tICgwLCAwKSBpbiB0aGUgaW1hZ2UncyBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgZnJvbSAoMCwgMCkgaW4gaW1hZ2UgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgc2V0SW1hZ2VPZmZzZXQob2Zmc2V0OiBWZWMyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5pbWFnZU9mZnNldCA9IG9mZnNldDtcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgVGlsZXNldCBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVzZXRcIjtcclxuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiXHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IFBoeXNpY3NNYW5hZ2VyIGZyb20gXCIuLi9QaHlzaWNzL1BoeXNpY3NNYW5hZ2VyXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgdGlsZW1hcCAtIHRoaXMgY2FuIGNvbnNpc3Qgb2YgYSBjb21iaW5hdGlvbiBvZiB0aWxlc2V0cyBpbiBvbmUgbGF5ZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFRpbGVtYXAgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgdGhhdCB0aGlzIHRpbGVtYXAgdXNlcyAqL1xyXG4gICAgcHJvdGVjdGVkIHRpbGVzZXRzOiBBcnJheTxUaWxlc2V0PjtcclxuXHJcbiAgICAvKiogVGhlIHNpemUgb2YgYSB0aWxlIGluIHRoaXMgdGlsZW1hcCAqL1xyXG4gICAgcHJvdGVjdGVkIHRpbGVTaXplOiBWZWMyO1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aWxlIGRhdGEgKi9cclxuICAgIHByb3RlY3RlZCBkYXRhOiBBcnJheTxudW1iZXI+O1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aWxlIGNvbGxpc2lvbiBkYXRhICovXHJcbiAgICBwcm90ZWN0ZWQgY29sbGlzaW9uTWFwOiBBcnJheTxib29sZWFuPjtcclxuXHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIHRpbGVtYXAgKi9cclxuICAgIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgbm8gbG9uZ2VyIGJlIHNwZWNpZmljIHRvIFRpbGVkXHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlbWFwRGF0YTogVGlsZWRUaWxlbWFwRGF0YSwgbGF5ZXI6IFRpbGVkTGF5ZXJEYXRhLCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD4sIHNjYWxlOiBWZWMyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRpbGVzZXRzID0gdGlsZXNldHM7XHJcbiAgICAgICAgdGhpcy50aWxlU2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGxheWVyLm5hbWU7XHJcblxyXG4gICAgICAgIGxldCB0aWxlY291bnQgPSAwO1xyXG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlc2V0cyl7XHJcbiAgICAgICAgICAgIHRpbGVjb3VudCArPSB0aWxlc2V0LmdldFRpbGVDb3VudCgpICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uTWFwID0gbmV3IEFycmF5KHRpbGVjb3VudCk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY29sbGlzaW9uTWFwLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXBbaV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmVyIHBhcnNpbmcgb2YgdGhlIGRhdGEgdG8gY2hpbGQgY2xhc3NlcyAtIHRoaXMgYWxsb3dzIGZvciBpc29tZXRyaWMgdnMuIG9ydGhvZ3JhcGhpYyB0aWxlbWFwcyBhbmQgaGFuZGxpbmcgb2YgVGlsZWQgZGF0YSBvciBvdGhlciBkYXRhXHJcbiAgICAgICAgdGhpcy5wYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhLCBsYXllcik7XHJcbiAgICAgICAgdGhpcy5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSB0aWxlc2V0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyB0aWxlbWFwXHJcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgb2YgdGhlIHRpbGVzZXRzIGFzc29jYWl0ZWQgd2l0aCB0aGlzIHRpbGVtYXAuXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVzZXRzKCk6IFRpbGVzZXRbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZXNldHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nXHJcbiAgICAgKiBAcmV0dXJucyBBIHZlY3RvciBjb250YWluaW5nIHRoZSBzaXplIG9mIHRpbGVzIGluIHRoaXMgdGlsZW1hcCBhcyB0aGV5IGFwcGVhciBpbiB0aGUgZ2FtZSB3b3JsZCBhZnRlciBzY2FsaW5nLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZS5zY2FsZWQodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdGlsZSBzaXplIHRha2luZyB6b29tIGludG8gYWNjb3VudFxyXG4gICAgICogQHJldHVybnMgVGhlIHRpbGUgc2l6ZSB3aXRoIHpvb21cclxuICAgICovXHJcbiAgICBnZXRUaWxlU2l6ZVdpdGhab29tKCk6IFZlYzIge1xyXG4gICAgICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVNpemUoKS5zY2FsZSh6b29tKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhpcyB0aWxlbWFwIHRvIHRoZSBwaHlzaWNzIHN5c3RlbVxyXG4gICAgKi9cclxuICAgIGFkZFBoeXNpY3MoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5oYXNQaHlzaWNzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5yZWdpc3RlclRpbGVtYXAodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIHBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcmV0dXJucyBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCB3b3JsZCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0VGlsZUF0V29ybGRQb3NpdGlvbih3b3JsZENvb3JkczogVmVjMik6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIFRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFRpbGVXb3JsZFBvc2l0aW9uKGluZGV4OiBudW1iZXIpOiBWZWMyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZURhdGEgYXJyYXlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0VGlsZShpbmRleDogbnVtYmVyKTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgbmV3IGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc2V0VGlsZShpbmRleDogbnVtYmVyLCB0eXBlOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IHVzZSB0aWxlZCBkYXRhIHNwZWNpZmljYWxseSAtIGl0IHNob3VsZCBiZSBtb3JlIGdlbmVyYWxcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCB0aGUgdGlsZXNldCB1c2luZyB0aGUgZGF0YSBsb2FkZWQgZnJvbSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcERhdGEgVGhlIHRpbGVtYXAgZGF0YSBmcm9tIGZpbGVcclxuICAgICAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIgZGF0YSBmcm9tIGZpbGVcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQ7XHJcbn0iLCJpbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vVGlsZW1hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSwgVGlsZWRMYXllckRhdGEgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb3J0aG9nb25hbCB0aWxlbWFwIC0gaS5lLiBhIHRvcCBkb3duIG9yIHBsYXRmb3JtZXIgdGlsZW1hcFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3J0aG9nb25hbFRpbGVtYXAgZXh0ZW5kcyBUaWxlbWFwIHtcclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRpbGVtYXAgKi9cclxuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSB0aWxlbWFwICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcHJvdGVjdGVkIHBhcnNlVGlsZW1hcERhdGEodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSk6IHZvaWQge1xyXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSB0aWxlbWFwIGluIGxvY2FsIHNwYWNlXHJcbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGlsZW1hcERhdGEud2lkdGg7XHJcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZW1hcERhdGEuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aWxlc1xyXG4gICAgICAgIHRoaXMudGlsZVNpemUuc2V0KHRpbGVtYXBEYXRhLnRpbGV3aWR0aCwgdGlsZW1hcERhdGEudGlsZWhlaWdodCk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSB0aWxlbWFwIG9uIHRoZSBjYW52YXNcclxuICAgICAgICB0aGlzLnNpemUuc2V0KHRoaXMubnVtQ29scyAqIHRoaXMudGlsZVNpemUueCwgdGhpcy5udW1Sb3dzICogdGhpcy50aWxlU2l6ZS55KTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBsYXllci5kYXRhO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGxheWVyLnZpc2libGU7XHJcblxyXG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIHRpbGVtYXAgaXMgY29sbGlkYWJsZSBvciBub3RcclxuICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGl0ZW0gb2YgbGF5ZXIucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29sbGlkYWJsZSA9IGl0ZW0udmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhbGwgdGlsZXMgYmVzaWRlcyBcImVtcHR5OiAwXCIgdG8gYmUgY29sbGlkYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCB0aGlzLmNvbGxpc2lvbk1hcC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWFwW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYW5kIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZW1hcC5cclxuICAgICAqL1xyXG4gICAgZ2V0RGltZW5zaW9ucygpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5udW1Db2xzLCB0aGlzLm51bVJvd3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHdvcmxkIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIGNvb3JkaW5hdGVzIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlQXRXb3JsZFBvc2l0aW9uKHdvcmxkQ29vcmRzOiBWZWMyKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgbG9jYWxDb29yZHMgPSB0aGlzLmdldENvbFJvd0F0KHdvcmxkQ29vcmRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlQXRSb3dDb2wobG9jYWxDb29yZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW5cclxuICAgICAqIEBwYXJhbSByb3dDb2wgVGhlIGNvb3JkaW5hdGVzIGluIHRpbGVtYXAgc3BhY2VcclxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVBdFJvd0NvbChyb3dDb2w6IFZlYzIpOiBudW1iZXIge1xyXG4gICAgICAgIGlmKHJvd0NvbC54IDwgMCB8fCByb3dDb2wueCA+PSB0aGlzLm51bUNvbHMgfHwgcm93Q29sLnkgPCAwIHx8IHJvd0NvbC55ID49IHRoaXMubnVtUm93cyl7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbcm93Q29sLnkgKiB0aGlzLm51bUNvbHMgKyByb3dDb2wueF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZVdvcmxkUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIC8vIEdldCB0aGUgbG9jYWwgcG9zaXRpb25cclxuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHdvcmxkIHBvc2l0aW9uXHJcbiAgICAgICAgbGV0IHggPSBjb2wgKiB0aGlzLnRpbGVTaXplLng7XHJcbiAgICAgICAgbGV0IHkgPSByb3cgKiB0aGlzLnRpbGVTaXplLnk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZShpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHNldFRpbGUoaW5kZXg6IG51bWJlciwgdHlwZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kYXRhW2luZGV4XSA9IHR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW5cclxuICAgICAqIEBwYXJhbSByb3dDb2wgVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWxlIGluIHRpbGVtYXAgc3BhY2VcclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSBuZXcgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxyXG4gICAgICovXHJcbiAgICBzZXRUaWxlQXRSb3dDb2wocm93Q29sOiBWZWMyLCB0eXBlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaW5kZXggPSByb3dDb2wueSAqIHRoaXMubnVtQ29scyArIHJvd0NvbC54O1xyXG4gICAgICAgIHRoaXMuc2V0VGlsZShpbmRleCwgdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCByb3cgYW5kIGNvbHVtbiBvZiB0aGUgdGlsZW1hcCBpcyBjb2xsaWRhYmxlXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhPckNvbCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgb3IgdGhlIGNvbHVtbiBpdCBpcyBpblxyXG4gICAgICogQHBhcmFtIHJvdyBUaGUgcm93IHRoZSB0aWxlIGlzIGluXHJcbiAgICAgKiBAcmV0dXJucyBBIGZsYWcgcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZSB0aWxlIGlzIGNvbGxpZGFibGUuXHJcbiAgICAgKi9cclxuICAgIGlzVGlsZUNvbGxpZGFibGUoaW5kZXhPckNvbDogbnVtYmVyLCByb3c/OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICAvLyBUaGUgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAgICBsZXQgdGlsZSA9IDA7XHJcblxyXG4gICAgICAgIGlmKHJvdyl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBjb2x1bW4gYW5kIGEgcm93XHJcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGVBdFJvd0NvbChuZXcgVmVjMihpbmRleE9yQ29sLCByb3cpKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHRpbGUgPCAwKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKGluZGV4T3JDb2wgPCAwIHx8IGluZGV4T3JDb2wgPj0gdGhpcy5kYXRhLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAvLyBUaWxlcyB0aGF0IGRvbid0IGV4aXN0IGFyZW4ndCBjb2xsaWRhYmxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBpbmRleFxyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy5nZXRUaWxlKGluZGV4T3JDb2wpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uTWFwW3RpbGVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgaW4gd29ybGQgY29vcmRpbmF0ZXMgYW5kIHJldHVybnMgdGhlIHJvdyBhbmQgY29sdW1uIG9mIHRoZSB0aWxlIGF0IHRoYXQgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB3b3JsZENvb3JkcyBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvdGVudGlhbCB0aWxlIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvdGVudGlhbCB0aWxlIGluIHRpbGVtYXAgc3BhY2VcclxuICAgICAqL1xyXG4gICAgZ2V0Q29sUm93QXQod29ybGRDb29yZHM6IFZlYzIpOiBWZWMyIHtcclxuICAgICAgICBsZXQgY29sID0gTWF0aC5mbG9vcih3b3JsZENvb3Jkcy54IC8gdGhpcy50aWxlU2l6ZS54IC8gdGhpcy5zY2FsZS54KTtcclxuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcih3b3JsZENvb3Jkcy55IC8gdGhpcy50aWxlU2l6ZS55IC8gdGhpcy5zY2FsZS55KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKGNvbCwgcm93KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIGRlYnVnUmVuZGVyKCl7XHJcbiAgICAgICAgLy8gSGFsZiBvZiB0aGUgdGlsZSBzaXplXHJcbiAgICAgICAgbGV0IHpvb21lZEhhbGZUaWxlU2l6ZSA9IHRoaXMuZ2V0VGlsZVNpemVXaXRoWm9vbSgpLnNjYWxlZCgwLjUpO1xyXG4gICAgICAgIGxldCBoYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGVkKDAuNSk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBjZW50ZXIgb2YgdGhlIHRvcCBsZWZ0IHRpbGVcclxuICAgICAgICBsZXQgdG9wTGVmdCA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5zdWIodGhpcy5zaXplLnNjYWxlZCgwLjUpKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBBIHZlYyB0byBzdG9yZSB0aGUgY2VudGVyXHJcbiAgICAgICAgbGV0IGNlbnRlciA9IFZlYzIuWkVSTztcclxuXHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLm51bUNvbHM7IGNvbCsrKXtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB4LXBvc2l0aW9uXHJcbiAgICAgICAgICAgIGNlbnRlci54ID0gdG9wTGVmdC54ICsgY29sKjIqaGFsZlRpbGVTaXplLnggKyBoYWxmVGlsZVNpemUueDtcclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5udW1Sb3dzOyByb3crKyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzQ29sbGlkYWJsZSAmJiB0aGlzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHktcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIueSA9IHRvcExlZnQueSArIHJvdyoyKmhhbGZUaWxlU2l6ZS55ICsgaGFsZlRpbGVTaXplLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERyYXcgYSBib3ggZm9yIHRoaXMgdGlsZVxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLmRyYXdCb3godGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXMoY2VudGVyKSwgem9vbWVkSGFsZlRpbGVTaXplLCBmYWxzZSwgQ29sb3IuQkxVRSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vSW5wdXQvSW5wdXRcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYSBVSUVsZW1lbnQgLSB0aGUgcGFyZW50IGNsYXNzIG9mIHRoaW5ncyBsaWtlIGJ1dHRvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFVJRWxlbWVudCBleHRlbmRzIENhbnZhc05vZGUge1xyXG5cdC8vIFN0eWxlIGF0dHJpYnV0ZXMgLSBUT0RPIC0gYWJzdHJhY3QgdGhpcyBpbnRvIGEgc3R5bGUgb2JqZWN0L2ludGVyZmFjZVxyXG5cdC8qKiBUaGUgYmFja2dvdW5kIGNvbG9yICovXHJcblx0YmFja2dyb3VuZENvbG9yOiBDb2xvcjtcclxuXHQvKiogVGhlIGJvcmRlciBjb2xvciAqL1xyXG5cdGJvcmRlckNvbG9yOiBDb2xvcjtcclxuXHQvKiogVGhlIGJvcmRlciByYWRpdXMgKi9cclxuXHRib3JkZXJSYWRpdXM6IG51bWJlcjtcclxuXHQvKiogVGhlIGJvcmRlciB3aWR0aCAqL1xyXG5cdGJvcmRlcldpZHRoOiBudW1iZXI7XHJcblx0LyoqIFRoZSBwYWRkaW5nICovXHJcblx0cGFkZGluZzogVmVjMjtcclxuXHJcblx0Ly8gRXZlbnRBdHRyaWJ1dGVzXHJcblx0LyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCBvbiBhIGNsaWNrICovXHJcblx0b25DbGljazogRnVuY3Rpb247XHJcblx0LyoqIFRoZSBldmVudCBwcm9wYWdhdGVkIG9uIGNsaWNrICovXHJcblx0b25DbGlja0V2ZW50SWQ6IHN0cmluZztcclxuXHQvKiogVGhlIHJlYWN0aW9uIHRvIHRoZSByZWxlYXNlIG9mIGEgY2xpY2sgKi9cclxuXHRvblJlbGVhc2U6IEZ1bmN0aW9uO1xyXG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXHJcblx0b25SZWxlYXNlRXZlbnRJZDogc3RyaW5nO1xyXG5cdC8qKiBUaGUgcmVhY3Rpb24gd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdG9uRW50ZXI6IEZ1bmN0aW9uO1xyXG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCB3aGVuIGEgbW91c2UgZW50ZXJzIHRoaXMgVUlFbGVtZW50ICovXHJcblx0b25FbnRlckV2ZW50SWQ6IHN0cmluZztcclxuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHRvbkxlYXZlOiBGdW5jdGlvbjtcclxuXHQvKiogVGhlIGV2ZW50IHByb3BvZ2F0ZWQgd2hlbiBhIG1vdXNlIGxlYXZlcyB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdG9uTGVhdmVFdmVudElkOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFVJRWxlbWVudCBpcyBjdXJyZW50bHkgY2xpY2tlZCBvbiAqL1xyXG5cdHByb3RlY3RlZCBpc0NsaWNrZWQ6IGJvb2xlYW47XHJcblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgVUlFbGVtZW50IGlzIGN1cnJlbnRseSBob3ZlcmVkIG92ZXIgKi9cclxuXHRwcm90ZWN0ZWQgaXNFbnRlcmVkOiBib29sZWFuO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG5cdFx0XHJcblx0XHR0aGlzLmJhY2tncm91bmRDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcclxuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XHJcblx0XHR0aGlzLmJvcmRlclJhZGl1cyA9IDU7XHJcblx0XHR0aGlzLmJvcmRlcldpZHRoID0gMTtcclxuXHRcdHRoaXMucGFkZGluZyA9IFZlYzIuWkVSTztcclxuXHJcblx0XHR0aGlzLm9uQ2xpY2sgPSBudWxsO1xyXG5cdFx0dGhpcy5vbkNsaWNrRXZlbnRJZCA9IG51bGw7XHJcblx0XHR0aGlzLm9uUmVsZWFzZSA9IG51bGw7XHJcblx0XHR0aGlzLm9uUmVsZWFzZUV2ZW50SWQgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMub25FbnRlciA9IG51bGw7XHJcblx0XHR0aGlzLm9uRW50ZXJFdmVudElkID0gbnVsbDtcclxuXHRcdHRoaXMub25MZWF2ZSA9IG51bGw7XHJcblx0XHR0aGlzLm9uTGVhdmVFdmVudElkID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc0VudGVyZWQgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8vIEBkZXByZWNhdGVkXHJcblx0c2V0QmFja2dyb3VuZENvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcclxuXHR9XHJcblxyXG5cdC8vIEBkZXByZWNhdGVkXHJcblx0c2V0UGFkZGluZyhwYWRkaW5nOiBWZWMyKTogdm9pZCB7XHJcblx0XHR0aGlzLnBhZGRpbmcuY29weShwYWRkaW5nKTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0c3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG5cdFx0Ly8gU2VlIG9mIHRoaXMgb2JqZWN0IHdhcyBqdXN0IGNsaWNrZWRcclxuXHRcdGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcclxuXHRcdFx0bGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XHJcblx0XHRcdGlmKHRoaXMuY29udGFpbnMoY2xpY2tQb3MueCwgY2xpY2tQb3MueSkgJiYgdGhpcy52aXNpYmxlICYmICF0aGlzLmxheWVyLmlzSGlkZGVuKCkpe1xyXG5cdFx0XHRcdHRoaXMuaXNDbGlja2VkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0aWYodGhpcy5vbkNsaWNrICE9PSBudWxsKXtcclxuXHRcdFx0XHRcdHRoaXMub25DbGljaygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih0aGlzLm9uQ2xpY2tFdmVudElkICE9PSBudWxsKXtcclxuXHRcdFx0XHRcdGxldCBkYXRhID0ge307XHJcblx0XHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25DbGlja0V2ZW50SWQsIGRhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHRoZSBtb3VzZSB3YXNuJ3QganVzdCBwcmVzc2VkLCB0aGVuIHdlIGRlZmluaXRlbHkgd2VyZW4ndCBjbGlja2VkXHJcblx0XHRpZighSW5wdXQuaXNNb3VzZVByZXNzZWQoKSl7XHJcblx0XHRcdGlmKHRoaXMuaXNDbGlja2VkKXtcclxuXHRcdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG1vdXNlIGlzIGhvdmVyaW5nIG92ZXIgdGhpcyBlbGVtZW50XHJcblx0XHRsZXQgbW91c2VQb3MgPSBJbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCk7XHJcblx0XHRpZihtb3VzZVBvcyAmJiB0aGlzLmNvbnRhaW5zKG1vdXNlUG9zLngsIG1vdXNlUG9zLnkpKXtcclxuXHRcdFx0dGhpcy5pc0VudGVyZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYodGhpcy5vbkVudGVyICE9PSBudWxsKXtcclxuXHRcdFx0XHR0aGlzLm9uRW50ZXIoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0aGlzLm9uRW50ZXJFdmVudElkICE9PSBudWxsKXtcclxuXHRcdFx0XHRsZXQgZGF0YSA9IHt9O1xyXG5cdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkVudGVyRXZlbnRJZCwgZGF0YSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYodGhpcy5pc0VudGVyZWQpIHtcclxuXHRcdFx0dGhpcy5pc0VudGVyZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmKHRoaXMub25MZWF2ZSAhPT0gbnVsbCl7XHJcblx0XHRcdFx0dGhpcy5vbkxlYXZlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5vbkxlYXZlRXZlbnRJZCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcclxuXHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25MZWF2ZUV2ZW50SWQsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYodGhpcy5pc0NsaWNrZWQpIHtcclxuXHRcdFx0Ly8gSWYgbW91c2UgaXMgZHJhZ2dlZCBvZmYgb2YgZWxlbWVudCB3aGlsZSBkb3duLCBpdCBpcyBub3QgY2xpY2tlZCBhbnltb3JlXHJcblx0XHRcdHRoaXMuaXNDbGlja2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVycmlkYWJsZSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIGJhY2tncm91bmQgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xyXG5cdCAqIEByZXR1cm5zIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBib3JkZXIgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xyXG5cdCAqIEByZXR1cm5zIFRoZSBib3JkZXIgY29sb3Igb2YgdGhlIFVJRWxlbWVudFxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZUJvcmRlckNvbG9yKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiB0aGlzLmJvcmRlckNvbG9yO1xyXG5cdH1cclxufSIsImltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuLyoqIEEgY2xpY2thYmxlIGJ1dHRvbiBVSUVsZW1lbnQgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uIGV4dGVuZHMgTGFiZWwge1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgdGV4dDogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHBvc2l0aW9uLCB0ZXh0KTtcclxuXHRcdFxyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMTUwLCA3NSwgMjAzKTtcclxuXHRcdHRoaXMuYm9yZGVyQ29sb3IgPSBuZXcgQ29sb3IoNDEsIDQ2LCAzMCk7XHJcblx0XHR0aGlzLnRleHRDb2xvciA9IG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1KTtcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdGNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpOiBDb2xvciB7XHJcblx0XHQvLyBDaGFuZ2UgdGhlIGJhY2tncm91bmQgY29sb3IgaWYgY2xpY2tlZCBvciBob3ZlcmVkXHJcblx0XHRpZih0aGlzLmlzRW50ZXJlZCAmJiAhdGhpcy5pc0NsaWNrZWQpe1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5iYWNrZ3JvdW5kQ29sb3IubGlnaHRlbigpO1xyXG5cdFx0fSBlbHNlIGlmKHRoaXMuaXNDbGlja2VkKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmRhcmtlbigpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL1VJRWxlbWVudFwiO1xyXG5cclxuLyoqIEEgYmFzaWMgdGV4dC1jb250YWluaW5nIGxhYmVsICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsIGV4dGVuZHMgVUlFbGVtZW50e1xyXG5cdC8qKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgb2YgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHR0ZXh0Q29sb3I6IENvbG9yO1xyXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhlIHRleHQgb2YgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHR0ZXh0OiBzdHJpbmc7XHJcblx0LyoqIFRoZSBuYW1lIG9mIHRoZSBmb250ICovXHJcblx0Zm9udDogc3RyaW5nO1xyXG5cdC8qKiBUaGUgc2l6ZSBvZiB0aGUgZm9udCAqL1xyXG5cdGZvbnRTaXplOiBudW1iZXI7XHJcblx0LyoqIFRoZSBob3Jpem9udGFsIGFsaWdubWVudCBvZiB0aGUgdGV4dCB3aXRoaW4gdGhlIGxhYmVsICovXHJcblx0cHJvdGVjdGVkIGhBbGlnbjogc3RyaW5nO1xyXG5cdC8qKiBUaGUgdmVydGljYWwgYWxpZ25tZW50IG9mIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xyXG5cdHByb3RlY3RlZCB2QWxpZ246IHN0cmluZztcclxuXHJcblx0LyoqIEEgZmxhZyBmb3IgaWYgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGhhcyBiZWVuIG1lYXN1cmVkIG9uIHRoZSBjYW52YXMgZm9yIGF1dG8gd2lkdGggYXNzaWdubWVudCAqL1xyXG5cdHByb3RlY3RlZCBzaXplQXNzaWduZWQ6IGJvb2xlYW47XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyLCB0ZXh0OiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIocG9zaXRpb24pO1xyXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcclxuXHRcdHRoaXMudGV4dENvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xyXG5cdFx0dGhpcy5mb250ID0gXCJBcmlhbFwiO1xyXG5cdFx0dGhpcy5mb250U2l6ZSA9IDMwO1xyXG5cdFx0dGhpcy5oQWxpZ24gPSBcImNlbnRlclwiO1xyXG5cdFx0dGhpcy52QWxpZ24gPSBcImNlbnRlclwiO1xyXG5cclxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBAZGVwcmVjYXRlZFxyXG5cdHNldFRleHQodGV4dDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xyXG5cdH1cclxuXHJcblx0Ly8gQGRlcHJlY2F0ZWRcclxuXHRzZXRUZXh0Q29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLnRleHRDb2xvciA9IGNvbG9yO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBhIHN0cmluZyBjb250YWluZyB0aGUgZm9udCBkZXRhaWxzIGZvciByZW5kZXJpbmdcclxuXHQgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBmb250IGRldGFpbHNcclxuXHQgKi9cclxuXHRnZXRGb250U3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVycmlkYWJsZSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIHRleHQgY29sb3IgLSB1c2VmdWwgZm9yIGVsZW1lbnRzIHRoYXQgd2FudCB0byBiZSBjb2xvcmVkIG9uIGRpZmZlcmVudCBhZnRlciBjZXJ0YWluIGV2ZW50c1xyXG5cdCAqIEByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5nIHRoZSB0ZXh0IGNvbG9yXHJcblx0ICovXHJcblx0Y2FsY3VsYXRlVGV4dENvbG9yKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0Q29sb3IudG9TdHJpbmdSR0JBKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVc2VzIHRoZSBjYW52YXMgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICogQHJldHVybnMgQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSByZW5kZXJlZCB0ZXh0IHdpZHRoXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGNhbGN1bGF0ZVRleHRXaWR0aChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IG51bWJlciB7XHJcblx0XHRjdHguZm9udCA9IHRoaXMuZm9udFNpemUgKyBcInB4IFwiICsgdGhpcy5mb250O1xyXG5cdFx0cmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xyXG5cdH1cclxuXHJcblx0c2V0SEFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdHRoaXMuaEFsaWduID0gYWxpZ247XHJcblx0fVxyXG5cclxuXHRzZXRWQWxpZ24oYWxpZ246IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy52QWxpZ24gPSBhbGlnbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSB0ZXh0IC0gdGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcgdGV4dCB3aXRoIGRpZmZlcmVudCBhbGlnbm1lbnRzXHJcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKiBAcmV0dXJucyBUaGUgb2Zmc2V0IG9mIHRoZSB0ZXh0IGluIGEgVmVjMlxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZVRleHRPZmZzZXQoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBWZWMyIHtcclxuXHRcdGxldCB0ZXh0V2lkdGggPSB0aGlzLmNhbGN1bGF0ZVRleHRXaWR0aChjdHgpO1xyXG5cclxuXHRcdGxldCBvZmZzZXQgPSBuZXcgVmVjMigwLCAwKTtcclxuXHJcblx0XHRsZXQgaERpZmYgPSB0aGlzLnNpemUueCAtIHRleHRXaWR0aDtcclxuXHRcdGlmKHRoaXMuaEFsaWduID09PSBIQWxpZ24uQ0VOVEVSKXtcclxuXHRcdFx0b2Zmc2V0LnggPSBoRGlmZi8yO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLmhBbGlnbiA9PT0gSEFsaWduLlJJR0hUKXtcclxuXHRcdFx0b2Zmc2V0LnggPSBoRGlmZjtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLnZBbGlnbiA9PT0gVkFsaWduLlRPUCl7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xyXG5cdFx0XHRvZmZzZXQueSA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMudkFsaWduID09PSBWQWxpZ24uQk9UVE9NKXtcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XHJcblx0XHRcdG9mZnNldC55ID0gdGhpcy5zaXplLnk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuXHRcdFx0b2Zmc2V0LnkgPSB0aGlzLnNpemUueS8yO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvZmZzZXQ7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgc2l6ZUNoYW5nZWQoKTogdm9pZCB7XHJcblx0XHRzdXBlci5zaXplQ2hhbmdlZCgpO1xyXG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQXV0b21hdGljYWxseSBzaXplcyB0aGUgZWxlbWVudCB0byB0aGUgdGV4dCB3aXRoaW4gaXRcclxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhdXRvU2l6ZShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge1xyXG5cdFx0bGV0IHdpZHRoID0gdGhpcy5jYWxjdWxhdGVUZXh0V2lkdGgoY3R4KTtcclxuXHRcdGxldCBoZWlnaHQgPSB0aGlzLmZvbnRTaXplO1xyXG5cdFx0dGhpcy5zaXplLnNldCh3aWR0aCArIHRoaXMucGFkZGluZy54KjIsIGhlaWdodCArIHRoaXMucGFkZGluZy55KjIpO1xyXG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGx5IGFzc2lnbnMgYSBzaXplIHRvIHRoZSBVSUVsZW1lbnQgaWYgbm9uZSBpcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICovXHJcblx0aGFuZGxlSW5pdGlhbFNpemluZyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge1xyXG5cdFx0aWYoIXRoaXMuc2l6ZUFzc2lnbmVkKXtcclxuXHRcdFx0dGhpcy5hdXRvU2l6ZShjdHgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqIE9uIHRoZSBuZXh0IHJlbmRlciwgc2l6ZSB0aGlzIGVsZW1lbnQgdG8gaXQncyBjdXJyZW50IHRleHQgdXNpbmcgaXRzIGN1cnJlbnQgZm9udCBzaXplICovXHJcblx0c2l6ZVRvVGV4dCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gZmFsc2U7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBWQWxpZ24ge1xyXG5cdFRPUCA9IFwidG9wXCIsXHJcblx0Q0VOVEVSID0gXCJjZW50ZXJcIixcclxuXHRCT1RUT00gPSBcImJvdHRvbVwiXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEhBbGlnbiB7XHJcblx0TEVGVCA9IFwibGVmdFwiLFxyXG5cdENFTlRFUiA9IFwiY2VudGVyXCIsXHJcblx0UklHSFQgPSBcInJpZ2h0XCJcclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL1VJRWxlbWVudFwiO1xyXG5cclxuLyoqIEEgc2xpZGVyIFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXIgZXh0ZW5kcyBVSUVsZW1lbnQge1xyXG4gICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyIGZyb20gWzAsIDFdICovXHJcbiAgICBwcm90ZWN0ZWQgdmFsdWU6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIHNsaWRlciBuaWIgKi9cclxuICAgIHB1YmxpYyBuaWJDb2xvcjogQ29sb3I7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG5pYiAqL1xyXG4gICAgcHVibGljIG5pYlNpemU6IFZlYzI7XHJcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgdHJhY2sgKi9cclxuICAgIHB1YmxpYyBzbGlkZXJDb2xvcjogQ29sb3I7XHJcbiAgICAvKiogVGhlIHJlYWN0aW9uIG9mIHRoaXMgVUlFbGVtZW50IHRvIGEgdmFsdWUgY2hhbmdlICovXHJcbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZTogRnVuY3Rpb247XHJcbiAgICAvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgYnkgdGhpcyBVSUVsZW1lbnQgd2hlbiB2YWx1ZSBjaGFuZ2VzICovXHJcbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZUV2ZW50SWQ6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgaW5pdFZhbHVlOiBudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGluaXRWYWx1ZTtcclxuICAgICAgICB0aGlzLm5pYkNvbG9yID0gQ29sb3IuUkVEO1xyXG4gICAgICAgIHRoaXMuc2xpZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICB0aGlzLm5pYlNpemUgPSBuZXcgVmVjMigxMCwgMjApO1xyXG5cclxuICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IHNpemVcclxuICAgICAgICB0aGlzLnNpemUuc2V0KDIwMCwgMjApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHNsaWRlclxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBIG1ldGhvZCBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gdGhlIHZhbHVlIGNoYW5naW5nICovXHJcbiAgICBwcm90ZWN0ZWQgdmFsdWVDaGFuZ2VkKCk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZSl7XHJcbiAgICAgICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZUV2ZW50SWQpe1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25WYWx1ZUNoYW5nZUV2ZW50SWQsIHt0YXJnZXQ6IHRoaXMsIHZhbHVlOiB0aGlzLnZhbHVlfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICBpZih0aGlzLmlzQ2xpY2tlZCl7XHJcbiAgICAgICAgICAgIGxldCB2YWwgPSBNYXRoVXRpbHMuaW52TGVycCh0aGlzLnBvc2l0aW9uLnggLSB0aGlzLnNpemUueC8yLCB0aGlzLnBvc2l0aW9uLnggKyB0aGlzLnNpemUueC8yLCBJbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCkueCk7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoVXRpbHMuY2xhbXAwMSh2YWwpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XHJcblxyXG4vKiogQSB0ZXh0IGlucHV0IFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgICAvKiogQSBmbGFnIHRoZSByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHVzZXIgY2FuIHR5cGUgaW4gdGhpcyBUZXh0SW5wdXQgKi9cclxuICAgIGZvY3VzZWQ6IGJvb2xlYW47XHJcbiAgICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgaW4gdGhpcyBUZXh0SW5wdXQgKi9cclxuICAgIGN1cnNvckNvdW50ZXI6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XHJcbiAgICAgICAgc3VwZXIocG9zaXRpb24sIFwiXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1cnNvckNvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAvLyBHaXZlIGEgZGVmYXVsdCBzaXplIHRvIHRoZSB4IG9ubHlcclxuICAgICAgICB0aGlzLnNpemUuc2V0KDIwMCwgdGhpcy5mb250U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5oQWxpZ24gPSBcImxlZnRcIjtcclxuXHJcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcclxuXHRcdFx0bGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XHJcblx0XHRcdGlmKHRoaXMuY29udGFpbnMoY2xpY2tQb3MueCwgY2xpY2tQb3MueSkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yQ291bnRlciA9IDMwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZm9jdXNlZCl7XHJcbiAgICAgICAgICAgIGxldCBrZXlzID0gSW5wdXQuZ2V0S2V5c0p1c3RQcmVzc2VkKCk7XHJcbiAgICAgICAgICAgIGxldCBudW1zID0gXCIxMjM0NTY3ODkwXCI7XHJcbiAgICAgICAgICAgIGxldCBzcGVjaWFsQ2hhcnMgPSBcImB+IUAjJCVeJiooKS1fPStbe119XFxcXHw7OidcXFwiLDwuPi8/XCI7XHJcbiAgICAgICAgICAgIGxldCBsZXR0ZXJzID0gXCJxd2VydHl1aW9wYXNkZmdoamtsenhjdmJubVwiO1xyXG4gICAgICAgICAgICBsZXQgbWFzayA9IG51bXMgKyBzcGVjaWFsQ2hhcnMgKyBsZXR0ZXJzO1xyXG4gICAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+IG1hc2suaW5jbHVkZXMoa2V5KSk7XHJcbiAgICAgICAgICAgIGxldCBzaGlmdFByZXNzZWQgPSBJbnB1dC5pc0tleVByZXNzZWQoXCJzaGlmdFwiKTtcclxuICAgICAgICAgICAgbGV0IGJhY2tzcGFjZVByZXNzZWQgPSBJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiYmFja3NwYWNlXCIpO1xyXG4gICAgICAgICAgICBsZXQgc3BhY2VQcmVzc2VkID0gSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcInNwYWNlXCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoYmFja3NwYWNlUHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIHRoaXMudGV4dC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHNwYWNlUHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmKHNoaWZ0UHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGtleXNbMF0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGtleXNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZW51bSBVSUVsZW1lbnRUeXBlIHtcclxuXHRCVVRUT04gPSBcIkJVVFRPTlwiLFxyXG5cdExBQkVMID0gXCJMQUJFTFwiLFxyXG5cdFNMSURFUiA9IFwiU0xJREVSXCIsXHJcblx0VEVYVF9JTlBVVCA9IFwiVEVYVElOUFVUXCJcclxufSIsImltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL05hdmlnYWJsZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFuYWdlciBjbGFzcyBmb3IgbmF2aWdhdGlvbi5cclxuICogSGFuZGxlcyBhbGwgbmF2aWdhYmxlIGVudGl0aWVzLCBzdWNoIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBhY2Nlc3NlZCBieSBvdXRzaWRlIHN5c3RlbXMgYnkgcmVxdWVzdGluZyBhIHBhdGhcclxuICogZnJvbSBvbmUgcG9zaXRpb24gdG8gYW5vdGhlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25NYW5hZ2VyIHtcclxuXHQvKiogVGhlIGxpc3Qgb2YgYWxsIG5hdmlnYWJsZSBlbnRpdGllcyAqL1xyXG5cdHByb3RlY3RlZCBuYXZpZ2FibGVFbnRpdGllczogTWFwPE5hdmlnYWJsZT47XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzID0gbmV3IE1hcCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIG5hdmlnYWJsZSBlbnRpdHkgdG8gdGhlIE5hdmlnYXRpb25NYW5hZ2VyXHJcblx0ICogQHBhcmFtIG5hdk5hbWUgVGhlIG5hbWUgb2YgdGhlIG5hdmlnYWJsZSBlbnRpdHJ5XHJcblx0ICogQHBhcmFtIG5hdiBUaGUgYWN0dWFsIE5hdmlnYWJsZSBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdGFkZE5hdmlnYWJsZUVudGl0eShuYXZOYW1lOiBzdHJpbmcsIG5hdjogTmF2aWdhYmxlKTogdm9pZCB7XHJcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmFkZChuYXZOYW1lLCBuYXYpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBhIHBhdGggZnJvbWUgb25lIHBvaW50IHRvIGFub3RoZXIgdXNpbmcgYSBzcGVjaWZpZWQgTmF2aWdhYmxlIG9iamVjdFxyXG5cdCAqIEBwYXJhbSBuYXZOYW1lIFRoZSBuYW1lIG9mIHRoZSByZWdpc3RlcmVkIE5hdmlnYWJsZSBvYmplY3RcclxuXHQgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiBuYXZpZ2F0aW9uXHJcblx0ICogQHBhcmFtIHRvUG9zaXRpb24gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiBOYXZpZ2F0aW9uXHJcblx0ICogQHJldHVybnMgQSBOYXZpZ2F0aW9uUGF0aCBjb250YWluaW5nIHRoZSByb3V0ZSB0byB0YWtlIG92ZXIgdGhlIE5hdmlnYWJsZSBlbnRpdHkgdG8gZ2V0IGJldHdlZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9ucy5cclxuXHQgKi9cclxuXHRnZXRQYXRoKG5hdk5hbWU6IHN0cmluZywgZnJvbVBvc2l0aW9uOiBWZWMyLCB0b1Bvc2l0aW9uOiBWZWMyKTogTmF2aWdhdGlvblBhdGgge1xyXG5cdFx0bGV0IG5hdiA9IHRoaXMubmF2aWdhYmxlRW50aXRpZXMuZ2V0KG5hdk5hbWUpO1xyXG5cdFx0cmV0dXJuIG5hdi5nZXROYXZpZ2F0aW9uUGF0aChmcm9tUG9zaXRpb24uY2xvbmUoKSwgdG9Qb3NpdGlvbi5jbG9uZSgpKTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uL0RhdGFUeXBlcy9TdGFja1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgcGF0aCB0aGF0IEFJcyBjYW4gZm9sbG93LiBVc2VzIGZpbmlzaE1vdmUoKSBpbiBQaHlzaWNhbCB0byBkZXRlcm1pbmUgcHJvZ3Jlc3Mgb24gdGhlIHJvdXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uUGF0aCB7XHJcblx0LyoqIFRoZSBuYXZpZ2F0aW9uIHBhdGgsIHN0b3JlZCBhcyBhIHN0YWNrIG9mIG5leHQgcG9zaXRpb25zICovXHJcblx0cHJvdGVjdGVkIHBhdGg6IFN0YWNrPFZlYzI+O1xyXG5cdC8qKiBUaGUgY3VycmVudCBkaXJlY3Rpb24gb2YgbW92ZW1lbnQgKi9cclxuXHRwcm90ZWN0ZWQgY3VycmVudE1vdmVEaXJlY3Rpb246IFZlYzI7XHJcblx0LyoqIFRoZSBkaXN0YW5jZSBhIG5vZGUgbXVzdCBiZSB0byBhIHBvaW50IHRvIGNvbnNpZGVyIGl0IGFzIGhhdmluZyBhcnJpdmVkICovXHJcblx0cHJvdGVjdGVkIGRpc3RhbmNlVGhyZXNob2xkOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgTmF2aWdhdGlvblBhdGhcclxuXHQgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiBub2RlcyB0byB0YWtlXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IocGF0aDogU3RhY2s8VmVjMj4pe1xyXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHRcdHRoaXMuY3VycmVudE1vdmVEaXJlY3Rpb24gPSBWZWMyLlpFUk87XHJcblx0XHR0aGlzLmRpc3RhbmNlVGhyZXNob2xkID0gNDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBuYXZpZ2F0aW9uIGFsb25nIHRoaXMgTmF2aWdhdGlvblBhdGhcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBub2RlIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHBhdGgsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdGlzRG9uZSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnBhdGguaXNFbXB0eSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgbW92ZW1lbnQgZGlyZWN0aW9uIGluIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFsb25nIHRoZSBwYXRoXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gbW92ZSBhbG9uZyB0aGUgcGF0aFxyXG5cdCAqIEByZXR1cm5zIFRoZSBtb3ZlbWVudCBkaXJlY3Rpb24gYXMgYSBWZWMyXHJcblx0ICovXHJcblx0Z2V0TW92ZURpcmVjdGlvbihub2RlOiBHYW1lTm9kZSk6IFZlYzIge1xyXG5cdFx0Ly8gUmV0dXJuIGRpcmVjdGlvbiB0byBuZXh0IHBvaW50IGluIHRoZSBuYXZcclxuXHRcdHJldHVybiBub2RlLnBvc2l0aW9uLmRpclRvKHRoaXMucGF0aC5wZWVrKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIE5hdmlnYXRpb25QYXRoIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBHYW1lTm9kZVxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIG1vdmluZyBhbG9uZyB0aGUgcGF0aFxyXG5cdCAqL1xyXG5cdGhhbmRsZVBhdGhQcm9ncmVzcyhub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xyXG5cdFx0aWYobm9kZS5wb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5wYXRoLnBlZWsoKSkgPCB0aGlzLmRpc3RhbmNlVGhyZXNob2xkKnRoaXMuZGlzdGFuY2VUaHJlc2hvbGQpe1xyXG5cdFx0XHQvLyBXZSd2ZSByZWFjaGVkIG91ciBub2RlLCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGRlc3RpbmF0aW9uXHJcblx0XHRcdHRoaXMucGF0aC5wb3AoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKClcclxuXHR9XHJcbn0iLCJpbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XHJcbmltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL05hdmlnYWJsZVwiO1xyXG5pbXBvcnQgU3RhY2sgZnJvbSBcIi4uL0RhdGFUeXBlcy9TdGFja1wiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdyYXBoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL0dyYXBoVXRpbHNcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuL05hdmlnYXRpb25QYXRoXCI7XHJcblxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBOYXZtZXNoLiBOYXZtZXNoZXMgYXJlIGdyYXBocyBpbiB0aGUgZ2FtZSB3b3JsZCBhbG9uZyB3aGljaCBub2RlcyBjYW4gbW92ZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdm1lc2ggaW1wbGVtZW50cyBOYXZpZ2FibGUge1xyXG5cdC8qKiBUaGUgZ3JhcGggb2YgcG9pbnRzIGluIHRoZSBOYXZNZXNoICovXHJcblx0cHJvdGVjdGVkIGdyYXBoOiBQb3NpdGlvbkdyYXBoO1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IE5hdm1lc2ggZnJvbSB0aGUgcG9pbnRzIGluIHRoZSBzcGVlY2lmaWVkIGdyYXBoXHJcblx0ICogQHBhcmFtIGdyYXBoIFRoZSBncmFwaCB0byBjb25zdHJ1Y3QgYSBuYXZtZXNoIGZyb21cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihncmFwaDogUG9zaXRpb25HcmFwaCl7XHJcblx0XHR0aGlzLmdyYXBoID0gZ3JhcGg7XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRnZXROYXZpZ2F0aW9uUGF0aChmcm9tUG9zaXRpb246IFZlYzIsIHRvUG9zaXRpb246IFZlYzIpOiBOYXZpZ2F0aW9uUGF0aCB7XHJcblx0XHRsZXQgc3RhcnQgPSB0aGlzLmdldENsb3Nlc3ROb2RlKGZyb21Qb3NpdGlvbik7XHJcblx0XHRsZXQgZW5kID0gdGhpcy5nZXRDbG9zZXN0Tm9kZSh0b1Bvc2l0aW9uKTtcclxuXHJcblx0XHRsZXQgcGFyZW50ID0gR3JhcGhVdGlscy5kamlrc3RyYSh0aGlzLmdyYXBoLCBzdGFydCk7XHJcblxyXG5cdFx0bGV0IHBhdGhTdGFjayA9IG5ldyBTdGFjazxWZWMyPih0aGlzLmdyYXBoLm51bVZlcnRpY2VzKTtcclxuXHRcdFxyXG5cdFx0Ly8gUHVzaCB0aGUgZmluYWwgcG9zaXRpb24gYW5kIHRoZSBmaW5hbCBwb3NpdGlvbiBpbiB0aGUgZ3JhcGhcclxuXHRcdHBhdGhTdGFjay5wdXNoKHRvUG9zaXRpb24uY2xvbmUoKSk7XHJcblx0XHRwYXRoU3RhY2sucHVzaCh0aGlzLmdyYXBoLnBvc2l0aW9uc1tlbmRdKTtcclxuXHJcblx0XHQvLyBBZGQgYWxsIHBhcmVudHMgYWxvbmcgdGhlIHBhdGhcclxuXHRcdGxldCBpID0gZW5kO1xyXG5cdFx0d2hpbGUocGFyZW50W2ldICE9PSAtMSl7XHJcblx0XHRcdHBhdGhTdGFjay5wdXNoKHRoaXMuZ3JhcGgucG9zaXRpb25zW3BhcmVudFtpXV0pO1xyXG5cdFx0XHRpID0gcGFyZW50W2ldO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgTmF2aWdhdGlvblBhdGgocGF0aFN0YWNrKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGNsb3Nlc3Qgbm9kZSBpbiB0aGlzIE5hdm1lc2ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gcXVlcnlcclxuXHQgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGNsb3Nlc3Qgbm9kZSBpbiB0aGUgTmF2bWVzaCB0byB0aGUgcG9zaXRpb25cclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgZ2V0Q2xvc2VzdE5vZGUocG9zaXRpb246IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0bGV0IG4gPSB0aGlzLmdyYXBoLm51bVZlcnRpY2VzO1xyXG5cdFx0bGV0IGkgPSAxO1xyXG5cdFx0bGV0IGluZGV4ID0gMDtcclxuXHRcdGxldCBkaXN0ID0gcG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMuZ3JhcGgucG9zaXRpb25zWzBdKTtcclxuXHRcdHdoaWxlKGkgPCBuKXtcclxuXHRcdFx0bGV0IGQgPSBwb3NpdGlvbi5kaXN0YW5jZVNxVG8odGhpcy5ncmFwaC5wb3NpdGlvbnNbaV0pO1xyXG5cdFx0XHRpZihkIDwgZGlzdCl7XHJcblx0XHRcdFx0ZGlzdCA9IGQ7XHJcblx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGkrKztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5kZXg7XHJcblx0fVxyXG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi9QaHlzaWNzTWFuYWdlclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBBcmVhQ29sbGlzaW9uIGZyb20gXCIuLi9EYXRhVHlwZXMvUGh5c2ljcy9BcmVhQ29sbGlzaW9uXCI7XHJcbmltcG9ydCBVbmlxdWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VuaXF1ZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFMR09SSVRITTpcclxuICogXHRJbiBhbiBlZmZvcnQgdG8ga2VlcCB0aGluZ3Mgc2ltcGxlIGFuZCB3b3JraW5nIGVmZmVjdGl2ZWx5LCBlYWNoIGR5bmFtaWMgbm9kZSB3aWxsIHJlc29sdmUgaXRzXHJcbiAqIFx0Y29sbGlzaW9ucyBjb25zaWRlcmluZyB0aGUgcmVzdCBvZiB0aGUgd29ybGQgYXMgc3RhdGljLlxyXG4gKiBcclxuICogXHRDb2xsaXNpb24gZGV0ZWN0aW5nIHdpbGwgaGFwcGVuIGZpcnN0LiBUaGlzIGNhbiBiZSBjb25zaWRlcmVkIGEgYnJvYWQgcGhhc2UsIGJ1dCBpdCBpcyBub3QgZXNwZWNpYWxseVxyXG4gKiBcdGVmZmljaWVudCwgYXMgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBmb3IgdGhpcyBnYW1lIGVuZ2luZS4gRXZlcnkgZHluYW1pYyBub2RlIGlzIGNoZWNrZWQgYWdhaW5zdCBldmVyeVxyXG4gKiBcdG90aGVyIG5vZGUgZm9yIGNvbGxpc2lvbiBhcmVhLiBJZiBjb2xsaXNpb24gYXJlYSBpcyBub24temVybyAobWVhbmluZyB0aGUgY3VycmVudCBub2RlIHN3ZWVwcyBpbnRvIGFub3RoZXIpLFxyXG4gKiBcdGl0IGlzIGFkZGVkIHRvIGEgbGlzdCBvZiBoaXRzLlxyXG4gKiBcclxuICogXHRJTklUSUFMSVpBVElPTjpcclxuICogXHRcdC0gUGh5c2ljcyBjb25zdGFudHMgYXJlIHJlc2V0XHJcbiAqIFx0XHQtIFN3ZXB0IHNoYXBlcyBhcmUgcmVjYWxjdWxhdGVkLiBJZiBhIG5vZGUgaXNuJ3QgbW92aW5nLCBpdCBpcyBza2lwcGVkLlxyXG4gKiBcclxuICogXHRDT0xMSVNJT04gREVURUNUSU9OOlxyXG4gKiBcdFx0LSBGb3IgYSBub2RlLCBjb2xsaXNpb24gYXJlYSB3aWxsIGJlIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIHN3ZXB0IEFBQkIgb2YgdGhlIG5vZGUgYWdhaW5zdCBldmVyeSBvdGhlciBBQUJCIGluIGEgc3RhdGljIHN0YXRlXHJcbiAqIFx0XHQtIFRoZXNlIGNvbGxpc2lvbnMgd2lsbCBiZSBzb3J0ZWQgYnkgYXJlYSBpbiBkZXNjZW5kaW5nIG9yZGVyXHJcbiAqIFx0XHJcbiAqIFx0Q09MTElTSU9OIFJFU09MVVRJT046XHJcbiAqIFx0XHQtIEZvciBlYWNoIGhpdCwgdGltZSBvZiBjb2xsaXNpb24gaXMgY2FsY3VsYXRlZCB1c2luZyBhIHN3ZXB0IGxpbmUgdGhyb3VnaCB0aGUgQUFCQiBvZiB0aGUgc3RhdGljIG5vZGUgZXhwYW5kZWRcclxuICogXHRcdFx0d2l0aCBtaW5rb3dza2kgc3VtcyAoZGlzY3JldGVseSwgYnV0IHRoZSBjb25jZXB0IGlzIHRoZXJlKVxyXG4gKiBcdFx0LSBUaGUgY29sbGlzaW9uIGlzIHJlc29sdmVkIGJhc2VkIG9uIHRoZSBuZWFyIHRpbWUgb2YgdGhlIGNvbGxpc2lvbiAoZnJvbSBtZXRob2Qgb2Ygc2VwYXJhdGVkIGF4ZXMpXHJcbiAqIFx0XHRcdC0gWCBpcyByZXNvbHZlZCBieSBuZWFyIHgsIFkgYnkgbmVhciB5LlxyXG4gKiBcdFx0XHQtIFRoZXJlIGlzIHNvbWUgZnVkZ2luZyB0byBhbGxvdyBmb3Igc2xpZGluZyBhbG9uZyB3YWxscyBvZiBzZXBhcmF0ZSBjb2xsaWRlcnMuIFNvcnRpbmcgYnkgYXJlYSBhbHNvIGhlbHBzIHdpdGggdGhpcy5cclxuICogXHRcdFx0LSBDb3JuZXIgdG8gY29ybmVyIGNvbGxpc2lvbnMgYXJlIHJlc29sdmUgdG8gZmF2b3IgeC1tb3ZlbWVudC4gVGhpcyBpcyBpbiBjb25zaWRlcmF0aW9uIG9mIHBsYXRmb3JtZXJzLCB0byBnaXZlXHJcbiAqIFx0XHRcdFx0dGhlIHBsYXllciBzb21lIGhlbHAgd2l0aCBqdW1wc1xyXG4gKiBcclxuICogXHRQcm9zOlxyXG4gKiBcdFx0LSBFdmVyeXRoaW5nIGhhcHBlbnMgd2l0aCBhIGNvbnNpc3RlbnQgdGltZS4gVGhlcmUgaXMgYSBkaXN0aW5jdCBiZWZvcmUgYW5kIGFmdGVyIGZvciBlYWNoIHJlc29sdXRpb24uXHJcbiAqIFx0XHQtIE5vIGJhY2stdHJhY2tpbmcgbmVlZHMgdG8gYmUgZG9uZS4gT25jZSB3ZSByZXNvbHZlIGEgbm9kZSwgaXQgaXMgZGVmaW5pdGl2ZWx5IHJlc29sdmVkLlxyXG4gKiBcdFxyXG4gKiBcdENvbnM6XHJcbiAqIFx0XHQtIE5vZGVzIHRoYXQgYXJlIHByb2Nlc3NlZCBlYXJseSBoYXZlIG1vdmVtZW50IHByaW9yaXR5IG92ZXIgb3RoZXIgbm9kZXMuIFRoaXMgY2FuIGxlYWQgdG8gc29tZSB1bmRlc2lyYWJsZSBpbnRlcmFjdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BoeXNpY3NNYW5hZ2VyIGV4dGVuZHMgUGh5c2ljc01hbmFnZXIge1xyXG5cclxuXHQvKiogVGhlIGFycmF5IG9mIHN0YXRpYyBub2RlcyAqL1xyXG5cdHByb3RlY3RlZCBzdGF0aWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xyXG5cclxuXHQvKiogVGhlIGFycmF5IG9mIGR5bmFtaWMgbm9kZXMgKi9cclxuXHRwcm90ZWN0ZWQgZHluYW1pY05vZGVzOiBBcnJheTxQaHlzaWNhbD47XHJcblxyXG5cdC8qKiBUaGUgYXJyYXkgb2YgdGlsZW1hcHMgKi9cclxuXHRwcm90ZWN0ZWQgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xyXG5cclxuXHQvKiogQW4gYXJyYXkgb2YgdGhlIGNvbGxpc2lvbiBtYXNrcyBmb3IgZWFjaCBncm91cCAqL1xyXG5cdHByb3RlY3RlZCBjb2xsaXNpb25NYXNrczogQXJyYXk8bnVtYmVyPjtcclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pil7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5zdGF0aWNOb2RlcyA9IG5ldyBBcnJheSgpO1xyXG5cdFx0dGhpcy5keW5hbWljTm9kZXMgPSBuZXcgQXJyYXkoKTtcclxuXHRcdHRoaXMudGlsZW1hcHMgPSBuZXcgQXJyYXkoKTtcclxuXHRcdHRoaXMuY29sbGlzaW9uTWFza3MgPSBuZXcgQXJyYXkoMzIpO1xyXG5cclxuXHRcdC8vIFBhcnNlIG9wdGlvbnNcclxuXHRcdHRoaXMucGFyc2VPcHRpb25zKG9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGFyc2VzIHRoZSBvcHRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGhlIHBoeXNpY3MgbWFuYWdlclxyXG5cdCAqIEBwYXJhbSBvcHRpb25zIEEgcmVjb3JkIG9mIG9wdGlvbnNcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgcGFyc2VPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuXHRcdGlmKG9wdGlvbnMuZ3JvdXBOYW1lcyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuY29sbGlzaW9ucyAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuZ3JvdXBOYW1lcy5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0bGV0IGdyb3VwID0gb3B0aW9ucy5ncm91cE5hbWVzW2ldO1xyXG5cclxuXHRcdFx0XHQvLyBSZWdpc3RlciB0aGUgZ3JvdXAgbmFtZSBhbmQgbnVtYmVyXHJcblx0XHRcdFx0dGhpcy5ncm91cE5hbWVzW2ldID0gZ3JvdXA7XHJcblxyXG5cdFx0XHRcdHRoaXMuZ3JvdXBNYXAuc2V0KGdyb3VwLCAxIDw8IGkpO1xyXG5cclxuXHRcdFx0XHRsZXQgY29sbGlzaW9uTWFzayA9IDA7XHJcblxyXG5cdFx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCBvcHRpb25zLmNvbGxpc2lvbnNbaV0ubGVuZ3RoOyBqKyspe1xyXG5cdFx0XHRcdFx0aWYob3B0aW9ucy5jb2xsaXNpb25zW2ldW2pdKXtcclxuXHRcdFx0XHRcdFx0Y29sbGlzaW9uTWFzayB8PSAxIDw8IGo7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmNvbGxpc2lvbk1hc2tzW2ldID0gY29sbGlzaW9uTWFzaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0cmVnaXN0ZXJPYmplY3Qobm9kZTogUGh5c2ljYWwpOiB2b2lkIHtcclxuXHRcdGlmKG5vZGUuaXNTdGF0aWMpe1xyXG5cdFx0XHQvLyBTdGF0aWMgYW5kIG5vdCBjb2xsaWRhYmxlXHJcblx0XHRcdHRoaXMuc3RhdGljTm9kZXMucHVzaChub2RlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIER5bmFtaWMgYW5kIG5vdCBjb2xsaWRhYmxlXHJcblx0XHRcdHRoaXMuZHluYW1pY05vZGVzLnB1c2gobm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRkZXJlZ2lzdGVyT2JqZWN0KG5vZGU6IFBoeXNpY2FsKTogdm9pZCB7XHJcblx0XHRjb25zb2xlLmxvZyhcIkRlcmVnaXN0ZXJpbmcgcGh5c2ljcyBvYmplY3RcIik7XHJcblx0XHRpZihub2RlLmlzU3RhdGljKXtcclxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIHN0YXRpYyBsaXN0XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5zdGF0aWNOb2Rlcy5pbmRleE9mKG5vZGUpO1xyXG5cdFx0XHR0aGlzLnN0YXRpY05vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgZHluYW1pYyBsaXN0XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5keW5hbWljTm9kZXMuaW5kZXhPZihub2RlKTtcclxuXHRcdFx0dGhpcy5keW5hbWljTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdHJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcblx0XHR0aGlzLnRpbGVtYXBzLnB1c2godGlsZW1hcCk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcblx0XHRjb25zdCBpbmRleCA9IHRoaXMudGlsZW1hcHMuaW5kZXhPZih0aWxlbWFwKTtcclxuXHRcdHRoaXMudGlsZW1hcHMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Zm9yKGxldCBub2RlIG9mIHRoaXMuZHluYW1pY05vZGVzKXtcclxuXHRcdFx0LyotLS0tLS0tLS0tIElOSVRJQUxJWkFUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xyXG5cdFx0XHQvLyBDbGVhciBmcmFtZSBkZXBlbmRlbnQgYm9vbGVhbiB2YWx1ZXMgZm9yIGVhY2ggbm9kZVxyXG5cdFx0XHRub2RlLm9uR3JvdW5kID0gZmFsc2U7XHJcblx0XHRcdG5vZGUub25DZWlsaW5nID0gZmFsc2U7XHJcblx0XHRcdG5vZGUub25XYWxsID0gZmFsc2U7XHJcblx0XHRcdG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xyXG5cdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0XHQvLyBJZiB0aGlzIG5vZGUgaXMgbm90IGFjdGl2ZSwgZG9uJ3QgcHJvY2VzcyBpdFxyXG5cdFx0XHRpZighbm9kZS5hY3RpdmUpe1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgdGhlIHN3ZXB0IHNoYXBlcyBvZiBlYWNoIG5vZGVcclxuXHRcdFx0aWYobm9kZS5tb3Zpbmcpe1xyXG5cdFx0XHRcdC8vIElmIG1vdmluZywgcmVmbGVjdCB0aGF0IGluIHRoZSBzd2VwdCBzaGFwZVxyXG5cdFx0XHRcdG5vZGUuc3dlcHRSZWN0LnN3ZWVwKG5vZGUuX3ZlbG9jaXR5LCBub2RlLmNvbGxpc2lvblNoYXBlLmNlbnRlciwgbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gSWYgb3VyIG5vZGUgaXNuJ3QgbW92aW5nLCBkb24ndCBib3RoZXIgdG8gY2hlY2sgaXQgKG90aGVyIG5vZGVzIHdpbGwgZGV0ZWN0IGlmIHRoZXkgcnVuIGludG8gaXQpXHJcblx0XHRcdFx0bm9kZS5fdmVsb2NpdHkuemVybygpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKi0tLS0tLS0tLS0gREVURUNUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xyXG5cdFx0XHQvLyBHYXRoZXIgYSBzZXQgb2Ygb3ZlcmxhcHNcclxuXHRcdFx0bGV0IG92ZXJsYXBzID0gbmV3IEFycmF5PEFyZWFDb2xsaXNpb24+KCk7XHJcblxyXG5cdFx0XHRsZXQgZ3JvdXBJbmRleCA9IE1hdGgubG9nMihub2RlLmdyb3VwKTtcclxuXHJcblx0XHRcdC8vIEZpcnN0LCBjaGVjayB0aGlzIG5vZGUgYWdhaW5zdCBldmVyeSBzdGF0aWMgbm9kZSAob3JkZXIgZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgaGVyZSwgc2luY2Ugd2Ugc29ydCBhbnl3YXlzKVxyXG5cdFx0XHRmb3IobGV0IG90aGVyIG9mIHRoaXMuc3RhdGljTm9kZXMpe1xyXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xyXG5cdFx0XHRcdGlmKCFvdGhlci5hY3RpdmUpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRsZXQgY29sbGlkZXIgPSBvdGhlci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcclxuXHRcdFx0XHRpZihhcmVhID4gMCl7XHJcblx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cclxuXHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIG90aGVyLCBcIkdhbWVOb2RlXCIsIG51bGwpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRoZW4sIGNoZWNrIGl0IGFnYWluc3QgZXZlcnkgZHluYW1pYyBub2RlXHJcblx0XHRcdGZvcihsZXQgb3RoZXIgb2YgdGhpcy5keW5hbWljTm9kZXMpe1xyXG5cdFx0XHRcdC8vIElnbm9yZSBvdXJzZWx2ZXNcclxuXHRcdFx0XHRpZihub2RlID09PSBvdGhlcikgY29udGludWU7XHJcblxyXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSBub2Rlc1xyXG5cdFx0XHRcdGlmKCFvdGhlci5hY3RpdmUpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRsZXQgY29sbGlkZXIgPSBvdGhlci5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcclxuXHRcdFx0XHRpZihhcmVhID4gMCl7XHJcblx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cclxuXHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIG90aGVyLCBcIkdhbWVOb2RlXCIsIG51bGwpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExhc3RseSwgZ2F0aGVyIGEgc2V0IG9mIEFBQkJzIGZyb20gdGhlIHRpbGVtYXAuXHJcblx0XHRcdC8vIFRoaXMgc3RlcCBpbnZvbHZlcyB0aGUgbW9zdCBleHRyYSB3b3JrLCBzbyBpdCBpcyBhYnN0cmFjdGVkIGludG8gYSBtZXRob2RcclxuXHRcdFx0Zm9yKGxldCB0aWxlbWFwIG9mIHRoaXMudGlsZW1hcHMpe1xyXG5cdFx0XHRcdC8vIElnbm9yZSBpbmFjdGl2ZSB0aWxlbWFwc1xyXG5cdFx0XHRcdGlmKCF0aWxlbWFwLmFjdGl2ZSkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmKHRpbGVtYXAgaW5zdGFuY2VvZiBPcnRob2dvbmFsVGlsZW1hcCl7XHJcblx0XHRcdFx0XHR0aGlzLmNvbGxpZGVXaXRoT3J0aG9nb25hbFRpbGVtYXAobm9kZSwgdGlsZW1hcCwgb3ZlcmxhcHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU29ydCB0aGUgb3ZlcmxhcHMgYnkgYXJlYVxyXG5cdFx0XHRvdmVybGFwcyA9IG92ZXJsYXBzLnNvcnQoKGEsIGIpID0+IGIuYXJlYSAtIGEuYXJlYSk7XHJcblxyXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIGhpdHMgdG8gdXNlIGxhdGVyXHJcblx0XHRcdGxldCBoaXRzID0gW107XHJcblxyXG5cdFx0XHQvKi0tLS0tLS0tLS0gUkVTT0xVVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cclxuXHRcdFx0Ly8gRm9yIGV2ZXJ5IG92ZXJsYXAsIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIGNvbGxpZGUgd2l0aCBpdCBhbmQgd2hlblxyXG5cdFx0XHRmb3IobGV0IG92ZXJsYXAgb2Ygb3ZlcmxhcHMpe1xyXG5cdFx0XHRcdC8vIElnbm9yZSBub2RlcyB3ZSBkb24ndCBpbnRlcmFjdCB3aXRoXHJcblx0XHRcdFx0aWYodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAhPT0gdW5kZWZpbmVkICYmICh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHQvLyBEbyBhIHN3ZXB0IGxpbmUgdGVzdCBvbiB0aGUgc3RhdGljIEFBQkIgd2l0aCB0aGlzIEFBQkIgc2l6ZSBhcyBwYWRkaW5nICh0aGlzIGlzIGJhc2ljYWxseSB1c2luZyBhIG1pbmtvd3NraSBzdW0hKVxyXG5cdFx0XHRcdC8vIFN0YXJ0IHRoZSBzd2VlcCBhdCB0aGUgcG9zaXRpb24gb2YgdGhpcyBub2RlIHdpdGggYSBkZWx0YSBvZiBfdmVsb2NpdHlcclxuXHRcdFx0XHRjb25zdCBwb2ludCA9IG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyO1xyXG5cdFx0XHRcdGNvbnN0IGRlbHRhID0gbm9kZS5fdmVsb2NpdHk7XHJcblx0XHRcdFx0Y29uc3QgcGFkZGluZyA9IG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemU7XHJcblx0XHRcdFx0Y29uc3Qgb3RoZXJBQUJCID0gb3ZlcmxhcC5jb2xsaWRlcjtcclxuXHJcblxyXG5cdFx0XHRcdGNvbnN0IGhpdCA9IG90aGVyQUFCQi5pbnRlcnNlY3RTZWdtZW50KG5vZGUuY29sbGlzaW9uU2hhcGUuY2VudGVyLCBub2RlLl92ZWxvY2l0eSwgbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZSk7XHJcblxyXG5cdFx0XHRcdG92ZXJsYXAuaGl0ID0gaGl0O1xyXG5cclxuXHRcdFx0XHRpZihoaXQgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0aGl0cy5wdXNoKGhpdCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gV2UgZ290IGEgaGl0LCByZXNvbHZlIHdpdGggdGhlIHRpbWUgaW5zaWRlIG9mIHRoZSBoaXRcclxuXHRcdFx0XHRcdGxldCB0bmVhcnggPSBoaXQubmVhclRpbWVzLng7XHJcblx0XHRcdFx0XHRsZXQgdG5lYXJ5ID0gaGl0Lm5lYXJUaW1lcy55O1xyXG5cclxuXHRcdFx0XHRcdC8vIEFsbG93IGVkZ2UgY2xpcHBpbmcgKGVkZ2Ugb3ZlcmxhcHMgZG9uJ3QgY291bnQsIG9ubHkgYXJlYSBvdmVybGFwcylcclxuXHRcdFx0XHRcdC8vIEltcG9ydGFudGx5IGRvbid0IGFsbG93IGJvdGggY2FzZXMgdG8gYmUgdHJ1ZS4gVGhlbiB3ZSBjbGlwIHRocm91Z2ggY29ybmVycy4gRmF2b3IgeCB0byBoZWxwIHBsYXllcnMgbGFuZCBqdW1wc1xyXG5cdFx0XHRcdFx0aWYodG5lYXJ4IDwgMS4wICYmIChwb2ludC55ID09PSBvdGhlckFBQkIudG9wIC0gcGFkZGluZy55IHx8IHBvaW50LnkgPT09IG90aGVyQUFCQi5ib3R0b20gKyBwYWRkaW5nLnkpICYmIGRlbHRhLnggIT09IDApIHtcclxuXHRcdFx0XHRcdFx0dG5lYXJ4ID0gMS4wO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHRuZWFyeSA8IDEuMCAmJiAocG9pbnQueCA9PT0gb3RoZXJBQUJCLmxlZnQgLSBwYWRkaW5nLnggfHwgcG9pbnQueCA9PT0gb3RoZXJBQUJCLnJpZ2h0ICsgcGFkZGluZy54KSAmJiBkZWx0YS55ICE9PSAwKSB7XHJcblx0XHRcdFx0XHRcdHRuZWFyeSA9IDEuMDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdFx0aWYoaGl0Lm5lYXJUaW1lcy54ID49IDAgJiYgaGl0Lm5lYXJUaW1lcy54IDwgMSl7XHJcblx0XHRcdFx0XHRcdC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcclxuXHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XHJcblx0XHRcdFx0XHRcdFx0bm9kZS5fdmVsb2NpdHkueCA9IG5vZGUuX3ZlbG9jaXR5LnggKiB0bmVhcng7XHJcblx0XHRcdFx0XHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZihoaXQubmVhclRpbWVzLnkgPj0gMCAmJiBoaXQubmVhclRpbWVzLnkgPCAxKXtcclxuXHRcdFx0XHRcdFx0Ly8gQW55IHRpbGVtYXAgb2JqZWN0cyB0aGF0IG1hZGUgaXQgaGVyZSBhcmUgY29sbGlkYWJsZVxyXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT09IFwiVGlsZW1hcFwiIHx8IG92ZXJsYXAub3RoZXIuaXNDb2xsaWRhYmxlKXtcclxuXHRcdFx0XHRcdFx0XHRub2RlLl92ZWxvY2l0eS55ID0gbm9kZS5fdmVsb2NpdHkueSAqIHRuZWFyeTtcclxuXHRcdFx0XHRcdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0LyotLS0tLS0tLS0tIElORk9STUFUSU9OL1RSSUdHRVIgUEhBU0UgLS0tLS0tLS0tLSovXHJcblx0XHRcdC8vIENoZWNrIGlmIHdlIGVuZGVkIHVwIG9uIHRoZSBncm91bmQsIGNlaWxpbmcgb3Igd2FsbFxyXG5cdFx0XHQvLyBBbHNvIGNoZWNrIGZvciB0cmlnZ2Vyc1xyXG5cdFx0XHRmb3IobGV0IG92ZXJsYXAgb2Ygb3ZlcmxhcHMpe1xyXG5cdFx0XHRcdC8vIENoZWNrIGZvciBhIHRyaWdnZXIuIElmIHdlIGNhcmUgYWJvdXQgdGhlIHRyaWdnZXIsIHJlYWN0XHJcblx0XHRcdFx0aWYob3ZlcmxhcC5vdGhlci5pc1RyaWdnZXIgJiYgKG92ZXJsYXAub3RoZXIudHJpZ2dlck1hc2sgJiBub2RlLmdyb3VwKSl7XHJcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGJpdCB0aGF0IHRoaXMgZ3JvdXAgaXMgcmVwcmVzZW50ZWQgYnlcclxuXHRcdFx0XHRcdGxldCBpbmRleCA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKG5vZGUuZ3JvdXApKTtcclxuXHJcblx0XHRcdFx0XHQvLyBFeHRyYWN0IHRoZSB0cmlnZ2VyRW50ZXIgZXZlbnQgbmFtZVxyXG5cdFx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudChvdmVybGFwLm90aGVyLnRyaWdnZXJFbnRlcnNbaW5kZXhdLCB7XHJcblx0XHRcdFx0XHRcdG5vZGU6ICg8R2FtZU5vZGU+bm9kZSkuaWQsXHJcblx0XHRcdFx0XHRcdG90aGVyOiAoPEdhbWVOb2RlPm92ZXJsYXAub3RoZXIpLmlkXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIElnbm9yZSBjb2xsaXNpb24gc2lkZXMgZm9yIG5vZGVzIHdlIGRvbid0IGludGVyYWN0IHdpdGhcclxuXHRcdFx0XHRpZigodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAmIG92ZXJsYXAub3RoZXIuZ3JvdXApID09PSAwKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Ly8gT25seSBjaGVjayBmb3IgZGlyZWN0aW9uIGlmIHRoZSBvdmVybGFwIHdhcyBjb2xsaWRhYmxlXHJcblx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XHJcblx0XHRcdFx0XHRsZXQgY29sbGlzaW9uU2lkZSA9IG92ZXJsYXAuY29sbGlkZXIudG91Y2hlc0FBQkJXaXRob3V0Q29ybmVycyhub2RlLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpKTtcclxuXHRcdFx0XHRcdGlmKGNvbGxpc2lvblNpZGUgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSB0b3VjaCwgbm90IGluY2x1ZGluZyBjb3JuZXIgY2FzZXMsIGNoZWNrIHRoZSBjb2xsaXNpb24gbm9ybWFsXHJcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAuaGl0ICE9PSBudWxsKXtcclxuXHRcdFx0XHRcdFx0XHQvLyBJZiB3ZSBoaXQgYSB0aWxlbWFwLCBrZWVwIHRyYWNrIG9mIGl0XHJcblx0XHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09IFwiVGlsZW1hcFwiKXtcclxuXHRcdFx0XHRcdFx0XHRcdG5vZGUuY29sbGlkZWRXaXRoVGlsZW1hcCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZihjb2xsaXNpb25TaWRlLnkgPT09IC0xKXtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgaXMgb24gdG9wIG9mIG92ZXJsYXAsIHNvIG9uR3JvdW5kXHJcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uR3JvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoY29sbGlzaW9uU2lkZS55ID09PSAxKXtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgaXMgb24gYm90dG9tIG9mIG92ZXJsYXAsIHNvIG9uQ2VpbGluZ1xyXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5vbkNlaWxpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBOb2RlIHdhc24ndCB0b3VjaGluZyBvbiB5LCBzbyBpdCBpcyB0b3VjaGluZyBvbiB4XHJcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uV2FsbCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBjb2xsaXNpb24gd2l0aCB0aGUgbm9kZSwgYW5kIG1vdmUgaXRcclxuXHRcdFx0bm9kZS5maW5pc2hNb3ZlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBIYW5kbGVzIGEgY29sbGlzaW9uIGJldHdlZW4gdGhpcyBub2RlIGFuZCBhbiBvcnRob2dvbmFsIHRpbGVtYXBcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZVxyXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRoZSBub2RlIG1heSBiZSBjb2xsaWRpbmcgd2l0aFxyXG5cdCAqIEBwYXJhbSBvdmVybGFwcyBUaGUgbGlzdCBvZiBvdmVybGFwc1xyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBjb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGU6IFBoeXNpY2FsLCB0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcCwgb3ZlcmxhcHM6IEFycmF5PEFyZWFDb2xsaXNpb24+KTogdm9pZCB7XHJcblx0XHQvLyBHZXQgdGhlIG1pbiBhbmQgbWF4IHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdmluZyBub2RlXHJcblx0XHRsZXQgbWluID0gbmV3IFZlYzIobm9kZS5zd2VwdFJlY3QubGVmdCwgbm9kZS5zd2VwdFJlY3QudG9wKTtcclxuXHRcdGxldCBtYXggPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5yaWdodCwgbm9kZS5zd2VwdFJlY3QuYm90dG9tKTtcclxuXHJcblx0XHQvLyBDb252ZXJ0IHRoZSBtaW4vbWF4IHgveSB0byB0aGUgbWluIGFuZCBtYXggcm93L2NvbCBpbiB0aGUgdGlsZW1hcCBhcnJheVxyXG5cdFx0bGV0IG1pbkluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtaW4pO1xyXG5cdFx0bGV0IG1heEluZGV4ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChtYXgpO1xyXG5cclxuXHRcdGxldCB0aWxlU2l6ZSA9IHRpbGVtYXAuZ2V0VGlsZVNpemUoKTtcclxuXHJcblx0XHQvLyBMb29wIG92ZXIgYWxsIHBvc3NpYmxlIHRpbGVzICh3aGljaCBpc24ndCBtYW55IGluIHRoZSBzY29wZSBvZiB0aGUgdmVsb2NpdHkgcGVyIGZyYW1lKVxyXG5cdFx0Zm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xyXG5cdFx0XHRmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XHJcblx0XHRcdFx0aWYodGlsZW1hcC5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XHJcblx0XHRcdFx0XHQvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxyXG5cdFx0XHRcdFx0bGV0IHRpbGVQb3MgPSBuZXcgVmVjMihjb2wgKiB0aWxlU2l6ZS54ICsgdGlsZVNpemUueC8yLCByb3cgKiB0aWxlU2l6ZS55ICsgdGlsZVNpemUueS8yKTtcclxuXHJcblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgY29sbGlkZXIgZm9yIHRoaXMgdGlsZVxyXG5cdFx0XHRcdFx0bGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xyXG5cclxuXHRcdFx0XHRcdC8vIENhbGN1bGF0ZSBjb2xsaXNpb24gYXJlYSBiZXR3ZWVuIHRoZSBub2RlIGFuZCB0aGUgdGlsZVxyXG5cdFx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XHJcblx0XHRcdFx0XHRpZihhcmVhID4gMCl7XHJcblx0XHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxyXG5cdFx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCB0aWxlbWFwLCBcIlRpbGVtYXBcIiwgbmV3IFZlYzIoY29sLCByb3cpKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IHBoeXNpY3MgbWFuYWdlci5cclxuICogVGhpcyBjbGFzcyBleHBvc2VzIGZ1bmN0aW9ucyBmb3Igc3ViY2xhc3NlcyB0byBpbXBsZW1lbnQgdGhhdCBzaG91bGQgYWxsb3cgZm9yIGEgd29ya2luZyBwaHlzaWNzIHN5c3RlbSB0byBiZSBjcmVhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUGh5c2ljc01hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHQvKiogVGhlIGV2ZW50IHJlY2VpdmVyIGZvciB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cclxuXHRwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cdC8qKiBUaGUgZXZlbnQgZW1pdHRlciBmb3IgdGhlIHBoeXNpY3Mgc3lzdGVtICovXHJcblx0cHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG5cdC8qKiBNYXBzIGxheWVyIG5hbWVzIHRvIG51bWJlcnMgKi9cclxuXHRwcm90ZWN0ZWQgZ3JvdXBNYXA6IE1hcDxudW1iZXI+O1xyXG5cclxuXHQvKiogTWFwcyBsYXllciBudW1iZXJzIHRvIG5hbWVzICovXHJcblx0cHJvdGVjdGVkIGdyb3VwTmFtZXM6IEFycmF5PHN0cmluZz47XHJcblxyXG5cdC8qKiBUaGUgZGVmYXVsdCBncm91cCBuYW1lICovXHJcblx0cHJvdGVjdGVkIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0dST1VQID0gXCJEZWZhdWx0XCI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuXHRcdC8vIFRoZSBjcmVhdGlvbiBhbmQgaW1wbGVtZW50YXRpb24gb2YgbGF5ZXJzIGlzIGRlZmVycmVkIHRvIHRoZSBzdWJjbGFzc1xyXG5cdFx0dGhpcy5ncm91cE1hcCA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMuZ3JvdXBOYW1lcyA9IG5ldyBBcnJheSgpO1xyXG5cdH1cclxuXHJcblx0ZGVzdHJveSgpOiB2b2lkIHtcclxuXHRcdHRoaXMucmVjZWl2ZXIuZGVzdHJveSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIGEgZ2FtZW5vZGUgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxyXG5cdCAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byByZWdpc3RlclxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IHJlZ2lzdGVyT2JqZWN0KG9iamVjdDogUGh5c2ljYWwpOiB2b2lkO1xyXG5cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcclxuXHQgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZGVyZWdpc3RlclxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IGRlcmVnaXN0ZXJPYmplY3Qob2JqZWN0OiBQaHlzaWNhbCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhIHRpbGVtYXAgd2l0aCB0aGlzIHBoeXNpY3MgbWFuYWdlclxyXG5cdCAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRvIHJlZ2lzdGVyXHJcblx0ICovXHJcblx0YWJzdHJhY3QgcmVnaXN0ZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHJlZmVyZW5jZXMgdG8gdGhpcyB0aWxlbWFwIGZyb20gdGhlIHBoeXNpY3MgbWFuYWdlcnJcclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBkZXJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcclxuXHJcblx0YWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgcGh5c2ljcyBsYXllciBvZiB0aGUgR2FtZU5vZGVcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgR2FtZU5vZGVcclxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIGdyb3VwIHRoYXQgdGhlIEdhbWVOb2RlIHNob3VsZCBiZSBvblxyXG5cdCAqL1xyXG5cdHNldEdyb3VwKG5vZGU6IFBoeXNpY2FsLCBncm91cDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHRub2RlLmdyb3VwID0gdGhpcy5ncm91cE1hcC5nZXQoZ3JvdXApO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0cmlldmVzIHRoZSBsYXllciBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lXHJcblx0ICogQHBhcmFtIGxheWVyIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG5cdCAqIEByZXR1cm5zIFRoZSBsYXllciBudW1iZXIsIG9yIDAgaWYgdGhlcmUgaXMgbm90IGEgbGF5ZXIgd2l0aCB0aGF0IG5hbWUgcmVnaXN0ZXJlZFxyXG5cdCAqL1xyXG5cdGdldEdyb3VwTnVtYmVyKGdyb3VwOiBzdHJpbmcpOiBudW1iZXIge1xyXG5cdFx0aWYodGhpcy5ncm91cE1hcC5oYXMoZ3JvdXApKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBNYXAuZ2V0KGdyb3VwKTtcclxuXHRcdH0gZWxzZXtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIGFsbCBncm91cCBuYW1lcyBhc3NvY2lhdGVkIHdpdGggdGhlIG51bWJlciBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSBncm91cHMgQSBtYXNrIG9mIGdyb3Vwc1xyXG5cdCAqIEByZXR1cm5zIEFsbCBncm91cHMgY29udGFpbmVkIGluIHRoZSBtYXNrXHJcblx0ICovXHJcblx0Z2V0R3JvdXBOYW1lcyhncm91cHM6IG51bWJlcik6IEFycmF5PHN0cmluZz4ge1xyXG5cdFx0aWYoZ3JvdXBzID09PSAtMSl7XHJcblx0XHRcdHJldHVybiBbUGh5c2ljc01hbmFnZXIuREVGQVVMVF9HUk9VUF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgZyA9IDE7XHJcblx0XHRcdGxldCBuYW1lcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IDMyOyBpKyspe1xyXG5cdFx0XHRcdGlmKGcgJiBncm91cHMpe1xyXG5cdFx0XHRcdFx0Ly8gVGhpcyBncm91cCBpcyBpbiB0aGUgZ3JvdXBzIG51bWJlclxyXG5cdFx0XHRcdFx0bmFtZXMucHVzaCh0aGlzLmdyb3VwTmFtZXNbaV0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gU2hpZnQgdGhlIGJpdCBvdmVyXHJcblx0XHRcdFx0ZyA9IGcgPDwgMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNvcmRlciB7XHJcblx0cHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblx0cHJpdmF0ZSBsb2c6IFF1ZXVlPExvZ0l0ZW0+O1xyXG5cdHByaXZhdGUgcmVjb3JkaW5nOiBib29sZWFuO1xyXG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuXHRwcml2YXRlIGZyYW1lOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBwbGF5aW5nOiBib29sZWFuO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG5cdFx0dGhpcy5sb2cgPSBuZXcgUXVldWUoMTAwMCk7XHJcblx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmZyYW1lID0gMDtcclxuXHJcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcblx0XHR0aGlzLmV2ZW50UXVldWUuc3Vic2NyaWJlKHRoaXMucmVjZWl2ZXIsIFwiYWxsXCIpO1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLnJlY29yZGluZyl7XHJcblx0XHRcdHRoaXMuZnJhbWUgKz0gMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLnBsYXlpbmcpe1xyXG5cdFx0XHQvLyBJZiBwbGF5aW5nLCBpZ25vcmUgZXZlbnRzLCBqdXN0IGZlZWQgdGhlIHJlY29yZCB0byB0aGUgZXZlbnQgcXVldWVcclxuXHRcdFx0dGhpcy5yZWNlaXZlci5pZ25vcmVFdmVudHMoKTtcclxuXHJcblx0XHRcdC8qXHJcblx0XHRcdFx0V2hpbGUgdGhlcmUgaXMgYSBuZXh0IGl0ZW0sIGFuZCB3aGlsZSBpdCBzaG91bGQgb2NjdXIgaW4gdGhpcyBmcmFtZSxcclxuXHRcdFx0XHRzZW5kIHRoZSBldmVudC4gaS5lLiwgd2hpbGUgY3VycmVudF9mcmFtZSAqIGN1cnJlbnRfZGVsdGFfdCBpcyBncmVhdGVyXHJcblx0XHRcdFx0dGhhbiByZWNvcmRlZF9mcmFtZSAqIHJlY29yZGVkX2RlbHRhX3RcclxuXHRcdFx0Ki9cclxuXHRcdFx0d2hpbGUodGhpcy5sb2cuaGFzSXRlbXMoKVxyXG5cdFx0XHRcdFx0JiYgdGhpcy5sb2cucGVla05leHQoKS5mcmFtZSAqIHRoaXMubG9nLnBlZWtOZXh0KCkuZGVsdGEgPCB0aGlzLmZyYW1lICogZGVsdGFUKXtcclxuXHRcdFx0XHRsZXQgZXZlbnQgPSB0aGlzLmxvZy5kZXF1ZXVlKCkuZXZlbnQ7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coZXZlbnQpO1xyXG5cdFx0XHRcdHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChldmVudCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKCF0aGlzLmxvZy5oYXNJdGVtcygpKXtcclxuXHRcdFx0XHR0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5mcmFtZSArPSAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gSWYgbm90IHBsYXlpbmcsIGhhbmRsZSBldmVudHNcclxuXHRcdFx0d2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XHJcblx0XHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcblx0XHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5TVE9QX1JFQ09SRElORyl7XHJcblx0XHRcdFx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYodGhpcy5yZWNvcmRpbmcpe1xyXG5cdFx0XHRcdFx0dGhpcy5sb2cuZW5xdWV1ZShuZXcgTG9nSXRlbSh0aGlzLmZyYW1lLCBkZWx0YVQsIGV2ZW50KSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlNUQVJUX1JFQ09SRElORyl7XHJcblx0XHRcdFx0XHR0aGlzLmxvZy5jbGVhcigpO1xyXG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0dGhpcy5mcmFtZSA9IDBcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9SRUNPUkRJTkcpe1xyXG5cdFx0XHRcdFx0dGhpcy5mcmFtZSA9IDA7XHJcblx0XHRcdFx0XHR0aGlzLnJlY29yZGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0dGhpcy5wbGF5aW5nID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmNsYXNzIExvZ0l0ZW0ge1xyXG5cdGZyYW1lOiBudW1iZXI7XHJcblx0ZGVsdGE6IG51bWJlcjtcclxuXHRldmVudDogR2FtZUV2ZW50O1xyXG5cclxuXHRjb25zdHJ1Y3RvcihmcmFtZTogbnVtYmVyLCBkZWx0YVQ6IG51bWJlciwgZXZlbnQ6IEdhbWVFdmVudCl7XHJcblx0XHR0aGlzLmZyYW1lID0gZnJhbWU7XHJcblx0XHR0aGlzLmRlbHRhID0gZGVsdGFUO1xyXG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xyXG5cdH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlZ2lzdHJ5PFQ+IGV4dGVuZHMgTWFwPFQ+e1xyXG5cclxuICAgIC8qKiBQcmVsb2FkcyByZWdpc3RyeSBkYXRhICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgcHJlbG9hZCgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGFuIGl0ZW0gYW5kIHByZWxvYWRzIGFueSBuZWNlc3NhcnkgZmlsZXNcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZWdpc3RlciB0aGlzIGl0ZW0gd2l0aFxyXG4gICAgICogQHBhcmFtIGFyZ3MgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIG5lZWRlZCBmb3IgcmVnaXN0cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nLCAuLi5hcmdzOiBhbnkpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGFuIGl0ZW0gYW5kIHByZWxvYWRzIGFueSBuZWNlc3NhcnkgZmlsZXNcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byByZWdpc3RlciB0aGlzIGl0ZW0gd2l0aFxyXG4gICAgICogQHBhcmFtIGFyZ3MgQW55IGFkaXRpb25hbCBhcmd1bWVudHMgbmVlZGVkIGZvciByZWdpc3RyYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IHJlZ2lzdGVySXRlbShrZXk6IHN0cmluZywgLi4uYXJnczogYW55KTogdm9pZDtcclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlXCI7XHJcbmltcG9ydCBMYWJlbFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9MYWJlbFNoYWRlclR5cGVcIjtcclxuaW1wb3J0IFBvaW50U2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1BvaW50U2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgUmVjdFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgU3ByaXRlU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1Nwcml0ZVNoYWRlclR5cGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cnlcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHJlZ2lzdHJ5IHRoYXQgaGFuZGxlcyBzaGFkZXJzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJSZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5PFNoYWRlclR5cGU+IHtcclxuXHJcblx0Ly8gU2hhZGVyIG5hbWVzXHJcblx0cHVibGljIHN0YXRpYyBQT0lOVF9TSEFERVIgPSBcInBvaW50XCI7XHJcblx0cHVibGljIHN0YXRpYyBSRUNUX1NIQURFUiA9IFwicmVjdFwiO1xyXG5cdHB1YmxpYyBzdGF0aWMgU1BSSVRFX1NIQURFUiA9IFwic3ByaXRlXCI7XHJcblx0cHVibGljIHN0YXRpYyBMQUJFTF9TSEFERVIgPSBcImxhYmVsXCI7XHJcblxyXG5cdHByaXZhdGUgcmVnaXN0cnlJdGVtczogQXJyYXk8U2hhZGVyUmVnaXN0cnlJdGVtPiA9IG5ldyBBcnJheSgpO1xyXG5cclxuXHQvKipcclxuXHQgKiBQcmVsb2FkcyBhbGwgYnVpbHQtaW4gc2hhZGVyc1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBwcmVsb2FkKCl7XHJcblx0XHQvLyBHZXQgdGhlIHJlc291cmNlTWFuYWdlciBhbmQgcXVldWUgYWxsIGJ1aWx0LWluIHNoYWRlcnMgZm9yIHByZWxvYWRpbmdcclxuXHRcdGNvbnN0IHJtID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblxyXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgcG9pbnQgc2hhZGVyXHJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuUE9JTlRfU0hBREVSLCBQb2ludFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3BvaW50LnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvcG9pbnQuZnNoYWRlclwiKTtcclxuXHJcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSByZWN0IHNoYWRlclxyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlJFQ1RfU0hBREVSLCBSZWN0U2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvcmVjdC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3JlY3QuZnNoYWRlclwiKTtcclxuXHJcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBzcHJpdGUgc2hhZGVyXHJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUiwgU3ByaXRlU2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvc3ByaXRlLnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvc3ByaXRlLmZzaGFkZXJcIik7XHJcblx0XHJcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBsYWJlbCBzaGFkZXJcclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5MQUJFTF9TSEFERVIsIExhYmVsU2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvbGFiZWwudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9sYWJlbC5mc2hhZGVyXCIpO1xyXG5cclxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgYW55IHByZWxvYWRlZCBpdGVtc1xyXG5cdFx0Zm9yKGxldCBpdGVtIG9mIHRoaXMucmVnaXN0cnlJdGVtcyl7XHJcblx0XHRcdGNvbnN0IHNoYWRlciA9IG5ldyBpdGVtLmNvbnN0cihpdGVtLmtleSk7XHJcblx0XHRcdHNoYWRlci5pbml0QnVmZmVyT2JqZWN0KCk7XHJcblx0XHRcdHRoaXMuYWRkKGl0ZW0ua2V5LCBzaGFkZXIpO1xyXG5cclxuXHRcdFx0Ly8gTG9hZCBpZiBkZXNpcmVkXHJcblx0XHRcdGlmKGl0ZW0ucHJlbG9hZCAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0XHRybS5zaGFkZXIoaXRlbS5rZXksIGl0ZW0ucHJlbG9hZC52c2hhZGVyTG9jYXRpb24sIGl0ZW0ucHJlbG9hZC5mc2hhZGVyTG9jYXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgYSBzaGFkZXIgaW4gdGhlIHJlZ2lzdHJ5IGFuZCBsb2FkcyBpdCBiZWZvcmUgdGhlIGdhbWUgYmVnaW5zXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHlvdSB3aXNoIHRvIGFzc2lnbiB0byB0aGUgc2hhZGVyXHJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIFNoYWRlclR5cGVcclxuXHQgKiBAcGFyYW0gdnNoYWRlckxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvZiB0aGUgdmVydGV4IHNoYWRlclxyXG5cdCAqIEBwYXJhbSBmc2hhZGVyTG9jYXRpb24gdGhlIGxvY2F0aW9uIG9mIHRoZSBmcmFnbWVudCBzaGFkZXJcclxuXHQgKi9cclxuXHRwdWJsaWMgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZywgY29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZSwgdnNoYWRlckxvY2F0aW9uOiBzdHJpbmcsIGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nKTogdm9pZCB7XHJcblx0XHRsZXQgc2hhZGVyUHJlbG9hZCA9IG5ldyBTaGFkZXJQcmVsb2FkKCk7XHJcblx0XHRzaGFkZXJQcmVsb2FkLnZzaGFkZXJMb2NhdGlvbiA9IHZzaGFkZXJMb2NhdGlvbjtcclxuXHRcdHNoYWRlclByZWxvYWQuZnNoYWRlckxvY2F0aW9uID0gZnNoYWRlckxvY2F0aW9uO1xyXG5cclxuXHRcdGxldCByZWdpc3RyeUl0ZW0gPSBuZXcgU2hhZGVyUmVnaXN0cnlJdGVtKCk7XHJcblx0XHRyZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xyXG5cdFx0cmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcclxuXHRcdHJlZ2lzdHJ5SXRlbS5wcmVsb2FkID0gc2hhZGVyUHJlbG9hZDtcclxuXHJcblx0XHR0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIGEgc2hhZGVyIGluIHRoZSByZWdpc3RyeS4gTk9URTogSWYgeW91IHVzZSB0aGlzLCB5b3UgTVVTVCBsb2FkIHRoZSBzaGFkZXIgYmVmb3JlIHVzZS5cclxuXHQgKiBJZiB5b3Ugd2lzaCB0byBwcmVsb2FkIHRoZSBzaGFkZXIsIHVzZSByZWdpc3RlckFuZFByZWxvYWRJdGVtKClcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgeW91IHdpc2ggdG8gYXNzaWduIHRvIHRoZSBzaGFkZXJcclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgU2hhZGVyVHlwZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGUpOiB2b2lkIHtcclxuXHRcdGxldCByZWdpc3RyeUl0ZW0gPSBuZXcgU2hhZGVyUmVnaXN0cnlJdGVtKCk7XHJcblx0XHRyZWdpc3RyeUl0ZW0ua2V5ID0ga2V5O1xyXG5cdFx0cmVnaXN0cnlJdGVtLmNvbnN0ciA9IGNvbnN0cjtcclxuXHJcblx0XHR0aGlzLnJlZ2lzdHJ5SXRlbXMucHVzaChyZWdpc3RyeUl0ZW0pO1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgU2hhZGVyUmVnaXN0cnlJdGVtIHtcclxuXHRrZXk6IHN0cmluZztcclxuXHRjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlO1xyXG5cdHByZWxvYWQ6IFNoYWRlclByZWxvYWQ7XHJcbn1cclxuXHJcbmNsYXNzIFNoYWRlclByZWxvYWQge1xyXG5cdHZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xyXG5cdGZzaGFkZXJMb2NhdGlvbjogc3RyaW5nO1xyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cmllcy9SZWdpc3RyeVwiO1xyXG5pbXBvcnQgU2hhZGVyUmVnaXN0cnkgZnJvbSBcIi4vUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBSZWdpc3RyeSBpcyB0aGUgc3lzdGVtJ3Mgd2F5IG9mIGNvbnZlcnRpbmcgY2xhc3NlcyBhbmQgdHlwZXMgaW50byBzdHJpbmdcclxuICogcmVwcmVzZW50YXRpb25zIGZvciB1c2UgZWxzZXdoZXJlIGluIHRoZSBhcHBsaWNhdGlvbi5cclxuICogSXQgYWxsb3dzIGNsYXNzZXMgdG8gYmUgYWNjZXNzZWQgd2l0aG91dCBleHBsaWNpdGx5IHVzaW5nIGNvbnN0cnVjdG9ycyBpbiBjb2RlLFxyXG4gKiBhbmQgZm9yIHJlc291cmNlcyB0byBiZSBsb2FkZWQgYXQgR2FtZSBjcmVhdGlvbiB0aW1lLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVnaXN0cnlNYW5hZ2VyIHtcclxuXHJcblx0cHVibGljIHN0YXRpYyBzaGFkZXJzID0gbmV3IFNoYWRlclJlZ2lzdHJ5KCk7XHJcblxyXG5cdC8qKiBBZGRpdGlvbmFsIGN1c3RvbSByZWdpc3RyaWVzIHRvIGFkZCB0byB0aGUgcmVnaXN0cnkgbWFuYWdlciAqL1xyXG5cdHByb3RlY3RlZCBzdGF0aWMgcmVnaXN0cmllczogTWFwPFJlZ2lzdHJ5PGFueT4+ID0gbmV3IE1hcCgpO1xyXG5cclxuXHRzdGF0aWMgcHJlbG9hZCgpe1xyXG5cdFx0dGhpcy5zaGFkZXJzLnByZWxvYWQoKTtcclxuXHJcblx0XHR0aGlzLnJlZ2lzdHJpZXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHRoaXMucmVnaXN0cmllcy5nZXQoa2V5KS5wcmVsb2FkKCkpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGFkZEN1c3RvbVJlZ2lzdHJ5KG5hbWU6IHN0cmluZywgcmVnaXN0cnk6IFJlZ2lzdHJ5PGFueT4pe1xyXG5cdFx0dGhpcy5yZWdpc3RyaWVzLmFkZChuYW1lLCByZWdpc3RyeSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0UmVnaXN0cnkoa2V5OiBzdHJpbmcpe1xyXG5cdFx0cmV0dXJuIHRoaXMucmVnaXN0cmllcy5nZXQoa2V5KTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgeyBBbmltYXRpb25EYXRhLCBBbmltYXRpb25TdGF0ZSB9IGZyb20gXCIuL0FuaW1hdGlvblR5cGVzXCI7XHJcblxyXG4vKipcclxuICogQW4gYW5pbWF0aW9uIG1hbmFnZXIgY2xhc3MgZm9yIGFuIGFuaW1hdGVkIENhbnZhc05vZGUuXHJcbiAqIFRoaXMgY2xhc3Mga2VlcHMgdHJhY2sgb2YgdGhlIHBvc3NpYmxlIGFuaW1hdGlvbnMsIGFzIHdlbGwgYXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlLFxyXG4gKiBhbmQgYWJzdHJhY3RzIGFsbCBpbnRlcmFjdGlvbnMgd2l0aCBwbGF5aW5nLCBwYXVzaW5nLCBhbmQgc3RvcHBpbmcgYW5pbWF0aW9ucyBhcyB3ZWxsIGFzIFxyXG4gKiBjcmVhdGluZyBuZXcgYW5pbWF0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uTWFuYWdlciB7XHJcbiAgICAvKiogVGhlIG93bmVyIG9mIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cclxuICAgIHByb3RlY3RlZCBvd25lcjogQ2FudmFzTm9kZTtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSBvZiB0aGlzIHNwcml0ZSAqL1xyXG4gICAgcHJvdGVjdGVkIGFuaW1hdGlvblN0YXRlOiBBbmltYXRpb25TdGF0ZTtcclxuXHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIG9mIHRoaXMgc3ByaXRlICovXHJcbiAgICBwcm90ZWN0ZWQgY3VycmVudEFuaW1hdGlvbjogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGlzIGFuaW1hdGlvbiAqL1xyXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRGcmFtZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHRocm91Z2ggdGhlIGN1cnJlbnQgZnJhbWUgKi9cclxuICAgIHByb3RlY3RlZCBmcmFtZVByb2dyZXNzOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGxvb3Bpbmcgb3Igbm90ICovXHJcbiAgICBwcm90ZWN0ZWQgbG9vcDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIG1hcCBvZiBhbmltYXRpb25zICovXHJcbiAgICBwcm90ZWN0ZWQgYW5pbWF0aW9uczogTWFwPEFuaW1hdGlvbkRhdGE+O1xyXG5cclxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKGlmIGFueSkgdG8gc2VuZCB3aGVuIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdG9wcyBwbGF5aW5nLiAqL1xyXG4gICAgcHJvdGVjdGVkIG9uRW5kRXZlbnQ6IHN0cmluZztcclxuXHJcbiAgICAvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoaXMgYW5pbWF0aW9uIG1hbmFnZXIgKi9cclxuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAgIC8qKiBBIHF1ZXVlZCBhbmltYXRpb24gKi9cclxuICAgIHByb3RlY3RlZCBwZW5kaW5nQW5pbWF0aW9uOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIFRoZSBsb29wIHN0YXR1cyBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXHJcbiAgICBwcm90ZWN0ZWQgcGVuZGluZ0xvb3A6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBvbkVuZCBldmVudCBvZiBhIHBlbmRpbmcgYW5pbWF0aW9uICovXHJcbiAgICBwcm90ZWN0ZWQgcGVuZGluZ09uRW5kOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFuaW1hdGlvbk1hbmFnZXJcclxuICAgICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgb2YgdGhlIEFuaW1hdGlvbk1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3duZXI6IENhbnZhc05vZGUpe1xyXG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gYW5pbWF0aW9uIHRvIHRoaXMgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5IG9mIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiBkYXRhXHJcbiAgICAgKi9cclxuICAgIGFkZChrZXk6IHN0cmluZywgYW5pbWF0aW9uOiBBbmltYXRpb25EYXRhKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmFkZChrZXksIGFuaW1hdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBzcGVjaWZpZWQgYnkgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCBjdXJyZW50IGZyYW1lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggaW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4KCk6IG51bWJlciB7XHJcbiAgICAgICAgaWYodGhpcy5hbmltYXRpb25zLmhhcyh0aGlzLmN1cnJlbnRBbmltYXRpb24pKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9ucy5nZXQodGhpcy5jdXJyZW50QW5pbWF0aW9uKS5mcmFtZXNbdGhpcy5jdXJyZW50RnJhbWVdLmluZGV4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCB3YXJuIHRoZSB1c2VyXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5pbWF0aW9uIGluZGV4IHdhcyByZXF1ZXN0ZWQsIGJ1dCB0aGUgY3VycmVudCBhbmltYXRpb246ICR7dGhpcy5jdXJyZW50QW5pbWF0aW9ufSB3YXMgaW52YWxpZGApO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBhbmltYXRpb24gaXMgY3VycmVudGx5IHBsYXlpbmdcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYW5pbWF0aW9uIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIGlzIHBsYXlpbmcsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBpc1BsYXlpbmcoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50QW5pbWF0aW9uID09PSBrZXkgJiYgdGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBhbmltYXRpb24gaW5kZXggYW5kIGFkdmFuY2VzIHRoZSBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpOiBudW1iZXIge1xyXG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCBwbGF5aW5nLCB3ZSB3b24ndCBiZSBhZHZhbmNpbmcgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgIGlmKCEodGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORykpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbmRleCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5hbmltYXRpb25zLmhhcyh0aGlzLmN1cnJlbnRBbmltYXRpb24pKXtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KHRoaXMuY3VycmVudEFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5pbmRleDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGFuaW1hdGlvblxyXG4gICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgKz0gMTtcclxuICAgICAgICAgICAgaWYodGhpcy5mcmFtZVByb2dyZXNzID49IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5kdXJhdGlvbil7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGJlZW4gb24gdGhpcyBmcmFtZSBmb3IgaXRzIHdob2xlIGR1cmF0aW9uLCBnbyB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudEZyYW1lID49IGN1cnJlbnRBbmltYXRpb24uZnJhbWVzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhpcyBhbmltYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmxvb3Ape1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDdXJyZW50QW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGN1cnJlbnQgYW5pbWF0aW9uLCBjYW4ndCBhZHZhbmNlLiBXYXJuIHRoZSB1c2VyXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQW5pbWF0aW9uIGluZGV4IGFuZCBhZHZhbmNlIHdhcyByZXF1ZXN0ZWQsIGJ1dCB0aGUgY3VycmVudCBhbmltYXRpb24gKCR7dGhpcy5jdXJyZW50QW5pbWF0aW9ufSkgaW4gbm9kZSB3aXRoIGlkOiAke3RoaXMub3duZXIuaWR9IHdhcyBpbnZhbGlkYCk7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogRW5kcyB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIGZpcmVzIGFueSBuZWNlc3NhcnkgZXZlbnRzLCBhcyB3ZWxsIGFzIHN0YXJ0aW5nIGFueSBuZXcgYW5pbWF0aW9ucyAqL1xyXG4gICAgcHJvdGVjdGVkIGVuZEN1cnJlbnRBbmltYXRpb24oKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG5cclxuICAgICAgICBpZih0aGlzLm9uRW5kRXZlbnQgIT09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25FbmRFdmVudCwge293bmVyOiB0aGlzLm93bmVyLmlkLCBhbmltYXRpb246IHRoaXMuY3VycmVudEFuaW1hdGlvbn0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGFuaW1hdGlvbiwgcGxheSBpdFxyXG4gICAgICAgIGlmKHRoaXMucGVuZGluZ0FuaW1hdGlvbiAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMucGxheSh0aGlzLnBlbmRpbmdBbmltYXRpb24sIHRoaXMucGVuZGluZ0xvb3AsIHRoaXMucGVuZGluZ09uRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gRG9lcyBub3QgcmVzdGFydCBpdCBpZiBpdCBpcyBhbHJlYWR5IHBsYXlpbmdcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBwbGF5XHJcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBhbmltYXRpb24uIEZhbHNlIGJ5IGRlZmF1bHRcclxuICAgICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHBsYXlJZk5vdEFscmVhZHkoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A/OiBib29sZWFuLCBvbkVuZD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMuY3VycmVudEFuaW1hdGlvbiAhPT0gYW5pbWF0aW9uKXtcclxuICAgICAgICAgICAgdGhpcy5wbGF5KGFuaW1hdGlvbiwgbG9vcCwgb25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxyXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgYW5pbWF0aW9uLiBGYWxzZSBieSBkZWZhdWx0XHJcbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIG5hbWUgb2YgYW4gZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgYW5pbWF0aW9uIG5hdHVyYWxseSBzdG9wcyBwbGF5aW5nLiBUaGlzIG9ubHkgbWF0dGVycyBpZiBsb29wIGlzIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBwbGF5KGFuaW1hdGlvbjogc3RyaW5nLCBsb29wPzogYm9vbGVhbiwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcblxyXG4gICAgICAgIC8vIElmIGxvb3AgYXJnIHdhcyBwcm92aWRlZCwgdXNlIHRoYXRcclxuICAgICAgICBpZihsb29wICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIHdoYXQgdGhlIGpzb24gZmlsZSBzcGVjaWZpZWRcclxuICAgICAgICAgICAgdGhpcy5sb29wID0gdGhpcy5hbmltYXRpb25zLmdldChhbmltYXRpb24pLnJlcGVhdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG9uRW5kICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBvbkVuZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRW5kRXZlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzZXQgcGVuZGluZyBhbmltYXRpb25cclxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUXVldWVzIGEgc2luZ2xlIGFuaW1hdGlvbiB0byBiZSBwbGF5ZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLiBEb2VzIE5PVCBzdGFjay5cclxuICAgICAqIFF1ZXVlaW5nIGFkZGl0aW9uYWwgYW5pbWF0aW9ucyBwYXN0IDEgd2lsbCBqdXN0IHJlcGxhY2UgdGhlIHF1ZXVlZCBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIGFuaW1hdGlvbiB0byBxdWV1ZVxyXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIGxvb3AgdGhlIHF1ZXVlZCBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBvbkVuZCBUaGUgZXZlbnQgdG8gZmlyZSB3aGVuIHRoZSBxdWV1ZWQgYW5pbWF0aW9uIGVuZHNcclxuICAgICAqL1xyXG4gICAgcXVldWUoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A6IGJvb2xlYW4gPSBmYWxzZSwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9vcCA9IGxvb3A7XHJcbiAgICAgICAgaWYob25FbmQgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ09uRW5kID0gb25FbmQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nT25FbmQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogUGF1c2VzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiAqL1xyXG4gICAgcGF1c2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBBVVNFRDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVzdW1lcyB0aGUgY3VycmVudCBhbmltYXRpb24gaWYgcG9zc2libGUgKi9cclxuICAgIHJlc3VtZSgpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpe1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFN0b3BzIHRoZSBjdXJyZW50IGFuaW1hdGlvbi4gVGhlIGFuaW1hdGlvbiBjYW5ub3QgYmUgcmVzdW1lZCBhZnRlciB0aGlzLiAqL1xyXG4gICAgc3RvcCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuICAgIH1cclxufSIsImltcG9ydCB7IFR3ZWVuYWJsZVByb3BlcnRpZXMgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IHsgRWFzZUZ1bmN0aW9uVHlwZSB9IGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuZXhwb3J0IGVudW0gQW5pbWF0aW9uU3RhdGUge1xyXG4gICAgU1RPUFBFRCA9IDAsXHJcbiAgICBQQVVTRUQgPSAxLFxyXG4gICAgUExBWUlORyA9IDIsXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBBbmltYXRpb25EYXRhIHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGZyYW1lczogQXJyYXk8e2luZGV4OiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXJ9PjtcclxuICAgIHJlcGVhdDogYm9vbGVhbiA9IGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHdlZW5FZmZlY3Qge1xyXG4gICAgLyoqIFRoZSBwcm9wZXJ0eSB0byB0d2VlbiAqL1xyXG4gICAgcHJvcGVydHk6IFR3ZWVuYWJsZVByb3BlcnRpZXM7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBUd2VlbiBzaG91bGQgcmVzZXQgdGhlIHByb3BlcnR5IHRvIGl0cyBvcmlnaW5hbCB2YWx1ZSBhZnRlciBwbGF5aW5nICovXHJcbiAgICByZXNldE9uQ29tcGxldGU6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIHR3ZWVuICovXHJcbiAgICBzdGFydDogYW55O1xyXG5cclxuICAgIC8qKiBUaGUgZW5kaW5nIHZhbHVlIGZvciB0aGUgdHdlZW4gKi9cclxuICAgIGVuZDogYW55O1xyXG5cclxuICAgIC8qKiBUaGUgZWFzZSBmdW5jdGlvbiB0byB1c2UgKi9cclxuICAgIGVhc2U6IEVhc2VGdW5jdGlvblR5cGU7XHJcblxyXG4gICAgLyoqIERPIE5PVCBNT0RJRlkgLSBUaGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5IC0gc2V0IGF1dG9tYXRpY2FsbHkgKi9cclxuICAgIGluaXRpYWxWYWx1ZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHdlZW5EYXRhIHtcclxuICAgIC8vIE1lbWJlcnMgZm9yIGluaXRpYWxpemF0aW9uIGJ5IHRoZSB1c2VyXHJcbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgdHdlZW4gKi9cclxuICAgIHN0YXJ0RGVsYXk6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgZHVyYXRpb24gb2YgdGltZSBvdmVyIHdoaWNoIHRoZSB2YWx1ZSB3aXRoIGNoYW5nZSBmcm9tIHN0YXJ0IHRvIGVuZCAqL1xyXG4gICAgZHVyYXRpb246IG51bWJlcjtcclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgZWZmZWN0cyBvbiB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0ICovXHJcbiAgICBlZmZlY3RzOiBBcnJheTxUd2VlbkVmZmVjdD47XHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBzaG91bGQgcmV2ZXJzZSBmcm9tIGVuZCB0byBzdGFydCBmb3IgZWFjaCBwcm9wZXJ0eSB3aGVuIGl0IGZpbmlzaGVzICovXHJcbiAgICByZXZlcnNlT25Db21wbGV0ZTogYm9vbGVhbjtcclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIHNob3VsZCBsb29wIHdoZW4gaXQgY29tcGxldGVzICovXHJcbiAgICBsb29wOiBib29sZWFuO1xyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIChpZiBhbnkpIHdoZW4gdGhlIHR3ZWVuIGZpbmlzaGVzIHBsYXlpbmcgKi9cclxuICAgIG9uRW5kOiBzdHJpbmdcclxuICAgIFxyXG4gICAgLy8gTWVtYmVycyBmb3IgbWFuYWdlbWVudCBieSB0aGUgdHdlZW4gbWFuYWdlclxyXG4gICAgLyoqIFRoZSBwcm9ncmVzcyBvZiB0aGlzIHR3ZWVuIHRocm91Z2ggaXRzIGVmZmVjdHMgKi9cclxuICAgIHByb2dyZXNzOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0aGF0IGhhcyBwYXNzZWQgZnJvbSB3aGVuIHRoaXMgdHdlZW4gc3RhcnRlZCBydW5uaW5nICovXHJcbiAgICBlbGFwc2VkVGltZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgc3RhdGUgb2YgdGhpcyB0d2VlbiAqL1xyXG4gICAgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIGlzIGN1cnJlbnRseSByZXZlcnNpbmcgKi9cclxuICAgIHJldmVyc2luZzogYm9vbGVhbjtcclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgeyBBbmltYXRpb25TdGF0ZSwgVHdlZW5EYXRhIH0gZnJvbSBcIi4vQW5pbWF0aW9uVHlwZXNcIjtcclxuaW1wb3J0IEVhc2VGdW5jdGlvbnMgZnJvbSBcIi4uLy4uL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBUd2Vlbk1hbmFnZXIgZnJvbSBcIi4vVHdlZW5NYW5hZ2VyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWFuYWdlciBmb3IgdGhlIHR3ZWVucyBvZiBhIEdhbWVOb2RlLlxyXG4gKiBUd2VlbnMgYXJlIHNob3J0IGFuaW1hdGlvbnMgcGxheWVkIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiB0d28gcHJvcGVydGllcyB1c2luZyBhbiBlYXNpbmcgZnVuY3Rpb24uXHJcbiAqIEZvciBhIGdvb2QgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMsIGNoZWNrIG91dCBAbGluayhodHRwczovL2Vhc2luZ3MubmV0LykoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pLlxyXG4gKiBNdWx0aXBsZSB0d2VlbiBjYW4gYmUgcGxheWVkIGF0IHRoZSBzYW1lIHRpbWUsIGFzIGxvbmcgYXMgdGhleSBkb24ndCBjaGFuZ2UgdGhlIHNhbWUgcHJvcGVydHkuXHJcbiAqIFRoaXMgYWxsb3dzIGZvciBzb21lIGludGVyZXN0aW5nIHBvbGlzaGVzIG9yIGFuaW1hdGlvbnMgdGhhdCBtYXkgYmUgdmVyeSBkaWZmaWN1bHQgdG8gZG8gd2l0aCBzcHJpdGUgd29yayBhbG9uZVxyXG4gKiAtIGVzcGVjaWFsbHkgcGl4ZWwgYXJ0IChzdWNoIGFzIHJvdGF0aW9ucyBvciBzY2FsaW5nKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuQ29udHJvbGxlciB7XHJcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoaXMgVHdlZW5Db250cm9sbGVyIGFjdHMgdXBvbiAqL1xyXG4gICAgcHJvdGVjdGVkIG93bmVyOiBHYW1lTm9kZTtcclxuICAgIC8qKiBUaGUgbGlzdCBvZiBjcmVhdGVkIHR3ZWVucyAqL1xyXG4gICAgcHJvdGVjdGVkIHR3ZWVuczogTWFwPFR3ZWVuRGF0YT47XHJcbiAgICAvKiogQW4gZXZlbnQgZW1pdHRlciAqL1xyXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFR3ZWVuQ29udHJvbGxlclxyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgVHdlZW5Db250cm9sbGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG93bmVyOiBHYW1lTm9kZSl7XHJcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgICAgIHRoaXMudHdlZW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcblxyXG4gICAgICAgIC8vIEdpdmUgb3Vyc2VsdmVzIHRvIHRoZSBUd2Vlbk1hbmFnZXJcclxuICAgICAgICBUd2Vlbk1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5yZWdpc3RlclR3ZWVuQ29udHJvbGxlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgVHdlZW5Db250cm9sbGVyXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKXtcclxuICAgICAgICAvLyBPbmx5IHRoZSBnYW1lbm9kZSBhbmQgdGhlIHR3ZWVuIG1hbmFnZXIgc2hvdWxkIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhpc1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm93bmVyLnR3ZWVucztcclxuICAgICAgICBUd2Vlbk1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5kZXJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdHdlZW4gdG8gdGhpcyBnYW1lIG5vZGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuXHJcbiAgICAgKiBAcGFyYW0gdHdlZW4gVGhlIGRhdGEgb2YgdGhlIHR3ZWVuXHJcbiAgICAgKi9cclxuICAgIGFkZChrZXk6IHN0cmluZywgdHdlZW46IFJlY29yZDxzdHJpbmcsIGFueT4gfCBUd2VlbkRhdGEpOiB2b2lkIHtcclxuICAgICAgICBsZXQgdHlwZWRUd2VlbiA9IDxUd2VlbkRhdGE+dHdlZW47XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgbWVtYmVycyB0aGF0IHdlIG5lZWQgKGFuZCB0aGUgdXNlciBkaWRuJ3QgcHJvdmlkZSlcclxuICAgICAgICB0eXBlZFR3ZWVuLnByb2dyZXNzID0gMDtcclxuICAgICAgICB0eXBlZFR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0eXBlZFR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuXHJcbiAgICAgICAgdGhpcy50d2VlbnMuYWRkKGtleSwgdHlwZWRUd2Vlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5IGEgdHdlZW4gd2l0aCBhIGNlcnRhaW4gbmFtZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGxheVxyXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdGhlIHR3ZWVuIHNob3VsZCBsb29wXHJcbiAgICAgKi9cclxuICAgIHBsYXkoa2V5OiBzdHJpbmcsIGxvb3A/OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBsb29wIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBpZihsb29wICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgdHdlZW4ubG9vcCA9IGxvb3A7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XHJcbiAgICAgICAgICAgICAgICBpZihlZmZlY3QucmVzZXRPbkNvbXBsZXRlKXtcclxuICAgICAgICAgICAgICAgICAgICBlZmZlY3QuaW5pdGlhbFZhbHVlID0gdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdHdlZW4gcnVubmluZ1xyXG4gICAgICAgICAgICB0d2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcbiAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgICB0d2Vlbi5yZXZlcnNpbmcgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRyaWVkIHRvIHBsYXkgdHdlZW4gXCIke2tleX1cIiBvbiBub2RlIHdpdGggaWQgJHt0aGlzLm93bmVyLmlkfSwgYnV0IG5vIHN1Y2ggdHdlZW4gZXhpc3RzYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGF1c2VzIGEgcGxheWluZyB0d2Vlbi4gRG9lcyBub3QgYWZmZWN0IHR3ZWVucyB0aGF0IGFyZSBzdG9wcGVkLlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcGF1c2UuXHJcbiAgICAgKi9cclxuICAgIHBhdXNlKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICB0aGlzLnR3ZWVucy5nZXQoa2V5KS5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBBVVNFRDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXN1bWVzIGEgcGF1c2VkIHR3ZWVuLlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW4gdG8gcmVzdW1lXHJcbiAgICAgKi9cclxuICAgIHJlc3VtZShrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcclxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QQVVTRUQpXHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0d2VlblxyXG4gICAgICovXHJcbiAgICBzdG9wKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRvIHRoZSBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcclxuICAgICAgICAgICAgICAgIGlmKGVmZmVjdC5yZXNldE9uQ29tcGxldGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XSA9IGVmZmVjdC5pbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmF0dXJhbCBzdG9wIG9mIGEgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGVuZChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc3RvcChrZXkpO1xyXG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSB0d2VlblxyXG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGhhcyBhbiBvbkVuZCwgc2VuZCBhbiBldmVudFxyXG4gICAgICAgICAgICBpZih0d2Vlbi5vbkVuZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHR3ZWVuLm9uRW5kLCB7a2V5OiBrZXksIG5vZGU6IHRoaXMub3duZXIuaWR9KTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBhbGwgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5zXHJcbiAgICAgKi9cclxuICAgIHN0b3BBbGwoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50d2VlbnMuZm9yRWFjaChrZXkgPT4gdGhpcy5zdG9wKGtleSkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZih0d2Vlbi5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUExBWUlORyl7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIG9mIHRoZSB0d2VlblxyXG4gICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgKz0gZGVsdGFUKjEwMDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgcGFzdCB0aGUgc3RhcnREZWxheSwgZG8gdGhlIHR3ZWVuXHJcbiAgICAgICAgICAgICAgICBpZih0d2Vlbi5lbGFwc2VkVGltZSA+PSB0d2Vlbi5zdGFydERlbGF5KXtcclxuICAgICAgICAgICAgICAgICAgICBpZighdHdlZW4ucmV2ZXJzaW5nICYmIHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkgKyB0d2Vlbi5kdXJhdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG92ZXIgdGltZSwgc3RvcCB0aGUgdHdlZW4sIGxvb3AsIG9yIHJldmVyc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ucmV2ZXJzZU9uQ29tcGxldGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgb3ZlciB0aW1lIGFuZCBjYW4gcmV2ZXJzZSwgZG8gc29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0d2Vlbi5sb29wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHJldmVyc2UgYW5kIGNhbiBsb29wLCBkbyBzb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gdHdlZW4uZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmVuJ3QgbG9vcGluZyBhbmQgY2FuJ3QgcmV2ZXJzZSwgc28gc3RvcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBlbmQgb2YgcmV2ZXJzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ucmV2ZXJzaW5nICYmIHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkgKyAyKnR3ZWVuLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ubG9vcCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5yZXZlcnNpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lIC09IDIqdHdlZW4uZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByb2dyZXNzLCBtYWtlIHN1cmUgaXQgaXMgYmV0d2VlbiAwIGFuZCAxLiBFcnJvcnMgZnJvbSB0aGlzIHNob3VsZCBuZXZlciBiZSBsYXJnZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2luZyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnByb2dyZXNzID0gTWF0aFV0aWxzLmNsYW1wMDEoKDIqdHdlZW4uZHVyYXRpb24gLSAodHdlZW4uZWxhcHNlZFRpbWUtIHR3ZWVuLnN0YXJ0RGVsYXkpKS90d2Vlbi5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSBNYXRoVXRpbHMuY2xhbXAwMSgodHdlZW4uZWxhcHNlZFRpbWUgLSB0d2Vlbi5zdGFydERlbGF5KS90d2Vlbi5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWUgZnJvbSB0aGUgZWFzZSBmdW5jdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIG91ciBwcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWFzZSA9IEVhc2VGdW5jdGlvbnNbZWZmZWN0LmVhc2VdKHR3ZWVuLnByb2dyZXNzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgdmFsdWUgdG8gbGVycCB0aGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gTWF0aFV0aWxzLmxlcnAoZWZmZWN0LnN0YXJ0LCBlZmZlY3QuZW5kLCBlYXNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFR3ZWVuQ29udHJvbGxlciBmcm9tIFwiLi9Ud2VlbkNvbnRyb2xsZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR3ZWVuTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBUd2Vlbk1hbmFnZXIgPSBudWxsO1xyXG4gICAgXHJcbiAgICBwcm90ZWN0ZWQgdHdlZW5Db250cm9sbGVyczogQXJyYXk8VHdlZW5Db250cm9sbGVyPjtcclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzID0gbmV3IEFycmF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCk6IFR3ZWVuTWFuYWdlciB7XHJcbiAgICAgICAgaWYoVHdlZW5NYW5hZ2VyLmluc3RhbmNlID09PSBudWxsKXtcclxuICAgICAgICAgICAgVHdlZW5NYW5hZ2VyLmluc3RhbmNlID0gbmV3IFR3ZWVuTWFuYWdlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFR3ZWVuTWFuYWdlci5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3RlclR3ZWVuQ29udHJvbGxlcihjb250cm9sbGVyOiBUd2VlbkNvbnRyb2xsZXIpe1xyXG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycy5wdXNoKGNvbnRyb2xsZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIoY29udHJvbGxlcjogVHdlZW5Db250cm9sbGVyKXtcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKTtcclxuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhclR3ZWVuQ29udHJvbGxlcnMoKXtcclxuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBmb3IobGV0IHR3ZWVuQ29udHJvbGxlciBvZiB0aGlzLnR3ZWVuQ29udHJvbGxlcnMpe1xyXG4gICAgICAgICAgICB0d2VlbkNvbnRyb2xsZXIudXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBHcmFwaGljUmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL0dyYXBoaWNSZW5kZXJlclwiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCJcclxuaW1wb3J0IFRpbGVtYXBSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvVGlsZW1hcFJlbmRlcmVyXCI7XHJcbmltcG9ydCBVSUVsZW1lbnRSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvVUlFbGVtZW50UmVuZGVyZXJcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XHJcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcblxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFJlbmRlcmluZ01hbmFnZXIgY2xhc3MgdXNpbmcgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcclxuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuICAgIHByb3RlY3RlZCBncmFwaGljUmVuZGVyZXI6IEdyYXBoaWNSZW5kZXJlcjtcclxuICAgIHByb3RlY3RlZCB0aWxlbWFwUmVuZGVyZXI6IFRpbGVtYXBSZW5kZXJlcjtcclxuICAgIHByb3RlY3RlZCB1aUVsZW1lbnRSZW5kZXJlcjogVUlFbGVtZW50UmVuZGVyZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIG9yaWdpbjogVmVjMjtcclxuICAgIHByb3RlY3RlZCB6b29tOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpe1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy53b3JsZFNpemUgPSBuZXcgVmVjMih3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlciA9IG5ldyBHcmFwaGljUmVuZGVyZXIodGhpcy5jdHgpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyID0gbmV3IFRpbGVtYXBSZW5kZXJlcih0aGlzLmN0eCk7XHJcbiAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlciA9IG5ldyBVSUVsZW1lbnRSZW5kZXJlcih0aGlzLmN0eClcclxuXHJcbiAgICAgICAgLy8gRm9yIGNyaXNwIHBpeGVsIGFydFxyXG4gICAgICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICByZW5kZXIodmlzaWJsZVNldDogQ2FudmFzTm9kZVtdLCB0aWxlbWFwczogVGlsZW1hcFtdLCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZCB7XHJcbiAgICAgICAgLy8gU29ydCBieSBkZXB0aCwgdGhlbiBieSB2aXNpYmxlIHNldCBieSB5LXZhbHVlXHJcbiAgICAgICAgdmlzaWJsZVNldC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGlmKGEuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpID09PSBiLmdldExheWVyKCkuZ2V0RGVwdGgoKSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGEuYm91bmRhcnkuYm90dG9tKSAtIChiLmJvdW5kYXJ5LmJvdHRvbSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRMYXllcigpLmdldERlcHRoKCkgLSBiLmdldExheWVyKCkuZ2V0RGVwdGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgdGlsZW1hcEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgdGlsZW1hcExlbmd0aCA9IHRpbGVtYXBzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgbGV0IHZpc2libGVTZXRJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IHZpc2libGVTZXRMZW5ndGggPSB2aXNpYmxlU2V0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgd2hpbGUodGlsZW1hcEluZGV4IDwgdGlsZW1hcExlbmd0aCB8fCB2aXNpYmxlU2V0SW5kZXggPCB2aXNpYmxlU2V0TGVuZ3RoKXtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgY29uZGl0aW9ucyB3aGVyZSB3ZSd2ZSBhbHJlYWR5IHJlYWNoZWQgdGhlIGVkZ2Ugb2Ygb25lIGxpc3RcclxuICAgICAgICAgICAgaWYodGlsZW1hcEluZGV4ID49IHRpbGVtYXBMZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSByZW5kZXIgdGhlIHJlbWFpbmluZyB2aXNpYmxlIHNldFxyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIGlmKG5vZGUudmlzaWJsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHZpc2libGVTZXRJbmRleCA+PSB2aXNpYmxlU2V0TGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVuZGVyIHRpbGVtYXBzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGVtYXAodGlsZW1hcHNbdGlsZW1hcEluZGV4KytdKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW5kZXIgd2hpY2hldmVyIGlzIGZ1cnRoZXIgZG93blxyXG4gICAgICAgICAgICBpZih0aWxlbWFwc1t0aWxlbWFwSW5kZXhdLmdldExheWVyKCkuZ2V0RGVwdGgoKSA8PSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleF0uZ2V0TGF5ZXIoKS5nZXREZXB0aCgpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZW1hcCh0aWxlbWFwc1t0aWxlbWFwSW5kZXgrK10pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aXNpYmxlU2V0W3Zpc2libGVTZXRJbmRleCsrXTtcclxuICAgICAgICAgICAgICAgIGlmKG5vZGUudmlzaWJsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW5kZXIgdGhlIHVpTGF5ZXJzIG9uIHRvcCBvZiBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICBsZXQgc29ydGVkVUlMYXllcnMgPSBuZXcgQXJyYXk8VUlMYXllcj4oKTtcclxuXHJcbiAgICAgICAgdWlMYXllcnMuZm9yRWFjaChrZXkgPT4gc29ydGVkVUlMYXllcnMucHVzaCh1aUxheWVycy5nZXQoa2V5KSkpO1xyXG5cclxuICAgICAgICBzb3J0ZWRVSUxheWVycyA9IHNvcnRlZFVJTGF5ZXJzLnNvcnQoKHVpMSwgdWkyKSA9PiB1aTEuZ2V0RGVwdGgoKSAtIHVpMi5nZXREZXB0aCgpKTtcclxuXHJcbiAgICAgICAgc29ydGVkVUlMYXllcnMuZm9yRWFjaCh1aUxheWVyID0+IHtcclxuXHRcdFx0aWYoIXVpTGF5ZXIuaXNIaWRkZW4oKSlcclxuXHRcdFx0XHR1aUxheWVyLmdldEl0ZW1zKCkuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZigoPENhbnZhc05vZGU+bm9kZSkudmlzaWJsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZSg8Q2FudmFzTm9kZT5ub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcblx0XHR9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBzcGVjaWZpZWQgQ2FudmFzTm9kZVxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIENhbnZhc05vZGUgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCByZW5kZXJOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbihub2RlKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB6b29tIGxldmVsIG9mIHRoZSBzY2VuZVxyXG4gICAgICAgIHRoaXMuem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTW92ZSB0aGUgY2FudmFzIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbmQgcm90YXRlXHJcbiAgICAgICAgbGV0IHhTY2FsZSA9IDE7XHJcbiAgICAgICAgbGV0IHlTY2FsZSA9IDE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XHJcbiAgICAgICAgICAgIHhTY2FsZSA9IG5vZGUuaW52ZXJ0WCA/IC0xIDogMTtcclxuICAgICAgICAgICAgeVNjYWxlID0gbm9kZS5pbnZlcnRZID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHhTY2FsZSwgMCwgMCwgeVNjYWxlLCAobm9kZS5wb3NpdGlvbi54IC0gdGhpcy5vcmlnaW4ueCkqdGhpcy56b29tLCAobm9kZS5wb3NpdGlvbi55IC0gdGhpcy5vcmlnaW4ueSkqdGhpcy56b29tKTtcclxuICAgICAgICB0aGlzLmN0eC5yb3RhdGUoLW5vZGUucm90YXRpb24pO1xyXG4gICAgICAgIGxldCBnbG9iYWxBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBSZWN0KXtcclxuICAgICAgICAgICAgRGVidWcubG9nKFwibm9kZVwiICsgbm9kZS5pZCwgXCJOb2RlXCIgKyBub2RlLmlkICsgXCIgQWxwaGE6IFwiICsgbm9kZS5hbHBoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbm9kZS5hbHBoYTtcclxuICAgICAgICBcclxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckFuaW1hdGVkU3ByaXRlKDxBbmltYXRlZFNwcml0ZT5ub2RlKTtcclxuICAgICAgICB9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU3ByaXRlKDxTcHJpdGU+bm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBHcmFwaGljKXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmFwaGljKDxHcmFwaGljPm5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgVUlFbGVtZW50KXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJVSUVsZW1lbnQoPFVJRWxlbWVudD5ub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcHJvdGVjdGVkIHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHNwcml0ZS5pbWFnZUlkKTtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSBpbWFnZTpcclxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc3RhcnQgLT4geCwgeVxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzaXplICAtPiB3LCBoXHJcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgd29ybGRcclxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc3RhcnQgLT4geCwgeVxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzaXplICAtPiB3LCBoXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXHJcbiAgICAgICAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC54LCBzcHJpdGUuaW1hZ2VPZmZzZXQueSxcclxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCwgc3ByaXRlLnNpemUueSxcclxuICAgICAgICAgICAgKC1zcHJpdGUuc2l6ZS54KnNwcml0ZS5zY2FsZS54LzIpKnRoaXMuem9vbSwgKC1zcHJpdGUuc2l6ZS55KnNwcml0ZS5zY2FsZS55LzIpKnRoaXMuem9vbSxcclxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCAqIHNwcml0ZS5zY2FsZS54KnRoaXMuem9vbSwgc3ByaXRlLnNpemUueSAqIHNwcml0ZS5zY2FsZS55KnRoaXMuem9vbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdldCB0aGUgaW1hZ2UgZnJvbSB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHNwcml0ZS5pbWFnZUlkKTtcclxuXHJcbiAgICAgICAgbGV0IGFuaW1hdGlvbkluZGV4ID0gc3ByaXRlLmFuaW1hdGlvbi5nZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTtcclxuXHJcbiAgICAgICAgbGV0IGFuaW1hdGlvbk9mZnNldCA9IHNwcml0ZS5nZXRBbmltYXRpb25PZmZzZXQoYW5pbWF0aW9uSW5kZXgpO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIGltYWdlOlxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzdGFydCAtPiB4LCB5XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHNpemUgIC0+IHcsIGhcclxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSB3b3JsZCAoZ2l2ZW4gd2UgbW92ZWQpXHJcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHN0YXJ0IC0+IC13LzIsIC1oLzJcclxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc2l6ZSAgLT4gdywgaFxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxyXG4gICAgICAgICAgICBzcHJpdGUuaW1hZ2VPZmZzZXQueCArIGFuaW1hdGlvbk9mZnNldC54LCBzcHJpdGUuaW1hZ2VPZmZzZXQueSArIGFuaW1hdGlvbk9mZnNldC55LFxyXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54LCBzcHJpdGUuc2l6ZS55LFxyXG4gICAgICAgICAgICAoLXNwcml0ZS5zaXplLngqc3ByaXRlLnNjYWxlLngvMikqdGhpcy56b29tLCAoLXNwcml0ZS5zaXplLnkqc3ByaXRlLnNjYWxlLnkvMikqdGhpcy56b29tLFxyXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54ICogc3ByaXRlLnNjYWxlLngqdGhpcy56b29tLCBzcHJpdGUuc2l6ZS55ICogc3ByaXRlLnNjYWxlLnkqdGhpcy56b29tKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkIHtcclxuICAgICAgICBpZihncmFwaGljIGluc3RhbmNlb2YgUG9pbnQpe1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJQb2ludCg8UG9pbnQ+Z3JhcGhpYywgdGhpcy56b29tKTtcclxuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIExpbmUpe1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJMaW5lKDxMaW5lPmdyYXBoaWMsIHRoaXMub3JpZ2luLCB0aGlzLnpvb20pO1xyXG4gICAgICAgIH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgUmVjdCl7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlclJlY3QoPFJlY3Q+Z3JhcGhpYywgdGhpcy56b29tKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGlsZW1hcCBpbnN0YW5jZW9mIE9ydGhvZ29uYWxUaWxlbWFwKXtcclxuICAgICAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIucmVuZGVyT3J0aG9nb25hbFRpbGVtYXAoPE9ydGhvZ29uYWxUaWxlbWFwPnRpbGVtYXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBMYWJlbCl7XHJcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyTGFiZWwodWlFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgQnV0dG9uKXtcclxuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJCdXR0b24odWlFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgU2xpZGVyKXtcclxuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJTbGlkZXIodWlFbGVtZW50KTtcclxuICAgICAgICB9IGVsc2UgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgVGV4dElucHV0KXtcclxuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJUZXh0SW5wdXQodWlFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXIoY2xlYXJDb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53b3JsZFNpemUueCwgdGhpcy53b3JsZFNpemUueSk7XHJcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY2xlYXJDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGhlbHAgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHJlbmRlciBAcmVmZXJlbmNlW0dyYXBoaWNdc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhpY1JlbmRlcmVyIHtcclxuICAgIC8qKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBvZiB0aGUgZ2FtZSBlbmdpbmUgKi9cclxuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIC8qKiBUaGUgY3VycmVudCBzY2VuZSAqL1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuICAgIC8qKiBUaGUgcmVuZGVyaW5nIGNvbnRleHQgKi9cclxuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgR3JhcGhpY1JlbmRlcmVyXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAqL1xyXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcclxuICAgICAqL1xyXG4gICAgcmVuZGVyUG9pbnQocG9pbnQ6IFBvaW50LCB6b29tOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHBvaW50LmNvbG9yLnRvU3RyaW5nUkdCQSgpO1xyXG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KCgtcG9pbnQuc2l6ZS54LzIpKnpvb20sICgtcG9pbnQuc2l6ZS55LzIpKnpvb20sXHJcbiAgICAgICAgcG9pbnQuc2l6ZS54Knpvb20sIHBvaW50LnNpemUueSp6b29tKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXJMaW5lKGxpbmU6IExpbmUsIG9yaWdpbjogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBsaW5lLmNvbG9yLnRvU3RyaW5nUkdCQSgpO1xyXG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IGxpbmUudGhpY2tuZXNzO1xyXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygwLCAwKTtcclxuICAgICAgICB0aGlzLmN0eC5saW5lVG8oKGxpbmUuZW5kLnggLSBsaW5lLnN0YXJ0LngpKnpvb20sIChsaW5lLmVuZC55IC0gbGluZS5zdGFydC55KSp6b29tKTtcclxuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSByZWN0XHJcbiAgICAgKiBAcGFyYW0gcmVjdCBUaGUgcmVjdCB0byByZW5kZXJcclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclJlY3QocmVjdDogUmVjdCwgem9vbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRHJhdyB0aGUgaW50ZXJpb3Igb2YgdGhlIHJlY3RcclxuICAgICAgICBpZihyZWN0LmNvbG9yLmEgIT09IDApe1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSByZWN0LmNvbG9yLnRvU3RyaW5nUkdCKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KCgtcmVjdC5zaXplLngvMikqem9vbSwgKC1yZWN0LnNpemUueS8yKSp6b29tLCByZWN0LnNpemUueCp6b29tLCByZWN0LnNpemUueSp6b29tKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgdGhlIGJvcmRlciBvZiB0aGUgcmVjdCBpZiBpdCBpc24ndCB0cmFuc3BhcmVudFxyXG4gICAgICAgIGlmKHJlY3QuYm9yZGVyQ29sb3IuYSAhPT0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gcmVjdC5nZXRCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHJlY3QuZ2V0Qm9yZGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlUmVjdCgoLXJlY3Quc2l6ZS54LzIpKnpvb20sICgtcmVjdC5zaXplLnkvMikqem9vbSwgcmVjdC5zaXplLngqem9vbSwgcmVjdC5zaXplLnkqem9vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHRvIHJlbmRlciBAcmVmZXJlbmNlW1RpbGVtYXBdc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZW1hcFJlbmRlcmVyIHtcclxuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpe1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBvZiB0aGlzIFRpbGVtYXBSZW5kZXJlclxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgKi9cclxuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYW4gb3J0aG9nb25hbCB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyT3J0aG9nb25hbFRpbGVtYXAodGlsZW1hcDogT3J0aG9nb25hbFRpbGVtYXApOiB2b2lkIHtcclxuICAgICAgICBsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdGlsZW1hcC5nZXRMYXllcigpLmdldEFscGhhKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IG9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKHRpbGVtYXApO1xyXG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zY2VuZS5nZXRWaWV3cG9ydCgpLmdldEhhbGZTaXplKCk7XHJcbiAgICAgICAgbGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xyXG4gICAgICAgIGxldCBib3R0b21SaWdodCA9IG9yaWdpbi5jbG9uZSgpLmFkZChzaXplLnNjYWxlZCgyKnpvb20pKTtcclxuXHJcbiAgICAgICAgaWYodGlsZW1hcC52aXNpYmxlKXtcclxuICAgICAgICAgICAgbGV0IG1pbkNvbFJvdyA9IHRpbGVtYXAuZ2V0Q29sUm93QXQob3JpZ2luKTtcclxuICAgICAgICAgICAgbGV0IG1heENvbFJvdyA9IHRpbGVtYXAuZ2V0Q29sUm93QXQoYm90dG9tUmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCB4ID0gbWluQ29sUm93Lng7IHggPD0gbWF4Q29sUm93Lng7IHgrKyl7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IHkgPSBtaW5Db2xSb3cueTsgeSA8PSBtYXhDb2xSb3cueTsgeSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRpbGUgYXQgdGhpcyBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlID0gdGlsZW1hcC5nZXRUaWxlQXRSb3dDb2wobmV3IFZlYzIoeCwgeSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSByb3QvZmxpcCBwYXJhbWV0ZXJzIGlmIHRoZXJlIGFyZSBhbnlcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gKDB4RSA8PCAyOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm90RmxpcCA9ICgobWFzayAmIHRpbGUpID4+IDI4KSAmIDB4RjtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlID0gdGlsZSAmIH5tYXNrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aWxlc2V0IHRoYXQgb3ducyB0aGlzIHRpbGUgaW5kZXggYW5kIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwLmdldFRpbGVzZXRzKCkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aWxlc2V0Lmhhc1RpbGUodGlsZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlKHRpbGVzZXQsIHRpbGUsIHgsIHksIG9yaWdpbiwgdGlsZW1hcC5zY2FsZSwgem9vbSwgcm90RmxpcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSB0aWxlXHJcbiAgICAgKiBAcGFyYW0gdGlsZXNldCBUaGUgdGlsZXNldCB0aGlzIHRpbGUgYmVsb25ncyB0byBcclxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcFJvdyBUaGUgcm93IG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcENvbCBUaGUgY29sdW1uIG9mIHRoZSB0aWxlIGluIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHJlbmRlclRpbGUodGlsZXNldDogVGlsZXNldCwgdGlsZUluZGV4OiBudW1iZXIsIHRpbGVtYXBSb3c6IG51bWJlciwgdGlsZW1hcENvbDogbnVtYmVyLCBvcmlnaW46IFZlYzIsIHNjYWxlOiBWZWMyLCB6b29tOiBudW1iZXIsIHJvdEZsaXA6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEltYWdlKHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxyXG4gICAgICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRpbGVzZXQuZ2V0U3RhcnRJbmRleCgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHJvdyBhbmQgY29sIG9mIHRoZSB0aWxlIGluIGltYWdlIHNwYWNlXHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aWxlc2V0LmdldE51bUNvbHMoKSk7XHJcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGlsZXNldC5nZXROdW1Db2xzKCk7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gdGlsZXNldC5nZXRUaWxlU2l6ZSgpLng7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS55O1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxyXG4gICAgICAgIGxldCBsZWZ0ID0gY29sICogd2lkdGg7XHJcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBpbiB0aGUgd29ybGQgdG8gcmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKHRpbGVtYXBSb3cgKiB3aWR0aCAqIHNjYWxlLngpO1xyXG4gICAgICAgIGxldCB5ID0gTWF0aC5mbG9vcih0aWxlbWFwQ29sICogaGVpZ2h0ICogc2NhbGUueSk7XHJcblxyXG4gICAgICAgIGxldCB3b3JsZFggPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luLngpKnpvb20pO1xyXG4gICAgICAgIGxldCB3b3JsZFkgPSBNYXRoLmZsb29yKCh5IC0gb3JpZ2luLnkpKnpvb20pO1xyXG4gICAgICAgIGxldCB3b3JsZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pO1xyXG4gICAgICAgIGxldCB3b3JsZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBzY2FsZS55ICogem9vbSk7XHJcblxyXG4gICAgICAgIGlmKHJvdEZsaXAgIT09IDApe1xyXG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gMTtcclxuICAgICAgICAgICAgbGV0IHNjYWxlWSA9IDE7XHJcbiAgICAgICAgICAgIGxldCBzaGVhclggPSAwO1xyXG4gICAgICAgICAgICBsZXQgc2hlYXJZID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIEZsaXAgb24gdGhlIHgtYXhpc1xyXG4gICAgICAgICAgICBpZihyb3RGbGlwICYgOCl7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVggPSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmxpcCBvbiB0aGUgeS1heGlzXHJcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiA0KXtcclxuICAgICAgICAgICAgICAgIHNjYWxlWSA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGbGlwIG92ZXIgdGhlIGxpbmUgeT14XHJcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiAyKXtcclxuICAgICAgICAgICAgICAgIHNoZWFyWCA9IHNjYWxlWTtcclxuICAgICAgICAgICAgICAgIHNoZWFyWSA9IHNjYWxlWDtcclxuICAgICAgICAgICAgICAgIHNjYWxlWCA9IDA7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCBzaGVhclgsIHNoZWFyWSwgc2NhbGVZLCB3b3JsZFggKyB3b3JsZFdpZHRoLzIsIHdvcmxkWSArIHdvcmxkSGVpZ2h0LzIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHRpbGVcclxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxyXG4gICAgICAgICAgICAgICAgbGVmdCwgdG9wLFxyXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcclxuICAgICAgICAgICAgICAgIC13b3JsZFdpZHRoLzIsIC13b3JsZEhlaWdodC8yLFxyXG4gICAgICAgICAgICAgICAgd29ybGRXaWR0aCwgd29ybGRIZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgaWYocm90RmxpcCAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyByb3RhdGlvbnMsIGRvbid0IGRvIHRoZSBjYWxjdWxhdGlvbnMsIGp1c3QgcmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgdGlsZVxyXG4gICAgICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0LCB0b3AsXHJcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgd29ybGRYLCB3b3JsZFksXHJcbiAgICAgICAgICAgICAgICB3b3JsZFdpZHRoLCB3b3JsZEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyXCI7XHJcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbVUlFbGVtZW50XXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJRWxlbWVudFJlbmRlcmVyIHtcclxuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpe1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBvZiB0aGlzIFVJRWxlbWVudFJlbmRlcmVyXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAqL1xyXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIGxhYmVsXHJcbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJMYWJlbChsYWJlbDogTGFiZWwpOiB2b2lkIHtcclxuICAgICAgICAvLyBJZiB0aGUgc2l6ZSBpcyB1bmFzc2lnbmVkIChieSB0aGUgdXNlciBvciBhdXRvbWF0aWNhbGx5KSBhc3NpZ24gaXRcclxuICAgICAgICBsYWJlbC5oYW5kbGVJbml0aWFsU2l6aW5nKHRoaXMuY3R4KTtcclxuXHRcdFxyXG5cdFx0Ly8gR3JhYiB0aGUgZ2xvYmFsIGFscGhhIHNvIHdlIGNhbiBhZGp1c3QgaXQgZm9yIHRoaXMgcmVuZGVyXHJcblx0XHRsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGZvbnQgYW5kIHRleHQgcG9zaXRpb24gaW4gbGFiZWxcclxuXHRcdHRoaXMuY3R4LmZvbnQgPSBsYWJlbC5nZXRGb250U3RyaW5nKCk7XHJcblx0XHRsZXQgb2Zmc2V0ID0gbGFiZWwuY2FsY3VsYXRlVGV4dE9mZnNldCh0aGlzLmN0eCk7XHJcblxyXG5cdFx0Ly8gU3Ryb2tlIGFuZCBmaWxsIGEgcm91bmRlZCByZWN0IGFuZCBnaXZlIGl0IHRleHRcclxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYmFja2dyb3VuZENvbG9yLmE7XHJcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBsYWJlbC5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKS50b1N0cmluZ1JHQkEoKTtcclxuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCgtbGFiZWwuc2l6ZS54LzIsIC1sYWJlbC5zaXplLnkvMixcclxuXHRcdFx0bGFiZWwuc2l6ZS54LCBsYWJlbC5zaXplLnksIGxhYmVsLmJvcmRlclJhZGl1cyk7XHJcblx0XHRcclxuXHRcdHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGFiZWwuY2FsY3VsYXRlQm9yZGVyQ29sb3IoKS50b1N0cmluZ1JHQkEoKTtcclxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwuYm9yZGVyQ29sb3IuYTtcclxuXHRcdHRoaXMuY3R4LmxpbmVXaWR0aCA9IGxhYmVsLmJvcmRlcldpZHRoO1xyXG5cdFx0dGhpcy5jdHguc3Ryb2tlUm91bmRlZFJlY3QoLWxhYmVsLnNpemUueC8yLCAtbGFiZWwuc2l6ZS55LzIsXHJcblx0XHRcdGxhYmVsLnNpemUueCwgbGFiZWwuc2l6ZS55LCBsYWJlbC5ib3JkZXJSYWRpdXMpO1xyXG5cclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZVRleHRDb2xvcigpO1xyXG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC50ZXh0Q29sb3IuYTtcclxuXHRcdHRoaXMuY3R4LmZpbGxUZXh0KGxhYmVsLnRleHQsIG9mZnNldC54IC0gbGFiZWwuc2l6ZS54LzIsIG9mZnNldC55IC0gbGFiZWwuc2l6ZS55LzIpO1xyXG5cdFxyXG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIGJ1dHRvblxyXG4gICAgICogQHBhcmFtIGJ1dHRvbiBUaGUgYnV0dG9uIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJCdXR0b24oYnV0dG9uOiBCdXR0b24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnJlbmRlckxhYmVsKGJ1dHRvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgc2xpZGVyXHJcbiAgICAgKiBAcGFyYW0gc2xpZGVyIFRoZSBzbGlkZXIgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclNsaWRlcihzbGlkZXI6IFNsaWRlcik6IHZvaWQge1xyXG5cdFx0Ly8gR3JhYiB0aGUgZ2xvYmFsIGFscGhhIHNvIHdlIGNhbiBhZGp1c3QgaXQgZm9yIHRoaXMgcmVuZGVyXHJcblx0XHRsZXQgcHJldmlvdXNBbHBoYSA9IHRoaXMuY3R4Lmdsb2JhbEFscGhhO1xyXG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBzbGlkZXIuZ2V0TGF5ZXIoKS5nZXRBbHBoYSgpO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWFsYXRlIHRoZSBzbGlkZXIgc2l6ZVxyXG4gICAgICAgIGxldCBzbGlkZXJTaXplID0gbmV3IFZlYzIoc2xpZGVyLnNpemUueCwgMik7XHJcblxyXG4gICAgICAgIC8vIERyYXcgdGhlIHNsaWRlclxyXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gc2xpZGVyLnNsaWRlckNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHR0aGlzLmN0eC5maWxsUm91bmRlZFJlY3QoLXNsaWRlclNpemUueC8yLCAtc2xpZGVyU2l6ZS55LzIsXHJcbiAgICAgICAgICAgIHNsaWRlclNpemUueCwgc2xpZGVyU2l6ZS55LCBzbGlkZXIuYm9yZGVyUmFkaXVzKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuaWIgc2l6ZSBhbmQgcG9zaXRpb25cclxuICAgICAgICBsZXQgeCA9IE1hdGhVdGlscy5sZXJwKC1zbGlkZXIuc2l6ZS54LzIsIHNsaWRlci5zaXplLngvMiwgc2xpZGVyLmdldFZhbHVlKCkpO1xyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSBuaWJcclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNsaWRlci5uaWJDb2xvci50b1N0cmluZygpO1xyXG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KHgtc2xpZGVyLm5pYlNpemUueC8yLCAtc2xpZGVyLm5pYlNpemUueS8yLFxyXG4gICAgICAgICAgICBzbGlkZXIubmliU2l6ZS54LCBzbGlkZXIubmliU2l6ZS55LCBzbGlkZXIuYm9yZGVyUmFkaXVzKTtcclxuXHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFscGhhXHJcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHRleHRJbnB1dFxyXG4gICAgICogQHBhcmFtIHRleHRJbnB1dCBUaGUgdGV4dElucHV0IHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJUZXh0SW5wdXQodGV4dElucHV0OiBUZXh0SW5wdXQpOiB2b2lkIHtcclxuICAgICAgICAvLyBTaG93IGEgY3Vyc29yIHNvbWV0aW1lc1xyXG4gICAgICAgIGlmKHRleHRJbnB1dC5mb2N1c2VkICYmIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICUgNjAgPiAzMCl7XHJcbiAgICAgICAgICAgIHRleHRJbnB1dC50ZXh0ICs9IFwifFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZW5kZXJMYWJlbCh0ZXh0SW5wdXQpO1xyXG5cclxuICAgICAgICBpZih0ZXh0SW5wdXQuZm9jdXNlZCl7XHJcbiAgICAgICAgICAgIGlmKHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICUgNjAgPiAzMCl7XHJcbiAgICAgICAgICAgICAgICB0ZXh0SW5wdXQudGV4dCA9IHRleHRJbnB1dC50ZXh0LnN1YnN0cmluZygwLCB0ZXh0SW5wdXQudGV4dC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgKz0gMTtcclxuICAgICAgICAgICAgaWYodGV4dElucHV0LmN1cnNvckNvdW50ZXIgPj0gNjApe1xyXG4gICAgICAgICAgICAgICAgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBmcmFtZXdvcmsgdG8gcHV0IGFsbCByZW5kZXJpbmcgaW4gb25jZSBwbGFjZSBpbiB0aGUgYXBwbGljYXRpb25cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlbmRlcmluZ01hbmFnZXIge1xyXG4gICAgLyoqIFRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cclxuICAgIHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgICAvKiogVGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZCAqL1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWRcclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBTY2VuZVxyXG4gICAgICovXHJcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSBjYW52YXMgZm9yIHRoZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcclxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBjYW52YXNcclxuICAgICAqIEByZXR1cm5zIFRoZSByZW5kZXJpbmcgY29udGV4dCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBhbnk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2RlcyBhbmQgdmlzaWJsZSBwb3J0aW9ucyBvZiB0aWxlbWFwcywgYXMgd2VsbCBhcyBhbnkgVUlFbGVtZW50IGluIFVJTGF5ZXJzXHJcbiAgICAgKiBAcGFyYW0gdmlzaWJsZVNldCBUaGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXNcclxuICAgICAqIEBwYXJhbSB0aWxlbWFwcyBUaGUgdGlsZW1hcHMgdXNlZCBpbiB0aGUgYXBwbGljYXRpb25cclxuICAgICAqIEBwYXJhbSB1aUxheWVycyBUaGUgdXNlciBpbnRlcmZhY2UgbGF5ZXJzXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHJlbmRlcih2aXNpYmxlU2V0OiBBcnJheTxDYW52YXNOb2RlPiwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+LCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZDtcclxuXHJcbiAgICAvKiogQ2xlYXJzIHRoZSBjYW52YXMgKi9cclxuICAgIGFic3RyYWN0IGNsZWFyKGNvbG9yOiBDb2xvcik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0gc3ByaXRlIFRoZSBzcHJpdGUgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhbiBhbmltYXRlZCBzcHJpdGVcclxuICAgICAqIEBwYXJhbSBzcHJpdGUgVGhlIGFuaW1hdGVkIHNwcml0ZSB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIGdyYXBoaWNcclxuICAgICAqIEBwYXJhbSBncmFwaGljIFRoZSBncmFwaGljIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQ7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIFVJRWxlbWVudFxyXG4gICAgICogQHBhcmFtIHVpRWxlbWVudCBUaGUgVUlFbGVtZW50IHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZDtcclxufSIsImltcG9ydCBHcmFwaCBmcm9tIFwiLi4vRGF0YVR5cGVzL0dyYXBocy9HcmFwaFwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBTaGFkZXJSZWdpc3RyeSBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeVwiO1xyXG5pbXBvcnQgUmVnaXN0cnlNYW5hZ2VyIGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXJcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1BhcmFsbGF4TGF5ZXJcIjtcclxuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi9SZW5kZXJpbmdNYW5hZ2VyXCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJpbmdNYW5hZ2VyIHtcclxuXHJcblx0cHJvdGVjdGVkIG9yaWdpbjogVmVjMjtcclxuXHRwcm90ZWN0ZWQgem9vbTogbnVtYmVyO1xyXG5cdHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XHJcblxyXG5cdHByb3RlY3RlZCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG5cdHByb3RlY3RlZCB0ZXh0Q3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG5cdGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQge1xyXG5cdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHR0aGlzLndvcmxkU2l6ZSA9IFZlYzIuWkVSTztcclxuXHRcdHRoaXMud29ybGRTaXplLnggPSB3aWR0aDtcclxuXHRcdHRoaXMud29ybGRTaXplLnkgPSBoZWlnaHQ7XHJcblxyXG5cdFx0Ly8gR2V0IHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgICAgdGhpcy5nbCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIik7XHJcblxyXG5cdFx0dGhpcy5nbC52aWV3cG9ydCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuXHRcdHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xyXG4gICAgICAgIHRoaXMuZ2wuYmxlbmRGdW5jKHRoaXMuZ2wuU1JDX0FMUEhBLCB0aGlzLmdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcclxuXHJcblx0XHQvLyBUZWxsIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHdlJ3JlIHVzaW5nIFdlYkdMXHJcblx0XHRSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51c2VXZWJHTCh0cnVlLCB0aGlzLmdsKTtcclxuXHJcblx0XHQvLyBTaG93IHRoZSB0ZXh0IGNhbnZhcyBhbmQgZ2V0IGl0cyBjb250ZXh0XHJcblx0XHRsZXQgdGV4dENhbnZhcyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRleHQtY2FudmFzXCIpO1xyXG5cdFx0dGV4dENhbnZhcy5oaWRkZW4gPSBmYWxzZTtcclxuXHRcdHRoaXMudGV4dEN0eCA9IHRleHRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuXHRcdC8vIFNpemUgdGhlIHRleHQgY2FudmFzIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBnYW1lIGNhbnZhc1xyXG5cdFx0dGV4dENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHR0ZXh0Q2FudmFzLndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdsO1xyXG5cdH1cclxuXHJcblx0cmVuZGVyKHZpc2libGVTZXQ6IENhbnZhc05vZGVbXSwgdGlsZW1hcHM6IFRpbGVtYXBbXSwgdWlMYXllcnM6IE1hcDxVSUxheWVyPik6IHZvaWQge1xyXG5cdFx0Zm9yKGxldCBub2RlIG9mIHZpc2libGVTZXQpe1xyXG5cdFx0XHR0aGlzLnJlbmRlck5vZGUobm9kZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dWlMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRpZighdWlMYXllcnMuZ2V0KGtleSkuaXNIaWRkZW4oKSlcclxuXHRcdFx0XHR1aUxheWVycy5nZXQoa2V5KS5nZXRJdGVtcygpLmZvckVhY2gobm9kZSA9PiB0aGlzLnJlbmRlck5vZGUoPENhbnZhc05vZGU+bm9kZSkpXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGNsZWFyKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0dGhpcy5nbC5jbGVhckNvbG9yKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmEpO1xyXG5cdFx0dGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCB0aGlzLmdsLkRFUFRIX0JVRkZFUl9CSVQpO1xyXG5cclxuXHRcdHRoaXMudGV4dEN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53b3JsZFNpemUueCwgdGhpcy53b3JsZFNpemUueSk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyTm9kZShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XHJcblx0XHQvLyBDYWxjdWxhdGUgdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnQgYWNjb3JkaW5nIHRvIHRoaXMgc3ByaXRlXHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbihub2RlKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB6b29tIGxldmVsIG9mIHRoZSBzY2VuZVxyXG4gICAgICAgIHRoaXMuem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcblx0XHRcclxuXHRcdGlmKG5vZGUuaGFzQ3VzdG9tU2hhZGVyKXtcclxuXHRcdFx0Ly8gSWYgdGhlIG5vZGUgaGFzIGEgY3VzdG9tIHNoYWRlciwgcmVuZGVyIHVzaW5nIHRoYXRcclxuXHRcdFx0dGhpcy5yZW5kZXJDdXN0b20obm9kZSk7XHJcblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIEdyYXBoaWMpe1xyXG5cdFx0XHR0aGlzLnJlbmRlckdyYXBoaWMobm9kZSk7XHJcblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFNwcml0ZSl7XHJcblx0XHRcdGlmKG5vZGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XHJcblx0XHRcdFx0dGhpcy5yZW5kZXJBbmltYXRlZFNwcml0ZShub2RlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnJlbmRlclNwcml0ZShub2RlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBVSUVsZW1lbnQpe1xyXG5cdFx0XHR0aGlzLnJlbmRlclVJRWxlbWVudChub2RlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkIHtcclxuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUik7XHJcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhzcHJpdGUpLCBzcHJpdGUpO1xyXG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZCB7XHJcblx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIpO1xyXG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoc3ByaXRlKSwgc3ByaXRlKTtcclxuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZCB7XHJcblxyXG5cdFx0aWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFBvaW50KXtcclxuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5QT0lOVF9TSEFERVIpO1xyXG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhncmFwaGljKSwgZ3JhcGhpYyk7XHJcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFJlY3QpIHtcclxuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5SRUNUX1NIQURFUik7XHJcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcclxuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHRcdH0gXHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZCB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkIHtcclxuXHRcdGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcclxuXHRcdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5MQUJFTF9TSEFERVIpO1xyXG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyh1aUVsZW1lbnQpLCB1aUVsZW1lbnQpO1xyXG5cdFx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAodWlFbGVtZW50LnBvc2l0aW9uLnggLSB0aGlzLm9yaWdpbi54KSp0aGlzLnpvb20sICh1aUVsZW1lbnQucG9zaXRpb24ueSAtIHRoaXMub3JpZ2luLnkpKnRoaXMuem9vbSk7XHJcblx0XHRcdHRoaXMudGV4dEN0eC5yb3RhdGUoLXVpRWxlbWVudC5yb3RhdGlvbik7XHJcblx0XHRcdGxldCBnbG9iYWxBbHBoYSA9IHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYTtcclxuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gdWlFbGVtZW50LmFscGhhO1xyXG5cclxuXHRcdFx0Ly8gUmVuZGVyIHRleHRcclxuXHRcdFx0dGhpcy50ZXh0Q3R4LmZvbnQgPSB1aUVsZW1lbnQuZ2V0Rm9udFN0cmluZygpO1xyXG5cdFx0XHRsZXQgb2Zmc2V0ID0gdWlFbGVtZW50LmNhbGN1bGF0ZVRleHRPZmZzZXQodGhpcy50ZXh0Q3R4KTtcclxuXHRcdFx0dGhpcy50ZXh0Q3R4LmZpbGxTdHlsZSA9IHVpRWxlbWVudC5jYWxjdWxhdGVUZXh0Q29sb3IoKTtcclxuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gdWlFbGVtZW50LnRleHRDb2xvci5hO1xyXG5cdFx0XHR0aGlzLnRleHRDdHguZmlsbFRleHQodWlFbGVtZW50LnRleHQsIG9mZnNldC54IC0gdWlFbGVtZW50LnNpemUueC8yLCBvZmZzZXQueSAtIHVpRWxlbWVudC5zaXplLnkvMik7XHJcblxyXG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcclxuICAgICAgICBcdHRoaXMudGV4dEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyQ3VzdG9tKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcclxuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQobm9kZS5jdXN0b21TaGFkZXJLZXkpO1xyXG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMobm9kZSksIG5vZGUpO1xyXG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBhZGRPcHRpb25zKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4sIG5vZGU6IENhbnZhc05vZGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuXHRcdC8vIEdpdmUgdGhlIHNoYWRlciBhY2Nlc3MgdG8gdGhlIHdvcmxkIHNpemVcclxuXHRcdG9wdGlvbnMud29ybGRTaXplID0gdGhpcy53b3JsZFNpemU7XHJcblxyXG5cdFx0Ly8gQWRqdXN0IHRoZSBvcmlnaW4gcG9zaXRpb24gdG8gdGhlIHBhcmFsbGF4XHJcblx0XHRsZXQgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XHJcblx0XHRsZXQgcGFyYWxsYXggPSBuZXcgVmVjMigxLCAxKTtcclxuXHRcdGlmKGxheWVyIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllcil7XHJcblx0XHRcdHBhcmFsbGF4ID0gKDxQYXJhbGxheExheWVyPmxheWVyKS5wYXJhbGxheDtcclxuXHRcdH1cclxuXHJcblx0XHRvcHRpb25zLm9yaWdpbiA9IHRoaXMub3JpZ2luLmNsb25lKCkubXVsdChwYXJhbGxheCk7XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG5cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBjbGFzcyBmb3IgV2ViR0wgc2hhZGVycy5cclxuICogVGhpcyBjbGFzcyBpcyBhIHNpbmdsZXRvbiwgYW5kIHRoZXJlIGlzIG9ubHkgb25lIGZvciBlYWNoIHNoYWRlciB0eXBlLlxyXG4gKiBBbGwgb2JqZWN0cyB0aGF0IHVzZSB0aGlzIHNoYWRlciB0eXBlIHdpbGwgcmVmZXIgdG8gYW5kIG1vZGlmeSB0aGlzIHNhbWUgdHlwZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNoYWRlclR5cGUge1xyXG5cdC8qKiBUaGUgbmFtZSBvZiB0aGlzIHNoYWRlciAqL1xyXG5cdHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBUaGUga2V5IHRvIHRoZSBXZWJHTFByb2dyYW0gaW4gdGhlIFJlc291cmNlTWFuYWdlciAqL1xyXG5cdHByb3RlY3RlZCBwcm9ncmFtS2V5OiBzdHJpbmc7XHJcblxyXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgcmVzb3VyY2UgbWFuYWdlciAqL1xyXG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHRoaXMucHJvZ3JhbUtleSA9IHByb2dyYW1LZXk7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgYW55IGJ1ZmZlciBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNoYWRlciB0eXBlLlxyXG5cdCAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIExvYWRzIGFueSB1bmlmb3Jtc1xyXG5cdCAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgb2JqZWN0IHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmdcclxuXHQgKi9cclxuXHRhYnN0cmFjdCByZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEV4dHJhY3RzIHRoZSBvcHRpb25zIGZyb20gdGhlIENhbnZhc05vZGUgYW5kIGdpdmVzIHRoZW0gdG8gdGhlIHJlbmRlciBmdW5jdGlvblxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGdldCBvcHRpb25zIGZyb21cclxuXHQgKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb3B0aW9ucyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHJlbmRlciBmdW5jdGlvblxyXG5cdCAqL1xyXG5cdGdldE9wdGlvbnMobm9kZTogQ2FudmFzTm9kZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge3JldHVybiB7fTt9XHJcbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cdH1cclxuXHJcblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJsYWJlbFwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci50b1dlYkdMKCk7XHJcblx0XHRjb25zdCBib3JkZXJDb2xvciA9IG9wdGlvbnMuYm9yZGVyQ29sb3IudG9XZWJHTCgpO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG5cdFx0Ly8gQXR0cmlidXRlc1xyXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcclxuXHJcblx0XHQvLyBVbmlmb3Jtc1xyXG5cdFx0Y29uc3QgdV9CYWNrZ3JvdW5kQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JhY2tncm91bmRDb2xvclwiKTtcclxuXHRcdGdsLnVuaWZvcm00ZnYodV9CYWNrZ3JvdW5kQ29sb3IsIGJhY2tncm91bmRDb2xvcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlckNvbG9yXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTRmdih1X0JvcmRlckNvbG9yLCBib3JkZXJDb2xvcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfTWF4U2l6ZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfTWF4U2l6ZVwiKTtcclxuICAgICAgICBnbC51bmlmb3JtMmYodV9NYXhTaXplLCAtdmVydGV4RGF0YVswXSwgdmVydGV4RGF0YVsxXSk7XHJcblxyXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxyXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyV2lkdGggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlcldpZHRoXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTFmKHVfQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgvbWF4RGltZW5zaW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdV9Cb3JkZXJSYWRpdXMgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlclJhZGl1c1wiKTtcclxuXHRcdGdsLnVuaWZvcm0xZih1X0JvcmRlclJhZGl1cywgb3B0aW9ucy5ib3JkZXJSYWRpdXMvbWF4RGltZW5zaW9uKTtcclxuXHJcblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXHJcblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XHJcblxyXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XHJcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XHJcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XHJcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcclxuXHJcblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcclxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xyXG5cclxuXHRcdC8vIERyYXcgdGhlIHF1YWRcclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcclxuXHQgKi9cclxuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRsZXQgeCwgeTtcclxuXHJcblx0XHRpZihoID4gdyl7XHJcblx0XHRcdHkgPSAwLjU7XHJcblx0XHRcdHggPSB3LygyKmgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9IDAuNTtcclxuXHRcdFx0eSA9IGgvKDIqdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHQteCwgIHksXHJcblx0XHRcdC14LCAteSxcclxuXHRcdFx0IHgsICB5LFxyXG5cdFx0XHQgeCwgLXlcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0Z2V0T3B0aW9ucyhyZWN0OiBMYWJlbCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcblx0XHRcdHBvc2l0aW9uOiByZWN0LnBvc2l0aW9uLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHJlY3QuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCksXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWN0LmNhbGN1bGF0ZUJvcmRlckNvbG9yKCksXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiByZWN0LmJvcmRlcldpZHRoLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlY3QuYm9yZGVyUmFkaXVzLFxyXG5cdFx0XHRzaXplOiByZWN0LnNpemUsXHJcblx0XHRcdHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi8uLi8uLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vU2hhZGVyVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XHJcblxyXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cdH1cclxuXHJcblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJwb2ludFwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRsZXQgcG9zaXRpb24gPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29vcmRzKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMub3JpZ2luLCBvcHRpb25zLndvcmxkU2l6ZSk7XHJcblx0XHRsZXQgY29sb3IgPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29sb3Iob3B0aW9ucy5jb2xvcik7XHJcblxyXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcclxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblxyXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gcG9zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cclxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuXHRcdC8vIEF0dHJpYnV0ZXNcclxuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xyXG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XHJcblxyXG5cdFx0Ly8gVW5pZm9ybXNcclxuXHRcdGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTRmdih1X0NvbG9yLCBjb2xvcik7XHJcblxyXG5cdFx0Y29uc3QgdV9Qb2ludFNpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1BvaW50U2l6ZVwiKTtcclxuXHRcdGdsLnVuaWZvcm0xZih1X1BvaW50U2l6ZSwgb3B0aW9ucy5wb2ludFNpemUpO1xyXG5cclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdGdldE9wdGlvbnMocG9pbnQ6IFBvaW50KTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuXHRcdFx0cG9zaXRpb246IHBvaW50LnBvc2l0aW9uLFxyXG5cdFx0XHRjb2xvcjogcG9pbnQuY29sb3IsXHJcblx0XHRcdHBvaW50U2l6ZTogcG9pbnQuc2l6ZSxcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XHJcblxyXG4vKiogUmVwcmVzZW50cyBhbnkgV2ViR0wgb2JqZWN0cyB0aGF0IGhhdmUgYSBxdWFkIG1lc2ggKGkuZS4gYSByZWN0YW5ndWxhciBnYW1lIG9iamVjdCBjb21wb3NlZCBvZiBvbmx5IHR3byB0cmlhbmdsZXMpICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFF1YWRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XHJcblx0LyoqIFRoZSBrZXkgdG8gdGhlIGJ1ZmZlciBvYmplY3QgZm9yIHRoaXMgc2hhZGVyICovXHJcblx0cHJvdGVjdGVkIGJ1ZmZlck9iamVjdEtleTogc3RyaW5nO1xyXG5cclxuXHQvKiogVGhlIHNjYWxlIG1hdHJpYyAqL1xyXG5cdHByb3RlY3RlZCBzY2FsZTogTWF0NHg0O1xyXG5cclxuXHQvKiogVGhlIHJvdGF0aW9uIG1hdHJpeCAqL1xyXG5cdHByb3RlY3RlZCByb3RhdGlvbjogTWF0NHg0O1xyXG5cclxuXHQvKiogVGhlIHRyYW5zbGF0aW9uIG1hdHJpeCAqL1xyXG5cdHByb3RlY3RlZCB0cmFuc2xhdGlvbjogTWF0NHg0O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XHJcblxyXG5cdFx0dGhpcy5zY2FsZSA9IE1hdDR4NC5JREVOVElUWTtcclxuXHRcdHRoaXMucm90YXRpb24gPSBNYXQ0eDQuSURFTlRJVFk7XHJcblx0XHR0aGlzLnRyYW5zbGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xyXG5cdH1cclxufSIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFF1YWRTaGFkZXJUeXBlIGZyb20gXCIuL1F1YWRTaGFkZXJUeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0U2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XHJcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicmVjdFwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3IudG9XZWJHTCgpO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG5cdFx0Ly8gQXR0cmlidXRlc1xyXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcclxuXHJcblx0XHQvLyBVbmlmb3Jtc1xyXG5cdFx0Y29uc3QgdV9Db2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfQ29sb3JcIik7XHJcblx0XHRnbC51bmlmb3JtNGZ2KHVfQ29sb3IsIGNvbG9yKTtcclxuXHJcblx0XHQvLyBHZXQgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXHJcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXHJcblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XHJcblxyXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XHJcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XHJcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XHJcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcclxuXHJcblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcclxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xyXG5cclxuXHRcdC8vIERyYXcgdGhlIHF1YWRcclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG5cdH1cclxuXHJcblxyXG5cdC8qXHJcblx0XHRTbyBhcyBpdCB0dXJucyBvdXQsIFdlYkdMIGhhcyBhbiBpc3N1ZSB3aXRoIG5vbi1zcXVhcmUgcXVhZHMuXHJcblx0XHRJdCBkb2Vzbid0IGxpa2Ugd2hlbiB5b3UgZG9uJ3QgaGF2ZSBhIDEtMSBzY2FsZSwgYW5kIHJvdGF0aW9ucyBhcmUgZW50aXJlbHkgbWVzc2VkIHVwIGlmIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxyXG5cdFx0VG8gc29sdmUgdGhpcywgSSB1c2VkIHRoZSBzY2FsZSBvZiB0aGUgTEFSR0VTVCBkaW1lbnNpb24gb2YgdGhlIHF1YWQgdG8gbWFrZSBhIHNxdWFyZSwgdGhlbiBhZGp1c3RlZCB0aGUgdmVydGV4IGNvb3JkaW5hdGVzIGluc2lkZSBvZiB0aGF0LlxyXG5cdFx0QSBkaWFncmFtIG9mIHRoZSBzb2x1dGlvbiBmb2xsb3dzLlxyXG5cclxuXHRcdFRoZXJlIGlzIGEgYm91bmRpbmcgc3F1YXJlIGZvciB0aGUgcXVhZCB3aXRoIGRpbWVuc2lvbnMgaHhoIChpbiB0aGlzIGNhc2UsIHNpbmNlIGhlaWdodCBpcyB0aGUgbGFyZ2VzdCBkaW1lbnNpb24pLlxyXG5cdFx0VGhlIG9mZnNldCBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uIGlzIHRoZXJlZm9yZSAwLjUsIGFzIGl0IGlzIG5vcm1hbGx5LlxyXG5cdFx0SG93ZXZlciwgdGhlIG9mZnNldCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gaXMgbm90IHNvIHN0cmFpZ2h0Zm9yd2FyZCwgYnV0IGlzbid0IGNvbmNlcHR1YWxseSBoYXJkLlxyXG5cdFx0QWxsIHdlIHJlYWxseSBoYXZlIHRvIGRvIGlzIGEgcmFuZ2UgY2hhbmdlIGZyb20gWzAsIGhlaWdodC8yXSB0byBbMCwgMC41XSwgd2hlcmUgb3VyIHZhbHVlIGlzIHQgPSB3aWR0aC8yLCBhbmQgMCA8PSB0IDw9IGhlaWdodC8yLlxyXG5cclxuXHRcdFNvIG5vdyB3ZSBoYXZlIG91ciByZWN0LCBpbiBhIHNwYWNlIHNjYWxlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uLlxyXG5cdFx0Um90YXRpb25zIHdvcmsgYXMgeW91IHdvdWxkIGV4cGVjdCwgZXZlbiBmb3IgbG9uZyByZWN0YW5nbGVzLlxyXG5cclxuXHRcdFx0XHRcdDAuNVxyXG5cdFx0XHRfXyBfXyBfXyBfXyBfXyBfXyBfX1xyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdFx0LTAuNXxfIF98ODg4ODg4ODg4ODh8XyBffDAuNVxyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdCAgXHRcdHxfX198ODg4ODg4ODg4ODh8X19ffFxyXG5cdFx0XHQgIFx0XHQtMC41XHJcblxyXG5cdFx0VGhlIGdldFZlcnRpY2VzIGZ1bmN0aW9uIGJlbG93IGRvZXMgYXMgZGVzY3JpYmVkLCBhbmQgY29udmVydHMgdGhlIHJhbmdlXHJcblx0Ki9cclxuXHQvKipcclxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxyXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxyXG5cdCAqL1xyXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcclxuXHRcdGxldCB4LCB5O1xyXG5cclxuXHRcdGlmKGggPiB3KXtcclxuXHRcdFx0eSA9IDAuNTtcclxuXHRcdFx0eCA9IHcvKDIqaCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4ID0gMC41O1xyXG5cdFx0XHR5ID0gaC8oMip3KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdC14LCAgeSxcclxuXHRcdFx0LXgsIC15LFxyXG5cdFx0XHQgeCwgIHksXHJcblx0XHRcdCB4LCAteVxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRnZXRPcHRpb25zKHJlY3Q6IFJlY3QpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xyXG5cdFx0XHRwb3NpdGlvbjogcmVjdC5wb3NpdGlvbixcclxuXHRcdFx0Y29sb3I6IHJlY3QuY29sb3IsXHJcblx0XHRcdHNpemU6IHJlY3Quc2l6ZSxcclxuXHRcdFx0cm90YXRpb246IHJlY3Qucm90YXRpb25cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uLy4uLy4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xyXG5cclxuLyoqIEEgc2hhZGVyIGZvciBzcHJpdGVzIGFuZCBhbmltYXRlZCBzcHJpdGVzICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwcml0ZVNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XHJcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwic3ByaXRlXCI7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5jcmVhdGVCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cdH1cclxuXHJcblx0cmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRleHR1cmUob3B0aW9ucy5pbWFnZUtleSk7XHJcblxyXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gdGhpcy5nZXRWZXJ0aWNlcyhvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnksIG9wdGlvbnMuc2NhbGUpO1xyXG5cclxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcblx0XHQvLyBCaW5kIHRoZSBidWZmZXJcclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcblx0XHQvLyBBdHRyaWJ1dGVzXHJcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiBGU0laRSwgMCAqIEZTSVpFKTtcclxuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xyXG5cclxuXHRcdGNvbnN0IGFfVGV4Q29vcmQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfVGV4Q29vcmRcIik7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfVGV4Q29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgNCAqIEZTSVpFLCAyKkZTSVpFKTtcclxuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfVGV4Q29vcmQpO1xyXG5cclxuXHRcdC8vIFVuaWZvcm1zXHJcblx0XHQvLyBHZXQgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHQvLyBXZSB3YW50IGEgc3F1YXJlIGZvciBvdXIgcmVuZGVyaW5nIHNwYWNlLCBzbyBnZXQgdGhlIG1heGltdW0gZGltZW5zaW9uIG9mIG91ciBxdWFkXHJcblx0XHRsZXQgbWF4RGltZW5zaW9uID0gTWF0aC5tYXgob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXHJcblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XHJcblxyXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XHJcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XHJcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XHJcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcclxuXHJcblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcclxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xyXG5cclxuXHRcdC8vIFNldCB1cCBvdXIgc2FtcGxlciB3aXRoIG91ciBhc3NpZ25lZCB0ZXh0dXJlIHVuaXRcclxuXHRcdGNvbnN0IHVfU2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfU2FtcGxlclwiKTtcclxuXHRcdGdsLnVuaWZvcm0xaSh1X1NhbXBsZXIsIHRleHR1cmUpO1xyXG5cclxuXHRcdC8vIFBhc3MgaW4gdGV4U2hpZnRcclxuXHRcdGNvbnN0IHVfdGV4U2hpZnQgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3RleFNoaWZ0XCIpO1xyXG5cdFx0Z2wudW5pZm9ybTJmdih1X3RleFNoaWZ0LCBvcHRpb25zLnRleFNoaWZ0KTtcclxuXHJcblx0XHQvLyBQYXNzIGluIHRleFNjYWxlXHJcblx0XHRjb25zdCB1X3RleFNjYWxlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXhTY2FsZVwiKTtcclxuXHRcdGdsLnVuaWZvcm0yZnYodV90ZXhTY2FsZSwgb3B0aW9ucy50ZXhTY2FsZSk7XHJcblxyXG5cdFx0Ly8gRHJhdyB0aGUgcXVhZFxyXG5cdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcmVuZGVyaW5nIHNwYWNlIGFsd2F5cyBoYXMgdG8gYmUgYSBzcXVhcmUsIHNvIG1ha2Ugc3VyZSBpdHMgc3F1YXJlIHcuci50IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvblxyXG5cdCAqIEBwYXJhbSB3IFRoZSB3aWR0aCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcGFyYW0gaCBUaGUgaGVpZ2h0IG9mIHRoZSBxdWFkIGluIHBpeGVsc1xyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgcXVhZFxyXG5cdCAqL1xyXG5cdGdldFZlcnRpY2VzKHc6IG51bWJlciwgaDogbnVtYmVyLCBzY2FsZTogRmxvYXQzMkFycmF5KTogRmxvYXQzMkFycmF5IHtcclxuXHRcdGxldCB4LCB5O1xyXG5cclxuXHRcdGlmKGggPiB3KXtcclxuXHRcdFx0eSA9IDAuNTtcclxuXHRcdFx0eCA9IHcvKDIqaCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4ID0gMC41O1xyXG5cdFx0XHR5ID0gaC8oMip3KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTY2FsZSB0aGUgcmVuZGVyaW5nIHNwYWNlIGlmIG5lZWRlZFxyXG5cdFx0eCAqPSBzY2FsZVswXTtcclxuXHRcdHkgKj0gc2NhbGVbMV07XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHQteCwgIHksIDAuMCwgMC4wLFxyXG5cdFx0XHQteCwgLXksIDAuMCwgMS4wLFxyXG5cdFx0XHQgeCwgIHksIDEuMCwgMC4wLFxyXG5cdFx0XHQgeCwgLXksIDEuMCwgMS4wXHJcblx0XHRdKTtcclxuXHR9XHJcblxyXG5cdGdldE9wdGlvbnMoc3ByaXRlOiBTcHJpdGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuXHRcdGxldCB0ZXhTaGlmdDtcclxuXHRcdGxldCB0ZXhTY2FsZTtcclxuXHJcblx0XHRpZihzcHJpdGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XHJcblx0XHRcdGxldCBhbmltYXRpb25JbmRleCA9IHNwcml0ZS5hbmltYXRpb24uZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk7XHJcblx0XHRcdGxldCBvZmZzZXQgPSBzcHJpdGUuZ2V0QW5pbWF0aW9uT2Zmc2V0KGFuaW1hdGlvbkluZGV4KTtcclxuXHRcdFx0dGV4U2hpZnQgPSBuZXcgRmxvYXQzMkFycmF5KFtvZmZzZXQueCAvIChzcHJpdGUuY29scyAqIHNwcml0ZS5zaXplLngpLCBvZmZzZXQueSAvIChzcHJpdGUucm93cyAqIHNwcml0ZS5zaXplLnkpXSk7XHJcblx0XHRcdHRleFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbMS8oc3ByaXRlLmNvbHMpLCAxLyhzcHJpdGUucm93cyldKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRleFNoaWZ0ID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMF0pO1xyXG5cdFx0XHR0ZXhTY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDFdKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuXHRcdFx0cG9zaXRpb246IHNwcml0ZS5wb3NpdGlvbixcclxuXHRcdFx0cm90YXRpb246IHNwcml0ZS5yb3RhdGlvbixcclxuXHRcdFx0c2l6ZTogc3ByaXRlLnNpemUsXHJcblx0XHRcdHNjYWxlOiBzcHJpdGUuc2NhbGUudG9BcnJheSgpLFxyXG5cdFx0XHRpbWFnZUtleTogc3ByaXRlLmltYWdlSWQsXHJcblx0XHRcdHRleFNoaWZ0LFxyXG5cdFx0XHR0ZXhTY2FsZVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvcHRpb25zO1xyXG5cdH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IHsgVGlsZWRUaWxlbWFwRGF0YSB9IGZyb20gXCIuLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCI7XHJcbmltcG9ydCBTdHJpbmdVdGlscyBmcm9tIFwiLi4vVXRpbHMvU3RyaW5nVXRpbHNcIjtcclxuaW1wb3J0IEF1ZGlvTWFuYWdlciBmcm9tIFwiLi4vU291bmQvQXVkaW9NYW5hZ2VyXCI7XHJcbmltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XHJcbmltcG9ydCBXZWJHTFByb2dyYW1UeXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBmb3IgdGhlIGdhbWUgZW5naW5lLlxyXG4gKiBUaGUgcmVzb3VyY2UgbWFuYWdlciBpbnRlcmZhY2VzIHdpdGggdGhlIGxvYWRhYmxlIGFzc2V0cyBvZiBhIGdhbWUgc3VjaCBhcyBpbWFnZXMsIGRhdGEgZmlsZXMsXHJcbiAqIGFuZCBzb3VuZHMsIHdoaWNoIGFyZSBhbGwgZm91bmQgaW4gdGhlIGRpc3QgZm9sZGVyLlxyXG4gKiBUaGlzIGNsYXNzIGNvbnRyb2xzIGxvYWRpbmcgYW5kIHVwZGF0ZXMgdGhlIEByZWZlcmVuY2VbU2NlbmVdIHdpdGggdGhlIGxvYWRpbmcgcHJvZ3Jlc3MsIHNvIHRoYXQgdGhlIHNjZW5lIGRvZXMgXHJcbiAqIG5vdCBzdGFydCBiZWZvcmUgYWxsIG5lY2Vzc2FyeSBhc3NldHMgYXJlIGxvYWRlZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc291cmNlTWFuYWdlciB7XHJcbiAgICAvLyBJbnN0YW5jZSBmb3IgdGhlIHNpbmdsZXRvbiBjbGFzc1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIFxyXG4gICAgLy8gQm9vbGVhbnMgdG8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgUmVzb3VyY2VNYW5hZ2VyIGlzIGN1cnJlbnRseSBsb2FkaW5nIHNvbWV0aGluZ1xyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IGFueSByZXNvdXJjZXMgYXJlIGxvYWRpbmcgKi9cclxuICAgIHByaXZhdGUgbG9hZGluZzogYm9vbGVhbjtcclxuICAgIC8qKiBBIGJvb2xlYW4gdG8gaW5kaWNhdGUgdGhhdCB0aGUgYXNzZXRzIGp1c3QgZmluaXNoZWQgbG9hZGluZyAqL1xyXG4gICAgcHJpdmF0ZSBqdXN0TG9hZGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8vIEZ1bmN0aW9ucyB0byBkbyBzb21ldGhpbmcgd2hlbiBsb2FkaW5nIHByb2dyZXNzZXMgb3IgaXMgY29tcGxldGVkIHN1Y2ggYXMgcmVuZGVyIGEgbG9hZGluZyBzY3JlZW5cclxuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBwcm9ncmVzc2VzICovXHJcbiAgICBwdWJsaWMgb25Mb2FkUHJvZ3Jlc3M6IEZ1bmN0aW9uO1xyXG4gICAgLyoqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBsb2FkaW5nIGNvbXBsZXRlcyAqL1xyXG4gICAgcHVibGljIG9uTG9hZENvbXBsZXRlOiBGdW5jdGlvbjtcclxuXHJcblxyXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGltYWdlcyBuZWVkIHRvIGJlIGxvYWRlZCovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlc0xvYWRlZDogbnVtYmVyO1xyXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGltYWdlcyBhcmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlc1RvTG9hZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBxdWV1ZSBvZiBpbWFnZXMgd2UgbXVzdCBsb2FkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICAvKiogQSBtYXAgb2YgdGhlIGltYWdlcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZS4gVGhlIHJlZmVyZW5jZSB0byB0aGVzZSBpbWFnZXMgb25seSBleGlzdCBoZXJlIGZvciBlYXN5IGNsZWFudXAuICovXHJcbiAgICBwcml2YXRlIGltYWdlczogTWFwPEhUTUxJbWFnZUVsZW1lbnQ+O1xyXG5cclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBuZWVkIHRvIGJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQ6IG51bWJlcjtcclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBxdWV1ZSBvZiB0aWxlbWFwcyB3ZSBtdXN0IGxvYWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcclxuICAgIC8qKiBBIG1hcCBvZiB0aGUgdGlsZW1hcHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXHJcbiAgICBwcml2YXRlIHNwcml0ZXNoZWV0czogTWFwPFNwcml0ZXNoZWV0PjtcclxuXHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQ6IG51bWJlcjtcclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSB0aWxlbWFwcyBhcmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHRpbGVtYXBzIHdlIG11c3QgbG9hZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICAvKiogQSBtYXAgb2YgdGhlIHRpbGVtYXBzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xyXG4gICAgcHJpdmF0ZSB0aWxlbWFwczogTWFwPFRpbGVkVGlsZW1hcERhdGE+O1xyXG5cclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VuZHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Mb2FkZWQ6IG51bWJlcjtcclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBzb3VuZHMgYXJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb1RvTG9hZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBxdWV1ZSBvZiBzb3VuZHMgd2UgbXVzdCBsb2FkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICAvKiogQSBtYXAgb2YgdGhlIHNvdW5kcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cclxuICAgIHByaXZhdGUgYXVkaW9CdWZmZXJzOiBNYXA8QXVkaW9CdWZmZXI+O1xyXG5cclxuICAgIC8qKiBUaGUgdG90YWwgbnVtYmVyIG9mIFwidHlwZXNcIiBvZiB0aGluZ3MgdGhhdCBuZWVkIHRvIGJlIGxvYWRlZCAoaS5lLiBpbWFnZXMgYW5kIHRpbGVtYXBzKSAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90eXBlc1RvTG9hZDogbnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfanNvbkxvYWRlZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uVG9Mb2FkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhQYWlyPjtcclxuICAgIHByaXZhdGUganNvbk9iamVjdHM6IE1hcDxSZWNvcmQ8c3RyaW5nLCBhbnk+PjtcclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIElORk9STUFUSU9OIFNQRUNJQUwgVE8gV0VCR0wgIyMjIyMjIyMjIyAqL1xyXG4gICAgcHJpdmF0ZSBnbF9XZWJHTEFjdGl2ZTogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aF9TaGFkZXI+O1xyXG5cclxuICAgIHByaXZhdGUgZ2xfU2hhZGVyUHJvZ3JhbXM6IE1hcDxXZWJHTFByb2dyYW1UeXBlPjtcclxuXHJcbiAgICBwcml2YXRlIGdsX1RleHR1cmVzOiBNYXA8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgZ2xfTmV4dFRleHR1cmVJRDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBnbF9CdWZmZXJzOiBNYXA8V2ViR0xCdWZmZXI+OyBcclxuXHJcbiAgICBwcml2YXRlIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBVTkxPQURJTkcgQU5EIEVYQ0xVU0lPTiBMSVNUICMjIyMjIyMjIyMgKi9cclxuICAgIC8qKiBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRoYXQgd2lsbCBiZSB1bmxvYWRlZCBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHNjZW5lICovXHJcbiAgICBwcml2YXRlIHJlc291cmNlc1RvVW5sb2FkOiBBcnJheTxSZXNvdXJjZVJlZmVyZW5jZT47XHJcblxyXG4gICAgLyoqIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8ga2VlcCB1bnRpbCBmdXJ0aGVyIG5vdGljZSAqL1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZXNUb0tlZXA6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID0gMDtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5qc29uT2JqZWN0cyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nbF9UZXh0dXJlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmdsX05leHRUZXh0dXJlSUQgPSAwO1xyXG4gICAgICAgIHRoaXMuZ2xfQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZCA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzVG9LZWVwID0gbmV3IEFycmF5KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgU0lOR0xFVE9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoaXMgY2xhc3Mgb3IgYSBuZXcgaW5zdGFuY2UgaWYgbm9uZSBleGlzdFxyXG4gICAgICogQHJldHVybnMgVGhlIHJlc291cmNlIG1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCk6IFJlc291cmNlTWFuYWdlciB7XHJcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFJlc291cmNlTWFuYWdlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBQVUJMSUMgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2YXRlcyBvciBkZWFjdGl2YXRlcyB0aGUgdXNlIG9mIFdlYkdMXHJcbiAgICAgKiBAcGFyYW0gZmxhZyBUcnVlIGlmIFdlYkdMIHNob3VsZCBiZSB1c2VkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgaW5zdGFuY2Ugb2YgdGhlIGdyYXBoaWNzIGNvbnRleHQsIGlmIGFwcGxpY2FibGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVzZVdlYkdMKGZsYWc6IGJvb2xlYW4sIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmdsX1dlYkdMQWN0aXZlID0gZmxhZztcclxuXHJcbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XHJcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbiBpbWFnZSBmcm9tIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgdGhlIGxvYWRlZCBpbWFnZSB3aXRoXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW1hZ2Uoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMga2VlcEltYWdlKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIGltYWdlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBpbWFnZVxyXG4gICAgICogQHJldHVybnMgVGhlIGltYWdlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRJbWFnZShrZXk6IHN0cmluZyk6IEhUTUxJbWFnZUVsZW1lbnQge1xyXG4gICAgICAgIGxldCBpbWFnZSA9IHRoaXMuaW1hZ2VzLmdldChrZXkpO1xyXG4gICAgICAgIGlmKGltYWdlID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmltYWdlcyk7XHJcbiAgICAgICAgICAgIHRocm93IGBUaGVyZSBpcyBubyBpbWFnZSBhc3NvY2lhdGVkIHdpdGgga2V5IFwiJHtrZXl9XCJgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc3ByaXRlc2hlZXQgZnJvbSBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHRoZSBsb2FkZWQgc3ByaXRlc2hlZXQgd2l0aFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNwcml0ZXNoZWV0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGtlZXBTcHJpdGVzaGVldChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBzcHJpdGVzaGVldFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbG9hZGVkIFNwcml0ZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTcHJpdGVzaGVldChrZXk6IHN0cmluZyk6IFNwcml0ZXNoZWV0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGVzaGVldHMuZ2V0KGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbiBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGxvYWRlZCBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhdWRpbyhrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgKi9cclxuICAgICBwdWJsaWMga2VlcEF1ZGlvKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuQVVESU8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIGF1ZGlvIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9CdWZmZXIgY3JlYXRlZCBmcm9tIHRoZSBsb2FkZWQgYXVkaW8gZmxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBdWRpbyhrZXk6IHN0cmluZyk6IEF1ZGlvQnVmZmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdWRpb0J1ZmZlcnMuZ2V0KGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGEgdGlsZW1hcCBmcm9tIGEganNvbiBmaWxlLiBBdXRvbWF0aWNhbGx5IGxvYWRzIHJlbGF0ZWQgaW1hZ2VzXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGxvYWRlZCB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgdGlsZW1hcCB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0aWxlbWFwKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICAgcHVibGljIGtlZXBUaWxlbWFwKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuVElMRU1BUCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyZWl2ZXMgYSBsb2FkZWQgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgdGlsZW1hcFxyXG4gICAgICogQHJldHVybnMgVGhlIHRpbGVtYXAgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0VGlsZW1hcChrZXk6IHN0cmluZyk6IFRpbGVkVGlsZW1hcERhdGEge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVtYXBzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYW4gb2JqZWN0IGZyb20gYSBqc29uIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGxvYWRlZCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBqc29uIGZpbGUgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb2JqZWN0KGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpe1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgKi9cclxuICAgICBwdWJsaWMga2VlcE9iamVjdChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmVpdmVzIGEgbG9hZGVkIG9iamVjdFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgb2JqZWN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldE9iamVjdChrZXk6IHN0cmluZyl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvbk9iamVjdHMuZ2V0KGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBMT0FEIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbGwgcmVzb3VyY2VzIGN1cnJlbnRseSBpbiB0aGUgcXVldWVcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsIHdoZW4gdGhlIHJlc291cmNlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xyXG4gICAgICovXHJcbiAgICBsb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdHlwZXNUb0xvYWQgPSA1O1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBMb2FkIGV2ZXJ5dGhpbmcgaW4gdGhlIHF1ZXVlcy4gVGlsZW1hcHMgaGF2ZSB0byBjb21lIGJlZm9yZSBpbWFnZXMgYmVjYXVzZSB0aGV5IHdpbGwgYWRkIG5ldyBpbWFnZXMgdG8gdGhlIHF1ZXVlXHJcbiAgICAgICAgdGhpcy5sb2FkVGlsZW1hcHNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBUaWxlbWFwc1wiKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIFNwcml0ZXNoZWV0c1wiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZEltYWdlc0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgSW1hZ2VzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZEF1ZGlvRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgQXVkaW9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdHNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgT2JqZWN0c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbF9Mb2FkU2hhZGVyc0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIFNoYWRlcnNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZyhjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZyhjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIC8vIERvbmUgbG9hZGluZ1xyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFVOTE9BRCBGVU5DVElPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBrZWVwUmVzb3VyY2Uoa2V5OiBzdHJpbmcsIHR5cGU6IFJlc291cmNlVHlwZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiS2VlcCByZXNvdXJjZS4uLlwiKTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2VzVG9VbmxvYWRbaV07XHJcbiAgICAgICAgICAgIGlmKHJlc291cmNlLmtleSA9PT0ga2V5ICYmIHJlc291cmNlLnJlc291cmNlVHlwZSA9PT0gdHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIHJlc291cmNlIFwiICsga2V5ICsgXCIgb2YgdHlwZSBcIiArIHR5cGUgKyBcIi4gS2VlcGluZy5cIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzb3VyY2VUb01vdmUgPSB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9LZWVwLnB1c2goLi4ucmVzb3VyY2VUb01vdmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgcmVmZXJlbmNlcyB0byBhbGwgcmVzb3VyY2VzIGluIHRoZSByZXNvdXJjZSBtYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHVubG9hZEFsbFJlc291cmNlcygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yKGxldCByZXNvdXJjZSBvZiB0aGlzLnJlc291cmNlc1RvVW5sb2FkKXtcclxuICAgICAgICAgICAgLy8gVW5sb2FkIHRoZSByZXNvdXJjZVxyXG4gICAgICAgICAgICB0aGlzLnVubG9hZFJlc291cmNlKHJlc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1bmxvYWRSZXNvdXJjZShyZXNvdXJjZTogUmVzb3VyY2VSZWZlcmVuY2UpOiB2b2lkIHtcclxuICAgICAgICAvLyBEZWxldGUgdGhlIHJlc291cmNlIGl0c2VsZlxyXG4gICAgICAgIHN3aXRjaChyZXNvdXJjZS5yZXNvdXJjZVR5cGUpe1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5JTUFHRTpcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbF9UZXh0dXJlcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5USUxFTUFQOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVDpcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlc2hlZXRzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLkFVRElPOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuSlNPTjpcclxuICAgICAgICAgICAgICAgIHRoaXMuanNvbk9iamVjdHMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuU0hBREVSOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5nZXQocmVzb3VyY2Uua2V5KS5kZWxldGUodGhpcy5nbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWxldGUgYW55IGRlcGVuZGVuY2llc1xyXG4gICAgICAgIGZvcihsZXQgZGVwZW5kZW5jeSBvZiByZXNvdXJjZS5kZXBlbmRlbmNpZXMpe1xyXG4gICAgICAgICAgICB0aGlzLnVubG9hZFJlc291cmNlKGRlcGVuZGVuY3kpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFdPUksgRlVOQ1RJT05TICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbGwgdGlsZW1hcHMgY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcclxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBsb2FkaW5nIGlzIGNvbXBsZXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZFRpbGVtYXBzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID09PSAwKXtcclxuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgbGV0IHRpbGVtYXAgPSB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRUaWxlbWFwKHRpbGVtYXAua2V5LCB0aWxlbWFwLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciB0aWxlbWFwIFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gcGF0aFRvVGlsZW1hcEpTT04gVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgSlNPTiBmaWxlXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkVGlsZW1hcChrZXk6IHN0cmluZywgcGF0aFRvVGlsZW1hcEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aFRvVGlsZW1hcEpTT04sIChmaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0aWxlbWFwT2JqZWN0ID0gPFRpbGVkVGlsZW1hcERhdGE+SlNPTi5wYXJzZShmaWxlVGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBXZSBjYW4gcGFyc2UgdGhlIG9iamVjdCBsYXRlciAtIGl0J3MgbXVjaCBmYXN0ZXIgdGhhbiBsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMudGlsZW1hcHMuYWRkKGtleSwgdGlsZW1hcE9iamVjdCk7XHJcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5USUxFTUFQKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIHRpbGVzZXQgaW1hZ2VzIHdlIG5lZWQgdG8gbG9hZCBhbmQgYWRkIHRoZW0gdG8gdGhlIGltYWdlbG9hZGluZyBxdWV1ZVxyXG4gICAgICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZW1hcE9iamVjdC50aWxlc2V0cyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aWxlc2V0LmltYWdlKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGlsZXNldC5pbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvVGlsZW1hcEpTT04pICsga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRpbGVzZXQudGlsZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZSBvZiB0aWxlc2V0LnRpbGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IHRpbGUuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRoID0gU3RyaW5nVXRpbHMuZ2V0UGF0aEZyb21GaWxlUGF0aChwYXRoVG9UaWxlbWFwSlNPTikgKyBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgaW1hZ2UgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0aWxlbWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHJlc291cmNlIHJlZmVyZW5jZSB0byB0aGUgbGlzdCBvZiByZXNvdXJjZSB0byB1bmxvYWRcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluaXNoIGxvYWRpbmcgYSB0aWxlbWFwLiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaWYgdGhpcyBpcyB0aGUgbGFzdCB0aWxlbWFwIGJlaW5nIGxvYWRlZFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHRpbGVtYXBzXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIHNwcml0ZXNoZWV0cyBjdXJyZW50bHkgaW4gdGhlIHNwcml0ZXNoZWV0IGxvYWRpbmcgcXVldWVcclxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgc3ByaXRlc2hlZXRzIGFyZSBkb25lIGxvYWRpbmdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICBsZXQgc3ByaXRlc2hlZXQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXQoc3ByaXRlc2hlZXQua2V5LCBzcHJpdGVzaGVldC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgc3ByaXRlc2hlZXQgXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBwYXRoVG9TcHJpdGVzaGVldEpTT04gVGhlIHBhdGggdG8gdGhlIHNwcml0ZXNoZWV0IEpTT04gZmlsZVxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcsIHBhdGhUb1Nwcml0ZXNoZWV0SlNPTjogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoVG9TcHJpdGVzaGVldEpTT04sIChmaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IDxTcHJpdGVzaGVldD5KU09OLnBhcnNlKGZpbGVUZXh0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbiBwYXJzZSB0aGUgb2JqZWN0IGxhdGVyIC0gaXQncyBtdWNoIGZhc3RlciB0aGFuIGxvYWRpbmdcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMuYWRkKGtleSwgc3ByaXRlc2hlZXQpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlc291cmNlID0gbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIGltYWdlIHdlIG5lZWQgdG8gbG9hZCBhbmQgYWRkIGl0IHRvIHRoZSBpbWFnZWxvYWRpbmcgcXVldWVcclxuICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1Nwcml0ZXNoZWV0SlNPTikgKyBzcHJpdGVzaGVldC5zcHJpdGVTaGVldEltYWdlO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleTogc3ByaXRlc2hlZXQubmFtZSwgcGF0aDogcGF0aCwgaXNEZXBlbmRlbmN5OiB0cnVlfSk7XHJcblxyXG4gICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShzcHJpdGVzaGVldC5uYW1lLCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1Nwcml0ZXNoZWV0KGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGEgc3ByaXRlc2hlZXQuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0IGJlaW5nIGxvYWRlZFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXQgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdTcHJpdGVzaGVldChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQpe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc3ByaXRlc2hlZXRzXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIGltYWdlcyBjdXJyZW50bHkgaW4gdGhlIGltYWdlIGxvYWRpbmcgcXVldWVcclxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBpbWFnZXMgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvYWRJbWFnZXNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPSAwO1xyXG5cclxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkID09PSAwKXtcclxuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIGxldCBpbWFnZSA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZShpbWFnZS5rZXksIGltYWdlLnBhdGgsIGltYWdlLmlzRGVwZW5kZW5jeSwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIGltYWdlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBpbWFnZSB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBpbWFnZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9hZEltYWdlKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGlzRGVwZW5kZW5jeTogYm9vbGVhbiwgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIGxvYWRlZCBpbWFnZXNcclxuICAgICAgICAgICAgdGhpcy5pbWFnZXMuYWRkKGtleSwgaW1hZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm90IGEgZGVwZW5kZW5jeSwgcHVzaCBpdCB0byB0aGUgdW5sb2FkIGxpc3QuIE90aGVyd2lzZSBpdCdzIG1hbmFnZWQgYnkgc29tZXRoaW5nIGVsc2VcclxuICAgICAgICAgICAgaWYoIWlzRGVwZW5kZW5jeSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIFdlYkdMIGlzIGFjdGl2ZSwgY3JlYXRlIGEgdGV4dHVyZVxyXG4gICAgICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlV2ViR0xUZXh0dXJlKGtleSwgaW1hZ2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5pc2ggaW1hZ2UgbG9hZFxyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdJbWFnZShjYWxsYmFja0lmTGFzdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbWFnZS5zcmMgPSBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluaXNoIGxvYWRpbmcgYW4gaW1hZ2UuIElmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2UsIGl0IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkICl7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBpbWFnZXNcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbGwgYXVkaW8gY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcclxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aWxlbWFwcyBhcmUgZG9uZSBsb2FkaW5nXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZEF1ZGlvRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pe1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPSB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID09PSAwKXtcclxuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIGxldCBhdWRpbyA9IHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRBdWRpbyhhdWRpby5rZXksIGF1ZGlvLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhIHNpbmd1bGFyIGF1ZGlvIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBmaWxlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkQXVkaW8oa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGF1ZGlvQ3R4ID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcclxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcblxyXG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgKGJ1ZmZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGxpc3Qgb2YgYXVkaW8gYnVmZmVyc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMuYWRkKGtleSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuQVVESU8pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZyBzb3VuZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+e1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBsb2FkaW5nIHNvdW5kXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIGF1ZGlvIGZpbGUuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdG9uIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gc2FtcGxlIGJlaW5nIGxvYWRlZC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdBdWRpbyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQpe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgYXVkaW9cclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbGwgb2JqZWN0cyBjdXJyZW50bHkgaW4gdGhlIG9iamVjdCBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgb2JqZWN0cyB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZE9iamVjdHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9IHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPT09IDApe1xyXG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkT2JqZWN0KG9iai5rZXksIG9iai5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIG9iamVjdCB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgb2JqZWN0IHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9hZE9iamVjdChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgb2JqID0gSlNPTi5wYXJzZShmaWxlVGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuanNvbk9iamVjdHMuYWRkKGtleSwgb2JqKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSlNPTikpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIG9iamVjdC4gSWYgdGhpcyBpcyB0aGUgbGFzdCBvYmplY3QsIGl0IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ09iamVjdChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQpe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgb2JqZWN0c1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIFdFQkdMIFNQRUNJRklDIEZVTkNUSU9OUyAjIyMjIyMjIyMjICovXHJcblxyXG4gICAgcHVibGljIGdldFRleHR1cmUoa2V5OiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdsX1RleHR1cmVzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRTaGFkZXJQcm9ncmFtKGtleTogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5nZXQoa2V5KS5wcm9ncmFtO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRCdWZmZXIoa2V5OiBzdHJpbmcpOiBXZWJHTEJ1ZmZlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfQnVmZmVycy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZVdlYkdMVGV4dHVyZShpbWFnZUtleTogc3RyaW5nLCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdldCB0aGUgdGV4dHVyZSBJRFxyXG4gICAgICAgIGNvbnN0IHRleHR1cmVJRCA9IHRoaXMuZ2V0VGV4dHVyZUlEKHRoaXMuZ2xfTmV4dFRleHR1cmVJRCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdGV4dHVyZVxyXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHVwIHRoZSB0ZXh0dXJlXHJcbiAgICAgICAgLy8gRW5hYmxlIHRleHR1cmUwXHJcbiAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVJRCk7XHJcblxyXG4gICAgICAgIC8vIEJpbmQgb3VyIHRleHR1cmUgdG8gdGV4dHVyZSAwXHJcbiAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgcGFyYW1ldGVyc1xyXG4gICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XHJcbiAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgaW1hZ2VcclxuICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgdGV4dHVyZSB0byBvdXIgbWFwIHdpdGggdGhlIHNhbWUga2V5IGFzIHRoZSBpbWFnZVxyXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMuYWRkKGltYWdlS2V5LCB0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xyXG5cclxuICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIGtleVxyXG4gICAgICAgIHRoaXMuZ2xfTmV4dFRleHR1cmVJRCArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0VGV4dHVyZUlEKGlkOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggOSBjYXNlcyAtIHRoaXMgY2FuIGJlIGV4cGFuZGVkIGlmIG5lZWRlZCwgYnV0IGZvciB0aGUgYmVzdCBwZXJmb3JtYW5jZSxcclxuICAgICAgICAvLyBUZXh0dXJlcyBzaG91bGQgYmUgc3RpdGNoZWQgaW50byBhbiBhdGxhc1xyXG4gICAgICAgIHN3aXRjaChpZCl7XHJcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTA7XHJcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTE7XHJcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTI7XHJcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTM7XHJcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTQ7XHJcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTU7XHJcbiAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTY7XHJcbiAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTc7XHJcbiAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTg7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlQnVmZmVyKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XHJcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nbF9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgbG9hZGluZyBvZiBhIG5ldyBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIHZTaGFkZXJGaWxlcGF0aCBcclxuICAgICAqIEBwYXJhbSBmU2hhZGVyRmlsZXBhdGggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaGFkZXIoa2V5OiBzdHJpbmcsIHZTaGFkZXJGaWxlcGF0aDogc3RyaW5nLCBmU2hhZGVyRmlsZXBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBzcGxpdFBhdGggPSB2U2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgIGxldCBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICBpZihlbmQgIT09IFwidnNoYWRlclwiKXtcclxuICAgICAgICAgICAgdGhyb3cgYCR7dlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIudnNoYWRlcmA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcGxpdFBhdGggPSBmU2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgIGVuZCA9IHNwbGl0UGF0aFtzcGxpdFBhdGgubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgIGlmKGVuZCAhPT0gXCJmc2hhZGVyXCIpe1xyXG4gICAgICAgICAgICB0aHJvdyBgJHtmU2hhZGVyRmlsZXBhdGh9IGlzIG5vdCBhIHZhbGlkIHZlcnRleCBzaGFkZXIgLSBtdXN0IGVuZCBpbiBcIi5mc2hhZGVyYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwYXRocyA9IG5ldyBLZXlQYXRoX1NoYWRlcigpO1xyXG4gICAgICAgIHBhdGhzLmtleSA9IGtleTtcclxuICAgICAgICBwYXRocy52cGF0aCA9IHZTaGFkZXJGaWxlcGF0aDtcclxuICAgICAgICBwYXRocy5mcGF0aCA9IGZTaGFkZXJGaWxlcGF0aDtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZW5xdWV1ZShwYXRocyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgIHB1YmxpYyBrZWVwU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2xfTG9hZFNoYWRlcnNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHdlYkdMIGlzbidhY3RpdmUgb3IgdGhlcmUgYXJlIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYoIXRoaXMuZ2xfV2ViR0xBY3RpdmUgfHwgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgbGV0IHNoYWRlciA9IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5nbF9Mb2FkU2hhZGVyKHNoYWRlci5rZXksIHNoYWRlci52cGF0aCwgc2hhZGVyLmZwYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdsX0xvYWRTaGFkZXIoa2V5OiBzdHJpbmcsIHZwYXRoOiBzdHJpbmcsIGZwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHZwYXRoLCAodkZpbGVUZXh0OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdlNoYWRlciA9IHZGaWxlVGV4dDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9hZFRleHRGaWxlKGZwYXRoLCAoZkZpbGVUZXh0OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZTaGFkZXIgPSBmRmlsZVRleHRcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBwcm9ncmFtIGFuZCBzaGFkZXJzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBbc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0gPSB0aGlzLmNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlciwgZlNoYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlciB0eXBlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmFtV3JhcHBlciA9IG5ldyBXZWJHTFByb2dyYW1UeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci5wcm9ncmFtID0gc2hhZGVyUHJvZ3JhbTtcclxuICAgICAgICAgICAgICAgIHByb2dyYW1XcmFwcGVyLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcclxuICAgICAgICAgICAgICAgIHByb2dyYW1XcmFwcGVyLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIG91ciBtYXBcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuYWRkKGtleSwgcHJvZ3JhbVdyYXBwZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU0hBREVSKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfRmluaXNoTG9hZGluZ1NoYWRlcihjYWxsYmFja0lmTGFzdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2xfRmluaXNoTG9hZGluZ1NoYWRlcihjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQpe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc2hhZGVyc1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlclNvdXJjZTogc3RyaW5nLCBmU2hhZGVyU291cmNlOiBzdHJpbmcpe1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMubG9hZFZlcnRleFNoYWRlcih2U2hhZGVyU291cmNlKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMubG9hZEZyYWdtZW50U2hhZGVyKGZTaGFkZXJTb3VyY2UpO1xyXG4gICAgXHJcbiAgICAgICAgaWYodmVydGV4U2hhZGVyID09PSBudWxsIHx8IGZyYWdtZW50U2hhZGVyID09PSBudWxsKXtcclxuICAgICAgICAgICAgLy8gV2UgaGFkIGEgcHJvYmxlbSBpbnRpYWxpemluZyAtIGVycm9yXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNoYWRlciBwcm9ncmFtXHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGlmKCFwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIC8vIEVycm9yIGNyZWF0aW5nXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjcmVhdGUgcHJvZ3JhbVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gQXR0YWNoIG91ciB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlclxyXG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gTGlua1xyXG4gICAgICAgIHRoaXMuZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgaWYoIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCB0aGlzLmdsLkxJTktfU1RBVFVTKSl7XHJcbiAgICAgICAgICAgIC8vIEVycm9yIGxpbmtpbmdcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gbGluayBwcm9ncmFtOiBcIiArIGVycm9yKTtcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gV2Ugc3VjY2Vzc2Z1bGx5IGNyZWF0ZSBhIHByb2dyYW1cclxuICAgICAgICByZXR1cm4gW3Byb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIGxvYWRWZXJ0ZXhTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdmVydGV4IHNoYWRlclxyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSLCBzaGFkZXJTb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIGxvYWRGcmFnbWVudFNoYWRlcihzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSLCBzaGFkZXJTb3VyY2UpO1x0XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByaXZhdGUgbG9hZFNoYWRlcih0eXBlOiBudW1iZXIsIHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICBcclxuICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBjcmVhdGUgdGhlIHNoYWRlciwgZXJyb3JcclxuICAgICAgICBpZihzaGFkZXIgPT09IG51bGwpe1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gY3JlYXRlIHNoYWRlclwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdG8gdGhlIHNoYWRlciBhbmQgY29tcGlsZVxyXG4gICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcclxuICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgIFxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSB3ZXJlIG5vIGVycm9ycyBkdXJpbmcgdGhpcyBwcm9jZXNzXHJcbiAgICAgICAgaWYoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpe1xyXG4gICAgICAgICAgICAvLyBOb3QgY29tcGlsZWQgLSBlcnJvclxyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6IFwiICsgZXJyb3IpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwXHJcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIFN1Y2Vzcywgc28gcmV0dXJuIHRoZSBzaGFkZXJcclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMgR0VORVJBTCBMT0FESU5HIEZVTkNUSU9OUyAjIyMjIyMjIyMjICovXHJcblxyXG4gICAgcHJpdmF0ZSBsb2FkVGV4dEZpbGUodGV4dEZpbGVQYXRoOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIGxldCB4b2JqOiBYTUxIdHRwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhvYmoub3ZlcnJpZGVNaW1lVHlwZShcImFwcGxpY2F0aW9uL2pzb25cIik7XHJcbiAgICAgICAgeG9iai5vcGVuKCdHRVQnLCB0ZXh0RmlsZVBhdGgsIHRydWUpO1xyXG4gICAgICAgIHhvYmoub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoKHhvYmoucmVhZHlTdGF0ZSA9PSA0KSAmJiAoeG9iai5zdGF0dXMgPT0gMjAwKSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soeG9iai5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB4b2JqLnNlbmQobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBMT0FESU5HIEJBUiBJTkZPICMjIyMjIyMjIyMgKi9cclxuXHJcbiAgICBwcml2YXRlIGdldExvYWRQZXJjZW50KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkL3RoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWRcclxuICAgICAgICAgICAgKyB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZC90aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZFxyXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkL3RoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkXHJcbiAgICAgICAgICAgICsgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZC90aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkKVxyXG4gICAgICAgICAgICAvIHRoaXMubG9hZG9ubHlfdHlwZXNUb0xvYWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5sb2FkaW5nKXtcclxuICAgICAgICAgICAgaWYodGhpcy5vbkxvYWRQcm9ncmVzcyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZFByb2dyZXNzKHRoaXMuZ2V0TG9hZFBlcmNlbnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYodGhpcy5qdXN0TG9hZGVkKXtcclxuICAgICAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkQ29tcGxldGUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRDb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSByZWZlcmVuY2UgdG8gYSByZXNvdXJjZS5cclxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgZXhlbXB0aW9uIGxpc3QgdG8gYXNzdXJlIGFzc2V0cyBhbmQgdGhlaXIgZGVwZW5kZW5jaWVzIGRvbid0IGdldFxyXG4gKiBkZXN0cm95ZWQgaWYgdGhleSBhcmUgc3RpbGwgbmVlZGVkLlxyXG4gKi9cclxuY2xhc3MgUmVzb3VyY2VSZWZlcmVuY2Uge1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICByZXNvdXJjZVR5cGU6IFJlc291cmNlVHlwZTtcclxuICAgIGRlcGVuZGVuY2llczogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGtleTogc3RyaW5nLCByZXNvdXJjZVR5cGU6IFJlc291cmNlVHlwZSl7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZVR5cGUgPSByZXNvdXJjZVR5cGU7XHJcbiAgICAgICAgdGhpcy4gZGVwZW5kZW5jaWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRGVwZW5kZW5jeShyZXNvdXJjZTogUmVzb3VyY2VSZWZlcmVuY2UpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHJlc291cmNlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmVudW0gUmVzb3VyY2VUeXBlIHtcclxuICAgIElNQUdFID0gXCJJTUFHRVwiLFxyXG4gICAgVElMRU1BUCA9IFwiVElMRU1BUFwiLFxyXG4gICAgU1BSSVRFU0hFRVQgPSBcIlNQUklURVNIRUVUXCIsXHJcbiAgICBBVURJTyA9IFwiQVVESU9cIixcclxuICAgIEpTT04gPSBcIkpTT05cIixcclxuICAgIFNIQURFUiA9IFwiU0hBREVSXCJcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgcGFpciByZXByZXNlbnRpbmcgYSBrZXkgYW5kIHRoZSBwYXRoIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkXHJcbiAqL1xyXG5jbGFzcyBLZXlQYXRoUGFpciB7XHJcbiAgICBrZXk6IHN0cmluZztcclxuICAgIHBhdGg6IHN0cmluZztcclxuICAgIGlzRGVwZW5kZW5jeT86IGJvb2xlYW4gPSBmYWxzZTtcclxufVxyXG5cclxuY2xhc3MgS2V5UGF0aF9TaGFkZXIge1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICB2cGF0aDogc3RyaW5nO1xyXG4gICAgZnBhdGg6IHN0cmluZztcclxufSIsImltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBpbnRlcmZhY2Ugb2YgYSBTY2VuZUdyYXBoLlxyXG4gKiBFeHBvc2VzIG1ldGhvZHMgZm9yIHVzZSBieSBvdGhlciBjb2RlLCBidXQgbGVhdmVzIHRoZSBpbXBsZW1lbnRhdGlvbiB1cCB0byB0aGUgc3ViY2xhc3Nlcy5cclxuICogVGhlIFNjZW5lR3JhcGggbWFuYWdlcyB0aGUgcG9zaXRpb25zIG9mIGFsbCBHYW1lTm9kZXMsIGFuZCBjYW4gZWFzaWx5IHBydW5lIGEgdmlzaWJsZSBzZXQgZm9yIHJlbmRlcmluZy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNjZW5lR3JhcGgge1xyXG5cdC8qKlx0QSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0ICovXHJcblx0cHJvdGVjdGVkIHZpZXdwb3J0OiBWaWV3cG9ydDtcclxuXHQvKipcdEEgbWFwIG9mIENhbnZhc05vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xyXG5cdHByb3RlY3RlZCBub2RlTWFwOiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHQvKiogQSBjb3VudGVyIG9mIElEcyBmb3Igbm9kZXMgaW4gdGhpcyBTY2VuZUdyYXBoICovXHJcblx0cHJvdGVjdGVkIGlkQ291bnRlcjogbnVtYmVyO1xyXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG8gKi9cclxuXHRwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IFNjZW5lR3JhcGhcclxuXHQgKiBAcGFyYW0gdmlld3BvcnQgVGhlIHZpZXdwb3J0XHJcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0aGlzIFNjZW5lR3JhcGggYmVsb25ncyB0b1xyXG5cdCAqL1xyXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZTogU2NlbmUpe1xyXG5cdFx0dGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdFx0dGhpcy5ub2RlTWFwID0gbmV3IEFycmF5KCk7XHJcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XHJcbiAgICB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZCBhIG5vZGUgdG8gdGhlIFNjZW5lR3JhcGhcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgQ2FudmFzTm9kZSB0byBhZGQgdG8gdGhlIFNjZW5lR3JhcGhcclxuXHQgKiBAcmV0dXJucyBUaGUgU2NlbmVHcmFwaCBJRCBvZiB0aGlzIG5ld2x5IGFkZGVkIENhbnZhc05vZGVcclxuXHQgKi9cclxuICAgIGFkZE5vZGUobm9kZTogQ2FudmFzTm9kZSk6IG51bWJlciB7XHJcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xyXG5cdFx0dGhpcy5hZGROb2RlU3BlY2lmaWMobm9kZSwgdGhpcy5pZENvdW50ZXIpO1xyXG5cdFx0dGhpcy5pZENvdW50ZXIgKz0gMTtcclxuXHRcdHJldHVybiB0aGlzLmlkQ291bnRlciAtIDE7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQW4gb3ZlcnJpZGFibGUgbWV0aG9kIHRvIGFkZCBhIENhbnZhc05vZGUgdG8gdGhlIHNwZWNpZmljIGRhdGEgc3RydWN0dXJlIG9mIHRoZSBTY2VuZUdyYXBoXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gYWRkIHRvIHRoZSBkYXRhIHN0cnVjdHVyZVxyXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIENhbnZhc05vZGVcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgYWRkTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBTY2VuZUdyYXBoXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXHJcblx0ICovXHJcbiAgICByZW1vdmVOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcclxuXHRcdC8vIEZpbmQgYW5kIHJlbW92ZSBub2RlIGluIE8obilcclxuXHRcdHRoaXMubm9kZU1hcFtub2RlLmlkXSA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMucmVtb3ZlTm9kZVNwZWNpZmljKG5vZGUsIG5vZGUuaWQpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiByZW1vdmluZyBhIG5vZGVcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcclxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBub2RlIHRvIHJlbW92ZVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCByZW1vdmVOb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhIHNwZWNpZmljIG5vZGUgdXNpbmcgaXRzIGlkXHJcblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgQ2FudmFzTm9kZSB0byByZXRyaWV2ZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBub2RlIHdpdGggdGhpcyBJRFxyXG5cdCAqL1xyXG5cdGdldE5vZGUoaWQ6IG51bWJlcik6IENhbnZhc05vZGUge1xyXG5cdFx0cmV0dXJuIHRoaXMubm9kZU1hcFtpZF07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBub2RlcyBhdCBzcGVjaWZpYyBjb29yZGluYXRlc1xyXG5cdCAqIEBwYXJhbSB2ZWNPclggVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb24sIG9yIHRoZSBjb29yZGluYXRlcyBpbiBhIFZlYzJcclxuXHQgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvblxyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIGZvdW5kIGF0IHRoZSBwb3NpdGlvbiBwcm92aWRlZFxyXG5cdCAqL1xyXG4gICAgZ2V0Tm9kZXNBdCh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiBBcnJheTxDYW52YXNOb2RlPiB7XHJcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZXNBdENvb3Jkcyh2ZWNPclgueCwgdmVjT3JYLnkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZXNBdENvb3Jkcyh2ZWNPclgsIHkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgdGhhdCBvdmVybGFwIGEgc3BlY2lmaWMgYm91bmRhcnlcclxuXHQgKiBAcGFyYW0gYm91bmRhcnkgVGhlIHJlZ2lvbiB0byBjaGVja1xyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIGZvdW5kIG92ZXJsYXBwaW5nIHRoZSBwcm92aWRlZCBib3VuZGFyeVxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IGdldE5vZGVzSW5SZWdpb24oYm91bmRhcnk6IEFBQkIpOiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFsbCBub2RlcyBpbiB0aGUgU2NlbmVHcmFwaFxyXG5cdCAqIEByZXR1cm5zIEFuIEFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXHJcblx0ICovXHJcblx0Z2V0QWxsTm9kZXMoKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG5cdFx0bGV0IGFyciA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubm9kZU1hcC5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdGlmKHRoaXMubm9kZU1hcFtpXSAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0XHRhcnIucHVzaCh0aGlzLm5vZGVNYXBbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXJyO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIGdldHRpbmcgYSBub2RlIGF0IGNlcnRhaW4gY29vcmRpbmF0ZXNcclxuXHQgKiBAcGFyYW0geCBUaGUgeC1jb29yZGluYXRlcyBvZiB0aGUgbm9kZVxyXG5cdCAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGVzIG9mIHRoZSBub2RlXHJcblx0ICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0Tm9kZXNBdENvb3Jkcyh4OiBudW1iZXIsIHk6IG51bWJlcik6IEFycmF5PENhbnZhc05vZGU+O1xyXG5cclxuXHRhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xyXG5cdFxyXG5cdGFic3RyYWN0IHJlbmRlcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzIGJhc2VkIG9uIHRoZSBAcmVmZXJlbmNlW1ZpZXdwb3J0XVxyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHZpc2libGUgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcclxuXHQgKi9cclxuICAgIGFic3RyYWN0IGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT47XHJcbn0iLCJpbXBvcnQgU2NlbmVHcmFwaCBmcm9tIFwiLi9TY2VuZUdyYXBoXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgU2NlbmVHcmFwaCB0aGF0IHNpbXBseSBzdG9yZWQgQ2FudmFzTm9kZXMgaW4gYW4gYXJyYXkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZUdyYXBoQXJyYXkgZXh0ZW5kcyBTY2VuZUdyYXBoIHtcclxuICAgIC8qKiBUaGUgbGlzdCBvZiBDYW52YXNOb2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cclxuICAgIHByaXZhdGUgbm9kZUxpc3Q6IEFycmF5PENhbnZhc05vZGU+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoQXJyYXlcclxuICAgICAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgVmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZTogU2NlbmUpe1xyXG4gICAgICAgIHN1cGVyKHZpZXdwb3J0LCBzY2VuZSk7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZUxpc3QgPSBuZXcgQXJyYXk8Q2FudmFzTm9kZT4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCBhZGROb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubm9kZUxpc3QucHVzaChub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW1vdmVOb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubm9kZUxpc3QuaW5kZXhPZihub2RlKTtcclxuICAgICAgICBpZihpbmRleCA+IC0xKXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xyXG4gICAgICAgICAgICBpZihub2RlLmNvbnRhaW5zKHgsIHkpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBnZXROb2Rlc0luUmVnaW9uKGJvdW5kYXJ5OiBBQUJCKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG4gICAgICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XHJcblxyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcclxuICAgICAgICAgICAgaWYoYm91bmRhcnkub3ZlcmxhcHMobm9kZS5ib3VuZGFyeSkpe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0MSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIFN0YXRzLmxvZyhcInNncXVlcnlcIiwgKHQxLXQwKSk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcclxuICAgICAgICAgICAgaWYoIW5vZGUuZ2V0TGF5ZXIoKS5pc1BhdXNlZCgpKXtcclxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgU3RhdHMubG9nKFwic2d1cGRhdGVcIiwgKHQxLXQwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7fVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgZ2V0VmlzaWJsZVNldCgpOiBBcnJheTxDYW52YXNOb2RlPiB7XHJcbiAgICAgICAgbGV0IHZpc2libGVTZXQgPSBuZXcgQXJyYXk8Q2FudmFzTm9kZT4oKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xyXG4gICAgICAgICAgICBpZighbm9kZS5nZXRMYXllcigpLmlzSGlkZGVuKCkgJiYgbm9kZS52aXNpYmxlICYmIHRoaXMudmlld3BvcnQuaW5jbHVkZXMobm9kZSkpe1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmlzaWJsZVNldDtcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyXCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB2aWV3cG9ydCBvZiB0aGUgZ2FtZS4gQ29ycmVzcG9uZHMgdG8gdGhlIHZpc2libGUgd2luZG93IGRpc3BsYXllZCBpbiB0aGUgYnJvd3Nlci5cclxuICogVGhlIHZpZXdwb3J0IGtlZXBzIHRyYWNrIG9mIGl0cyBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB3b3JsZCwgYW5kIGNhbiBhY3QgYXMgYSBjYW1lcmEgdG8gZm9sbG93IG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3cG9ydCB7XHJcbiAgICAvKiogVGhlIEFBQkIgdGhhdCBjb250YWlucyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHZpZXdwb3J0IHZpZXcgKi9cclxuICAgIHByaXZhdGUgdmlldzogQUFCQjtcclxuICAgIC8qKiBUaGUgYm91bmRhcnkgZm9yIHRoZSB2aWV3cG9ydC4gVGhpcyByZXByZXNlbnRzIHRoZSBsaW1pdHMgdG8gd2hlcmUgdGhlIHZpZXdwb3J0IGNhbiBnbyAqL1xyXG4gICAgcHJpdmF0ZSBib3VuZGFyeTogQUFCQjtcclxuICAgIC8qKiBUaGUgR2FtZU5vZGUgdGhlIFZpZXdwb3J0IGlzIGZvbGxvd2luZyAqL1xyXG4gICAgcHJpdmF0ZSBmb2xsb3dpbmc6IEdhbWVOb2RlO1xyXG4gICAgLyoqIFRoZSBwb3NpdGlvbiB0aGUgR2FtZU5vZGUgaXMgZm9jdXNpbmcgb24uIFRoaXMgaXMgb3ZlcnJpZGRlbiBpZiBcImZvbGxvd2luZ1wiIGlzIHNldC4gKi9cclxuICAgIHByaXZhdGUgZm9jdXM6IFZlYzI7XHJcblxyXG4gICAgLyoqIEEgcXVldWUgb2YgcHJldmlvdXMgcG9zaXRpb25zIG9mIHdoYXQgdGhpcyB2aWV3cG9ydCBpcyBmb2xsb3dpbmcuIFVzZWQgZm9yIHNtb290aGluZyB2aWV3cG9ydCBtb3ZlbWVudCAqL1xyXG4gICAgcHJpdmF0ZSBsYXN0UG9zaXRpb25zOiBRdWV1ZTxWZWMyPjtcclxuXHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBwcmV2aW91cyBwb3NpdGlvbnMgdGhpcyB2aWV3cG9ydCB0cmFja3MgKi9cclxuICAgIHByaXZhdGUgc21vb3RoaW5nRmFjdG9yOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIEEgYm9vbGVhbiB0aGEgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHpvb20gYnkgc2Nyb2xsaW5nIHdpdGggdGhlIG1vdXNlIHdoZWVsICovXHJcbiAgICBwcml2YXRlIHNjcm9sbFpvb21FbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgYW1vdW50IHRoYXQgaXMgem9vbWVkIGluIG9yIG91dC4gKi9cclxuICAgIHByaXZhdGUgWk9PTV9GQUNUT1I6IG51bWJlciA9IDEuMjtcclxuXHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIGNhbnZhcyAqL1xyXG4gICAgcHJpdmF0ZSBjYW52YXNTaXplOiBWZWMyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNhbnZhc1NpemU6IFZlYzIsIHpvb21MZXZlbDogbnVtYmVyKXtcclxuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGFyeSA9IG5ldyBBQUJCKFZlYzIuWkVSTywgVmVjMi5aRVJPKTtcclxuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICB0aGlzLnNtb290aGluZ0ZhY3RvciA9IDEwO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhbnZhc1NpemUgPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5mb2N1cyA9IFZlYzIuWkVSTztcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXNcclxuICAgICAgICB0aGlzLnNldENhbnZhc1NpemUoY2FudmFzU2l6ZSk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAgICB0aGlzLnNldFNpemUoY2FudmFzU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5zZXRab29tTGV2ZWwoem9vbUxldmVsKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBjZW50ZXIgKGFuZCBtYWtlIHRoZSB2aWV3cG9ydCBzdGF5IHRoZXJlKVxyXG4gICAgICAgIHRoaXMuc2V0Q2VudGVyKHRoaXMudmlldy5oYWxmU2l6ZS5jbG9uZSgpKTtcclxuICAgICAgICB0aGlzLnNldEZvY3VzKHRoaXMudmlldy5oYWxmU2l6ZS5jbG9uZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRW5hYmxlcyB0aGUgdmlld3BvcnQgdG8gem9vbSBpbiBhbmQgb3V0ICovXHJcbiAgICBlbmFibGVab29tKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcclxuICAgICAqL1xyXG4gICAgZ2V0Q2VudGVyKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuY2VudGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWMyIHdpdGggdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3AgbGVmdCBjb3JuZGVyIG9mIHRoZSBWaWVwb3J0IGFzIGEgVmVjMlxyXG4gICAgICovXHJcbiAgICBnZXRPcmlnaW4oKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMudmlldy5sZWZ0LCB0aGlzLnZpZXcudG9wKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoaXMgdmlld3BvcnRcclxuICAgICAqIEByZXR1cm5zIFRoZSBBQUJCIGNvbnRhaW5pbmcgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBnZXRWaWV3KCk6IEFBQkIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHBvc2l0aW9uIG9yIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIHNldENlbnRlcih2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgICBsZXQgcG9zOiBWZWMyO1xyXG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XHJcbiAgICAgICAgICAgIHBvcyA9IHZlY09yWDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3MgPSBuZXcgVmVjMih2ZWNPclgsIHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlciA9IHBvcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxyXG4gICAgICogQHJldHVybnMgVGhlIGhhbGYtc2l6ZSBvZiB0aGUgdmlld3BvcnQgYXMgYSBWZWMyXHJcbiAgICAgKi9cclxuICAgIGdldEhhbGZTaXplKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SGFsZlNpemUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHdpZHRoIG9mIHRoZSB2aWV3cG9ydCBvciB0aGUgbmV3IHNpemUgYXMgYSBWZWMyXHJcbiAgICAgKiBAcGFyYW0geSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgc2V0U2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xyXG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUodmVjT3JYLnNjYWxlZCgxLzIpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZShuZXcgVmVjMih2ZWNPclgvMiwgeS8yKSk7XHJcblx0XHR9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gdmVjT3JYIFRoZSBuZXcgaGFsZi13aWR0aCBvZiB0aGUgdmlld3BvcnQgb3IgdGhlIG5ldyBoYWxmLXNpemUgYXMgYSBWZWMyXHJcbiAgICAgKiBAcGFyYW0geSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgc2V0SGFsZlNpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKHZlY09yWC5jbG9uZSgpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZShuZXcgVmVjMih2ZWNPclgsIHkpKTtcclxuXHRcdH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpZXdwb3J0IHdpdGggdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0gdmVjT3JYIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzLCBvciB0aGUgY2FudmFzIHNpemUgYXMgYSBWZWMyXHJcbiAgICAgKiBAcGFyYW0geSBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXNcclxuICAgICAqL1xyXG4gICAgc2V0Q2FudmFzU2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xyXG5cdFx0XHR0aGlzLmNhbnZhc1NpemUgPSB2ZWNPclguY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHZlY09yWCwgeSk7XHJcblx0XHR9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcclxuICAgICAqL1xyXG4gICAgc2V0Wm9vbUxldmVsKHpvb206IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudmlldy5oYWxmU2l6ZS5jb3B5KHRoaXMuY2FudmFzU2l6ZS5zY2FsZWQoMS96b29tLzIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbFxyXG4gICAgICovXHJcbiAgICBnZXRab29tTGV2ZWwoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNTaXplLngvdGhpcy52aWV3Lmh3LzJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydCBtb3ZlbWVudC5cclxuICAgICAqIEBwYXJhbSBzbW9vdGhpbmdGYWN0b3IgVGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBzZXRTbW9vdGhpbmdGYWN0b3Ioc21vb3RoaW5nRmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZihzbW9vdGhpbmdGYWN0b3IgPCAxKSBzbW9vdGhpbmdGYWN0b3IgPSAxO1xyXG4gICAgICAgIHRoaXMuc21vb3RoaW5nRmFjdG9yID0gc21vb3RoaW5nRmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHZpZXdwb3J0IHRvIGZvY3VzIG9uIGEgcG9pbnQuIE92ZXJpZGRlbiBieSBcImZvbGxvd2luZ1wiLlxyXG4gICAgICogQHBhcmFtIGZvY3VzIFRoZSBwb2ludCB0aGUgIHZpZXdwb3J0IHNob3VsZCBmb2N1cyBvblxyXG4gICAgICovXHJcbiAgICBzZXRGb2N1cyhmb2N1czogVmVjMik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZm9jdXMuY29weShmb2N1cyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBDYW52YXNOb2RlIGlzIGluc2lkZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBub2RlIGlzIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydCwgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIGluY2x1ZGVzKG5vZGU6IENhbnZhc05vZGUpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgcGFyYWxsYXggPSBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyIHx8IG5vZGUuZ2V0TGF5ZXIoKSBpbnN0YW5jZW9mIFVJTGF5ZXIgPyAoPFBhcmFsbGF4TGF5ZXI+bm9kZS5nZXRMYXllcigpKS5wYXJhbGxheCA6IG5ldyBWZWMyKDEsIDEpO1xyXG4gICAgICAgIGxldCBjZW50ZXIgPSB0aGlzLnZpZXcuY2VudGVyLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlci5tdWx0KHBhcmFsbGF4KTtcclxuICAgICAgICBsZXQgb3ZlcmxhcHMgPSB0aGlzLnZpZXcub3ZlcmxhcHMobm9kZS5ib3VuZGFyeSk7XHJcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlciA9IGNlbnRlclxyXG4gICAgICAgIHJldHVybiBvdmVybGFwcztcclxuICAgIH1cclxuXHJcblx0Ly8gVE9ETzogUHV0IHNvbWUgZXJyb3IgaGFuZGxpbmcgb24gdGhpcyBmb3IgdHJ5aW5nIHRvIG1ha2UgdGhlIGJvdW5kcyB0b28gc21hbGwgZm9yIHRoZSB2aWV3cG9ydFxyXG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSBhdXRvbWF0aWNhbGx5LCBvciBzaG91bGQgY29uc2lkZXIgdGhlIGFzcGVjdCByYXRpbyBvciBzb21ldGhpbmdcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYm91bmRzIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIGxvd2VyWCBUaGUgbGVmdCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIGxvd2VyWSBUaGUgdG9wIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gdXBwZXJYIFRoZSByaWdodCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHVwcGVyWSBUaGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHNldEJvdW5kcyhsb3dlclg6IG51bWJlciwgbG93ZXJZOiBudW1iZXIsIHVwcGVyWDogbnVtYmVyLCB1cHBlclk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBod2lkdGggPSAodXBwZXJYIC0gbG93ZXJYKS8yO1xyXG4gICAgICAgIGxldCBoaGVpZ2h0ID0gKHVwcGVyWSAtIGxvd2VyWSkvMjtcclxuICAgICAgICBsZXQgeCA9IGxvd2VyWCArIGh3aWR0aDtcclxuICAgICAgICBsZXQgeSA9IGxvd2VyWSArIGhoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5ib3VuZGFyeS5jZW50ZXIuc2V0KHgsIHkpO1xyXG4gICAgICAgIHRoaXMuYm91bmRhcnkuaGFsZlNpemUuc2V0KGh3aWR0aCwgaGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIHRoZSB2aWV3cG9ydCBmb2xsb3cgdGhlIHNwZWNpZmllZCBHYW1lTm9kZVxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIEdhbWVOb2RlIHRvIGZvbGxvd1xyXG4gICAgICovXHJcbiAgICBmb2xsb3cobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZvbGxvd2luZyA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVmlldygpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLmxhc3RQb3NpdGlvbnMuZ2V0U2l6ZSgpID4gdGhpcy5zbW9vdGhpbmdGYWN0b3Ipe1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZGVxdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBHZXQgdGhlIGF2ZXJhZ2Ugb2YgdGhlIGxhc3QgMTAgcG9zaXRpb25zXHJcbiAgICAgICAgbGV0IHBvcyA9IFZlYzIuWkVSTztcclxuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBwb3MuYWRkKHBvc2l0aW9uKSk7XHJcbiAgICAgICAgcG9zLnNjYWxlKDEvdGhpcy5sYXN0UG9zaXRpb25zLmdldFNpemUoKSk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGlzIHBvc2l0aW9uIGVpdGhlciB0byB0aGUgb2JqZWN0IG9yIHRvIGl0cyBib3VuZHNcclxuICAgICAgICBwb3MueCA9IE1hdGhVdGlscy5jbGFtcChwb3MueCwgdGhpcy5ib3VuZGFyeS5sZWZ0ICsgdGhpcy52aWV3Lmh3LCB0aGlzLmJvdW5kYXJ5LnJpZ2h0IC0gdGhpcy52aWV3Lmh3KTtcclxuICAgICAgICBwb3MueSA9IE1hdGhVdGlscy5jbGFtcChwb3MueSwgdGhpcy5ib3VuZGFyeS50b3AgKyB0aGlzLnZpZXcuaGgsIHRoaXMuYm91bmRhcnkuYm90dG9tIC0gdGhpcy52aWV3LmhoKTtcclxuXHJcbiAgICAgICAgLy8gQXNzdXJlIHRoZXJlIGFyZSBubyBsaW5lcyBpbiB0aGUgdGlsZW1hcFxyXG4gICAgICAgIHBvcy54ID0gTWF0aC5mbG9vcihwb3MueCk7XHJcbiAgICAgICAgcG9zLnkgPSBNYXRoLmZsb29yKHBvcy55KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnZpZXcuY2VudGVyLmNvcHkocG9zKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICAvLyBJZiB6b29tIGlzIGVuYWJsZWRcclxuICAgICAgICBpZih0aGlzLnNjcm9sbFpvb21FbmFibGVkKXtcclxuICAgICAgICAgICAgaWYoSW5wdXQuZGlkSnVzdFNjcm9sbCgpKXtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMudmlldy5nZXRIYWxmU2l6ZSgpLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBpZihJbnB1dC5nZXRTY3JvbGxEaXJlY3Rpb24oKSA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFpvb20gaW5cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSgxL3RoaXMuWk9PTV9GQUNUT1IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBab29tIG91dFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnNjYWxlKHRoaXMuWk9PTV9GQUNUT1IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnggPiB0aGlzLmJvdW5kYXJ5Lmh3KXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjdG9yID0gdGhpcy5ib3VuZGFyeS5ody9jdXJyZW50U2l6ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnggPSB0aGlzLmJvdW5kYXJ5Lmh3O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnkgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnkgPiB0aGlzLmJvdW5kYXJ5LmhoKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjdG9yID0gdGhpcy5ib3VuZGFyeS5oaC9jdXJyZW50U2l6ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnkgPSB0aGlzLmJvdW5kYXJ5LmhoO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnggKj0gZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRIYWxmU2l6ZShjdXJyZW50U2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHZpZXdwb3J0IGlzIGZvbGxvd2luZyBhbiBvYmplY3RcclxuICAgICAgICBpZih0aGlzLmZvbGxvd2luZyl7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXIgbGlzdCBvZiBwcmV2aW91cyBwb3NpdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmVucXVldWUodGhpcy5mb2xsb3dpbmcucG9zaXRpb24uY2xvbmUoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmVucXVldWUodGhpcy5mb2N1cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcclxuICAgIH1cclxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcclxuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgU2xpZGVyIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlclwiO1xyXG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuLyoqXHJcbiAqIEEgZmFjdG9yeSB0aGF0IGFic3RyYWN0cyBhZGRpbmcgQHJlZmVyZW5jZVtDYW52YXNOb2RlXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxyXG4gKiBBY2Nlc3MgbWV0aG9kcyBpbiB0aGlzIGZhY3RvcnkgdGhyb3VnaCBTY2VuZS5hZGQuW21ldGhvZE5hbWVdKCkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNOb2RlRmFjdG9yeSB7XHJcblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuXHRwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcblxyXG5cdGluaXQoc2NlbmU6IFNjZW5lKTogdm9pZCB7XHJcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhbiBpbnN0YW5jZSBvZiBhIFVJRWxlbWVudCB0byB0aGUgY3VycmVudCBzY2VuZSAtIGkuZS4gYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBVSUVsZW1lbnRcclxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBVSUVsZW1lbnQgdG8gYWRkXHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgdG8gYWRkIHRoZSBVSUVsZW1lbnQgdG9cclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gZmVlZCB0byB0aGUgY29uc3RydWN0b3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBVSUVsZW1lbnRcclxuXHQgKi9cclxuXHRhZGRVSUVsZW1lbnQgPSAodHlwZTogc3RyaW5nIHwgVUlFbGVtZW50VHlwZSwgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVUlFbGVtZW50ID0+IHtcclxuXHRcdC8vIEdldCB0aGUgbGF5ZXJcclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcclxuXHJcblx0XHRsZXQgaW5zdGFuY2U6IFVJRWxlbWVudDtcclxuXHJcblx0XHRzd2l0Y2godHlwZSl7XHJcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5CVVRUT046XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkQnV0dG9uKG9wdGlvbnMpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLkxBQkVMOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZExhYmVsKG9wdGlvbnMpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLlNMSURFUjpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRTbGlkZXIob3B0aW9ucyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuVEVYVF9JTlBVVDpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRUZXh0SW5wdXQob3B0aW9ucyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93IGBVSUVsZW1lbnRUeXBlICcke3R5cGV9JyBkb2VzIG5vdCBleGlzdCwgb3IgaXMgcmVnaXN0ZXJlZCBpbmNvcnJlY3RseS5gXHJcblx0XHR9XHJcblxyXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG5cdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXHJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKVxyXG5cclxuXHRcdHJldHVybiBpbnN0YW5jZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBzcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IFNwcml0ZVxyXG5cdCAqL1xyXG5cdGFkZFNwcml0ZSA9IChrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBTcHJpdGUgPT4ge1xyXG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xyXG5cclxuXHRcdGxldCBpbnN0YW5jZSA9IG5ldyBTcHJpdGUoa2V5KTtcclxuXHJcblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gc2NlbmVcclxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcclxuXHJcblx0XHRpZighKHRoaXMuc2NlbmUuaXNQYXJhbGxheExheWVyKGxheWVyTmFtZSkgfHwgdGhpcy5zY2VuZS5pc1VJTGF5ZXIobGF5ZXJOYW1lKSkpe1xyXG5cdFx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXHJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcclxuXHJcblx0XHRyZXR1cm4gaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGFuIEFuaW1hdGVkU3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBBbmltYXRlZFNwcml0ZVxyXG5cdCAqL1xyXG5cdGFkZEFuaW1hdGVkU3ByaXRlID0gKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IEFuaW1hdGVkU3ByaXRlID0+IHtcclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcclxuXHRcdGxldCBzcHJpdGVzaGVldCA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNwcml0ZXNoZWV0KGtleSk7XHJcblx0XHRsZXQgaW5zdGFuY2UgPSBuZXcgQW5pbWF0ZWRTcHJpdGUoc3ByaXRlc2hlZXQpO1xyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSBmbyBzY2VuZVxyXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG5cdFx0XHJcblx0XHRpZighKHRoaXMuc2NlbmUuaXNQYXJhbGxheExheWVyKGxheWVyTmFtZSkgfHwgdGhpcy5zY2VuZS5pc1VJTGF5ZXIobGF5ZXJOYW1lKSkpe1xyXG5cdFx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cclxuXHRcdHJldHVybiBpbnN0YW5jZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBuZXcgZ3JhcGhpYyBlbGVtZW50IHRvIHRoZSBjdXJyZW50IFNjZW5lXHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZ3JhcGhpYyB0byBhZGRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIGdyYXBoaWNcclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgZ3JhcGhpYyBjb25zdHJ1Y3RvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IEdyYXBoaWNcclxuXHQgKi9cclxuXHRhZGRHcmFwaGljID0gKHR5cGU6IEdyYXBoaWNUeXBlIHwgc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBHcmFwaGljID0+IHtcclxuXHRcdC8vIEdldCB0aGUgbGF5ZXJcclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcclxuXHJcblx0XHRsZXQgaW5zdGFuY2U6IEdyYXBoaWM7XHJcblxyXG5cdFx0c3dpdGNoKHR5cGUpe1xyXG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLlBPSU5UOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFBvaW50KG9wdGlvbnMpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLkxJTkU6XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkTGluZShvcHRpb25zKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5SRUNUOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFJlY3Qob3B0aW9ucyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhyb3cgYEdyYXBoaWNUeXBlICcke3R5cGV9JyBkb2VzIG5vdCBleGlzdCwgb3IgaXMgcmVnaXN0ZXJlZCBpbmNvcnJlY3RseS5gXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIHNjZW5lXHJcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcclxuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcblxyXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXHJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcclxuXHJcblx0XHRyZXR1cm4gaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuXHQvKiAtLS0tLS0tLS0tIEJVSUxERVJTIC0tLS0tLS0tLS0gKi9cclxuXHJcblx0YnVpbGRCdXR0b24ob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBCdXR0b24ge1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkJ1dHRvblwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJ0ZXh0XCIsIFwic3RyaW5nXCIpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgQnV0dG9uKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMudGV4dCk7XHJcblx0fVxyXG5cclxuXHRidWlsZExhYmVsKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogTGFiZWwge1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxhYmVsXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxhYmVsXCIsIG9wdGlvbnMsIFwidGV4dFwiLCBcInN0cmluZ1wiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExhYmVsKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMudGV4dClcclxuXHR9XHJcblxyXG5cdGJ1aWxkU2xpZGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBTbGlkZXIge1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlNsaWRlclwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHJcblx0XHRsZXQgaW5pdFZhbHVlID0gMDtcclxuXHRcdGlmKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdGluaXRWYWx1ZSA9IG9wdGlvbnMudmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBTbGlkZXIob3B0aW9ucy5wb3NpdGlvbiwgaW5pdFZhbHVlKTtcclxuXHR9XHJcblxyXG5cdGJ1aWxkVGV4dElucHV0KG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBUZXh0SW5wdXQge1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlRleHRJbnB1dFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRleHRJbnB1dChvcHRpb25zLnBvc2l0aW9uKTtcclxuXHR9XHJcblxyXG5cdGJ1aWxkUG9pbnQob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQb2ludCB7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUG9pbnRcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2ludChvcHRpb25zLnBvc2l0aW9uKTtcclxuXHR9XHJcblxyXG5cdGJ1aWxkTGluZShvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFBvaW50IHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMaW5lXCIsIG9wdGlvbnMsIFwic3RhcnRcIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIkxpbmVcIiwgb3B0aW9ucywgXCJlbmRcIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGluZShvcHRpb25zLnN0YXJ0LCBvcHRpb25zLmVuZCk7XHJcblx0fVxyXG5cclxuXHRidWlsZFJlY3Qob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWN0IHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlJlY3RcIiwgb3B0aW9ucywgXCJzaXplXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFJlY3Qob3B0aW9ucy5wb3NpdGlvbiwgb3B0aW9ucy5zaXplKTtcclxuXHR9XHJcblxyXG5cdC8qIC0tLS0tLS0tLS0gRVJST1IgSEFORExJTkcgLS0tLS0tLS0tLSAqL1xyXG5cclxuXHRjaGVja0lmUHJvcEV4aXN0czxUPihvYmplY3ROYW1lOiBzdHJpbmcsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3A6IHN0cmluZywgdHlwZTogKG5ldyAoLi4uYXJnczogYW55KSA9PiBUKSB8IHN0cmluZywgdHlwZU5hbWU/OiBzdHJpbmcpe1xyXG5cdFx0aWYoIW9wdGlvbnMgfHwgb3B0aW9uc1twcm9wXSA9PT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgb3B0aW9ucyBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eVxyXG5cdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgbm9uZSB3YXMgcHJvdmlkZWQuYDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIHByb3BlcnR5IGhhcyB0aGUgY29ycmVjdCB0eXBlXHJcblx0XHRcdGlmKCh0eXBlb2YgdHlwZSkgPT09IFwic3RyaW5nXCIpe1xyXG5cdFx0XHRcdGlmKCEodHlwZW9mIG9wdGlvbnNbcHJvcF0gPT09IHR5cGUpKXtcclxuXHRcdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlfSwgYnV0IHByb3ZpZGVkICR7cHJvcH0gd2FzIG5vdCBvZiB0eXBlICR7dHlwZX0uYDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZih0eXBlIGluc3RhbmNlb2YgRnVuY3Rpb24pe1xyXG5cdFx0XHRcdC8vIElmIHR5cGUgaXMgYSBjb25zdHJ1Y3RvciwgY2hlY2sgYWdhaW5zdCB0aGF0XHJcblx0XHRcdFx0aWYoIShvcHRpb25zW3Byb3BdIGluc3RhbmNlb2YgdHlwZSkpe1xyXG5cdFx0XHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGVOYW1lfSwgYnV0IHByb3ZpZGVkICR7cHJvcH0gd2FzIG5vdCBvZiB0eXBlICR7dHlwZU5hbWV9LmA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZUZhY3RvcnkgZnJvbSBcIi4vQ2FudmFzTm9kZUZhY3RvcnlcIjtcclxuaW1wb3J0IFRpbGVtYXBGYWN0b3J5IGZyb20gXCIuL1RpbGVtYXBGYWN0b3J5XCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtYW5hZ2VyIG9mIGFsbCBmYWN0b3JpZXMgdXNlZCBmb3IgYWRkaW5nIEByZWZlcmVuY2VbR2FtZU5vZGVdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWN0b3J5TWFuYWdlciB7XHJcblxyXG4gICAgLy8gQ29uc3RydWN0b3JzIGFyZSBjYWxsZWQgaGVyZSB0byBhbGxvdyBhc3NpZ25tZW50IG9mIHRoZWlyIGZ1bmN0aW9ucyB0byBmdW5jdGlvbnMgaW4gdGhpcyBjbGFzc1xyXG4gICAgcHJpdmF0ZSBjYW52YXNOb2RlRmFjdG9yeTogQ2FudmFzTm9kZUZhY3RvcnkgPSBuZXcgQ2FudmFzTm9kZUZhY3RvcnkoKTtcclxuICAgIHByaXZhdGUgdGlsZW1hcEZhY3Rvcnk6IFRpbGVtYXBGYWN0b3J5ID0gbmV3IFRpbGVtYXBGYWN0b3J5KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD4pe1xyXG4gICAgICAgIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuaW5pdChzY2VuZSk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwRmFjdG9yeS5pbml0KHNjZW5lLCB0aWxlbWFwcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhwb3NlIGFsbCBvZiB0aGUgZmFjdG9yaWVzIHRocm91Z2ggdGhlIGZhY3RvcnkgbWFuYWdlclxyXG4gICAgLyoqXHJcblx0ICogQWRkcyBhbiBpbnN0YW5jZSBvZiBhIFVJRWxlbWVudCB0byB0aGUgY3VycmVudCBzY2VuZSAtIGkuZS4gYW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBVSUVsZW1lbnRcclxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBVSUVsZW1lbnQgdG8gYWRkXHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgdG8gYWRkIHRoZSBVSUVsZW1lbnQgdG9cclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gZmVlZCB0byB0aGUgY29uc3RydWN0b3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBVSUVsZW1lbnRcclxuXHQgKi9cclxuICAgIHVpRWxlbWVudCh0eXBlOiBzdHJpbmcgfCBVSUVsZW1lbnRUeXBlLCBsYXllck5hbWU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBVSUVsZW1lbnQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZFVJRWxlbWVudCh0eXBlLCBsYXllck5hbWUsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIEFkZHMgYSBzcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IFNwcml0ZVxyXG5cdCAqL1xyXG5cdHNwcml0ZShrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBTcHJpdGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZFNwcml0ZShrZXksIGxheWVyTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcblx0ICogQWRkcyBhbiBBbmltYXRlZFNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXHJcblx0ICogQHJldHVybnMgQSBuZXcgQW5pbWF0ZWRTcHJpdGVcclxuXHQgKi9cclxuXHRhbmltYXRlZFNwcml0ZShrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBBbmltYXRlZFNwcml0ZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkQW5pbWF0ZWRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIEFkZHMgYSBuZXcgZ3JhcGhpYyBlbGVtZW50IHRvIHRoZSBjdXJyZW50IFNjZW5lXHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZ3JhcGhpYyB0byBhZGRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIGdyYXBoaWNcclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgZ3JhcGhpYyBjb25zdHJ1Y3RvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IEdyYXBoaWNcclxuXHQgKi9cclxuXHRncmFwaGljKHR5cGU6IEdyYXBoaWNUeXBlIHwgc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBHcmFwaGljIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRHcmFwaGljKHR5cGUsIGxheWVyTmFtZSwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdGlsZW1hcCB0byB0aGUgc2NlbmVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIHRpbGVtYXAgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRlc2lyZWQgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgdGlsZW1hcCBjb25zdHJ1Y3RvclxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgTGF5ZXJzLCBlYWNoIG9mIHdoaWNoIGNvbnRhaW5zIGEgbGF5ZXIgb2YgdGhlIHRpbGVtYXAgYXMgaXRzIG93biBUaWxlbWFwIGluc3RhbmNlLlxyXG4gICAgICovXHJcblx0dGlsZW1hcChrZXk6IHN0cmluZywgc2NhbGU/OiBWZWMyKTogQXJyYXk8TGF5ZXI+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlbWFwRmFjdG9yeS5hZGQoa2V5LCBzY2FsZSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL0xheWVyXCI7XHJcbmltcG9ydCBUaWxlc2V0IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZXNldFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgVGlsZWRDb2xsZWN0aW9uVGlsZSB9IGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVGlsZXNldHMvVGlsZWREYXRhXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcclxuaW1wb3J0IE5hdm1lc2ggZnJvbSBcIi4uLy4uL1BhdGhmaW5kaW5nL05hdm1lc2hcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogQSBmYWN0b3J5IHRoYXQgYWJzdHJhY3RzIGFkZGluZyBAcmVmZXJlbmNlW1RpbGVtYXBdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXHJcbiAqIEFjY2VzcyBtZXRob2RzIGluIHRoaXMgZmFjdG9yeSB0aHJvdWdoIFNjZW5lLmFkZC5bbWV0aG9kTmFtZV0oKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVtYXBGYWN0b3J5IHtcclxuICAgIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xyXG4gICAgcHJpdmF0ZSB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD47XHJcbiAgICBwcml2YXRlIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG4gICAgXHJcbiAgICBpbml0KHNjZW5lOiBTY2VuZSwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSB0aWxlbWFwcztcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gLSBUaGlzIGlzIHNwZWNpZmljYWxseSBjYXRlcmVkIHRvIFRpbGVkIHRpbGVtYXBzIHJpZ2h0IG5vdy4gSW4gdGhlIGZ1dHVyZSxcclxuICAgIC8vIGl0IHdvdWxkIGJlIGdvb2QgdG8gaGF2ZSBhIFwicGFyc2VUaWxlbWFwXCIgZnVuY3Rpb24gdGhhdCB3b3VsZCBjb252ZXJ0IHRoZSB0aWxlbWFwXHJcbiAgICAvLyBkYXRhIGludG8gYSBzdGFuZGFyZCBmb3JtYXQuIFRoaXMgY291bGQgYWxsb3cgZm9yIHN1cHBvcnQgZnJvbSBvdGhlciBwcm9ncmFtc1xyXG4gICAgLy8gb3IgdGhlIGRldmVsb3BtZW50IG9mIGFuIGludGVybmFsIGxldmVsIGJ1aWxkZXIgdG9vbFxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgdGlsZW1hcCB0byB0aGUgc2NlbmVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIHRpbGVtYXAgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRlc2lyZWQgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gc2VuZCB0byB0aGUgdGlsZW1hcCBjb25zdHJ1Y3RvclxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgTGF5ZXJzLCBlYWNoIG9mIHdoaWNoIGNvbnRhaW5zIGEgbGF5ZXIgb2YgdGhlIHRpbGVtYXAgYXMgaXRzIG93biBUaWxlbWFwIGluc3RhbmNlLlxyXG4gICAgICovXHJcblx0YWRkID0gKGtleTogc3RyaW5nLCBzY2FsZTogVmVjMiA9IG5ldyBWZWMyKDEsIDEpKTogQXJyYXk8TGF5ZXI+ID0+IHtcclxuICAgICAgICAvLyBHZXQgVGlsZW1hcCBEYXRhXHJcbiAgICAgICAgbGV0IHRpbGVtYXBEYXRhID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0VGlsZW1hcChrZXkpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGlzIHRpbGVtYXAgdG8gZWl0aGVyIGJlIG9ydGhvZ3JhcGhpYyBvciBpc29tZXRyaWNcclxuICAgICAgICBsZXQgY29uc3RyOiBuZXcoLi4uYXJnczogYW55KSA9PiBUaWxlbWFwO1xyXG4gICAgICAgIGlmKHRpbGVtYXBEYXRhLm9yaWVudGF0aW9uID09PSBcIm9ydGhvZ3JhcGhpY1wiKXtcclxuICAgICAgICAgICAgY29uc3RyID0gT3J0aG9nb25hbFRpbGVtYXA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gaXNvbWV0cmljIHRpbGVtYXAgc3VwcG9ydCByaWdodCBub3csIHNvIE9ydGhvZ3JhcGhpYyB0aWxlbWFwXHJcbiAgICAgICAgICAgIGNvbnN0ciA9IE9ydGhvZ29uYWxUaWxlbWFwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmV0dXJuIHZhbHVlIGFycmF5XHJcbiAgICAgICAgbGV0IHNjZW5lTGF5ZXJzID0gbmV3IEFycmF5PExheWVyPigpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYWxsIG9mIHRoZSB0aWxlc2V0cyBmb3IgdGhpcyB0aWxlbWFwXHJcbiAgICAgICAgbGV0IHRpbGVzZXRzID0gbmV3IEFycmF5PFRpbGVzZXQ+KCk7XHJcblxyXG4gICAgICAgIGxldCBjb2xsZWN0aW9uVGlsZXMgPSBuZXcgQXJyYXk8VGlsZWRDb2xsZWN0aW9uVGlsZT4oKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXBEYXRhLnRpbGVzZXRzKXtcclxuICAgICAgICAgICAgaWYodGlsZXNldC5pbWFnZSl7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3RhbmRhcmQgdGlsZXNldCBhbmQgbm90IGEgY29sbGVjdGlvbiwgY3JlYXRlIGEgdGlsZXNldCBmb3IgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gV2UgYXJlIGlnbm9yaW5nIGNvbGxlY3Rpb24gdGlsZXNldHMgZm9yIG5vdy4gVGhpcyBpcyBsaWtlbHkgbm90IGEgZ3JlYXQgaWRlYSBpbiBwcmFjdGljZSxcclxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZW9yZXRpY2FsbHkgc29tZW9uZSBjb3VsZCB3YW50IHRvIHVzZSBvbmUgZm9yIGEgc3RhbmRhcmQgdGlsZW1hcC4gV2UgYXJlIGFzc3VtaW5nIGZvciBub3dcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2Ugb25seSB3YW50IHRvIHVzZSB0aGVtIGZvciBvYmplY3QgbGF5ZXJzXHJcbiAgICAgICAgICAgICAgICB0aWxlc2V0cy5wdXNoKG5ldyBUaWxlc2V0KHRpbGVzZXQpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRpbGVzZXQudGlsZXMuZm9yRWFjaCh0aWxlID0+IHRpbGUuaWQgKz0gdGlsZXNldC5maXJzdGdpZCk7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uVGlsZXMucHVzaCguLi50aWxlc2V0LnRpbGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSBsYXllcnMgb2YgdGhlIHRpbGVtYXAgYW5kIGNyZWF0ZSB0aWxlZGxheWVycyBvciBvYmplY3QgbGF5ZXJzXHJcbiAgICAgICAgZm9yKGxldCBsYXllciBvZiB0aWxlbWFwRGF0YS5sYXllcnMpe1xyXG5cclxuICAgICAgICAgICAgbGV0IHNjZW5lTGF5ZXI7XHJcbiAgICAgICAgICAgIGxldCBpc1BhcmFsbGF4TGF5ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGRlcHRoID0gMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHByb3AubmFtZSA9PT0gXCJQYXJhbGxheFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXJhbGxheExheWVyID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIkRlcHRoXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoaXNQYXJhbGxheExheWVyKXtcclxuICAgICAgICAgICAgICAgIHNjZW5lTGF5ZXIgPSB0aGlzLnNjZW5lLmFkZFBhcmFsbGF4TGF5ZXIobGF5ZXIubmFtZSwgbmV3IFZlYzIoMSwgMSksIGRlcHRoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNjZW5lTGF5ZXIgPSB0aGlzLnNjZW5lLmFkZExheWVyKGxheWVyLm5hbWUsIGRlcHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYobGF5ZXIudHlwZSA9PT0gXCJ0aWxlbGF5ZXJcIil7XHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdGlsZW1hcCBvYmplY3QgZm9yIHRoZSBsYXllclxyXG4gICAgICAgICAgICAgICAgbGV0IHRpbGVtYXAgPSBuZXcgY29uc3RyKHRpbGVtYXBEYXRhLCBsYXllciwgdGlsZXNldHMsIHNjYWxlKTtcclxuICAgICAgICAgICAgICAgIHRpbGVtYXAuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcclxuICAgICAgICAgICAgICAgIHRpbGVtYXAuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aWxlbWFwIHRvIHNjZW5lXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVtYXBzLnB1c2godGlsZW1hcCk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHNjZW5lTGF5ZXIuYWRkTm9kZSh0aWxlbWFwKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdGlsZW1hcCB3aXRoIHBoeXNpY3MgaWYgaXQncyBjb2xsaWRhYmxlXHJcbiAgICAgICAgICAgICAgICBpZih0aWxlbWFwLmlzQ29sbGlkYWJsZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZW1hcC5hZGRQaHlzaWNzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGl0ZW0gb2YgbGF5ZXIucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLm5hbWUgPT09IFwiR3JvdXBcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsZW1hcC5zZXRHcm91cChpdGVtLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaXNOYXZtZXNoUG9pbnRzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmF2bWVzaE5hbWU7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWRnZXM7XHJcbiAgICAgICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHByb3Agb2YgbGF5ZXIucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByb3AubmFtZSA9PT0gXCJOYXZtZXNoUG9pbnRzXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOYXZtZXNoUG9pbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJuYW1lXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2bWVzaE5hbWUgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcImVkZ2VzXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBwcm9wLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKGlzTmF2bWVzaFBvaW50cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBuZXcgUG9zaXRpb25HcmFwaCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IG9iaiBvZiBsYXllci5vYmplY3RzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZy5hZGRQb3NpdGlvbmVkTm9kZShuZXcgVmVjMihvYmoueCwgb2JqLnkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgZWRnZSBvZiBlZGdlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcuYWRkRWRnZShlZGdlLmZyb20sIGVkZ2UudG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2VuZS5nZXROYXZpZ2F0aW9uTWFuYWdlcigpLmFkZE5hdmlnYWJsZUVudGl0eShuYXZtZXNoTmFtZSwgbmV3IE5hdm1lc2goZykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMYXllciBpcyBhbiBvYmplY3QgbGF5ZXIsIHNvIGFkZCBlYWNoIG9iamVjdCBhcyBhIHNwcml0ZSB0byBhIG5ldyBsYXllclxyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBvYmogb2YgbGF5ZXIub2JqZWN0cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb2JqIGlzIGNvbGxpZGFibGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGFzUGh5c2ljcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0NvbGxpZGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9uRW50ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvbkV4aXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmlnZ2VyR3JvdXAgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBncm91cCA9IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9iai5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIG9iai5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByb3AubmFtZSA9PT0gXCJIYXNQaHlzaWNzXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1BoeXNpY3MgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJDb2xsaWRhYmxlXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29sbGlkYWJsZSA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIkdyb3VwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiSXNUcmlnZ2VyXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVHJpZ2dlciA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJHcm91cFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyR3JvdXAgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJUcmlnZ2VyT25FbnRlclwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVudGVyID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiVHJpZ2dlck9uRXhpdFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkV4aXQgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3ByaXRlOiBTcHJpdGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9iaiBpcyBhIHRpbGUgZnJvbSBhIHRpbGVzZXRcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZXNldHMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aWxlc2V0Lmhhc1RpbGUob2JqLmdpZCkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdCBpcyBhIHRpbGUgZnJvbSB0aGlzIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlS2V5ID0gdGlsZXNldC5nZXRJbWFnZUtleSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRpbGVzZXQuZ2V0SW1hZ2VPZmZzZXRGb3JUaWxlKG9iai5naWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdGlsZXNldC5nZXRUaWxlU2l6ZSgpLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUucG9zaXRpb24uc2V0KChvYmoueCArIHNpemUueC8yKSpzY2FsZS54LCAob2JqLnkgLSBzaXplLnkvMikqc2NhbGUueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0SW1hZ2VPZmZzZXQob2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zaXplLmNvcHkoc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaW4gYSB0aWxlc2V0LCBtdXN0IGNvcnJlc3BvbmQgdG8gYSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXNwcml0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZSBvZiBjb2xsZWN0aW9uVGlsZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqLmdpZCA9PT0gdGlsZS5pZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlS2V5ID0gdGlsZS5pbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUgPSB0aGlzLnNjZW5lLmFkZC5zcHJpdGUoaW1hZ2VLZXksIGxheWVyLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoKG9iai54ICsgdGlsZS5pbWFnZXdpZHRoLzIpKnNjYWxlLngsIChvYmoueSAtIHRpbGUuaW1hZ2VoZWlnaHQvMikqc2NhbGUueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgc3ByaXRlLiBBc3NvY2lhdGUgaXQgd2l0aCBvdXIgcGh5c2ljcyBvYmplY3QgaWYgdGhlcmUgaXMgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzUGh5c2ljcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIHNwcml0ZSBhIHN0YXRpYyBwaHlzaWNzIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuYWRkUGh5c2ljcyhzcHJpdGUuYm91bmRhcnkuY2xvbmUoKSwgVmVjMi5aRVJPLCBpc0NvbGxpZGFibGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0R3JvdXAoZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpc1RyaWdnZXIgJiYgdHJpZ2dlckdyb3VwICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zZXRUcmlnZ2VyKHRyaWdnZXJHcm91cCwgb25FbnRlciwgb25FeGl0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZXR1cm4gdmFsdWVcclxuICAgICAgICAgICAgc2NlbmVMYXllcnMucHVzaChzY2VuZUxheWVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzY2VuZUxheWVycztcclxuXHR9XHJcbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4vU2NlbmVcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuXHJcblxyXG4vKipcclxuICogQSBsYXllciBpbiB0aGUgc2NlbmUuIExheWVycyBhcmUgdXNlZCBmb3Igc29ydGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgYnkgZGVwdGguXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllciB7XHJcbiAgICAvKiogVGhlIHNjZW5lIHRoaXMgbGF5ZXIgYmVsb25ncyB0byAqL1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuXHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhpcyBsYXllciAqL1xyXG4gICAgcHJvdGVjdGVkIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKiogV2hldGhlciB0aGlzIGxheWVyIGlzIHBhdXNlZCBvciBub3QgKi9cclxuICAgIHByb3RlY3RlZCBwYXVzZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBsYXllciBpcyBoaWRkZW4gZnJvbSBiZWluZyByZW5kZXJlZCBvciBub3QgKi9cclxuICAgIHByb3RlY3RlZCBoaWRkZW46IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBnbG9iYWwgYWxwaGEgbGV2ZWwgb2YgdGhpcyBsYXllciAqL1xyXG4gICAgcHJvdGVjdGVkIGFscGhhOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSBHYW1lTm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBsYXllciAqL1xyXG4gICAgcHJvdGVjdGVkIGl0ZW1zOiBBcnJheTxHYW1lTm9kZT47XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgbGF5ZXIgc2hvdWxkIGJlIHlzb3J0ZWQgKi9cclxuICAgIHByb3RlY3RlZCB5U29ydDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIGRlcHRoIG9mIHRoaXMgbGF5ZXIgY29tcGFyZWQgdG8gb3RoZXIgbGF5ZXJzICovXHJcbiAgICBwcm90ZWN0ZWQgZGVwdGg6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbGF5ZXIuIFRvIGRvIHRoaXMgaW4gYSBnYW1lLCB1c2UgdGhlIGFkZExheWVyKCkgbWV0aG9kIGluIEByZWZyZW5jZVtTY2VuZV1cclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdG8gYWRkIHRoZSBsYXllciB0b1xyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgbmFtZTogc3RyaW5nKXtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMueVNvcnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRlcHRoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJlaXZlcyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAgICovXHJcbiAgICBnZXROYW1lKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhdXNlcy9VbnBhdXNlcyB0aGUgbGF5ZXIuIEFmZmVjdHMgYWxsIGVsZW1lbnRzIGluIHRoaXMgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBwYXVzZVZhbHVlIFRydWUgaWYgdGhlIGxheWVyIHNob3VsZCBiZSBwYXVzZWQsIGZhbHNlIGlmIG5vdFxyXG4gICAgICovXHJcbiAgICBzZXRQYXVzZWQocGF1c2VWYWx1ZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gcGF1c2VWYWx1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBsYXllciBpcyBwYXVzZWRcclxuICAgICAqL1xyXG4gICAgaXNQYXVzZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF1c2VkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBhbHBoYSBUaGUgbmV3IG9wYWNpdHkgdmFsdWUgaW4gdGhlIHJhbmdlIFswLCAxXVxyXG4gICAgICovXHJcbiAgICBzZXRBbHBoYShhbHBoYTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IE1hdGhVdGlscy5jbGFtcChhbHBoYSwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIG9wYWNpdHlcclxuICAgICAqL1xyXG4gICAgZ2V0QWxwaGEoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hbHBoYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGxheWVyJ3MgaGlkZGVuIHZhbHVlLiBJZiBoaWRkZW4sIGEgbGF5ZXIgd2lsbCBub3QgYmUgcmVuZGVyZWQsIGJ1dCB3aWxsIHN0aWxsIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIGhpZGRlbiBUaGUgaGlkZGVuIHZhbHVlIG9mIHRoZSBsYXllclxyXG4gICAgICovXHJcbiAgICBzZXRIaWRkZW4oaGlkZGVuOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBoaWRkZW47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBoaWRlZW4gdmFsdWUgb2YgdGhlIGx5YWVyXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzY2VuZSBpcyBoaWRkZW4sIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBpc0hpZGRlbigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWRkZW47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFBhdXNlcyB0aGlzIHNjZW5lIGFuZCBoaWRlcyBpdCAqL1xyXG4gICAgZGlzYWJsZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBVbnBhdXNlcyB0aGlzIGxheWVyIGFuZCBtYWtlcyBpdCB2aXNpYmxlICovXHJcbiAgICBlbmFibGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgc2NlbmUgd2lsbCB5U29ydCBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICogeVNvcnRpbmcgbWVhbnMgdGhhdCBDYW52YXNOb2RlcyBvbiB0aGlzIGxheWVyIHdpbGwgaGF2ZSB0aGVpciBkZXB0aCBzb3J0ZWQgZGVwZW5kaW5nIG9uIHRoZWlyIHktdmFsdWUuXHJcbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgYW4gb2JqZWN0IGlzIFwiaGlnaGVyXCIgaW4gdGhlIHNjZW5lLCBpdCB3aWxsIHNvcnQgYmVoaW5kIG9iamVjdHMgdGhhdCBhcmUgXCJsb3dlclwiLlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIDMvNCB2aWV3IGdhbWVzLCBvciBzaW1pbGFyIHNpdHVhdGlvbnMsIHdoZXJlIHlvdSBzb21ldGltZXMgd2FudCB0byBiZSBpbiBmcm9udCBvZiBvYmplY3RzLFxyXG4gICAgICogYW5kIG90aGVyIHRpbWVzIHdhbnQgdG8gYmUgYmVoaW5kIHRoZSBzYW1lIG9iamVjdHMuXHJcbiAgICAgKiBAcGFyYW0geVNvcnQgVHJ1ZSBpZiB5U29ydGluZyBzaG91bGQgYmUgYWN0aXZlLCBmYWxzZSBpZiBub3RcclxuICAgICAqL1xyXG4gICAgc2V0WVNvcnQoeVNvcnQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnlTb3J0ID0geVNvcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB5U29ydCBzdGF0dXMgb2YgdGhlIHNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHlTb3J0aW5nIGlzIG9jY3VycmluZywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGdldFlTb3J0KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnlTb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZGVwdGggb2YgdGhlIGxheWVyIGNvbXBhcmVkIHRvIG90aGVyIGxheWVycy4gQSBsYXJnZXIgbnVtYmVyIG1lYW5zIHRoZSBsYXllciB3aWxsIGJlIGNsb3NlciB0byB0aGUgc2NyZWVuLlxyXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIHNldERlcHRoKGRlcHRoOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGRlcHRoIG9mIHRoZSBsYXllci5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkZXB0aFxyXG4gICAgICovXHJcbiAgICBnZXREZXB0aCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5vZGUgdG8gdGhpcyBsYXllclxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gYWRkIHRvIHRoaXMgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIGFkZE5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLml0ZW1zLnB1c2gobm9kZSk7XHJcbiAgICAgICAgbm9kZS5zZXRMYXllcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhpcyBsYXllclxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIHdhcyByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTm9kZShub2RlOiBHYW1lTm9kZSk6IHZvaWQge1xyXG4gICAgICAgIC8vIEZpbmQgYW5kIHJlbW92ZSB0aGUgbm9kZVxyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihub2RlKTtcclxuXHJcbiAgICAgICAgaWYoaW5kZXggIT09IC0xKXtcclxuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICBub2RlLnNldExheWVyKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmVpdmVzIGFsbCBHYW1lTm9kZXMgZnJvbSB0aGlzIGxheWVyXHJcbiAgICAgKiBAcmV0dXJucyBhbiBBcnJheSB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgR2FtZU5vZGVzIGluIHRoaXMgbGF5ZXIuXHJcbiAgICAgKi9cclxuICAgIGdldEl0ZW1zKCk6IEFycmF5PEdhbWVOb2RlPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXM7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL0xheWVyXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XHJcblxyXG4vKipcclxuICogQW4gZXh0ZW5zaW9uIG9mIGEgTGF5ZXIgdGhhdCBoYXMgYSBwYXJhbGxheCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhcmFsbGF4TGF5ZXIgZXh0ZW5kcyBMYXllciB7XHJcblx0LyoqIFRoZSB2YWx1ZSBvZiB0aGUgcGFyYWxsYXggb2YgdGhlIExheWVyICovXHJcblx0cGFyYWxsYXg6IFZlYzI7XHJcblx0XHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBQYXJhbGxheExheWVyLlxyXG5cdCAqIFVzZSBhZGRQYXJhbGxheExheWVyKCkgaW4gQHJlZmVyZW5jZVtTY2VuZV0gdG8gYWRkIGEgbGF5ZXIgb2YgdGhpcyB0eXBlIHRvIHlvdXIgZ2FtZS5cclxuXHQgKiBAcGFyYW0gc2NlbmUgVGhlIFNjZW5lIHRvIGFkZCB0aGlzIFBhcmFsbGF4TGF5ZXIgdG9cclxuXHQgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgUGFyYWxsYXhMYXllclxyXG5cdCAqIEBwYXJhbSBwYXJhbGxheCBUaGUgcGFyYWxsYXggbGV2ZWxcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZywgcGFyYWxsYXg6IFZlYzIpe1xyXG5cdFx0c3VwZXIoc2NlbmUsIG5hbWUpO1xyXG5cdFx0dGhpcy5wYXJhbGxheCA9IHBhcmFsbGF4O1xyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XHJcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuL1BhcmFsbGF4TGF5ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBBIExheWVyIHN0cmljdGx5IHRvIGJlIHVzZWQgZm9yIG1hbmFnaW5nIFVJRWxlbWVudHMuXHJcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYSBMYXllciB0aGF0IGFsd2F5cyBzdGF5cyBpbiB0aGUgc2FtZSBwbGFjZSxcclxuICogYW5kIHRodXMgcmVuZGVycyB0aGluZ3MgbGlrZSBhIEhVRCBvciBhbiBpbnZlbnRvcnkgd2l0aG91dCB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBcXHJlZmVyZW5jZVtWaWV3cG9ydF0gc2Nyb2xsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlMYXllciBleHRlbmRzIFBhcmFsbGF4TGF5ZXIge1xyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgVUlMYXllci5cclxuXHQgKiBVc2UgYWRkVUlMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXHJcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0byBhZGQgdGhpcyBVSUxheWVyIHRvXHJcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFVJTGF5ZXJcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZyl7XHJcblx0XHRzdXBlcihzY2VuZSwgbmFtZSwgVmVjMi5aRVJPKTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTGF5ZXIgZnJvbSBcIi4vTGF5ZXJcIjtcclxuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgU2NlbmVHcmFwaCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9TY2VuZUdyYXBoXCI7XHJcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9QaHlzaWNzTWFuYWdlclwiO1xyXG5pbXBvcnQgQmFzaWNQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9CYXNpY1BoeXNpY3NNYW5hZ2VyXCI7XHJcbmltcG9ydCBTY2VuZUdyYXBoQXJyYXkgZnJvbSBcIi4uL1NjZW5lR3JhcGgvU2NlbmVHcmFwaEFycmF5XCI7XHJcbmltcG9ydCBGYWN0b3J5TWFuYWdlciBmcm9tIFwiLi9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXJcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgR2FtZSBmcm9tIFwiLi4vTG9vcC9HYW1lXCI7XHJcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSBcIi4vU2NlbmVNYW5hZ2VyXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5pbXBvcnQgTmF2aWdhdGlvbk1hbmFnZXIgZnJvbSBcIi4uL1BhdGhmaW5kaW5nL05hdmlnYXRpb25NYW5hZ2VyXCI7XHJcbmltcG9ydCBBSU1hbmFnZXIgZnJvbSBcIi4uL0FJL0FJTWFuYWdlclwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuL0xheWVycy9QYXJhbGxheExheWVyXCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuL0xheWVycy9VSUxheWVyXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IFNjZW5lT3B0aW9ucyBmcm9tIFwiLi9TY2VuZU9wdGlvbnNcIjtcclxuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IFRpbWVyTWFuYWdlciBmcm9tIFwiLi4vVGltaW5nL1RpbWVyTWFuYWdlclwiO1xyXG5pbXBvcnQgVHdlZW5NYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2Vlbk1hbmFnZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBTY2VuZXMgYXJlIHRoZSBtYWluIGNvbnRhaW5lciBpbiB0aGUgZ2FtZSBlbmdpbmUuXHJcbiAqIFlvdXIgbWFpbiBzY2VuZSBpcyB0aGUgY3VycmVudCBsZXZlbCBvciBtZW51IG9mIHRoZSBnYW1lLCBhbmQgd2lsbCBjb250YWluIGFsbCBvZiB0aGUgR2FtZU5vZGVzIG5lZWRlZC5cclxuICogU2NlbmVzIHByb3ZpZGUgYW4gZWFzeSB3YXkgdG8gbG9hZCBhc3NldHMsIGFkZCBhc3NldHMgdG8gdGhlIGdhbWUgd29ybGQsIGFuZCB1bmxvYWQgYXNzZXRzLFxyXG4gKiBhbmQgaGF2ZSBsaWZlY3ljbGUgbWV0aG9kcyBleHBvc2VkIGZvciB0aGVzZSBmdW5jdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBnYW1lIHdvcmxkLiAqL1xyXG4gICAgcHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcclxuXHJcbiAgICAvKiogVGhlIHZpZXdwb3J0LiAqL1xyXG4gICAgcHJvdGVjdGVkIHZpZXdwb3J0OiBWaWV3cG9ydDtcclxuXHJcbiAgICAvKiogQSBmbGFnIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgc2NlbmUgaXMgcnVubmluZyBvciBub3QuICovXHJcbiAgICBwcm90ZWN0ZWQgcnVubmluZzogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIG1hbmFnZXIgb2YgdGhpcyBzY2VuZS4gKi9cclxuICAgIHByb3RlY3RlZCBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlcjtcclxuXHJcbiAgICAvKiogVGhlIHJlY2VpdmVyIGZvciB0aGlzIHNjZW5lLiAqL1xyXG4gICAgcHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcclxuXHJcbiAgICAvKiogVGhlIGVtaXR0ZXIgZm9yIHRoaXMgc2NlbmUuICovXHJcbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuXHJcbiAgICAvKiogVGhpcyBsaXN0IG9mIHRpbGVtYXBzIGluIHRoaXMgc2NlbmUuICovXHJcbiAgICBwcm90ZWN0ZWQgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xyXG5cclxuICAgIC8qKiBBIG1hcCBmcm9tIGxheWVyIG5hbWVzIHRvIHRoZSBsYXllcnMgdGhlbXNlbHZlcyAqL1xyXG4gICAgcHJvdGVjdGVkIGxheWVyczogTWFwPExheWVyPjtcclxuXHJcbiAgICAvKiogQSBtYXAgZnJvbSBwYXJhbGxheCBsYXllciBuYW1lcyB0byB0aGUgcGFyYWxsYXggbGF5ZXJzIHRoZW1zZWx2ZXMgKi9cclxuICAgIHByb3RlY3RlZCBwYXJhbGxheExheWVyczogTWFwPFBhcmFsbGF4TGF5ZXI+O1xyXG5cclxuICAgIC8qKiBBIG1hcCBmcm9tIHVpTGF5ZXIgbmFtZXMgdG8gdGhlIHVpTGF5ZXJzIHRoZW1zZWx2ZXMgKi9cclxuICAgIHByb3RlY3RlZCB1aUxheWVyczogTWFwPFVJTGF5ZXI+O1xyXG5cclxuICAgIC8qKiBUaGUgc2NlbmUgZ3JhcGggb2YgdGhlIFNjZW5lKi9cclxuICAgIHByb3RlY3RlZCBzY2VuZUdyYXBoOiBTY2VuZUdyYXBoO1xyXG5cclxuICAgIC8qKiBUaGUgcGh5c2ljcyBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xyXG4gICAgcHJvdGVjdGVkIHBoeXNpY3NNYW5hZ2VyOiBQaHlzaWNzTWFuYWdlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBuYXZpZ2F0aW9uIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXHJcbiAgICBwcm90ZWN0ZWQgbmF2TWFuYWdlcjogTmF2aWdhdGlvbk1hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSBBSSBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xyXG4gICAgcHJvdGVjdGVkIGFpTWFuYWdlcjogQUlNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgcmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgc2NlbmUgKi9cclxuICAgIHByb3RlY3RlZCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGFkZGluZyBvZiBkaWZmZXJlbnQgbm9kZXMgdG8gdGhlIHNjZW5lICovXHJcbiAgICBwdWJsaWMgYWRkOiBGYWN0b3J5TWFuYWdlcjtcclxuXHJcbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBsb2FkaW5nIG9mIGRpZmZlcmVudCBmaWxlcyBmb3IgdXNlIGluIHRoZSBzY2VuZS4gQW4gYWxpYXMgZm9yIHJlc291cmNlTWFuYWdlciAqL1xyXG4gICAgcHVibGljIGxvYWQ6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBsb2FkaW5nIGFuZCB1bmxvYWRpbmcgb2YgZGlmZmVyZW50IGZpbGVzIGZvciB1c2UgaW4gdGhlIHNjZW5lICovXHJcbiAgICBwdWJsaWMgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoaXMgc2NlbmUgKi9cclxuICAgIHB1YmxpYyBzY2VuZU9wdGlvbnM6IFNjZW5lT3B0aW9ucztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2NlbmUuIFRvIGFkZCBhIG5ldyBTY2VuZSBpbiB5b3VyIGdhbWUsIHVzZSBjaGFuZ2VUb1NjZW5lKCkgaW4gQHJlZmVyZW5jZVtTY2VuZU1hbmFnZXJdXHJcbiAgICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIHZpZXdwb3J0IG9mIHRoZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gc2NlbmVNYW5hZ2VyIFRoZSBTY2VuZU1hbmFnZXIgdGhhdCBvd25zIHRoaXMgU2NlbmVcclxuICAgICAqIEBwYXJhbSByZW5kZXJpbmdNYW5hZ2VyIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIHRoYXQgd2lsbCBoYW5kbGUgdGhpcyBTY2VuZSdzIHJlbmRlcmluZ1xyXG4gICAgICogQHBhcmFtIGdhbWUgVGhlIGluc3RhbmNlIG9mIHRoZSBHYW1lXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgU2NlbmUgaW5pdGlhbGl6YXRpb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZU1hbmFnZXI6IFNjZW5lTWFuYWdlciwgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlciwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pil7XHJcbiAgICAgICAgdGhpcy5zY2VuZU9wdGlvbnMgPSBTY2VuZU9wdGlvbnMucGFyc2Uob3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy53b3JsZFNpemUgPSBuZXcgVmVjMig1MDAsIDUwMCk7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Qm91bmRzKDAsIDAsIDI1NjAsIDEyODApO1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyID0gc2NlbmVNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuICAgICAgICB0aGlzLnRpbGVtYXBzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoID0gbmV3IFNjZW5lR3JhcGhBcnJheSh0aGlzLnZpZXdwb3J0LCB0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5sYXllcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy51aUxheWVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICB0aGlzLnBoeXNpY3NNYW5hZ2VyID0gbmV3IEJhc2ljUGh5c2ljc01hbmFnZXIodGhpcy5zY2VuZU9wdGlvbnMucGh5c2ljcyk7XHJcbiAgICAgICAgdGhpcy5uYXZNYW5hZ2VyID0gbmV3IE5hdmlnYXRpb25NYW5hZ2VyKCk7XHJcbiAgICAgICAgdGhpcy5haU1hbmFnZXIgPSBuZXcgQUlNYW5hZ2VyKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gcmVuZGVyaW5nTWFuYWdlcjtcclxuXHJcbiAgICAgICAgdGhpcy5hZGQgPSBuZXcgRmFjdG9yeU1hbmFnZXIodGhpcywgdGhpcy50aWxlbWFwcyk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZCA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpXHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSB0aGlzLmxvYWQ7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgdGltZXIgbWFuYWdlciBhbmQgY2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyc1xyXG4gICAgICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLmNsZWFyVGltZXJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgbmV3IHNjZW5lIGlzIGNyZWF0ZWQsIGJlZm9yZSBhbnl0aGluZyBlbHNlLiAqL1xyXG4gICAgaW5pdFNjZW5lKGluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XHJcblxyXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIHdoZW4gYSBuZXcgc2NlbmUgaXMgY3JlYXRlZC4gTG9hZCBhbGwgZmlsZXMgeW91IHdpc2ggdG8gYWNjZXNzIGluIHRoZSBzY2VuZSBoZXJlLiAqL1xyXG4gICAgbG9hZFNjZW5lKCk6IHZvaWQge31cclxuXHJcbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIGNhbGxlZCBzdHJpY3RseSBhZnRlciBsb2FkU2NlbmUoKS4gQ3JlYXRlIGFueSBnYW1lIG9iamVjdHMgeW91IHdpc2ggdG8gdXNlIGluIHRoZSBzY2VuZSBoZXJlLiAqL1xyXG4gICAgc3RhcnRTY2VuZSgpOiB2b2lkIHt9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGxpZmVjeWNsZSBtZXRob2QgY2FsbGVkIGV2ZXJ5IGZyYW1lIG9mIHRoZSBnYW1lLiBUaGlzIGlzIHdoZXJlIHlvdSBjYW4gZHluYW1pY2FsbHkgZG8gdGhpbmdzIGxpa2UgYWRkIGluIG5ldyBlbmVtaWVzXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIHRpbWUgdGhpcyBmcmFtZSByZXByZXNlbnRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVNjZW5lKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7fVxyXG5cclxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCBvbiBzY2VuZSBkZXN0cnVjdGlvbi4gU3BlY2lmeSB3aGljaCBmaWxlcyB5b3Ugbm8gbG9uZ2VyIG5lZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi4gKi9cclxuICAgIHVubG9hZFNjZW5lKCk6IHZvaWQge31cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNjZW5lKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIERvIHRpbWUgdXBkYXRlc1xyXG4gICAgICAgIFRpbWVyTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBEbyBhbGwgQUkgdXBkYXRlc1xyXG4gICAgICAgIHRoaXMuYWlNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgYWxsIHBoeXNpY3Mgb2JqZWN0c1xyXG4gICAgICAgIHRoaXMucGh5c2ljc01hbmFnZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgY2FudmFzIG9iamVjdHNcclxuICAgICAgICB0aGlzLnNjZW5lR3JhcGgudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgdGlsZW1hcHNcclxuICAgICAgICB0aGlzLnRpbGVtYXBzLmZvckVhY2godGlsZW1hcCA9PiB7XHJcbiAgICAgICAgICAgIGlmKCF0aWxlbWFwLmdldExheWVyKCkuaXNQYXVzZWQoKSl7XHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgdHdlZW5zXHJcbiAgICAgICAgVHdlZW5NYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxyXG4gICAgICAgIHRoaXMudmlld3BvcnQudXBkYXRlKGRlbHRhVCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyByZW5kZXJhYmxlIHNldHMgYW5kIGNvb3JkaW5hdGVzIHdpdGggdGhlIFJlbmRlcmluZ01hbmFnZXIgdG8gZHJhdyB0aGUgU2NlbmVcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdldCB0aGUgdmlzaWJsZSBzZXQgb2Ygbm9kZXNcclxuICAgICAgICBsZXQgdmlzaWJsZVNldCA9IHRoaXMuc2NlbmVHcmFwaC5nZXRWaXNpYmxlU2V0KCk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBwYXJhbGxheCBsYXllciBpdGVtcyB0byB0aGUgdmlzaWJsZSBzZXQgKHdlJ3JlIHJlbmRlcmluZyB0aGVtIGFsbCBmb3Igbm93KVxyXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcExheWVyID0gdGhpcy5wYXJhbGxheExheWVycy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgZm9yKGxldCBub2RlIG9mIHBMYXllci5nZXRJdGVtcygpKXtcclxuICAgICAgICAgICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBDYW52YXNOb2RlKXtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlU2V0LnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCB0aGUgdmlzaWJsZSBzZXQsIHRpbGVtYXBzLCBhbmQgdWlMYXllcnMgdG8gdGhlIHJlbmRlcmVyXHJcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLnJlbmRlcih2aXNpYmxlU2V0LCB0aGlzLnRpbGVtYXBzLCB0aGlzLnVpTGF5ZXJzKTtcclxuXHJcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwcy5mb3JFYWNoKHRpbGVtYXAgPT4gdGlsZW1hcC52aXNpYmxlID8gbm9kZXMucHVzaCh0aWxlbWFwKSA6IDApO1xyXG4gICAgICAgIERlYnVnLnNldE5vZGVzKG5vZGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjZW5lIGFzIHJ1bm5pbmcgb3Igbm90XHJcbiAgICAgKiBAcGFyYW0gcnVubmluZyBUcnVlIGlmIHRoZSBTY2VuZSBzaG91bGQgYmUgcnVubmluZywgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIHNldFJ1bm5pbmcocnVubmluZzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IHJ1bm5pbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBTY2VuZSBpcyBydW5uaW5nXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzY2VuZSBpcyBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgaXNSdW5uaW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoaXMgU2NlbmVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG4gICAgICovXHJcbiAgICByZW1vdmUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgc2NlbmUgZ3JhcGhcclxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQ2FudmFzTm9kZSl7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVHcmFwaC5yZW1vdmVOb2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERlc3Ryb3lzIHRoaXMgc2NlbmUgYW5kIGFsbCBub2RlcyBpbiBpdCAqL1xyXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCkpe1xyXG4gICAgICAgICAgICBub2RlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcclxuICAgICAgICAgICAgdGlsZW1hcC5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVHcmFwaDtcclxuICAgICAgICBkZWxldGUgdGhpcy5waHlzaWNzTWFuYWdlcjtcclxuICAgICAgICBkZWxldGUgdGhpcy5uYXZNYW5hZ2VyO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmFpTWFuYWdlcjtcclxuICAgICAgICBkZWxldGUgdGhpcy5yZWNlaXZlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgbGF5ZXIgdG8gdGhlIHNjZW5lIGFuZCByZXR1cm5zIGl0XHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IGxheWVyXHJcbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgTGF5ZXJcclxuICAgICAqL1xyXG4gICAgYWRkTGF5ZXIobmFtZTogc3RyaW5nLCBkZXB0aD86IG51bWJlcik6IExheWVyIHtcclxuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xyXG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxheWVyID0gbmV3IExheWVyKHRoaXMsIG5hbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmxheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xyXG5cclxuICAgICAgICBpZihkZXB0aCl7XHJcbiAgICAgICAgICAgIGxheWVyLnNldERlcHRoKGRlcHRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgcGFyYWxsYXggbGF5ZXIgdG8gdGhpcyBzY2VuZSBhbmQgcmV0dXJucyBpdFxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcmFsbGF4IGxheWVyXHJcbiAgICAgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXHJcbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgUGFyYWxsYXhMYXllclxyXG4gICAgICovXHJcbiAgICBhZGRQYXJhbGxheExheWVyKG5hbWU6IHN0cmluZywgcGFyYWxsYXg6IFZlYzIsIGRlcHRoPzogbnVtYmVyKTogUGFyYWxsYXhMYXllciB7XHJcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcclxuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBQYXJhbGxheExheWVyKHRoaXMsIG5hbWUsIHBhcmFsbGF4KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJhbGxheExheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xyXG5cclxuICAgICAgICBpZihkZXB0aCl7XHJcbiAgICAgICAgICAgIGxheWVyLnNldERlcHRoKGRlcHRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgVUlMYXllciB0byB0aGUgc2NlbmVcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBuZXcgVUlsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgVUlMYXllclxyXG4gICAgICovXHJcbiAgICBhZGRVSUxheWVyKG5hbWU6IHN0cmluZyk6IFVJTGF5ZXIge1xyXG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGF5ZXIgPSBuZXcgVUlMYXllcih0aGlzLCBuYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy51aUxheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgbGF5ZXIgZnJvbSB0aGUgc2NlbmUgYnkgbmFtZSBpZiBpdCBleGlzdHMuXHJcbiAgICAgKiBUaGlzIGNhbiBiZSBhIExheWVyIG9yIGFueSBvZiBpdHMgc3ViY2xhc3Nlc1xyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgTGF5ZXIgZm91bmQgd2l0aCB0aGF0IG5hbWVcclxuICAgICAqL1xyXG4gICAgZ2V0TGF5ZXIobmFtZTogc3RyaW5nKTogTGF5ZXIge1xyXG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVpTGF5ZXJzLmdldChuYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBgUmVxdWVzdGVkIGxheWVyICR7bmFtZX0gZG9lcyBub3QgZXhpc3QuYDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsYXllciBpcyBhIFBhcmFsbGF4TGF5ZXJcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgUGFyYWxsYXhMYXllclxyXG4gICAgICovXHJcbiAgICBpc1BhcmFsbGF4TGF5ZXIobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGF5ZXIgaXMgYSBVSUxheWVyXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBQYXJhbGxheExheWVyXHJcbiAgICAgKi9cclxuICAgIGlzVUlMYXllcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51aUxheWVycy5oYXMobmFtZSk7XHJcbiAgICB9ICAgIFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gb2YgdGhpcyBub2RlIHdpdGggcmVzcGVjdCB0byBjYW1lcmEgc3BhY2UgKGR1ZSB0byB0aGUgdmlld3BvcnQgbW92aW5nKS5cclxuICAgICAqIFRoaXMgdmFsdWUgaXMgYWZmZWN0ZWQgYnkgdGhlIHBhcmFsbGF4IGxldmVsIG9mIHRoZSBAcmVmZXJlbmNlW0xheWVyXSB0aGUgbm9kZSBpcyBvbi5cclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrIHRoZSB2aWV3cG9ydCB3aXRoIHJlc3BlY3QgdG9cclxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSB0cmFuc2xhdGlvbiBvZiB2aWV3cG9ydCB3aXRoIHJlc3BlY3QgdG8gdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBnZXRWaWV3VHJhbnNsYXRpb24obm9kZTogR2FtZU5vZGUpOiBWZWMyIHtcclxuICAgICAgICBsZXQgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XHJcblxyXG4gICAgICAgIGlmKGxheWVyIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBsYXllciBpbnN0YW5jZW9mIFVJTGF5ZXIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW4oKS5tdWx0KGxheWVyLnBhcmFsbGF4KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW4oKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgbGV2ZWwgb2YgdGhlIHZpZXdcclxuICAgICAqIEByZXR1cm5zIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgKi9cclxuXHRnZXRWaWV3U2NhbGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpO1xyXG5cdH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFZpZXdwb3J0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBWaWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBnZXRWaWV3cG9ydCgpOiBWaWV3cG9ydCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB3b3JsZCBzaXplIG9mIHRoaXMgU2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSB3b3JsZCBzaXplIGluIGEgVmVjMlxyXG4gICAgICovXHJcbiAgICBnZXRXb3JsZFNpemUoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGRTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgU2NlbmVHcmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxyXG4gICAgICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGhcclxuICAgICAqL1xyXG4gICAgZ2V0U2NlbmVHcmFwaCgpOiBTY2VuZUdyYXBoIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZUdyYXBoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgUGh5c2ljc01hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSBQaHlzaWNzTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXRQaHlzaWNzTWFuYWdlcigpOiBQaHlzaWNzTWFuYWdlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGh5c2ljc01hbmFnZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBOYXZpZ2F0aW9uTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxyXG4gICAgICogQHJldHVybnMgVGhlIE5hdmlnYXRpb25NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGdldE5hdmlnYXRpb25NYW5hZ2VyKCk6IE5hdmlnYXRpb25NYW5hZ2VyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYXZNYW5hZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgQUlNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQUlNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGdldEFJTWFuYWdlcigpOiBBSU1hbmFnZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFpTWFuYWdlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhbiBJRCBmb3IgYSBHYW1lTm9kZVxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBJRFxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUlkKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVNYW5hZ2VyLmdlbmVyYXRlSWQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIFRpbGVtYXAgaW4gdGhpcyBTY2VuZVxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFRpbGVtYXBcclxuICAgICAqIEByZXR1cm5zIFRoZSBUaWxlbWFwLCBpZiBvbmUgdGhpcyBuYW1lIGV4aXN0cywgb3RoZXJ3aXNlIG51bGxcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZW1hcChuYW1lOiBzdHJpbmcpOiBUaWxlbWFwIHtcclxuICAgICAgICBmb3IobGV0IHRpbGVtYXAgb2YgdGhpcyAudGlsZW1hcHMpe1xyXG4gICAgICAgICAgICBpZih0aWxlbWFwLm5hbWUgPT09IG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGVtYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuL1NjZW5lXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgTWVtb3J5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL01lbW9yeVV0aWxzXCI7XHJcblxyXG4vKipcclxuICogVGhlIFNjZW5lTWFuYWdlciBhY3RzIGFzIGFuIGludGVyZmFjZSB0byBjcmVhdGUgU2NlbmVzLCBhbmQgaGFuZGxlcyB0aGUgbGlmZWN5Y2xlIG1ldGhvZHMgb2YgU2NlbmVzLlxyXG4gKiBJdCBnaXZlcyBTY2VuZXMgYWNjZXNzIHRvIGluZm9ybWF0aW9uIHRoZXkgbmVlZCBmcm9tIHRoZSBAcmVmZXJlbmNlW0dhbWVdIGNsYXNzIHdoaWxlIGtlZXBpbmcgYSBsYXllciBvZiBzZXBhcmF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVNYW5hZ2VyIHtcclxuXHQvKiogVGhlIGN1cnJlbnQgU2NlbmUgb2YgdGhlIGdhbWUgKi9cclxuXHRwcm90ZWN0ZWQgY3VycmVudFNjZW5lOiBTY2VuZTtcclxuXHJcblx0LyoqIFRoZSBWaWV3cG9ydCBvZiB0aGUgZ2FtZSAqL1xyXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblxyXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgUmVzb3VyY2VNYW5hZ2VyICovXHJcblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuXHQvKiogQSBjb3VudGVyIHRvIGtlZXAgdHJhY2sgb2YgZ2FtZSBpZHMgKi9cclxuXHRwcm90ZWN0ZWQgaWRDb3VudGVyOiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgUmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgZ2FtZSAqL1xyXG5cdHByb3RlY3RlZCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xyXG5cclxuXHQvKiogRm9yIGNvbnNpc3RlbmN5LCBvbmx5IGNoYW5nZSBzY2VuZXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdXBkYXRlIGN5Y2xlICovXHJcblx0cHJvdGVjdGVkIHBlbmRpbmdTY2VuZTogU2NlbmU7XHJcblx0cHJvdGVjdGVkIHBlbmRpbmdTY2VuZUluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgU2NlbmVNYW5hZ2VyXHJcblx0ICogQHBhcmFtIHZpZXdwb3J0IFRoZSBWaWV3cG9ydCBvZiB0aGUgZ2FtZVxyXG5cdCAqIEBwYXJhbSBnYW1lIFRoZSBHYW1lIGluc3RhbmNlXHJcblx0ICogQHBhcmFtIHJlbmRlcmluZ01hbmFnZXIgVGhlIFJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIGdhbWVcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXIpe1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHRcdHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuXHRcdHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IHJlbmRlcmluZ01hbmFnZXI7XHJcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XHJcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBzY2VuZSBhcyB0aGUgbWFpbiBzY2VuZS5cclxuXHQgKiBVc2UgdGhpcyBtZXRob2QgaWYgeW91J3ZlIGNyZWF0ZWQgYSBzdWJjbGFzcyBvZiBTY2VuZSwgYW5kIHlvdSB3YW50IHRvIGFkZCBpdCBhcyB0aGUgbWFpbiBTY2VuZS5cclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc2NlbmUgdG8gYWRkXHJcblx0ICogQHBhcmFtIGluaXQgQW4gb2JqZWN0IHRvIHBhc3MgdG8gdGhlIGluaXQgZnVuY3Rpb24gb2YgdGhlIG5ldyBzY2VuZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjaGFuZ2VUb1NjZW5lPFQgZXh0ZW5kcyBTY2VuZT4oY29uc3RyOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCwgaW5pdD86IFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHRoZSBuZXcgc2NlbmUgLSBjaGFuZ2UgaXMgcGVuZGluZyB1bnRpbCBuZXh0IHVwZGF0ZVwiKTtcclxuXHRcdHRoaXMucGVuZGluZ1NjZW5lID0gbmV3IGNvbnN0cih0aGlzLnZpZXdwb3J0LCB0aGlzLCB0aGlzLnJlbmRlcmluZ01hbmFnZXIsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5wZW5kaW5nU2NlbmVJbml0ID0gaW5pdDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBkb1NjZW5lQ2hhbmdlKCl7XHJcblx0XHRjb25zb2xlLmxvZyhcIlBlcmZvcm1pbmcgc2NlbmUgY2hhbmdlXCIpO1xyXG5cdFx0dGhpcy52aWV3cG9ydC5zZXRDZW50ZXIodGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLngsIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55KTtcclxuXHRcdFxyXG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUpe1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIlVubG9hZGluZyBvbGQgc2NlbmVcIilcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUudW5sb2FkU2NlbmUoKTtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKFwiRGVzdHJveWluZyBvbGQgc2NlbmVcIik7XHJcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLmRlc3Ryb3koKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zb2xlLmxvZyhcIlVubG9hZGluZyBvbGQgcmVzb3VyY2VzLi4uXCIpO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIudW5sb2FkQWxsUmVzb3VyY2VzKCk7XHJcblxyXG5cdFx0Ly8gTWFrZSB0aGUgcGVuZGluZyBzY2VuZSB0aGUgY3VycmVudCBvbmVcclxuXHRcdHRoaXMuY3VycmVudFNjZW5lID0gdGhpcy5wZW5kaW5nU2NlbmU7XHJcblxyXG5cdFx0Ly8gTWFrZSB0aGUgcGVuZGluZyBzY2VuZSBudWxsXHJcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XHJcblxyXG5cdFx0Ly8gSW5pdCB0aGUgc2NlbmVcclxuXHRcdHRoaXMuY3VycmVudFNjZW5lLmluaXRTY2VuZSh0aGlzLnBlbmRpbmdTY2VuZUluaXQpO1xyXG5cclxuXHRcdC8vIEVucXVldWUgYWxsIHNjZW5lIGFzc2V0IGxvYWRzXHJcblx0XHR0aGlzLmN1cnJlbnRTY2VuZS5sb2FkU2NlbmUoKTtcclxuXHJcblx0XHQvLyBMb2FkIGFsbCBhc3NldHNcclxuXHRcdGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgU2NlbmUgTG9hZFwiKTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmxvYWRSZXNvdXJjZXNGcm9tUXVldWUoKCkgPT4ge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIFNjZW5lXCIpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zdGFydFNjZW5lKCk7XHJcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnNldFJ1bm5pbmcodHJ1ZSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnJlbmRlcmluZ01hbmFnZXIuc2V0U2NlbmUodGhpcy5jdXJyZW50U2NlbmUpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSURcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBJRFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZW5lcmF0ZUlkKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5pZENvdW50ZXIrKztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgU2NlbmVcclxuXHQgKi9cclxuXHRwdWJsaWMgcmVuZGVyKCk6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUpe1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5yZW5kZXIoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgU2NlbmVcclxuXHQgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lc3RlcCBvZiB0aGUgU2NlbmVcclxuXHQgKi9cclxuXHRwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKXtcclxuXHRcdGlmKHRoaXMucGVuZGluZ1NjZW5lICE9PSBudWxsKXtcclxuXHRcdFx0dGhpcy5kb1NjZW5lQ2hhbmdlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuaXNSdW5uaW5nKCkpe1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS51cGRhdGUoZGVsdGFUKTtcclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgQXJyYXlVdGlscyBmcm9tIFwiLi4vVXRpbHMvQXJyYXlVdGlsc1wiO1xyXG5cclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBUaGUgb3B0aW9ucyB0byBnaXZlIGEgQHJlZmVyZW5jZVtTY2VuZV0gZm9yIGluaXRpYWxpemF0aW9uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZU9wdGlvbnMge1xyXG4gICAgcGh5c2ljczoge1xyXG4gICAgICAgIGdyb3VwczogQXJyYXk8c3RyaW5nPixcclxuICAgICAgICBjb2xsaXNpb25zOiBBcnJheTxBcnJheTxudW1iZXI+PjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcGFyc2Uob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFNjZW5lT3B0aW9uc3tcclxuICAgICAgICBsZXQgc09wdCA9IG5ldyBTY2VuZU9wdGlvbnMoKTtcclxuXHJcbiAgICAgICAgaWYob3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBzT3B0LnBoeXNpY3MgPSB7Z3JvdXBzOiB1bmRlZmluZWQsIGNvbGxpc2lvbnM6IHVuZGVmaW5lZH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc09wdC5waHlzaWNzID0gb3B0aW9ucy5waHlzaWNzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNPcHQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIE1hbmFnZXMgYW55IHNvdW5kcyBvciBtdXNpYyBuZWVkZWQgZm9yIHRoZSBnYW1lLlxyXG4gKiBUaHJvdWdoIHRoZSBFdmVudFF1ZXVlLCBleHBvc2VzIGludGVyZmFjZSB0byBwbGF5IHNvdW5kcyBzbyBHYW1lTm9kZXMgY2FuIGFjdGl2YXRlIHNvdW5kcyB3aXRob3V0XHJcbiAqIG5lZWRpbmcgZGlyZWN0IHJlZmVyZW5jZXMgdG8gdGhlIGF1ZGlvIHN5c3RlbVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9NYW5hZ2VyIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBBdWRpb01hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSBldmVudCByZWNlaXZlciBvZiB0aGlzIEF1ZGlvTWFuYWdlciAqL1xyXG4gICAgcHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblxyXG4gICAgLyoqIEEgTWFwIG9mIHRoZSBuYW1lcyBvZiBjdXJyZW50bHkgcGxheWluZyAob3IgcGF1c2VkKSBzb3VuZHMgdG8gdGhlaXIgQXVkaW9CdWZmZXJzICovXHJcbiAgICBwcml2YXRlIGN1cnJlbnRTb3VuZHM6IE1hcDxBdWRpb0J1ZmZlclNvdXJjZU5vZGU+O1xyXG5cclxuICAgIHByaXZhdGUgYXVkaW9DdHg6IEF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICBwcml2YXRlIGdhaW5Ob2RlczogQXJyYXk8R2Fpbk5vZGU+O1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmluaXRBdWRpbygpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShbXHJcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9TT1VORCxcclxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5TVE9QX1NPVU5ELFxyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMsXHJcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9TRlgsXHJcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuTVVURV9DSEFOTkVMLFxyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlVOTVVURV9DSEFOTkVMXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U291bmRzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICB0aGlzLmdhaW5Ob2RlcyA9IG5ldyBBcnJheTxHYWluTm9kZT4oTUFYX0FVRElPX0NIQU5ORUxTKTtcclxuICAgICAgICB0aGlzLmluaXRHYWluTm9kZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW5zdGFuY2Ugb2YgdGhlIEF1ZGlvTWFuYWdlciBjbGFzcyBvciBjcmVhdGUgYSBuZXcgb25lIGlmIG5vbmUgZXhpc3RzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogQXVkaW9NYW5hZ2VyIHtcclxuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgQXVkaW9NYW5hZ2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHdlYkF1ZGlvIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpbml0QXVkaW8oKTogdm9pZCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQ7Ly8gfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDsgXHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9DdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7IFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV2ViIEF1ZGlvIEFQSSBzdWNjZXNzZnVsbHkgbG9hZGVkJyk7XHJcbiAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViIEF1ZGlvIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpOyBcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0R2Fpbk5vZGVzKCk6IHZvaWQge1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBNQVhfQVVESU9fQ0hBTk5FTFM7IGkrKyl7XHJcbiAgICAgICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2ldID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdWRpbyBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9Db250ZXh0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBdWRpb0NvbnRleHQoKTogQXVkaW9Db250ZXh0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdWRpb0N0eDtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICAgIEFjY29yZGluZyB0byB0aGUgTUROLCBjcmVhdGUgYSBuZXcgc291bmQgZm9yIGV2ZXJ5IGNhbGw6XHJcblxyXG4gICAgICAgIEFuIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBjYW4gb25seSBiZSBwbGF5ZWQgb25jZTsgYWZ0ZXIgZWFjaCBjYWxsIHRvIHN0YXJ0KCksIHlvdSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBub2RlXHJcbiAgICAgICAgaWYgeW91IHdhbnQgdG8gcGxheSB0aGUgc2FtZSBzb3VuZCBhZ2Fpbi4gRm9ydHVuYXRlbHksIHRoZXNlIG5vZGVzIGFyZSB2ZXJ5IGluZXhwZW5zaXZlIHRvIGNyZWF0ZSwgYW5kIHRoZVxyXG4gICAgICAgIGFjdHVhbCBBdWRpb0J1ZmZlcnMgY2FuIGJlIHJldXNlZCBmb3IgbXVsdGlwbGUgcGxheXMgb2YgdGhlIHNvdW5kLiBJbmRlZWQsIHlvdSBjYW4gdXNlIHRoZXNlIG5vZGVzIGluIGFcclxuICAgICAgICBcImZpcmUgYW5kIGZvcmdldFwiIG1hbm5lcjogY3JlYXRlIHRoZSBub2RlLCBjYWxsIHN0YXJ0KCkgdG8gYmVnaW4gcGxheWluZyB0aGUgc291bmQsIGFuZCBkb24ndCBldmVuIGJvdGhlciB0b1xyXG4gICAgICAgIGhvbGQgYSByZWZlcmVuY2UgdG8gaXQuIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBnYXJiYWdlLWNvbGxlY3RlZCBhdCBhbiBhcHByb3ByaWF0ZSB0aW1lLCB3aGljaCB3b24ndCBiZVxyXG4gICAgICAgIHVudGlsIHNvbWV0aW1lIGFmdGVyIHRoZSBzb3VuZCBoYXMgZmluaXNoZWQgcGxheWluZy5cclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgc291bmQgZnJvbSB0aGUga2V5IG9mIGEgbG9hZGVkIGF1ZGlvIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIGF1ZGlvIGZpbGUgdG8gY3JlYXRlIGEgbmV3IHNvdW5kIGZvclxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgQXVkaW9CdWZmZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVNvdW5kKGtleTogc3RyaW5nLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCBvcHRpb25zOiBNYXA8YW55Pik6IEF1ZGlvQnVmZmVyU291cmNlTm9kZSB7XHJcbiAgICAgICAgLy8gR2V0IGF1ZGlvIGJ1ZmZlclxyXG4gICAgICAgIGxldCBidWZmZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRBdWRpbyhrZXkpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBzb3VuZCBzb3VyY2VcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVCdWZmZXJTb3VyY2UoKTsgXHJcbiAgICAgIFxyXG4gICAgICAgIC8vIFRlbGwgdGhlIHNvdXJjZSB3aGljaCBzb3VuZCB0byBwbGF5XHJcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjsgICAgICAgICAgICAgICBcclxuICAgICAgXHJcbiAgICAgICAgLy8gQWRkIGFueSBhZGRpdGlvbmFsIG5vZGVzXHJcbiAgICAgICAgY29uc3Qgbm9kZXM6IEFycmF5PEF1ZGlvTm9kZT4gPSBbc291cmNlXTtcclxuXHJcbiAgICAgICAgLy8gRG8gYW55IGFkZGl0aW9uYWwgbm9kZXMgaGVyZT9cclxuICAgICAgICAvLyBPZiBjb3Vyc2UsIHRoZXJlIGFyZW4ndCBhbnkgc3VwcG9ydGVkIHlldC4uLlxyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIGdhaW4gbm9kZSBmb3IgdGhpcyBjaGFubmVsXHJcbiAgICAgICAgbm9kZXMucHVzaCh0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXSk7XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3QgYW55IG5vZGVzIGFsb25nIHRoZSBwYXRoXHJcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbm9kZXNbaS0xXS5jb25uZWN0KG5vZGVzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIHNvdXJjZSB0byB0aGUgY29udGV4dCdzIGRlc3RpbmF0aW9uXHJcbiAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uY29ubmVjdCh0aGlzLmF1ZGlvQ3R4LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheSB0aGUgc291bmQgc3BlY2lmaWVkIGJ5IHRoZSBrZXlcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc291bmQgdG8gcGxheVxyXG4gICAgICogQHBhcmFtIGxvb3AgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBzb3VuZFxyXG4gICAgICogQHBhcmFtIGhvbGRSZWZlcmVuY2UgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB3ZSB3YW50IHRvIGhvbGQgb24gdG8gYSByZWZlcmVuY2Ugb2YgdGhlIGF1ZGlvIG5vZGUuIFRoaXMgaXMgZ29vZCBmb3IgcGxheWluZyBtdXNpYyBvbiBhIGxvb3AgdGhhdCB3aWxsIGV2ZW50dWFsbHkgbmVlZCB0byBiZSBzdG9wcGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGxheVNvdW5kKGtleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCBvcHRpb25zOiBNYXA8YW55Pik6IHZvaWQge1xyXG4gICAgICAgIGxldCBzb3VuZCA9IHRoaXMuY3JlYXRlU291bmQoa2V5LCBob2xkUmVmZXJlbmNlLCBjaGFubmVsLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgaWYobG9vcCl7XHJcbiAgICAgICAgICAgIHNvdW5kLmxvb3AgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGEgcmVmZXJlbmNlIG9mIHRoZSBuZXcgc291bmQgdG8gYSBtYXAuIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBzdG9wIGEgbG9vcGluZyBvciBsb25nIHNvdW5kIGF0IGEgbGF0ZXIgdGltZVxyXG4gICAgICAgIGlmKGhvbGRSZWZlcmVuY2Upe1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTb3VuZHMuYWRkKGtleSwgc291bmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBzb3VuZC5zdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCB0aGUgc291bmQgc3BlY2lmaWVkIGJ5IHRoZSBrZXlcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0b3BTb3VuZChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBzb3VuZCA9IHRoaXMuY3VycmVudFNvdW5kcy5nZXQoa2V5KTtcclxuICAgICAgICBpZihzb3VuZCl7XHJcbiAgICAgICAgICAgIHNvdW5kLnN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U291bmRzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgbXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XHJcbiAgICAgICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgdW5tdXRlQ2hhbm5lbChjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcclxuICAgICAgICB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXS5nYWluLnNldFZhbHVlQXRUaW1lKDEsIHRoaXMuYXVkaW9DdHguY3VycmVudFRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdm9sdW1lIG9mIGEgY2hhbm5lbCB1c2luZyB0aGUgR2Fpbk5vZGUgZm9yIHRoYXQgY2hhbm5lbC4gRm9yIG1vcmVcclxuICAgICAqIGluZm9ybWF0aW9uIG9uIEdhaW5Ob2Rlcywgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxyXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGF1ZGlvIGNoYW5uZWwgdG8gc2V0IHRoZSB2b2x1bWUgZm9yXHJcbiAgICAgKiBAcGFyYW0gdm9sdW1lIFRoZSB2b2x1bWUgb2YgdGhlIGNoYW5uZWwuIDAgaXMgbXV0ZWQuIFZhbHVlcyBiZWxvdyB6ZXJvIHdpbGwgYmUgc2V0IHRvIHplcm8uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzZXRWb2x1bWUoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgdm9sdW1lOiBudW1iZXIpe1xyXG4gICAgICAgIGlmKHZvbHVtZSA8IDApe1xyXG4gICAgICAgICAgICB2b2x1bWUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYW0gPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBhbS5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2x1bWUsIGFtLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIEdhaW5Ob2RlIGZvciB0aGlzIGNoYW5uZWwuXHJcbiAgICAgKiBMZWFybiBtb3JlIGFib3V0IEdhaW5Ob2RlcyBoZXJlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxyXG4gICAgICogRE9OJ1QgVVNFIFRISVMgVU5MRVNTIFlPVSBLTk9XIFdIQVQgWU9VJ1JFIERPSU5HXHJcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbFxyXG4gICAgICogQHJldHVybnMgVGhlIEdhaW5Ob2RlIGZvciB0aGUgc3BlY2lmaWVkIGNoYW5uZWxcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhbm5lbEdhaW5Ob2RlKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gUGxheSBlYWNoIGF1ZGlvIGNsaXAgcmVxdWVzdGVkXHJcbiAgICAgICAgLy8gVE9ETyAtIEFkZCBsb2dpYyB0byBtZXJnZSBzb3VuZHMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIG9mIHRoZSBzYW1lIGtleVxyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQgfHwgZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX01VU0lDIHx8IGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9TRlgpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdW5kS2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG9vcCA9IGV2ZW50LmRhdGEuZ2V0KFwibG9vcFwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBob2xkUmVmZXJlbmNlID0gZXZlbnQuZGF0YS5nZXQoXCJob2xkUmVmZXJlbmNlXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBjaGFubmVsID0gQXVkaW9DaGFubmVsVHlwZS5ERUZBVUxUO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuTVVTSUM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoR2FtZUV2ZW50VHlwZS5QTEFZX1NGWCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuU0ZYO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEuaGFzKFwiY2hhbm5lbFwiKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IGV2ZW50LmRhdGEuZ2V0KFwiY2hhbm5lbFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlTb3VuZChzb3VuZEtleSwgbG9vcCwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291bmRLZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNvdW5kKHNvdW5kS2V5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NVVRFX0NIQU5ORUwpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlQ2hhbm5lbChldmVudC5kYXRhLmdldChcImNoYW5uZWxcIikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlVOTVVURV9DSEFOTkVMKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5tdXRlQ2hhbm5lbChldmVudC5kYXRhLmdldChcImNoYW5uZWxcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBBdWRpb0NoYW5uZWxUeXBlIHtcclxuICAgIERFRkFVTFQgPSAwLFxyXG4gICAgU0ZYID0gMSxcclxuICAgIE1VU0lDID0gMixcclxuICAgIENVU1RPTV8xID0gMyxcclxuICAgIENVU1RPTV8yID0gNCxcclxuICAgIENVU1RPTV8zID0gNSxcclxuICAgIENVU1RPTV80ID0gNixcclxuICAgIENVU1RPTV81ID0gNyxcclxuICAgIENVU1RPTV82ID0gOCxcclxuICAgIENVU1RPTV83ID0gOSxcclxuICAgIENVU1RPTV84ID0gMTAsXHJcbiAgICBDVVNUT01fOSA9IDExLFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTUFYX0FVRElPX0NIQU5ORUxTID0gMTI7IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL1RpbWVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lck1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgdGltZXJzOiBBcnJheTxUaW1lcj47XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5zdGFuY2U6IFRpbWVyTWFuYWdlcjtcclxuXHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVGltZXJNYW5hZ2VyIHtcclxuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgVGltZXJNYW5hZ2VyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRUaW1lcih0aW1lcjogVGltZXIpe1xyXG4gICAgICAgIHRoaXMudGltZXJzLnB1c2godGltZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyVGltZXJzKCl7XHJcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnRpbWVycy5mb3JFYWNoKHRpbWVyID0+IHRpbWVyLnVwZGF0ZShkZWx0YVQpKTtcclxuICAgIH1cclxufSIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4vTWF0aFV0aWxzXCI7XHJcblxyXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgZGF0YXR5cGVzIGZvbGRlclxyXG4vKipcclxuICogQSBDb2xvciB1dGlsIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgY29sb3JzIGxpa2UgYSB2ZWN0b3IsIGJ1dCBjYW4gYmUgY29udmVydGVkIGludG8gYSBzdHJpbmcgZm9ybWF0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvciB7XHJcblx0LyoqIFRoZSByZWQgdmFsdWUgKi9cclxuXHRwdWJsaWMgcjogbnVtYmVyO1xyXG5cdC8qKiBUaGUgZ3JlZW4gdmFsdWUgKi9cclxuXHRwdWJsaWMgZzogbnVtYmVyO1xyXG5cdC8qKiBUaGUgYmx1ZSB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBiOiBudW1iZXI7XHJcblx0LyoqIFRoZSBhbHBoYSB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBhOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgY29sb3JcclxuXHQgKiBAcGFyYW0gciBSZWRcclxuXHQgKiBAcGFyYW0gZyBHcmVlblxyXG5cdCAqIEBwYXJhbSBiIEJsdWVcclxuXHQgKiBAcGFyYW0gYSBBbHBoYVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHI6IG51bWJlciA9IDAsIGc6IG51bWJlciA9IDAsIGI6IG51bWJlciA9IDAsIGE6IG51bWJlciA9IDEpe1xyXG4gICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgdGhpcy5nID0gZztcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYSA9IGE7XHJcblx0fVxyXG5cclxuXHQvKipcdFxyXG5cdCAqIFRyYW5zcGFyZW50IGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiYSgwLCAwLCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgVFJBTlNQQVJFTlQoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHRcclxuXHQgKiBSZWQgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgUkVEKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogR3JlZW4gY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgR1JFRU4oKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDAsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBCbHVlIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDAsIDAsIDI1NSlcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IEJMVUUoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAyNTUsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBZZWxsb3cgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDApXHJcblx0ICovXHJcblx0c3RhdGljIGdldCBZRUxMT1coKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDI1NSwgMCwgMSk7XHJcblx0fVxyXG5cclxuXHQvKipcdFxyXG5cdCAqIE1hZ2VudGEgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAyNTUpXHJcblx0ICovXHJcblx0c3RhdGljIGdldCBNQUdFTlRBKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAyNTUsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBDeWFuIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDAsIDI1NSwgMjU1KVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgQ1lBTigpOiBDb2xvciB7XHJcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDI1NSwgMjU1LCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogV2hpdGUgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDI1NSlcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IFdISVRFKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSwgMSk7XHJcblx0fSBcclxuXHJcblx0LyoqXHRcclxuXHQgKiBCbGFjayBjb2xvclxyXG5cdCAqIEByZXR1cm5zIHJnYigwLCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgQkxBQ0soKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogT3JhbmdlIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMTAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgT1JBTkdFKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAxMDAsIDAsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgY29sb3IgdG8gdGhlIHZhbHVlcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSByIFJlZFxyXG5cdCAqIEBwYXJhbSBnIEdyZWVuXHJcblx0ICogQHBhcmFtIGIgQmx1ZVxyXG5cdCAqIEBwYXJhbSBhIEFscGhhXHJcblx0ICovXHJcblx0c2V0KHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuXHRcdHRoaXMuciA9IHI7XHJcblx0XHR0aGlzLmcgPSBnO1xyXG5cdFx0dGhpcy5iID0gYjtcclxuXHRcdHRoaXMuYSA9IGE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGxpZ2h0ZXIgdGhhbiB0aGUgY3VycmVudCBjb2xvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IGxpZ2h0ZXIgQ29sb3JcclxuXHQgKi9cclxuXHRsaWdodGVuKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoTWF0aFV0aWxzLmNsYW1wKHRoaXMuciArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5nICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmIgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYSArIDEwLCAwLCAyNTUpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igc2xpZ2h0bHkgZGFya2VyIHRoYW4gdGhlIGN1cnJlbnQgY29sb3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBkYXJrZXIgQ29sb3JcclxuXHQgKi9cclxuXHRkYXJrZW4oKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcihNYXRoVXRpbHMuY2xhbXAodGhpcy5yIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmcgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYiAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5hICsgMTAsIDAsIDI1NSkpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoaXMgY29sb3IgYXMgYW4gYXJyYXlcclxuXHQgKiBAcmV0dXJucyBbciwgZywgYiwgYV1cclxuXHQgKi9cclxuXHR0b0FycmF5KCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gI1JSR0dCQlxyXG5cdCAqIEByZXR1cm5zICNSUkdHQkJcclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiI1wiICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuciwgMikgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5nLCAyKSArIE1hdGhVdGlscy50b0hleCh0aGlzLmIsIDIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiKHIsIGcsIGIpXHJcblx0ICogQHJldHVybnMgcmdiKHIsIGcsIGIpXHJcblx0ICovXHJcblx0dG9TdHJpbmdSR0IoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcInJnYihcIiArIHRoaXMuci50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5nLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmIudG9TdHJpbmcoKSArIFwiKVwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiYShyLCBnLCBiLCBhKVxyXG5cdCAqIEByZXR1cm5zIHJnYmEociwgZywgYiwgYSlcclxuXHQgKi9cclxuXHR0b1N0cmluZ1JHQkEoKTogc3RyaW5nIHtcclxuXHRcdGlmKHRoaXMuYSA9PT0gMCl7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nUkdCKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCJyZ2JhKFwiICsgdGhpcy5yLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmcudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYi50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5hLnRvU3RyaW5nKCkgK1wiKVwiXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUdXJucyB0aGlzIGNvbG9yIGludG8gYSBmbG9hdDMyQXJyYXkgYW5kIGNoYW5nZXMgY29sb3IgcmFuZ2UgdG8gWzAuMCwgMS4wXVxyXG5cdCAqIEByZXR1cm5zIGEgRmxvYXQzMkFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbG9yXHJcblx0ICovXHJcblx0dG9XZWJHTCgpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHR0aGlzLnIvMjU1LFxyXG5cdFx0XHR0aGlzLmcvMjU1LFxyXG5cdFx0XHR0aGlzLmIvMjU1LFxyXG5cdFx0XHR0aGlzLmFcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21TdHJpbmdIZXgoc3RyOiBzdHJpbmcpOiBDb2xvciB7XHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRpZihzdHIuY2hhckF0KDApID09IFwiI1wiKSBpKz0gMTtcclxuXHRcdGxldCByID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpLCBpKzIpKTtcclxuXHRcdGxldCBnID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpKzIsIGkrNCkpO1xyXG5cdFx0bGV0IGIgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGkrNCwgaSs2KSk7XHJcblx0XHRyZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIpO1xyXG5cdH1cclxufSIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYXNlRnVuY3Rpb25zIHtcclxuXHJcbiAgICBzdGF0aWMgZWFzZUluT3V0U2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZWFzZU91dEluU2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gLU1hdGguY29zKE1hdGguUEkqKHggKyAwLjUpKS8yIDogLU1hdGguY29zKE1hdGguUEkqKHggLSAwLjUpKS8yICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZWFzZU91dFNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zaW4oKHggKiBNYXRoLlBJKSAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5TaW5lKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoeCAqIE1hdGguUEkpIC8gMik7IFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWludCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gMTYgKiB4ICogeCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCA1KSAvIDI7ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgMikgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlT3V0SW5RdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyB0aGlzLmVhc2VPdXRJbl9PdXRQb3coeCwgMikgOiB0aGlzLmVhc2VPdXRJbl9JblBvdyh4LCAyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fT3V0UG93KHg6IG51bWJlciwgcG93OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAwLjUgLSBNYXRoLnBvdygtMiAqIHggKyAxLCBwb3cpIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fSW5Qb3coeDogbnVtYmVyLCBwb3c6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSArIE1hdGgucG93KDIgKiB4IC0gMSwgcG93KSAvIDI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEVhc2VGdW5jdGlvblR5cGUge1xyXG4gICAgLy8gU0lORVxyXG4gICAgSU5fT1VUX1NJTkUgPSBcImVhc2VJbk91dFNpbmVcIixcclxuICAgIE9VVF9JTl9TSU5FID0gXCJlYXNlT3V0SW5TaW5lXCIsXHJcbiAgICBJTl9TSU5FID0gXCJlYXNlSW5TaW5lXCIsXHJcbiAgICBPVVRfU0lORSA9IFwiZWFzZU91dFNpbmVcIixcclxuXHJcbiAgICAvLyBRVUFEXHJcbiAgICBJTl9PVVRfUVVBRCA9IFwiZWFzZUluT3V0UXVhZFwiLFxyXG4gICAgT1VUX0lOX1FVQUQgPSBcImVhc2VPdXRJblF1YWRcIixcclxuXHJcbiAgICAvLyBRVUlOVFxyXG4gICAgSU5fT1VUX1FVSU5UID0gXCJlYXNlSW5PdXRRdWludFwiXHJcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcclxuaW1wb3J0IEVkZ2VOb2RlIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0VkZ2VOb2RlXCI7XHJcblxyXG4vKiogQSBjbGFzcyB0byBwcm92aWRlcyBzb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBncmFwaHMgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhVdGlscyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERqaWtzdHJhJ3Mgc2hvcnRlc3QgcGF0aCBhbGdvcml0aG0gYmFzZWQgb24gdGhlIG9uZSBkZXNjcmliZWQgaW4gVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxyXG5cdCAqIEBwYXJhbSBnIFRoZSBncmFwaFxyXG5cdCAqIEBwYXJhbSBzdGFydCBUaGUgbnVtYmVyIHRvIHN0YXJ0IHRoZSBzaG9ydGVzdCBwYXRoIGZyb21cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwYXJlbnQgb2YgZWFjaCBub2RlIG9mIHRoZSBHcmFwaCBpbiB0aGUgc2hvcnRlc3QgcGF0aC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZGppa3N0cmEoZzogR3JhcGgsIHN0YXJ0OiBudW1iZXIpOiBBcnJheTxudW1iZXI+IHtcclxuXHRcdGxldCBpOiBudW1iZXI7XHRcdC8vIENvdW50ZXJcclxuXHRcdGxldCBwOiBFZGdlTm9kZTtcdC8vIFBvaW50ZXIgdG8gZWRnZW5vZGVcclxuXHRcdGxldCBpblRyZWU6IEFycmF5PGJvb2xlYW4+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG5cdFx0bGV0IGRpc3RhbmNlOiBBcnJheTxudW1iZXI+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG5cdFx0bGV0IHBhcmVudDogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcclxuXHRcdGxldCB2OiBudW1iZXI7XHRcdC8vIEN1cnJlbnQgdmVydGV4IHRvIHByb2Nlc3NcclxuXHRcdGxldCB3OiBudW1iZXI7IFx0XHQvLyBDYW5kaWRhdGUgZm9yIG5leHQgdmVydGV4XHJcblx0XHRsZXQgd2VpZ2h0OiBudW1iZXI7XHQvLyBFZGdlIHdlaWdodFxyXG5cdFx0bGV0IGRpc3Q7XHRcdFx0Ly8gQmVzdCBjdXJyZW50IGRpc3RhbmNlIGZyb20gc3RhcnRcclxuXHJcblx0XHRmb3IoaSA9IDA7IGkgPCBnLm51bVZlcnRpY2VzOyBpKyspe1xyXG5cdFx0XHRpblRyZWVbaV0gPSBmYWxzZTtcclxuXHRcdFx0ZGlzdGFuY2VbaV0gPSBJbmZpbml0eTtcclxuXHRcdFx0cGFyZW50W2ldID0gLTE7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGlzdGFuY2Vbc3RhcnRdID0gMDtcclxuXHRcdHYgPSBzdGFydDtcclxuXHJcblx0XHR3aGlsZSghaW5UcmVlW3ZdKXtcclxuXHRcdFx0aW5UcmVlW3ZdID0gdHJ1ZTtcclxuXHRcdFx0cCA9IGcuZWRnZXNbdl07XHJcblxyXG5cdFx0XHR3aGlsZShwICE9PSBudWxsKXtcclxuXHRcdFx0XHR3ID0gcC55O1xyXG5cdFx0XHRcdHdlaWdodCA9IHAud2VpZ2h0O1xyXG5cclxuXHRcdFx0XHRpZihkaXN0YW5jZVt3XSA+IGRpc3RhbmNlW3ZdICsgd2VpZ2h0KXtcclxuXHRcdFx0XHRcdGRpc3RhbmNlW3ddID0gZGlzdGFuY2Vbdl0gKyB3ZWlnaHQ7XHJcblx0XHRcdFx0XHRwYXJlbnRbd10gPSB2O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cCA9IHAubmV4dDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0diA9IDA7XHJcblxyXG5cdFx0XHRkaXN0ID0gSW5maW5pdHk7XHJcblxyXG5cdFx0XHRmb3IoaSA9IDA7IGkgPD0gZy5udW1WZXJ0aWNlczsgaSsrKXtcclxuXHRcdFx0XHRpZighaW5UcmVlW2ldICYmIGRpc3QgPiBkaXN0YW5jZVtpXSl7XHJcblx0XHRcdFx0XHRkaXN0ID0gZGlzdGFuY2U7XHJcblx0XHRcdFx0XHR2ID0gaTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFyZW50O1xyXG5cclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKiBBIGNsYXNzIGNvbnRhaW5pbmcgc29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgbWF0aCBvcGVyYXRpb25zICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGhVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgdGhlIHZhbHVlIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gZXh0cmFjdCB0aGUgc2lnbiBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyAtMSBpZiB0aGUgbnVtYmVyIGlzIGxlc3MgdGhhbiAwLCAxIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2lnbih4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMCA/IC0xIDogMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgeCBpcyBiZXR3ZWVuIGEgYW5kIGJcclxuICAgICAqIEBwYXJhbSBhIFRoZSBtaW4gYm91bmRcclxuICAgICAqIEBwYXJhbSBiIFRoZSBtYXggYm91bmRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIGV4Y2x1c2l2ZSBXaGV0aGVyIG9yIG5vdCBhIGFuZCBiIGFyZSBleGNsdXNpdmUgYm91bmRzXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHggaXMgYmV0d2VlbiBhIGFuZCBiLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJldHdlZW4oYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciwgZXhjbHVzaXZlPzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmKGV4Y2x1c2l2ZSl7XHJcbiAgICAgICAgICAgIHJldHVybiAoYSA8IHgpICYmICh4IDwgYik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhIDw9IHgpICYmICh4IDw9IGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgW21pbiwgbWF4XSwgcm91bmRpbmcgdXAgb3IgZG93biBpZiBuZWVkZWRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW4gb2YgdGhlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbWF4IFRoZSBtYXggb2YgdGhlIHJhbmdlXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCBvciBtaW4vbWF4IGlmIGl0IGV4Y2VlZHMgdGhlaXIgYm91bmRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbGFtcCh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgaWYoeCA8IG1pbikgcmV0dXJuIG1pbjtcclxuICAgICAgICBpZih4ID4gbWF4KSByZXR1cm4gbWF4O1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhbXBzIHRoZSB2YWx1ZSB4IHRvIHRoZSByYW5nZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEsIG9yIDAvMSBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2xhbXAwMSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXAoeCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFtcHMgdGhlIGxvd2VyIGVuZCBvZiB0aGUgdmFsdWUgb2YgeCB0byB0aGUgcmFuZ2UgdG8gbWluXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxyXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIG9mIHhcclxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiBtaW4sIG90aGVyd2lzZSBtaW5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsYW1wTG93KHg6IG51bWJlciwgbWluOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgbG93ZXIgZW5kIG9mIHRoZSB2YWx1ZSBvZiB4IHRvIHplcm9cclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMCwgb3RoZXJ3aXNlIDBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsYW1wTG93MCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXBMb3coeCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNsYW1wTWFnbml0dWRlKHY6IFZlYzIsIG06IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIGlmKHYubWFnU3EoKSA+IG0qbSl7XHJcbiAgICAgICAgICAgIHJldHVybiB2LnNjYWxlVG8obSk7XHJcbiAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNoYW5nZVJhbmdlKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBuZXdNaW46IG51bWJlciwgbmV3TWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlcnAobmV3TWluLCBuZXdNYXgsIHRoaXMuaW52TGVycChtaW4sIG1heCwgeCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIExpbmVhciBJbnRlcnBvbGF0aW9uXHJcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXHJcblx0ICogQHBhcmFtIHQgVGhlIHRpbWUgd2UgYXJlIGludGVycG9sYXRpbmcgdG9cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIgYXQgdGltZSB0XHJcblx0ICovXHJcblx0c3RhdGljIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIGEgKyB0ICogKGIgLSBhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludmVyc2UgTGluZWFyIEludGVycG9sYXRpb24uIEZpbmRzIHRoZSB0aW1lIGF0IHdoaWNoIGEgdmFsdWUgYmV0d2VlbiBhIGFuZCBiIHdvdWxkIG9jY3VyXHJcbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXHJcbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdGltZSBhdCB3aGljaCB0aGUgY3VycmVudCB2YWx1ZSBvY2N1cnMgYmV0d2VlbiBhIGFuZCBiXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnZMZXJwKGE6IG51bWJlciwgYjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKXtcclxuICAgICAgICByZXR1cm4gKHZhbHVlIC0gYSkvKGIgLSBhKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXRzIG9mZiBkZWNpbWFsIHBvaW50cyBvZiBhIG51bWJlciBhZnRlciBhIHNwZWNpZmllZCBwbGFjZVxyXG4gICAgICogQHBhcmFtIG51bSBUaGUgbnVtYmVyIHRvIGZsb29yXHJcbiAgICAgKiBAcGFyYW0gcGxhY2UgVGhlIGxhc3QgZGVjaW1hbCBwbGFjZSBvZiB0aGUgbmV3IG51bWJlclxyXG4gICAgICogQHJldHVybnMgVGhlIGZsb29yZWQgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmbG9vclRvUGxhY2UobnVtOiBudW1iZXIsIHBsYWNlOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGlmKHBsYWNlID09PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmYWN0b3IgPSAxMDtcclxuICAgICAgICB3aGlsZShwbGFjZSA+IDEpe1xyXG4gICAgICAgICAgICBmYWN0b3IgIT0gMTA7XHJcbiAgICAgICAgICAgIHBsYWNlLS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW0qZmFjdG9yKS9mYWN0b3I7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG51bWJlciBmcm9tIGEgaGV4IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGhleCBudW1iZXJcclxuICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgaW4gZGVjaW1hbCByZXByZXNlbnRlZCBieSB0aGUgaGV4IHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUhleChzdHI6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIGFzIGEgaGV4YWRlY2ltYWxcclxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGhleFxyXG4gICAgICogQHBhcmFtIG1pbkxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBoZXggc3RyaW5nIChhZGRzIHplcm8gcGFkZGluZyBpZiBuZWVkZWQpXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRvSGV4KG51bTogbnVtYmVyLCBtaW5MZW5ndGg6IG51bWJlciA9IG51bGwpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBmYWN0b3IgPSAxO1xyXG4gICAgICAgIHdoaWxlKGZhY3RvcioxNiA8IG51bSl7XHJcbiAgICAgICAgICAgIGZhY3RvciAqPSAxNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhleFN0ciA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUoZmFjdG9yID49IDEpe1xyXG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBNYXRoLmZsb29yKG51bS9mYWN0b3IpO1xyXG4gICAgICAgICAgICBoZXhTdHIgKz0gTWF0aFV0aWxzLnRvSGV4RGlnaXQoZGlnaXQpO1xyXG4gICAgICAgICAgICBudW0gLT0gZGlnaXQgKiBmYWN0b3I7XHJcbiAgICAgICAgICAgIGZhY3RvciAvPSAxNjtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYobWluTGVuZ3RoICE9PSBudWxsKXtcclxuXHRcdFx0d2hpbGUoaGV4U3RyLmxlbmd0aCA8IG1pbkxlbmd0aCl7XHJcblx0XHRcdFx0aGV4U3RyID0gXCIwXCIgKyBoZXhTdHI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGhleFN0cjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgZGlnaXQgdG8gaGV4YWRlY2ltYWwuIEluIHRoaXMgY2FzZSwgYSBkaWdpdCBpcyBiZXR3ZWVuIDAgYW5kIDE1IGluY2x1c2l2ZVxyXG4gICAgICogQHBhcmFtIG51bSBUaGUgZGlnaXQgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbFxyXG4gICAgICogQHJldHVybnMgVGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGlnaXQgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRvSGV4RGlnaXQobnVtOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmKG51bSA8IDEwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBudW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBudW0gLSAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi9Db2xvclwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuL01hdGhVdGlsc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyaW5nVXRpbHMge1xyXG5cdHN0YXRpYyB0b1dlYkdMQ29vcmRzKHBvaW50OiBWZWMyLCBvcmlnaW46IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShwb2ludC54LCBvcmlnaW4ueCwgb3JpZ2luLnggKyB3b3JsZFNpemUueCwgLTEsIDEpLFxyXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueSwgb3JpZ2luLnksIG9yaWdpbi55ICsgd29ybGRTaXplLnksIDEsIC0xKVxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgdG9XZWJHTFNjYWxlKHNpemU6IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdDIqc2l6ZS54L3dvcmxkU2l6ZS54LFxyXG5cdFx0XHQyKnNpemUueS93b3JsZFNpemUueSxcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIHRvV2ViR0xDb2xvcihjb2xvcjogQ29sb3IpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuciwgMCwgMjU1LCAwLCAxKSxcclxuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLmcsIDAsIDI1NSwgMCwgMSksXHJcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5iLCAwLCAyNTUsIDAsIDEpLFxyXG5cdFx0XHRjb2xvci5hXHJcblx0XHRdKTtcclxuXHR9XHJcbn0iLCIvKiogU29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIHN0cmluZ3MgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nVXRpbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyB0aGUgcGF0aCBmcm9tIGEgZmlsZXBhdGggdGhhdCBpbmNsdWRlcyB0aGUgZmlsZVxyXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHRoZSBmaWxlcGF0aCB0byBleHRyYWN0IHRoZSBwYXRoIGZyb21cclxuICAgICAqIEByZXR1cm5zIFRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIGZpbGVwYXRoIHByb3ZpZGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQYXRoRnJvbUZpbGVQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgc3BsaXRQYXRoLnBvcCgpO1xyXG4gICAgICAgIHNwbGl0UGF0aC5wdXNoKFwiXCIpO1xyXG4gICAgICAgIHJldHVybiBzcGxpdFBhdGguam9pbihcIi9cIik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR2FtZSBmcm9tIFwiLi9Xb2xmaWUyRC9Mb29wL0dhbWVcIjtcclxuaW1wb3J0IFNwbGFzaFNjcmVlbiBmcm9tIFwiLi9TY2VuZXMvU3BsYXNoU2NyZWVuXCI7XHJcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4vV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBXZWFwb25SZWdpc3RyeSBmcm9tIFwiLi9HYW1lU3lzdGVtcy9SZWdpc3RyeS9XZWFwb25SZWdpc3RyeVwiO1xyXG5pbXBvcnQgV2VhcG9uVHlwZVJlZ2lzdHJ5IGZyb20gXCIuL0dhbWVTeXN0ZW1zL1JlZ2lzdHJ5L1dlYXBvblR5cGVSZWdpc3RyeVwiO1xyXG5cclxuLy8gVGhlIG1haW4gZnVuY3Rpb24gaXMgeW91ciBlbnRyeXBvaW50IGludG8gV29sZmllMkQuIFNwZWNpZnkgeW91ciBmaXJzdCBzY2VuZSBhbmQgYW55IG9wdGlvbnMgaGVyZS5cclxuKGZ1bmN0aW9uIG1haW4oKXtcclxuICAgIC8vIFJ1biBhbnkgdGVzdHNcclxuICAgIHJ1blRlc3RzKCk7XHJcblxyXG4gICAgLy8gU2V0IHVwIG9wdGlvbnMgZm9yIG91ciBnYW1lXHJcbiAgICBsZXQgb3B0aW9ucyA9IHtcclxuICAgICAgICBjYW52YXNTaXplOiB7eDogMTI4MCwgeTogNzIwfSwgICAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIGdhbWVcclxuICAgICAgICBjbGVhckNvbG9yOiB7cjogMCwgZzogMCwgYjogMH0sICAgICAgICAgLy8gVGhlIGNvbG9yIHRoZSBnYW1lIGNsZWFycyB0b1xyXG4gICAgICAgIGlucHV0czogWyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR1cCBpbnB1dHNcclxuICAgICAgICAgICAge25hbWU6IFwidXBcIiwga2V5czogW1wid1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImRvd25cIiwga2V5czogW1wic1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImxlZnRcIiwga2V5czogW1wiYVwiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcInJpZ2h0XCIsIGtleXM6IFtcImRcIl19LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJpbnRlcmFjdFwiLCBrZXlzOiBbXCJlXCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwicGF1c2VcIiwga2V5czogW1wiZXNjYXBlXCJdfSxcclxuICAgICAgICBdXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0dXAgY3VzdG9tIHdlYXBvbiByZWdpc3RyeVxyXG4gICAgbGV0IHdlYXBvblRlbXBsYXRlUmVnaXN0cnkgPSBuZXcgV2VhcG9uUmVnaXN0cnkoKTtcclxuICAgIFJlZ2lzdHJ5TWFuYWdlci5hZGRDdXN0b21SZWdpc3RyeShcIndlYXBvblRlbXBsYXRlc1wiLCB3ZWFwb25UZW1wbGF0ZVJlZ2lzdHJ5KTtcclxuICAgIFxyXG4gICAgbGV0IHdlYXBvblR5cGVSZWdpc3RyeSA9IG5ldyBXZWFwb25UeXBlUmVnaXN0cnkoKTtcclxuICAgIFJlZ2lzdHJ5TWFuYWdlci5hZGRDdXN0b21SZWdpc3RyeShcIndlYXBvblR5cGVzXCIsIHdlYXBvblR5cGVSZWdpc3RyeSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgZ2FtZSB3aXRoIHRoZSBvcHRpb25zIHNwZWNpZmllZFxyXG4gICAgY29uc3QgZ2FtZSA9IG5ldyBHYW1lKG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIFN0YXJ0IG91ciBnYW1lXHJcbiAgICBnYW1lLnN0YXJ0KFNwbGFzaFNjcmVlbiwge30pO1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gcnVuVGVzdHMoKXt9OyJdfQ==
