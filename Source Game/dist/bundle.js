(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnemyStates = void 0;
const StateMachineAI_1 = require("./../Wolfie2D/AI/StateMachineAI");
const AABB_1 = require("./../Wolfie2D/DataTypes/Shapes/AABB");
const Vec2_1 = require("./../Wolfie2D/DataTypes/Vec2");
const Attack_1 = require("./BatStates/Attack");
const Idle_1 = require("./BatStates/Idle");
const game_enums_1 = require("./../GameSystems/game_enums");
const Damaged_1 = require("./BatStates/Damaged");
class BatAI extends StateMachineAI_1.default {
    constructor() {
        super(...arguments);
        /** The default movement speed of this AI */
        this.speed = 20;
        // State machine defers updates and event handling to its children
        // Check super classes for details
    }
    initializeAI(owner, options) {
        this.owner = owner;
        this.addState(EnemyStates.DEFAULT, new Idle_1.default(this, owner));
        this.addState(EnemyStates.ATTACKING, new Attack_1.default(this, owner));
        this.addState(EnemyStates.DAMAGED, new Damaged_1.default(this, owner));
        this.health = options.health;
        this.player = options.player;
        // Initialize to the default state
        this.initialize(EnemyStates.DEFAULT);
        this.getPlayerPosition();
    }
    activate(options) {
    }
    damage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
            this.owner.setAIActive(false, {});
            this.owner.isCollidable = false;
            if (!this.owner.animation.isPlaying("DYING")) {
                this.owner.animation.play("DYING", false, game_enums_1.Game_Events.ENEMY_DIED);
            }
        }
        else {
            this.changeState(EnemyStates.DAMAGED);
        }
    }
    getPlayerPosition() {
        let pos = this.player.position;
        // Get the new player location
        let start = this.owner.position.clone();
        let delta = pos.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, pos.x);
        let maxX = Math.max(start.x, pos.x);
        let minY = Math.min(start.y, pos.y);
        let maxY = Math.max(start.y, pos.y);
        // Get the wall tilemap
        let walls = this.owner.getScene().getLayer("Wall").getItems()[0];
        let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
        let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
        let tileSize = walls.getTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(pos)) {
                        // We hit a wall, we can't see the player
                        return null;
                    }
                }
            }
        }
        return pos;
    }
}
exports.default = BatAI;
var EnemyStates;
(function (EnemyStates) {
    EnemyStates["DEFAULT"] = "default";
    EnemyStates["ATTACKING"] = "attacking";
    EnemyStates["DAMAGED"] = "damaged";
    EnemyStates["PREVIOUS"] = "previous";
})(EnemyStates = exports.EnemyStates || (exports.EnemyStates = {}));
},{"./../GameSystems/game_enums":19,"./../Wolfie2D/AI/StateMachineAI":24,"./../Wolfie2D/DataTypes/Shapes/AABB":36,"./../Wolfie2D/DataTypes/Vec2":43,"./BatStates/Attack":2,"./BatStates/Damaged":3,"./BatStates/Idle":5}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("./../../Wolfie2D/DataTypes/Vec2");
const Timer_1 = require("./../../Wolfie2D/Timing/Timer");
const BatAI_1 = require("../BatAI");
const EnemyState_1 = require("./EnemyState");
class Attack extends EnemyState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
        // Regularly update the player location
        this.exitTimer = new Timer_1.default(1000);
        this.resetTimer = new Timer_1.default(3000);
    }
    onEnter(options) {
        this.resetTimer.start();
        this.owner.animation.play("ATTACK", true);
        this.lastPlayerPos = new Vec2_1.default(this.parent.getPlayerPosition().x, this.parent.getPlayerPosition().y);
        // Reset the return object
        this.retObj = {};
    }
    handleInput(event) { }
    update(deltaT) {
        if (this.parent.getPlayerPosition() !== null) {
            // Player is visible, restart the exitTimer
            this.exitTimer.start();
            if (!this.doneMoving) {
                if (this.resetTimer.isStopped()) {
                    this.finished(BatAI_1.EnemyStates.DEFAULT);
                }
                if (this.owner.position.distanceTo(this.lastPlayerPos) < 5) {
                    this.doneMoving = true;
                }
                this.owner.move(this.owner.position.dirTo(this.lastPlayerPos).scale(3.5));
            }
            else {
                this.resetTimer.start();
                this.doneMoving = false;
                this.lastPlayerPos = new Vec2_1.default(this.parent.getPlayerPosition().x, this.parent.getPlayerPosition().y);
            }
        }
        if (this.exitTimer.isStopped()) {
            // We haven't seen the player in a while, go check out where we last saw them, if possible
            this.finished(BatAI_1.EnemyStates.DEFAULT);
        }
    }
    onExit() {
        return this.retObj;
    }
}
exports.default = Attack;
},{"../BatAI":1,"./../../Wolfie2D/DataTypes/Vec2":43,"./../../Wolfie2D/Timing/Timer":114,"./EnemyState":4}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EnemyState_1 = require("./EnemyState");
const BatAI_1 = require("../BatAI");
class Damaged extends EnemyState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
    }
    onEnter(options) {
        this.owner.animation.play("DAMAGE", false);
        this.lastPlayerPos = this.parent.getPlayerPosition();
        // Reset the return object
        this.retObj = {};
    }
    handleInput(event) { }
    update(deltaT) {
        if (!this.owner.animation.isPlaying("DAMAGE")) {
            this.finished(BatAI_1.EnemyStates.DEFAULT);
        }
    }
    onExit() {
        this.owner.animation.stop();
        return this.retObj;
    }
}
exports.default = Damaged;
},{"../BatAI":1,"./EnemyState":4}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const State_1 = require("./../../Wolfie2D/DataTypes/State/State");
class EnemyState extends State_1.default {
    constructor(parent, owner) {
        super(parent);
        this.owner = owner;
    }
}
exports.default = EnemyState;
},{"./../../Wolfie2D/DataTypes/State/State":40}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BatAI_1 = require("../BatAI");
const EnemyState_1 = require("./EnemyState");
class Idle extends EnemyState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
    }
    onEnter(options) {
        this.owner.animation.play("IDLE", true);
    }
    handleInput(event) {
    }
    update(deltaT) {
        if (this.parent.getPlayerPosition() !== null && this.owner.position.distanceTo(this.parent.getPlayerPosition()) < 200) {
            this.finished(BatAI_1.EnemyStates.ATTACKING);
        }
    }
    onExit() {
        this.owner.animation.stop();
        return {};
    }
}
exports.default = Idle;
},{"../BatAI":1,"./EnemyState":4}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BossStates = void 0;
const StateMachineAI_1 = require("./../Wolfie2D/AI/StateMachineAI");
const AABB_1 = require("./../Wolfie2D/DataTypes/Shapes/AABB");
const Vec2_1 = require("./../Wolfie2D/DataTypes/Vec2");
const Attack_1 = require("./GluttonyStates/Attack");
const Idle_1 = require("./GluttonyStates/Idle");
const Damage_1 = require("./GluttonyStates/Damage");
const game_enums_1 = require("../GameSystems/game_enums");
class GluttonyAI extends StateMachineAI_1.default {
    constructor() {
        super(...arguments);
        /** The default movement speed of this AI */
        this.speed = 20;
        // State machine defers updates and event handling to its children
        // Check super classes for details
    }
    initializeAI(owner, options) {
        console.log("Initialize Gluttony");
        this.owner = owner;
        this.addState(BossStates.DEFAULT, new Idle_1.default(this, owner));
        this.addState(BossStates.ATTACKING, new Attack_1.default(this, owner));
        this.addState(BossStates.DAMAGE, new Damage_1.default(this, owner));
        this.health = options.health;
        this.player = options.player;
        // Initialize to the default state
        this.initialize(BossStates.DEFAULT);
        this.getPlayerPosition();
    }
    activate(options) {
    }
    damage(damage) {
        this.health -= damage;
        if (this.health <= 0) {
            this.owner.setAIActive(false, {});
            this.owner.isCollidable = false;
            if (!this.owner.animation.isPlaying("DYING")) {
                this.owner.animation.play("DYING", false, game_enums_1.Game_Events.BOSS_DIED);
            }
            console.log("ded gluttony");
            // this.owner.animation.play("DYING");
            // this.owner.visible = false;
        }
        else {
            this.changeState(BossStates.DAMAGE);
        }
    }
    getPlayerPosition() {
        let pos = this.player.position;
        // Get the new player location
        let start = this.owner.position.clone();
        let delta = pos.clone().sub(start);
        // Iterate through the tilemap region until we find a collision
        let minX = Math.min(start.x, pos.x);
        let maxX = Math.max(start.x, pos.x);
        let minY = Math.min(start.y, pos.y);
        let maxY = Math.max(start.y, pos.y);
        // Get the wall tilemap
        let walls = this.owner.getScene().getLayer("Wall").getItems()[0];
        let minIndex = walls.getColRowAt(new Vec2_1.default(minX, minY));
        let maxIndex = walls.getColRowAt(new Vec2_1.default(maxX, maxY));
        let tileSize = walls.getTileSize();
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (walls.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    let hit = collider.intersectSegment(start, delta, Vec2_1.default.ZERO);
                    if (hit !== null && start.distanceSqTo(hit.pos) < start.distanceSqTo(pos)) {
                        // We hit a wall, we can't see the player
                        return null;
                    }
                }
            }
        }
        return pos;
    }
}
exports.default = GluttonyAI;
var BossStates;
(function (BossStates) {
    BossStates["DEFAULT"] = "default";
    BossStates["DAMAGE"] = "damage";
    BossStates["ATTACKING"] = "attacking";
    BossStates["PREVIOUS"] = "previous";
    BossStates["DYING"] = "dying";
})(BossStates = exports.BossStates || (exports.BossStates = {}));
},{"../GameSystems/game_enums":19,"./../Wolfie2D/AI/StateMachineAI":24,"./../Wolfie2D/DataTypes/Shapes/AABB":36,"./../Wolfie2D/DataTypes/Vec2":43,"./GluttonyStates/Attack":7,"./GluttonyStates/Damage":9,"./GluttonyStates/Idle":10}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Timer_1 = require("./../../Wolfie2D/Timing/Timer");
const BossState_1 = require("./BossState");
const GluttonyAI_1 = require("../GluttonyAI");
class Attack extends BossState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
        // Regularly update the player location
        this.pollTimer = new Timer_1.default(100);
        this.exitTimer = new Timer_1.default(1000);
    }
    onEnter(options) {
        this.owner.animation.play("ATTACK", true);
        this.lastPlayerPos = this.parent.getPlayerPosition();
        // Reset the return object
        this.retObj = {};
    }
    handleInput(event) { }
    update(deltaT) {
        if (this.pollTimer.isStopped()) {
            // Restart the timer
            this.pollTimer.start();
            this.playerPos = this.parent.getPlayerPosition();
            if (this.playerPos !== null) {
                // If we see a new player position, update the last position
                this.lastPlayerPos = this.playerPos;
            }
        }
        if (this.parent.getPlayerPosition() !== null && this.owner.position.distanceTo(this.parent.getPlayerPosition()) < 200) {
            // Player is nearby, restart the exitTimer
            this.exitTimer.start();
        }
        if (this.exitTimer.isStopped()) {
            this.finished(GluttonyAI_1.BossStates.DEFAULT);
        }
    }
    onExit() {
        return this.retObj;
    }
}
exports.default = Attack;
},{"../GluttonyAI":6,"./../../Wolfie2D/Timing/Timer":114,"./BossState":8}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const State_1 = require("./../../Wolfie2D/DataTypes/State/State");
class BossState extends State_1.default {
    constructor(parent, owner) {
        super(parent);
        this.owner = owner;
    }
}
exports.default = BossState;
},{"./../../Wolfie2D/DataTypes/State/State":40}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BossState_1 = require("./BossState");
const GluttonyAI_1 = require("../GluttonyAI");
class Damage extends BossState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
    }
    onEnter(options) {
        this.owner.animation.play("DAMAGE", false);
        // Reset the return object
        this.retObj = {};
    }
    handleInput(event) { }
    update(deltaT) {
        if (!this.owner.animation.isPlaying("DAMAGE")) {
            this.finished(GluttonyAI_1.BossStates.ATTACKING);
        }
    }
    onExit() {
        this.owner.animation.stop();
        return this.retObj;
    }
}
exports.default = Damage;
},{"../GluttonyAI":6,"./BossState":8}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BossState_1 = require("./BossState");
const GluttonyAI_1 = require("../GluttonyAI");
class Idle extends BossState_1.default {
    constructor(parent, owner) {
        super(parent, owner);
    }
    onEnter(options) {
        this.owner.animation.play("IDLE", true);
    }
    handleInput(event) {
    }
    update(deltaT) {
        if (this.parent.getPlayerPosition() !== null && this.owner.position.distanceTo(this.parent.getPlayerPosition()) < 200) {
            this.finished(GluttonyAI_1.BossStates.ATTACKING);
        }
    }
    onExit() {
        this.owner.animation.stop();
        return this.retObj;
    }
}
exports.default = Idle;
},{"../GluttonyAI":6,"./BossState":8}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlayerStates = void 0;
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const Input_1 = require("../Wolfie2D/Input/Input");
const Emitter_1 = require("../Wolfie2D/Events/Emitter");
const game_enums_1 = require("../GameSystems/game_enums");
var PlayerStates;
(function (PlayerStates) {
    PlayerStates["IDLE"] = "idle";
    PlayerStates["WALK"] = "walk";
    PlayerStates["ATTACK"] = "attack";
    PlayerStates["DAMAGE"] = "damage";
})(PlayerStates = exports.PlayerStates || (exports.PlayerStates = {}));
class PlayerController {
    initializeAI(owner, options) {
        this.owner = owner;
        this.direction = Vec2_1.default.ZERO;
        this.curr_velocity = Vec2_1.default.ZERO; // for use with slippery movement
        this.attack_direction = Vec2_1.default.ZERO;
        this.speed = options.speed;
        this.emitter = new Emitter_1.default();
        this.health_sprites = options.health_sprites;
        this.health = options.health;
        this.coins = options.coins;
        this.slippery = options.slippery !== undefined ? options.slippery : false;
        this.fist = options.fist;
    }
    activate(options) { }
    handleEvent(event) {
        if (event.type === game_enums_1.Game_Events.BAT_COLLISION) {
            // take 1 damage
            this.damage(1);
            this.invincible = true;
        }
        else if (event.type === game_enums_1.Game_Events.BOSS_COLLISION) {
            // take 1 damage
            this.damage(1);
            this.invincible = true;
        }
        else if (event.type === game_enums_1.Game_Events.IFRAMES_OVER) {
            console.log("not invincible");
            this.invincible = false;
        }
    }
    update(deltaT) {
        // get the movement direction
        this.direction.x = (Input_1.default.isPressed("left") ? -1 : 0) + (Input_1.default.isPressed("right") ? 1 : 0);
        this.direction.y = (Input_1.default.isPressed("up") ? -1 : 0) + (Input_1.default.isPressed("down") ? 1 : 0);
        let dont_interrupt = this.owner.animation.isPlaying("ATTACK") || this.owner.animation.isPlaying("DAMAGE");
        if (!this.direction.isZero() && !this.owner.animation.isPlaying("ATTACK")) {
            if (this.slippery) {
                // slippery movement
                if (this.direction.x !== 0) {
                    this.curr_velocity.x += this.direction.normalized().scale(this.speed * deltaT).x / 20;
                }
                else {
                    this.curr_velocity.x -= this.curr_velocity.normalized().scale(this.speed * deltaT).x / 40;
                }
                if (this.direction.y !== 0) {
                    this.curr_velocity.y += this.direction.normalized().scale(this.speed * deltaT).y / 20;
                }
                else {
                    this.curr_velocity.y -= this.curr_velocity.normalized().scale(this.speed * deltaT).y / 40;
                }
                this.owner.move(this.curr_velocity);
            }
            else {
                // normal movement
                this.owner.move(this.direction.normalized().scale(this.speed * deltaT));
            }
            if (!dont_interrupt) {
                this.owner.animation.playIfNotAlready("WALK", true);
            }
        }
        else {
            // no movement input
            if (this.slippery && (Math.abs(this.curr_velocity.x) > 0 || Math.abs(this.curr_velocity.y) > 0)) {
                // slide a bit
                this.curr_velocity.x -= this.curr_velocity.normalized().scale(this.speed * deltaT).x / 40;
                this.curr_velocity.y -= this.curr_velocity.normalized().scale(this.speed * deltaT).y / 40;
                if (Math.abs(this.curr_velocity.x) < .05) {
                    this.curr_velocity.x = 0;
                }
                if (Math.abs(this.curr_velocity.y) < .05) {
                    this.curr_velocity.y = 0;
                }
                this.owner.move(this.curr_velocity);
                if (!dont_interrupt) {
                    this.owner.animation.playIfNotAlready("IDLE", true);
                }
            }
            else {
                // play idle animation
                if (!dont_interrupt) {
                    this.owner.animation.playIfNotAlready("IDLE", true);
                }
            }
        }
        // Get the unit vector in the attack direction
        this.attack_direction = this.owner.position.dirTo(Input_1.default.getGlobalMousePosition());
        // update rotation for attacking
        this.owner.attack_direction = Vec2_1.default.UP.angleToCCW(this.attack_direction);
        // punch attack
        if (!this.owner.animation.isPlaying("ATTACK") && Input_1.default.isMouseJustPressed()) {
            // TODO PROJECT - implement punch attack here
            let attack_success = this.fist.use(this.owner, "player", this.attack_direction);
            if (attack_success) {
                console.log("punch event");
                this.owner.animation.play("ATTACK", false);
            }
        }
        // have player face left or right
        if (!this.owner.animation.isPlaying("ATTACK")) {
            let mouse_position = Input_1.default.getGlobalMousePosition();
            if (mouse_position.x < this.owner.position.x) {
                this.owner.invertX = true;
            }
            else {
                this.owner.invertX = false;
            }
        }
    }
    damage(damage) {
        if (!this.invincible) {
            this.health -= damage;
            this.health_sprites[this.health_sprites.length - 1].getLayer().removeNode(this.health_sprites[this.health_sprites.length - 1]);
            this.health_sprites.splice(this.health_sprites.length - 1, 1);
            if (this.health <= 0) {
                console.log("Game Over");
                this.emitter.fireEvent(game_enums_1.Game_Events.GAME_OVER, {});
            }
            else {
                this.owner.animation.play("DAMAGE", false, game_enums_1.Game_Events.IFRAMES_OVER);
                this.invincible = true;
                console.log("invincible");
            }
        }
    }
    destroy() {
        delete this.owner;
    }
}
exports.default = PlayerController;
},{"../GameSystems/game_enums":19,"../Wolfie2D/DataTypes/Vec2":43,"../Wolfie2D/Events/Emitter":46,"../Wolfie2D/Input/Input":51}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BattleManager {
    handleInteraction(attackerType, weapon) {
        if (attackerType === "player") {
            // Check for collisions with enemies
            for (let enemy of this.enemies) {
                if (weapon.hits(enemy.owner)) {
                    enemy.damage(weapon.type.damage);
                }
            }
        }
        else {
            // Check for collision with player
            if (weapon.hits(this.player.owner)) {
                this.player.damage(weapon.type.damage);
            }
        }
    }
    setPlayer(player) {
        this.player = player;
    }
    setEnemies(enemies) {
        this.enemies = enemies;
    }
}
exports.default = BattleManager;
},{}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Item {
    constructor(sprite) {
        this.sprite = sprite;
    }
    moveSprite(position, layer) {
        // Change the layer if needed
        if (layer) {
            let currentLayer = this.sprite.getLayer();
            currentLayer.removeNode(this.sprite);
            let newLayer = this.sprite.getScene().getLayer(layer);
            newLayer.addNode(this.sprite);
            this.sprite.setLayer(newLayer);
        }
        // Move the sprite
        this.sprite.position.copy(position);
    }
}
exports.default = Item;
},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Registry_1 = require("../../Wolfie2D/Registry/Registries/Registry");
const ResourceManager_1 = require("../../Wolfie2D/ResourceManager/ResourceManager");
const Punch_1 = require("../WeaponTypes/Punch");
class WeaponRegistry extends Registry_1.default {
    preload() {
        const rm = ResourceManager_1.default.getInstance();
        rm.image("fist", "game_assets/images/splash_screen.png");
        // load spritesheets
        // TODO PROJECT - import punch spritesheet
        rm.spritesheet("fist", "game_assets/spritesheets/impact.json");
        console.log("loaded sprite");
        this.registerItem("fist", Punch_1.default);
    }
    registerAndPreloadItem(key) { }
    registerItem(key, constr) {
        this.add(key, constr);
    }
}
exports.default = WeaponRegistry;
},{"../../Wolfie2D/Registry/Registries/Registry":81,"../../Wolfie2D/ResourceManager/ResourceManager":100,"../WeaponTypes/Punch":17}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Registry_1 = require("../../Wolfie2D/Registry/Registries/Registry");
class WeaponTypeRegistry extends Registry_1.default {
    preload() { }
    // We don't need this for this assignment
    registerAndPreloadItem(key) { }
    registerItem(key, type) {
        this.add(key, type);
    }
}
exports.default = WeaponTypeRegistry;
},{"../../Wolfie2D/Registry/Registries/Registry":81}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = require("../Wolfie2D/Events/Emitter");
const Timer_1 = require("../Wolfie2D/Timing/Timer");
const Item_1 = require("./Item");
class Weapon extends Item_1.default {
    constructor(sprite, type, battleManager) {
        super(sprite);
        // Set the weapon type
        this.type = type;
        // Keep a reference to the sprite of this weapon
        this.sprite = sprite;
        // Rely on the weapon type to create any necessary assets
        this.assets = this.type.createRequiredAssets(this.sprite.getScene());
        // Create an event emitter
        this.emitter = new Emitter_1.default();
        // Save a reference to the battler manager
        this.battleManager = battleManager;
        // Create the cooldown timer
        this.cooldownTimer = new Timer_1.default(type.cooldown);
    }
    // @override
    /**
     * Uses this weapon in the specified direction.
     * This only works if the cooldown timer has ended
     */
    use(user, userType, direction) {
        // If the cooldown timer is still running, we can't use the weapon
        if (!this.cooldownTimer.isStopped()) {
            return false;
        }
        // Do a type specific weapon animation
        this.type.doAnimation(user, direction, ...this.assets);
        // Apply damage
        this.battleManager.handleInteraction(userType, this);
        // Send out an event to alert enemies
        this.emitter.fireEvent("PUNCH", { position: user.position.clone(), volume: this.type.use_volume });
        // Reset the cooldown timer
        this.cooldownTimer.start();
        return true;
    }
    /**
     * A check for whether or not this weapon hit a node
     */
    hits(node) {
        return this.type.hits(node, ...this.assets);
    }
}
exports.default = Weapon;
},{"../Wolfie2D/Events/Emitter":46,"../Wolfie2D/Timing/Timer":114,"./Item":13}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const WeaponType_1 = require("./WeaponType");
class Punch extends WeaponType_1.default {
    initialize(options) {
        this.damage = options.damage;
        this.cooldown = options.cooldown;
        this.display_name = options.displayName;
        this.sprite_key = options.spriteKey;
        this.use_volume = options.useVolume;
    }
    doAnimation(attacker, direction, punch_sprite) {
        // rotate this with the game node
        punch_sprite.rotation = attacker.attack_direction;
        // move the punch out from the player
        punch_sprite.position = attacker.position.clone().add(direction.scaled(30));
        // play the punch animation but queue the normal animation
        punch_sprite.animation.play("PUNCH");
        punch_sprite.animation.queue("NORMAL", true);
    }
    createRequiredAssets(scene) {
        let punch = scene.add.animatedSprite("fist", "primary");
        console.log(punch.getLayer());
        punch.animation.play("NORMAL", true);
        return [punch];
    }
    hits(node, punch_sprite) {
        return punch_sprite.boundary.overlaps(node.collisionShape);
    }
}
exports.default = Punch;
},{"./WeaponType":18}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class WeaponType {
}
exports.default = WeaponType;
},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Game_Events = void 0;
var Game_Events;
(function (Game_Events) {
    Game_Events["ENEMY_DIED"] = "EnemyDied";
    Game_Events["ENEMY_DAMAGED"] = "EnemyDamaged";
    Game_Events["BOSS_DAMAGED"] = "BossDamaged";
    Game_Events["BOSS_DIED"] = "BossDied";
    Game_Events["BAT_COLLISION"] = "BatCollision";
    Game_Events["GAME_OVER"] = "GameOver";
    Game_Events["IFRAMES_OVER"] = "IframesOver";
    Game_Events["BOSS_COLLISION"] = "BossCollision";
})(Game_Events = exports.Game_Events || (exports.Game_Events = {}));
},{}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const Scene_1 = require("../Wolfie2D/Scene/Scene");
const RegistryManager_1 = require("../Wolfie2D/Registry/RegistryManager");
const AABB_1 = require("../Wolfie2D/DataTypes/Shapes/AABB");
const PlayerController_1 = require("../AI/PlayerController");
const BatAI_1 = require("../AI/BatAI");
const Weapon_1 = require("../GameSystems/Weapon");
const BattleManager_1 = require("../GameSystems/BattleManager");
const GluttonyAI_1 = require("../AI/GluttonyAI");
const game_enums_1 = require("./../GameSystems/game_enums");
const GameEvent_1 = require("../Wolfie2D/Events/GameEvent");
class GluttonyLevel extends Scene_1.default {
    // use initScene to differentiate between level select start and game continue?
    initScene(init) {
        this.player_health = init.health;
        this.player_coins = init.coins;
    }
    loadScene() {
        // load the player and enemy spritesheets
        this.load.spritesheet("player", "game_assets/spritesheets/zara.json");
        //Load Zaras Heart image
        this.load.image("heart", "game_assets/images/heart.png");
        // TODO PROJECT - add enemy spritesheets
        // Load in the enemy info
        this.load.spritesheet("hellbat", "game_assets/spritesheets/hellbat.json");
        this.load.spritesheet("gluttony", "game_assets/spritesheets/gluttony.json");
        this.load.spritesheet("boss_hitbox", "game_assets/spritesheets/boss_hitbox.json");
        this.load.object("enemyData", "game_assets/data/enemy.json");
        // load the tilemap
        // TODO PROJECT - switch with correct tilemap
        this.load.tilemap("gluttonyLevel", "game_assets/tilemaps/hells_fury.json");
        // load weapon info
        this.load.object("weaponData", "game_assets/data/weapon_data.json");
        this.load.image("fist", "game_assets/spritesheets/impact.png");
        this.load.spritesheet("fist", "game_assets/spritesheets/impact.json");
    }
    startScene() {
        // Add in the tilemap
        let tilemap_layers = this.add.tilemap("gluttonyLevel");
        // get the wall layer
        this.walls = tilemap_layers[1].getItems()[0];
        // set the viewport bounds to the tilemap
        let tilemap_size = this.walls.size;
        this.viewport.setBounds(0, 0, tilemap_size.x, tilemap_size.y);
        // add primary layer
        this.addLayer("primary", 10);
        // Add a layer for UI
        this.addUILayer("UI");
        this.addUI();
        this.battle_manager = new BattleManager_1.default;
        this.initializeWeapons();
        this.initializePlayer();
        // TODO PROJECT - write initializeEnemies()
        this.initializeEnemies();
        this.battle_manager.setPlayer(this.player._ai);
        this.battle_manager.setEnemies(this.enemies.map(enemy => enemy._ai));
        // setup viewport
        this.viewport.follow(this.player);
        this.viewport.setZoomLevel(2);
        // TODO PROJECT - receiver subscribe to events
        // this.receiver.subscribe(EVENTSTRING);
        this.subscribeToEvents();
    }
    updateScene(deltaT) {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            switch (event.type) {
                case game_enums_1.Game_Events.BAT_COLLISION:
                    {
                        let node = this.sceneGraph.getNode(event.data.get("node"));
                        let other = this.sceneGraph.getNode(event.data.get("other"));
                        console.log("bat collision");
                        let bat_pos = Vec2_1.default.ZERO;
                        if (node === this.player) {
                            // other is bat
                            bat_pos = other.position;
                        }
                        else {
                            // node is bat
                            bat_pos = node.position;
                        }
                        event.data.add("batPosition", bat_pos);
                        node._ai.handleEvent(event);
                        other._ai.handleEvent(event);
                    }
                    break;
                case game_enums_1.Game_Events.BOSS_COLLISION:
                    {
                        let node = this.sceneGraph.getNode(event.data.get("node"));
                        let other = this.sceneGraph.getNode(event.data.get("other"));
                        console.log("boss collision");
                        let boss_pos = Vec2_1.default.ZERO;
                        if (node === this.player) {
                            // other is bat
                            boss_pos = other.position;
                        }
                        else {
                            // node is bat
                            boss_pos = node.position;
                        }
                        event.data.add("bossPosition", boss_pos);
                        node._ai.handleEvent(event);
                        other._ai.handleEvent(event);
                    }
                    break;
                case game_enums_1.Game_Events.ENEMY_DAMAGED:
                    {
                    }
                    break;
                case game_enums_1.Game_Events.ENEMY_DIED:
                    {
                        let node = this.sceneGraph.getNode(event.data.get("owner"));
                        for (let i = 0; i < this.enemies.length; i++) {
                            if (this.enemies[i].id === node.id) {
                                this.enemies.splice(i, 1);
                                break;
                            }
                        }
                        this.battle_manager.setEnemies(this.enemies.map(enemy => enemy._ai));
                        // for(let i = 0; i < this.enemies.length; i++){
                        //     console.log(this.enemies[i].imageId);
                        // }
                        console.log(this.enemies);
                        node.destroy();
                    }
                    break;
                case game_enums_1.Game_Events.BOSS_DAMAGED:
                    {
                    }
                    break;
                case game_enums_1.Game_Events.BOSS_DIED:
                    {
                        let node = this.sceneGraph.getNode(event.data.get("owner"));
                        for (let i = 0; i < this.enemies.length; i++) {
                            if (this.enemies[i].id === node.id) {
                                this.enemies.splice(i, 1);
                                break;
                            }
                        }
                        this.battle_manager.setEnemies(this.enemies.map(enemy => enemy._ai));
                        // for(let i = 0; i < this.enemies.length; i++){
                        //     console.log(this.enemies[i].imageId);
                        // }
                        console.log(this.enemies);
                        node.destroy();
                    }
                    break;
                case game_enums_1.Game_Events.IFRAMES_OVER:
                    {
                        this.player._ai.handleEvent(new GameEvent_1.default(game_enums_1.Game_Events.IFRAMES_OVER, {}));
                    }
                    break;
                case game_enums_1.Game_Events.GAME_OVER:
                    {
                        console.log("GAME OVER");
                    }
                    break;
            }
        }
    }
    initializePlayer() {
        // Create the player
        this.player = this.add.animatedSprite("player", "primary");
        this.player.position.set(30 * 16, 62 * 16);
        this.player.addPhysics(new AABB_1.default(new Vec2_1.default(0, 14), new Vec2_1.default(16, 15)), new Vec2_1.default(0, 15));
        let fist = this.createWeapon("punch");
        this.player.addAI(PlayerController_1.default, {
            speed: 150,
            fist: fist,
            slippery: true,
            health: this.player_health,
            coins: this.player_coins,
            health_sprites: this.health_sprites
        });
        this.player.animation.play("IDLE", true);
        this.player.setGroup("player");
    }
    initializeEnemies() {
        // Get the enemy data
        const enemyData = this.load.getObject("enemyData");
        // Create an enemies array
        this.enemies = new Array(enemyData.numEnemies);
        // Initialize the enemies
        for (let i = 0; i < enemyData.numEnemies; i++) {
            let data = enemyData.enemies[i];
            // Create an enemy
            this.enemies[i] = this.add.animatedSprite(data.enemy_type, "primary");
            this.enemies[i].position.set(data.position[0], data.position[1]);
            this.enemies[i].animation.play("IDLE");
            let enemyOptions = {
                health: data.health,
                player: this.player,
            };
            // Activate physics
            //Only one enemy for now
            if (data.enemy_type === "hellbat") {
                this.enemies[i].addPhysics();
                this.enemies[i].addAI(BatAI_1.default, enemyOptions);
                // this.enemies[i].addPhysics(new AABB(Vec2.ZERO, new Vec2(9, 7)));
                this.enemies[i].setGroup("enemy");
                this.enemies[i].setTrigger("player", game_enums_1.Game_Events.BAT_COLLISION, "bat hit player");
            }
            else if (data.enemy_type === "gluttony") {
                this.enemies[i].addAI(GluttonyAI_1.default, enemyOptions);
                this.enemies[i].addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(56, 56)));
                this.enemies[i].setGroup("enemy");
                this.enemies[i].setTrigger("player", game_enums_1.Game_Events.BOSS_COLLISION, "boss hit player");
            }
            else {
                this.enemies[i].addAI(GluttonyAI_1.default, enemyOptions);
                this.enemies[i].addPhysics(new AABB_1.default(Vec2_1.default.ZERO, new Vec2_1.default(50, 50)));
            }
        }
    }
    initializeWeapons() {
        let weapon_data = this.load.getObject("weaponData");
        for (let i = 0; i < weapon_data.numWeapons; i++) {
            let weapon = weapon_data.weapons[i];
            let constr = RegistryManager_1.default.getRegistry("weaponTemplates").get(weapon.weaponType);
            let weaponType = new constr();
            weaponType.initialize(weapon);
            RegistryManager_1.default.getRegistry("weaponTypes").registerItem(weapon.name, weaponType);
        }
    }
    createWeapon(type) {
        let weaponType = RegistryManager_1.default.getRegistry("weaponTypes").get(type);
        let sprite = this.add.sprite(weaponType.sprite_key, "primary");
        return new Weapon_1.default(sprite, weaponType, this.battle_manager);
    }
    addUI() {
        // Zara Health
        let prev_loc = new Vec2_1.default(2, 20);
        this.health_sprites = new Array();
        for (let i = 0; i < this.player_health; i++) {
            let spriteToAdd = this.add.sprite("heart", "UI");
            console.log(spriteToAdd);
            spriteToAdd.position = new Vec2_1.default(prev_loc.x + 25, prev_loc.y);
            console.log(spriteToAdd);
            this.health_sprites.push(spriteToAdd);
            console.log("yooo");
            prev_loc = new Vec2_1.default(prev_loc.x + 25, prev_loc.y);
        }
    }
    subscribeToEvents() {
        this.receiver.subscribe([
            game_enums_1.Game_Events.ENEMY_DAMAGED,
            game_enums_1.Game_Events.ENEMY_DIED,
            game_enums_1.Game_Events.BOSS_DAMAGED,
            game_enums_1.Game_Events.BOSS_DIED,
            game_enums_1.Game_Events.BAT_COLLISION,
            game_enums_1.Game_Events.GAME_OVER,
            game_enums_1.Game_Events.IFRAMES_OVER,
            game_enums_1.Game_Events.BOSS_COLLISION
        ]);
    }
}
exports.default = GluttonyLevel;
},{"../AI/BatAI":1,"../AI/GluttonyAI":6,"../AI/PlayerController":11,"../GameSystems/BattleManager":12,"../GameSystems/Weapon":16,"../Wolfie2D/DataTypes/Shapes/AABB":36,"../Wolfie2D/DataTypes/Vec2":43,"../Wolfie2D/Events/GameEvent":48,"../Wolfie2D/Registry/RegistryManager":83,"../Wolfie2D/Scene/Scene":110,"./../GameSystems/game_enums":19}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../Wolfie2D/Scene/Scene");
const Color_1 = require("../Wolfie2D/Utils/Color");
const GluttonyLevel_1 = require("./GluttonyLevel");
class MainMenu extends Scene_1.default {
    loadScene() {
        this.load.image("mainMenuImage", "game_assets/images/main_menu_background.png");
        this.load.image("levelSelectImage", "game_assets/images/level_select_background.png");
        this.load.image("helpImage", "game_assets/images/help_background.png");
        this.load.image("controlsImage", "game_assets/images/controls_background.png");
    }
    startScene() {
        const center = this.viewport.getCenter();
        // subscribe to button events
        this.receiver.subscribe("newGame");
        this.receiver.subscribe("levelSelect");
        this.receiver.subscribe("help");
        this.receiver.subscribe("controls");
        this.receiver.subscribe("mainMenu");
        this.receiver.subscribe("levelGluttony");
        this.receiver.subscribe("levelLust");
        this.receiver.subscribe("levelWrath");
        this.receiver.subscribe("levelGreed");
        this.receiver.subscribe("levelSloth");
        this.receiver.subscribe("levelEnvy");
        this.receiver.subscribe("levelPride");
        /* ################ MAIN MENU ################ */
        // create main menu layer
        this.main_menu = this.addUILayer("mainMenu");
        // add main menu background image
        let mmb = this.add.sprite("mainMenuImage", "mainMenu");
        mmb.position.set(mmb.size.x / 2, mmb.size.y / 2);
        // Add new game button, and give it an event to emit on press
        const new_game_button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x - 14, center.y - 170), text: "" });
        new_game_button.size.set(330, 70);
        new_game_button.borderWidth = 2;
        new_game_button.borderColor = Color_1.default.TRANSPARENT;
        new_game_button.backgroundColor = Color_1.default.TRANSPARENT;
        new_game_button.onClickEventId = "newGame";
        // Add level select button
        const level_select_button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x - 13, center.y - 60), text: "" });
        level_select_button.size.set(420, 70);
        level_select_button.borderWidth = 2;
        level_select_button.borderColor = Color_1.default.TRANSPARENT;
        level_select_button.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_button.onClickEventId = "levelSelect";
        // Add help button
        const help_button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x - 21, center.y + 55), text: "" });
        help_button.size.set(145, 75);
        help_button.borderWidth = 2;
        help_button.borderColor = Color_1.default.TRANSPARENT;
        help_button.backgroundColor = Color_1.default.TRANSPARENT;
        help_button.onClickEventId = "help";
        // Add controls
        const controls_button = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1.default(center.x - 13, center.y + 150), text: "" });
        controls_button.size.set(268, 70);
        controls_button.borderWidth = 2;
        controls_button.borderColor = Color_1.default.TRANSPARENT;
        controls_button.backgroundColor = Color_1.default.TRANSPARENT;
        controls_button.onClickEventId = "controls";
        /* ################ LEVEL SELECT ################ */
        // create level select layer
        this.level_select = this.addUILayer("levelSelect");
        this.level_select.setHidden(true);
        // add level select background image
        let lsb = this.add.sprite("levelSelectImage", "levelSelect");
        lsb.position.set(lsb.size.x / 2, lsb.size.y / 2);
        const level_select_back = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x + 518, center.y + 308), text: "" });
        level_select_back.size.set(168, 65);
        level_select_back.borderWidth = 2;
        level_select_back.borderColor = Color_1.default.TRANSPARENT;
        level_select_back.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_back.onClickEventId = "mainMenu";
        const level_select_gluttony = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 20, center.y - 195), text: "" });
        level_select_gluttony.size.set(285, 75);
        level_select_gluttony.borderWidth = 2;
        level_select_gluttony.borderColor = Color_1.default.TRANSPARENT;
        level_select_gluttony.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_gluttony.onClickEventId = "levelGluttony";
        const level_select_lust = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 27, center.y - 95), text: "" });
        level_select_lust.size.set(140, 58);
        level_select_lust.borderWidth = 2;
        level_select_lust.borderColor = Color_1.default.TRANSPARENT;
        level_select_lust.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_lust.onClickEventId = "levelLust";
        const level_select_wrath = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 21, center.y + 3), text: "" });
        level_select_wrath.size.set(164, 54);
        level_select_wrath.borderWidth = 2;
        level_select_wrath.borderColor = Color_1.default.TRANSPARENT;
        level_select_wrath.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_wrath.onClickEventId = "levelWrath";
        const level_select_greed = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 21, center.y + 85), text: "" });
        level_select_greed.size.set(150, 50);
        level_select_greed.borderWidth = 2;
        level_select_greed.borderColor = Color_1.default.TRANSPARENT;
        level_select_greed.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_greed.onClickEventId = "levelGreed";
        const level_select_sloth = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 19, center.y + 160), text: "" });
        level_select_sloth.size.set(135, 50);
        level_select_sloth.borderWidth = 2;
        level_select_sloth.borderColor = Color_1.default.TRANSPARENT;
        level_select_sloth.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_sloth.onClickEventId = "levelSloth";
        const level_select_envy = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 20, center.y + 230), text: "" });
        level_select_envy.size.set(114, 50);
        level_select_envy.borderWidth = 2;
        level_select_envy.borderColor = Color_1.default.TRANSPARENT;
        level_select_envy.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_envy.onClickEventId = "levelEnvy";
        const level_select_pride = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levelSelect", { position: new Vec2_1.default(center.x - 22, center.y + 295), text: "" });
        level_select_pride.size.set(107, 47);
        level_select_pride.borderWidth = 2;
        level_select_pride.borderColor = Color_1.default.TRANSPARENT;
        level_select_pride.backgroundColor = Color_1.default.TRANSPARENT;
        level_select_pride.onClickEventId = "levelPride";
        /* ################ HELP ################ */
        // create help layer
        this.help = this.addUILayer("help");
        this.help.setHidden(true);
        // add help background image
        let hb = this.add.sprite("helpImage", "help");
        hb.position.set(hb.size.x / 2, hb.size.y / 2);
        const help_back = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "help", { position: new Vec2_1.default(center.x + 518, center.y + 308), text: "" });
        help_back.size.set(168, 65);
        help_back.borderWidth = 2;
        help_back.borderColor = Color_1.default.TRANSPARENT;
        help_back.backgroundColor = Color_1.default.TRANSPARENT;
        help_back.onClickEventId = "mainMenu";
        /* ################ CONTROLS ################ */
        // create controls layer
        this.controls = this.addUILayer("controls");
        this.controls.setHidden(true);
        // add controls background image
        let cb = this.add.sprite("controlsImage", "controls");
        cb.position.set(cb.size.x / 2, cb.size.y / 2);
        const controls_back = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "controls", { position: new Vec2_1.default(center.x + 518, center.y + 308), text: "" });
        controls_back.size.set(168, 65);
        controls_back.borderWidth = 2;
        controls_back.borderColor = Color_1.default.TRANSPARENT;
        controls_back.backgroundColor = Color_1.default.TRANSPARENT;
        controls_back.onClickEventId = "mainMenu";
    }
    updateScene() {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            let sceneOptions = {
                physics: {
                    groupNames: ["ground", "player", "enemy"],
                    collisions: [
                        [0, 1, 1],
                        [1, 0, 0],
                        [1, 0, 0]
                    ]
                }
            };
            if (event.type === "newGame") {
                // TODO PROJECT - setup new game scene from here (maybe add options)
                console.log("New Game Event");
                this.sceneManager.changeToScene(GluttonyLevel_1.default, {
                    health: 5,
                    coins: 0
                }, sceneOptions);
            }
            if (event.type === "mainMenu") {
                console.log("Main Menu Event");
                this.main_menu.setHidden(false);
                this.level_select.setHidden(true);
                this.help.setHidden(true);
                this.controls.setHidden(true);
            }
            if (event.type === "levelSelect") {
                console.log("Level Select Event");
                this.main_menu.setHidden(true);
                this.level_select.setHidden(false);
            }
            if (event.type === "help") {
                console.log("Help Event");
                this.main_menu.setHidden(true);
                this.help.setHidden(false);
            }
            if (event.type === "controls") {
                console.log("Controls Event");
                this.main_menu.setHidden(true);
                this.controls.setHidden(false);
            }
            if (event.type === "levelGluttony") {
                // TODO PROJECT - go to gluttony level (level 1)
                console.log("Gluttony Level");
                this.sceneManager.changeToScene(GluttonyLevel_1.default, {
                    health: 5,
                    coins: 0
                });
            }
            if (event.type === "levelLust") {
                // TODO PROJECT - go to lust level (level 2)
                console.log("Lust Level");
            }
            if (event.type === "levelWrath") {
                // TODO PROJECT - go to wrath level (level 3)
                console.log("Wrath Level");
            }
            if (event.type === "levelGreed") {
                // TODO PROJECT - go to greed level (level 4)
                console.log("Greed Level");
            }
            if (event.type === "levelSloth") {
                // TODO PROJECT - go to sloth level (level 5)
                console.log("Sloth Level");
            }
            if (event.type === "levelEnvy") {
                // TODO PROJECT - go to envy level (level 6)
                console.log("Envy Level");
            }
            if (event.type === "levelPride") {
                // TODO PROJECT - go to pride level (level 7)
                console.log("Pride Level");
            }
        }
    }
}
exports.default = MainMenu;
},{"../Wolfie2D/DataTypes/Vec2":43,"../Wolfie2D/Nodes/UIElements/UIElementTypes":74,"../Wolfie2D/Scene/Scene":110,"../Wolfie2D/Utils/Color":116,"./GluttonyLevel":20}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Wolfie2D/DataTypes/Vec2");
const UIElementTypes_1 = require("../Wolfie2D/Nodes/UIElements/UIElementTypes");
const Scene_1 = require("../Wolfie2D/Scene/Scene");
const Color_1 = require("../Wolfie2D/Utils/Color");
const MainMenu_1 = require("./MainMenu");
class SplashScreen extends Scene_1.default {
    loadScene() {
        this.load.image("splashImage", "game_assets/images/splash_screen.png");
    }
    startScene() {
        const center = this.viewport.getCenter();
        // The splash screen
        this.splash = this.addUILayer("splashScreen");
        // Add a background to the scene
        this.splash_background = this.addParallaxLayer("splash_background", new Vec2_1.default(0.5, 1), -1);
        let sb = this.add.sprite("splashImage", "splash_background");
        sb.position.set(sb.size.x / 2, sb.size.y / 2);
        // Add transparent button
        const confirm = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "splashScreen", { position: new Vec2_1.default(center.x, center.y), text: "" });
        confirm.size.set(1280, 720);
        confirm.borderWidth = 0;
        confirm.borderColor = Color_1.default.TRANSPARENT;
        confirm.backgroundColor = Color_1.default.TRANSPARENT;
        confirm.onClickEventId = "confirm";
        // Subscribe to the button events
        this.receiver.subscribe("confirm");
    }
    updateScene() {
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === "confirm") {
                this.splash_background.disable();
                this.sceneManager.changeToScene(MainMenu_1.default, {});
            }
        }
    }
}
exports.default = SplashScreen;
},{"../Wolfie2D/DataTypes/Vec2":43,"../Wolfie2D/Nodes/UIElements/UIElementTypes":74,"../Wolfie2D/Scene/Scene":110,"../Wolfie2D/Utils/Color":116,"./MainMenu":21}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
class AIManager {
    constructor() {
        this.actors = new Array();
        this.registeredAI = new Map_1.default();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    registerActor(actor) {
        this.actors.push(actor);
    }
    removeActor(actor) {
        let index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    }
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    registerAI(name, constr) {
        this.registeredAI.add(name, constr);
    }
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    generateAI(name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw `Cannot create AI with name ${name}, no AI with that name is registered`;
        }
    }
    update(deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(actor => { if (actor.aiActive)
            actor.ai.update(deltaT); });
    }
}
exports.default = AIManager;
},{"../DataTypes/Map":30}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const StateMachine_1 = require("../DataTypes/State/StateMachine");
/**
 * A version of a @reference[StateMachine] that is configured to work as an AI controller for a @reference[GameNode]
 */
class StateMachineAI extends StateMachine_1.default {
    // @implemented
    initializeAI(owner, config) { }
    // @implemented
    destroy() {
        // Get rid of our reference to the owner
        delete this.owner;
        this.receiver.destroy();
    }
    // @implemented
    activate(options) { }
}
exports.default = StateMachineAI;
},{"../DataTypes/State/StateMachine":41}],25:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A placeholder function for No Operation. Does nothing
 */
const NullFunc = () => { };
exports.default = NullFunc;
},{}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A linked-list for the edges in a @reference[Graph].
 */
class EdgeNode {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    constructor(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
}
exports.default = EdgeNode;
},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_V = void 0;
const EdgeNode_1 = require("./EdgeNode");
exports.MAX_V = 100;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
class Graph {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
    */
    addNode() {
        this.numVertices++;
        return this.numVertices;
    }
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
    */
    addEdge(x, y, weight) {
        let edge = new EdgeNode_1.default(y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1.default(x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    }
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    edgeExists(x, y) {
        let edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    }
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    getEdges(x) {
        return this.edges[x];
    }
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    getDegree(x) {
        return this.degree[x];
    }
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    nodeToString(index) {
        return "Node " + index;
    }
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    toString() {
        let retval = "";
        for (let i = 0; i < this.numVertices; i++) {
            let edge = this.edges[i];
            let edgeStr = "";
            while (edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    }
}
exports.default = Graph;
},{"./EdgeNode":26}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = require("./Graph");
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
*/
class PositionGraph extends Graph_1.default {
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    constructor(directed = false) {
        super(directed);
        this.debugRender = () => {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        this.positions = new Array(Graph_1.MAX_V);
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    addPositionedNode(position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    }
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    setNodePosition(index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (let i = 0; i < this.numEdges; i++) {
            let edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    }
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    getNodePosition(index) {
        return this.positions[index];
    }
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    addEdge(x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        let weight = this.positions[x].distanceTo(this.positions[y]);
        super.addEdge(x, y, weight);
    }
    // @override
    nodeToString(index) {
        return "Node " + index + " - " + this.positions[index].toString();
    }
}
exports.default = PositionGraph;
},{"./Graph":27}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;
},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Associates strings with elements of type T
 */
class Map {
    /** Creates a new map */
    constructor() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    add(key, value) {
        this.map[key] = value;
    }
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    get(key) {
        return this.map[key];
    }
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    set(key, value) {
        this.add(key, value);
    }
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    has(key) {
        return this.map[key] !== undefined;
    }
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    keys() {
        return Object.keys(this.map);
    }
    // @implemented
    forEach(func) {
        Object.keys(this.map).forEach(key => func(key));
    }
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    delete(key) {
        delete this.map[key];
    }
    // @implemented
    clear() {
        this.forEach(key => delete this.map[key]);
    }
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    toString() {
        let str = "";
        this.forEach((key) => str += key + " -> " + this.get(key).toString() + "\n");
        return str;
    }
}
exports.default = Map;
},{}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("./Vec2");
/** A 4x4 matrix0 */
class Mat4x4 {
    constructor() {
        this.mat = new Float32Array([
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ]);
    }
    // Static members
    static get IDENTITY() {
        return new Mat4x4().identity();
    }
    static get ZERO() {
        return new Mat4x4().zero();
    }
    // Accessors
    set _00(x) {
        this.mat[0] = x;
    }
    set(col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw `Error - index (${col}, ${row}) is out of bounds for Mat4x4`;
        }
        this.mat[row * 4 + col] = value;
        return this;
    }
    get(col, row) {
        return this.mat[row * 4 + col];
    }
    setAll(...items) {
        this.mat.set(items);
        return this;
    }
    identity() {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    zero() {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    rotate(zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    translate(translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1.default) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    }
    scale(scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1.default) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    mult(other, out) {
        let temp = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let value = 0;
                for (let k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll(...temp);
        }
        else {
            return new Mat4x4().setAll(...temp);
        }
    }
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    static MULT(...mats) {
        // Create a new array
        let temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (let i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    }
    toArray() {
        return this.mat;
    }
    toString() {
        return `|${this.mat[0].toFixed(2)}, ${this.mat[1].toFixed(2)}, ${this.mat[2].toFixed(2)}, ${this.mat[3].toFixed(2)}|\n` +
            `|${this.mat[4].toFixed(2)}, ${this.mat[5].toFixed(2)}, ${this.mat[6].toFixed(2)}, ${this.mat[7].toFixed(2)}|\n` +
            `|${this.mat[8].toFixed(2)}, ${this.mat[9].toFixed(2)}, ${this.mat[10].toFixed(2)}, ${this.mat[11].toFixed(2)}|\n` +
            `|${this.mat[12].toFixed(2)}, ${this.mat[13].toFixed(2)}, ${this.mat[14].toFixed(2)}, ${this.mat[15].toFixed(2)}|`;
    }
}
exports.default = Mat4x4;
},{"./Vec2":43}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
class AreaCollision {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    constructor(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
}
exports.default = AreaCollision;
},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class Hit {
    constructor() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1.default.ZERO;
        /** The position of the collision */
        this.pos = Vec2_1.default.ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1.default.ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1.default.ZERO;
    }
}
exports.default = Hit;
},{"../Vec2":43}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A FIFO queue with elements of type T
 */
class Queue {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    enqueue(item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    }
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    dequeue() {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        let item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    }
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    peekNext() {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        let item = this.q[this.head];
        return item;
    }
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    hasItems() {
        return this.head !== this.tail;
    }
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    getSize() {
        return this.size;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.q[index]);
        this.size = 0;
        this.head = this.tail;
    }
    // @implemented
    forEach(func) {
        let i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    }
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Queue;
},{}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A container for info about a webGL shader program */
class WebGLProgramType {
    /**
     * Deletes this shader program
     */
    delete(gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    }
}
exports.default = WebGLProgramType;
},{}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Shape_1 = require("./Shape");
const Vec2_1 = require("../Vec2");
const MathUtils_1 = require("../../Utils/MathUtils");
const Circle_1 = require("./Circle");
const Hit_1 = require("../Physics/Hit");
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
class AABB extends Shape_1.default {
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    constructor(center, halfSize) {
        super();
        this.center = center ? center : new Vec2_1.default(0, 0);
        this.halfSize = halfSize ? halfSize : new Vec2_1.default(0, 0);
    }
    /** Returns a point representing the top left corner of the AABB */
    get topLeft() {
        return new Vec2_1.default(this.left, this.top);
    }
    /** Returns a point representing the top right corner of the AABB */
    get topRight() {
        return new Vec2_1.default(this.right, this.top);
    }
    /** Returns a point representing the bottom left corner of the AABB */
    get bottomLeft() {
        return new Vec2_1.default(this.left, this.bottom);
    }
    /** Returns a point representing the bottom right corner of the AABB */
    get bottomRight() {
        return new Vec2_1.default(this.right, this.bottom);
    }
    // @override
    getBoundingRect() {
        return this.clone();
    }
    // @override
    getBoundingCircle() {
        let r = Math.max(this.hw, this.hh);
        return new Circle_1.default(this.center.clone(), r);
    }
    // @deprecated
    getHalfSize() {
        return this.halfSize;
    }
    // @deprecated
    setHalfSize(halfSize) {
        this.halfSize = halfSize;
    }
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return point.x >= this.x - this.hw && point.x <= this.x + this.hw
            && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    intersectPoint(point) {
        let dx = point.x - this.x;
        let px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = point.y - this.y;
        let py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPointSoft(point) {
        return point.x > this.x - this.hw && point.x <= this.x + this.hw
            && point.y > this.y - this.hh && point.y <= this.y + this.hh;
    }
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    intersectSegment(point, delta, padding) {
        let paddingX = padding ? padding.x : 0;
        let paddingY = padding ? padding.y : 0;
        let scaleX = 1 / delta.x;
        let scaleY = 1 / delta.y;
        let signX = MathUtils_1.default.sign(scaleX);
        let signY = MathUtils_1.default.sign(scaleY);
        let tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        let tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        let tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        let tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        let tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        let tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        let hit = new Hit_1.default();
        hit.time = MathUtils_1.default.clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    }
    // @override
    overlaps(other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    }
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    overlapsAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    touchesAABB(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    touchesAABBWithoutCorners(other) {
        let dx = other.x - this.x;
        let px = this.hw + other.hw - Math.abs(dx);
        let dy = other.y - this.y;
        let py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            let ret = new Vec2_1.default();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    }
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    overlapArea(other) {
        let leftx = Math.max(this.x - this.hw, other.x - other.hw);
        let rightx = Math.min(this.x + this.hw, other.x + other.hw);
        let dx = rightx - leftx;
        let lefty = Math.max(this.y - this.hh, other.y - other.hh);
        let righty = Math.min(this.y + this.hh, other.y + other.hh);
        let dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    }
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    sweep(velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        let centerX = fromPosition.x + velocity.x / 2;
        let centerY = fromPosition.y + velocity.y / 2;
        let minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        let minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    }
    // @override
    clone() {
        return new AABB(this.center.clone(), this.halfSize.clone());
    }
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    toString() {
        return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
    }
}
exports.default = AABB;
},{"../../Utils/MathUtils":119,"../Physics/Hit":33,"../Vec2":43,"./Circle":37,"./Shape":38}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
const Shape_1 = require("./Shape");
/**
 * A Circle
 */
class Circle extends Shape_1.default {
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    constructor(center, radius) {
        super();
        this._center = center ? center : new Vec2_1.default(0, 0);
        this.radius = radius ? radius : 0;
    }
    get center() {
        return this._center;
    }
    set center(center) {
        this._center = center;
    }
    get halfSize() {
        return new Vec2_1.default(this.radius, this.radius);
    }
    get r() {
        return this.radius;
    }
    set r(radius) {
        this.radius = radius;
    }
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    containsPoint(point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    }
    // @override
    getBoundingRect() {
        return new AABB_1.default(this._center.clone(), new Vec2_1.default(this.radius, this.radius));
    }
    // @override
    getBoundingCircle() {
        return this.clone();
    }
    // @override
    overlaps(other) {
        throw new Error("Method not implemented.");
    }
    // @override
    clone() {
        return new Circle(this._center.clone(), this.radius);
    }
    toString() {
        return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
    }
}
exports.default = Circle;
},{"../Vec2":43,"./AABB":36,"./Shape":38}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../Vec2");
const AABB_1 = require("./AABB");
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
class Shape {
    get x() {
        return this.center.x;
    }
    get y() {
        return this.center.y;
    }
    get hw() {
        return this.halfSize.x;
    }
    get hh() {
        return this.halfSize.y;
    }
    get top() {
        return this.y - this.hh;
    }
    get bottom() {
        return this.y + this.hh;
    }
    get left() {
        return this.x - this.hw;
    }
    get right() {
        return this.x + this.hw;
    }
    static getTimeOfCollision(A, velA, B, velB) {
        if (A instanceof AABB_1.default && B instanceof AABB_1.default) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    }
    static getTimeOfCollision_AABB_AABB(A, velA, B, velB) {
        let posSmaller = A.center;
        let posLarger = B.center;
        let sizeSmaller = A.halfSize;
        let sizeLarger = B.halfSize;
        let firstContact = new Vec2_1.default(0, 0);
        let lastContact = new Vec2_1.default(0, 0);
        let collidingX = false;
        let collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            let relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            let temp;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            let relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    }
}
exports.default = Shape;
},{"../Vec2":43,"./AABB":36}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A LIFO stack with items of type T
 */
class Stack {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    constructor(maxElements = 100) {
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    push(item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    }
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    pop() {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    }
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    peek() {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    }
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
    */
    isEmpty() {
        return this.head === -1;
    }
    // @implemented
    clear() {
        this.forEach((item, index) => delete this.stack[index]);
        this.head = -1;
    }
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    size() {
        return this.head + 1;
    }
    // @implemented
    forEach(func) {
        let i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    }
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    toString() {
        let retval = "";
        this.forEach((item, index) => {
            let str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    }
}
exports.default = Stack;
},{}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Emitter_1 = require("../../Events/Emitter");
/**
 * An abstract implementation of a state for a @reference[StateMachine].
 * This class should be extended to allow for custom state behaviors.
 */
class State {
    /**
     * Constructs a new State
     * @param parent The parent StateMachine of this state
     */
    constructor(parent) {
        this.parent = parent;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Tells the state machine that this state has ended, and makes it transition to the new state specified
     * @param stateName The name of the state to transition to
     */
    finished(stateName) {
        this.parent.changeState(stateName);
    }
}
exports.default = State;
},{"../../Events/Emitter":46}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../Stack");
const Map_1 = require("../Map");
const Receiver_1 = require("../../Events/Receiver");
const Emitter_1 = require("../../Events/Emitter");
/**
 * An implementation of a Push Down Automata State machine. States can also be hierarchical
 * for more flexibility, as described in @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/state.html).
 */
class StateMachine {
    /**
     * Creates a new StateMachine
     */
    constructor() {
        this.stack = new Stack_1.default();
        this.stateMap = new Map_1.default();
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.emitEventOnStateChange = false;
    }
    /**
     * Sets the activity state of this state machine
     * @param flag True if you want to set this machine running, false otherwise
     */
    setActive(flag) {
        this.active = flag;
    }
    /**
     * Makes this state machine emit an event any time its state changes
     * @param stateChangeEventName The name of the event to emit
     */
    setEmitEventOnStateChange(stateChangeEventName) {
        this.emitEventOnStateChange = true;
        this.stateChangeEventName = stateChangeEventName;
    }
    /**
     * Stops this state machine from emitting events on state change.
     */
    cancelEmitEventOnStateChange() {
        this.emitEventOnStateChange = false;
    }
    /**
     * Initializes this state machine with an initial state and sets it running
     * @param initialState The name of initial state of the state machine
     */
    initialize(initialState, options = {}) {
        this.stack.push(this.stateMap.get(initialState));
        this.currentState = this.stack.peek();
        this.currentState.onEnter(options);
        this.setActive(true);
    }
    /**
     * Adds a state to this state machine
     * @param stateName The name of the state to add
     * @param state The state to add
     */
    addState(stateName, state) {
        this.stateMap.add(stateName, state);
    }
    /**
     * Changes the state of this state machine to the provided string
     * @param state The string name of the state to change to
     */
    changeState(state) {
        // Exit the current state
        let options = this.currentState.onExit();
        // Make sure the correct state is at the top of the stack
        if (state === "previous") {
            // Pop the current state off the stack
            this.stack.pop();
        }
        else {
            // Retrieve the new state from the statemap and put it at the top of the stack
            this.stack.pop();
            this.stack.push(this.stateMap.get(state));
        }
        // Retreive the new state from the stack
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
        }
        // Enter the new state
        this.currentState.onEnter(options);
    }
    /**
     * Handles input. This happens at the very beginning of this state machine's update cycle.
     * @param event The game event to process
     */
    handleEvent(event) {
        if (this.active) {
            this.currentState.handleInput(event);
        }
    }
    // @implemented
    update(deltaT) {
        // Distribute events
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            this.handleEvent(event);
        }
        // Delegate the update to the current state
        this.currentState.update(deltaT);
    }
}
exports.default = StateMachine;
},{"../../Events/Emitter":46,"../../Events/Receiver":50,"../Map":30,"../Stack":39}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../Vec2");
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
class Tileset {
    // TODO: Change this to be more general and work with other tileset formats
    constructor(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    initFromTiledData(tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1.default(tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1.default(tiledData.imagewidth, tiledData.imageheight);
    }
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    getImageKey() {
        return this.imageKey;
    }
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    getImageOffsetForTile(tileIndex) {
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        return new Vec2_1.default(left, top);
    }
    /**
     * Gets the start index
     * @returns The start index
     */
    getStartIndex() {
        return this.startIndex;
    }
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    getTileSize() {
        return this.tileSize;
    }
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    getNumRows() {
        return this.numRows;
    }
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    getNumCols() {
        return this.numCols;
    }
    getTileCount() {
        return this.endIndex - this.startIndex + 1;
    }
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    hasTile(tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    }
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    renderTile(ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        let image = ResourceManager_1.default.getInstance().getImage(this.imageKey);
        // Get the true index
        let index = tileIndex - this.startIndex;
        let row = Math.floor(index / this.numCols);
        let col = index % this.numCols;
        let width = this.tileSize.x;
        let height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor((dataIndex % maxCols) * width * scale.x);
        let y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    }
}
exports.default = Tileset;
},{"../../ResourceManager/ResourceManager":100,"../Vec2":43}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A two-dimensional vector (x, y)
 */
class Vec2 {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    constructor(x = 0, y = 0) {
        /**
         * When this vector changes its value, do something
         */
        this.onChange = () => { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    // Expose x and y with getters and setters
    get x() {
        return this.vec[0];
    }
    set x(x) {
        this.vec[0] = x;
        if (this.onChange) {
            this.onChange();
        }
    }
    get y() {
        return this.vec[1];
    }
    set y(y) {
        this.vec[1] = y;
        if (this.onChange) {
            this.onChange();
        }
    }
    static get ZERO() {
        return new Vec2(0, 0);
    }
    static get INF() {
        return new Vec2(Infinity, Infinity);
    }
    static get UP() {
        return new Vec2(0, -1);
    }
    static get DOWN() {
        return new Vec2(0, 1);
    }
    static get LEFT() {
        return new Vec2(-1, 0);
    }
    static get RIGHT() {
        return new Vec2(1, 0);
    }
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    magSq() {
        return this.x * this.x + this.y * this.y;
    }
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    mag() {
        return Math.sqrt(this.magSq());
    }
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    normalize() {
        if (this.x === 0 && this.y === 0)
            return this;
        let mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    }
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    normalized() {
        if (this.isZero()) {
            return this;
        }
        let mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    }
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    zero() {
        return this.set(0, 0);
    }
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    setToAngle(angle, radius = 1) {
        this.x = MathUtils_1.default.floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1.default.floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    }
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    vecTo(other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    }
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    dirTo(other) {
        return this.vecTo(other).normalize();
    }
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    scaleTo(magnitude) {
        return this.normalize().scale(magnitude);
    }
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    scale(factor, yFactor = null) {
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    }
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    scaled(factor, yFactor = null) {
        return this.clone().scale(factor, yFactor);
    }
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    rotateCCW(angle) {
        let cs = Math.cos(angle);
        let sn = Math.sin(angle);
        let tempX = this.x * cs - this.y * sn;
        let tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    }
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    copy(other) {
        return this.set(other.x, other.y);
    }
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    inc(a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    }
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    sub(other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    }
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    mult(other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    }
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    div(other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    }
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    remainder(other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    }
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    distanceSqTo(other) {
        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
    }
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    distanceTo(other) {
        return Math.sqrt(this.distanceSqTo(other));
    }
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    angleToCCW(other) {
        let dot = this.dot(other);
        let det = this.x * other.y - this.y * other.x;
        let angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    }
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    toString() {
        return this.toFixed();
    }
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    toFixed(numDecimalPoints = 1) {
        return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
    }
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    clone() {
        return new Vec2(this.x, this.y);
    }
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    strictEquals(other) {
        return this.x === other.x && this.y === other.y;
    }
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    equals(other) {
        let xEq = Math.abs(this.x - other.x) < 0.0000001;
        let yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    }
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    strictIsZero() {
        return this.x === 0 && this.y === 0;
    }
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    isZero() {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    }
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    setOnChange(f) {
        this.onChange = f;
    }
    toArray() {
        return this.vec;
    }
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    static lerp(a, b, t) {
        return new Vec2(MathUtils_1.default.lerp(a.x, b.x, t), MathUtils_1.default.lerp(a.y, b.y, t));
    }
}
exports.default = Vec2;
Vec2.ZERO_STATIC = new Vec2(0, 0);
},{"../Utils/MathUtils":119}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const Color_1 = require("../Utils/Color");
/**
 * A util class for rendering Debug messages to the canvas.
 */
class Debug {
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    static log(id, ...messages) {
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        let message = messages.map((m) => m.toString()).join(" ");
        this.logMessages.add(id, message);
    }
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    static clearLogItem(id) {
        this.logMessages.delete(id);
    }
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    static setNodes(nodes) {
        this.nodes = nodes;
    }
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    static drawBox(center, halfSize, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    static drawCircle(center, radius, filled, color) {
        let alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            let lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    }
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    static drawRay(from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    }
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    static drawPoint(pos, color) {
        let pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    }
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    static setDefaultTextColor(color) {
        this.defaultTextColor = color;
    }
    /**
     * Performs any necessary setup operations on the Debug canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    static initializeDebugCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1.default(width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    }
    /** Clears the debug canvas */
    static clearCanvas() {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    }
    /** Renders the text and nodes sent to the Debug system */
    static render() {
        this.renderText();
        this.renderNodes();
    }
    /** Renders the text sent to the Debug canvas */
    static renderText() {
        let y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach((key) => {
            this.debugRenderingContext.fillText(this.logMessages.get(key), 10, y);
            y += 30;
        });
    }
    /** Renders the nodes registered with the debug canvas */
    static renderNodes() {
        if (this.nodes) {
            this.nodes.forEach(node => {
                node.debugRender();
            });
        }
    }
}
exports.default = Debug;
/** A map of log messages to display on the screen */
Debug.logMessages = new Map_1.default();
/** The rendering color for text */
Debug.defaultTextColor = Color_1.default.WHITE;
},{"../DataTypes/Map":30,"../DataTypes/Vec2":43,"../Utils/Color":116}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../Utils/Color");
// @ignorePage
class Stats extends Object {
    static initStats() {
        let canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        let clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        let fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        let updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        let queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        let br1 = document.createElement("br");
        let br2 = document.createElement("br");
        let br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = document.getElementById("chart-option");
        let option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        let option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        let option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        let option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        let option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        let optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    }
    static updateFPS(fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    }
    static log(key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    }
    static render() {
        // Display stats
        this.drawCharts();
    }
    static drawCharts() {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        let paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            let param = this.prevfps;
            let color = Color_1.default.BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            let param = this.prevClearTimes;
            let color = Color_1.default.RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            let param = this.prevFillTimes;
            let color = Color_1.default.GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            let param = this.prevUpdateTimes;
            let color = Color_1.default.CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            let param = this.prevQueryTimes;
            let color = Color_1.default.ORANGE.toString();
            this.drawChart(param, color);
        }
    }
    static drawChart(param, color) {
        this.ctx.strokeStyle = Color_1.default.BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        let max = Math.max(...param);
        let prevX = 10;
        let prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (let i = 1; i < param.length; i++) {
            let fps = param[i];
            let x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
            let y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    }
    static updateSGStats() {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime = this.SGClearTimes.reduce((acc, val) => acc + val) / this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime = this.SGFillTimes.reduce((acc, val) => acc + val) / this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime = this.SGUpdateTimes.reduce((acc, val) => acc + val) / this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime = this.SGQueryTimes.reduce((acc, val) => acc + val) / this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
    }
}
exports.default = Stats;
Stats.NUM_POINTS = 60;
Stats.CANVAS_WIDTH = 300;
Stats.CANVAS_HEIGHT = 300;
},{"../Utils/Color":116}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("./EventQueue");
const GameEvent_1 = require("./GameEvent");
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
class Emitter {
    /** Creates a new Emitter */
    constructor() {
        this.eventQueue = EventQueue_1.default.getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    fireEvent(eventType, data = null) {
        this.eventQueue.addEvent(new GameEvent_1.default(eventType, data));
    }
}
exports.default = Emitter;
},{"./EventQueue":47,"./GameEvent":48}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Map_1 = require("../DataTypes/Map");
const GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
class EventQueue {
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
        this.receivers = new Map_1.default();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    static getInstance() {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    }
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    addEvent(event) {
        this.q.enqueue(event);
    }
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    subscribe(receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (let t of type) {
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    }
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    unsubscribe(receiver, ...events) {
        this.receivers.forEach(eventName => {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            let index = this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                this.receivers.get(eventName).splice(index, 1);
            }
        });
    }
    // Associate the receiver and the type
    addListener(receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    }
    update(deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            let event = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event.type)) {
                for (let receiver of this.receivers.get(event.type)) {
                    receiver.receive(event);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (let receiver of this.receivers.get(GameEventType_1.GameEventType.ALL)) {
                    receiver.receive(event);
                }
            }
        }
    }
}
exports.default = EventQueue;
EventQueue.instance = null;
},{"../DataTypes/Map":30,"../DataTypes/Queue":34,"./GameEventType":49}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
class GameEvent {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    constructor(type, data = null) {
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1.default();
        }
        else if (!(data instanceof Map_1.default)) {
            // data is a raw object, unpack
            this.data = new Map_1.default();
            for (let key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    isType(type) {
        return this.type === type;
    }
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    toString() {
        return this.type + ": @" + this.time;
    }
}
exports.default = GameEvent;
},{"../DataTypes/Map":30}],49:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));
},{}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const EventQueue_1 = require("./EventQueue");
/**
 * Receives subscribed events from the EventQueue.
 */
class Receiver {
    /** Creates a new Receiver */
    constructor() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1.default(this.MAX_SIZE);
    }
    destroy() {
        EventQueue_1.default.getInstance().unsubscribe(this);
    }
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    subscribe(eventTypes) {
        EventQueue_1.default.getInstance().subscribe(this, eventTypes);
        this.q.clear();
    }
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    receive(event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    }
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    getNextEvent() {
        return this.q.dequeue();
    }
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    peekNextEvent() {
        return this.q.peekNext();
    }
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    hasNextEvent() {
        return this.q.hasItems();
    }
    /**
     * Ignore all events this frame
     */
    ignoreEvents() {
        this.q.clear();
    }
}
exports.default = Receiver;
},{"../DataTypes/Queue":34,"./EventQueue":47}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Map_1 = require("../DataTypes/Map");
const Vec2_1 = require("../DataTypes/Vec2");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
class Input {
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     */
    static initialize(viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1.default();
        Input.keyJustPressed = new Map_1.default();
        Input.keyPressed = new Map_1.default();
        Input.mousePosition = new Vec2_1.default(0, 0);
        Input.mousePressPosition = new Vec2_1.default(0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1.default();
        // Add all keys to the keymap
        for (let entry in keyMap) {
            let name = keyMap[entry].name;
            let keys = keyMap[entry].keys;
            Input.keyMap.add(name, keys);
        }
        Input.eventQueue = EventQueue_1.default.getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
    }
    static update(deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            let event = Input.receiver.getNextEvent();
            // Handle each event type
            if (event.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event.data.get("position");
            }
            if (event.type === GameEventType_1.GameEventType.KEY_DOWN) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event.type === GameEventType_1.GameEventType.KEY_UP) {
                let key = event.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    }
    static clearKeyPresses() {
        Input.keyJustPressed.forEach((key) => Input.keyJustPressed.set(key, false));
        Input.keyPressed.forEach((key) => Input.keyPressed.set(key, false));
    }
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    static isKeyJustPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    static getKeysJustPressed() {
        if (Input.keysDisabled)
            return [];
        let keys = Array();
        Input.keyJustPressed.forEach(key => {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    }
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    static isKeyPressed(key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    }
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    static changeKeyBinding(inputName, keys) {
        Input.keyMap.set(inputName, keys);
    }
    /**
     * Clears all key bindings
     */
    static clearAllKeyBindings() {
        Input.keyMap.clear();
    }
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    static isJustPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let justPressed = false;
            for (let key of keys) {
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    static isPressed(inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            const keys = Input.keyMap.get(inputName);
            let pressed = false;
            for (let key of keys) {
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    }
    /**
     * Returns whether or not the mouse was newly pressed Input frame
     * @returns True if the mouse was just pressed, false otherwise
     */
    static isMouseJustPressed() {
        return Input.mouseJustPressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether or not the mouse is currently pressed
     * @returns True if the mouse is currently pressed, false otherwise
     */
    static isMousePressed() {
        return Input.mousePressed && !Input.mouseDisabled;
    }
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    static didJustScroll() {
        return Input.justScrolled && !Input.mouseDisabled;
    }
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    static getScrollDirection() {
        return Input.scrollDirection;
    }
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    static getMousePosition() {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    }
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePosition() {
        return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
    }
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    static getMousePressPosition() {
        return Input.mousePressPosition;
    }
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    static getGlobalMousePressPosition() {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    }
    /**
     * Disables all keypress and mouse click inputs
     */
    static disableInput() {
        Input.keysDisabled = true;
        Input.mouseDisabled = true;
    }
    /**
     * Enables all keypress and mouse click inputs
     */
    static enableInput() {
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
    }
}
exports.default = Input;
},{"../DataTypes/Map":30,"../DataTypes/Vec2":43,"../Events/EventQueue":47,"../Events/GameEventType":49,"../Events/Receiver":50}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Vec2_1 = require("../DataTypes/Vec2");
const GameEvent_1 = require("../Events/GameEvent");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
class InputHandler {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    constructor(canvas) {
        this.handleMouseDown = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = (event, canvas) => {
            let pos = this.getMousePosition(event, canvas);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = (event) => {
            let key = this.getKey(event);
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.KEY_UP, { key: key });
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = (event) => {
            let gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.CANVAS_BLUR, {});
            this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = (event) => {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = (event) => {
            event.preventDefault();
            event.stopPropagation();
            let gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1.default(GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1.default.getInstance();
        canvas.onmousedown = (event) => this.handleMouseDown(event, canvas);
        canvas.onmouseup = (event) => this.handleMouseUp(event, canvas);
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = (event) => this.handleMouseMove(event, canvas);
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
    }
    getKey(keyEvent) {
        return keyEvent.key.toLowerCase();
    }
    getMousePosition(mouseEvent, canvas) {
        let rect = canvas.getBoundingClientRect();
        let x = mouseEvent.clientX - rect.left;
        let y = mouseEvent.clientY - rect.top;
        return new Vec2_1.default(x, y);
    }
}
exports.default = InputHandler;
},{"../DataTypes/Vec2":43,"../Events/EventQueue":47,"../Events/GameEvent":48,"../Events/GameEventType":49}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
class EnvironmentInitializer {
    static setup() {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    }
}
exports.default = EnvironmentInitializer;
},{}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameLoop_1 = require("./GameLoop");
const Debug_1 = require("../Debug/Debug");
const Stats_1 = require("../Debug/Stats");
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
class FixedUpdateGameLoop extends GameLoop_1.default {
    constructor() {
        super();
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        this.doFrame = (timestamp) => {
            // If a pause was executed, stop doing the loop.
            if (this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame((t) => this.doFrame(t));
            // If we are trying to render too soon, do nothing.
            if (timestamp < this.lastFrameTime + this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            this.numUpdateSteps = 0;
            let panic = false;
            while (this.frameDelta >= this.updateTimestep) {
                // Do an update
                this._doUpdate(this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                this.frameDelta -= this.updateTimestep;
                // Increment steps and check if we've done too many
                this.numUpdateSteps++;
                if (this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            this._doRender();
            // Wrap up the frame
            this.finishFrame(panic);
        };
        this.maxUpdateFPS = 60;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
        this.frameDelta = 0;
        this.lastFrameTime = 0;
        this.minFrameDelay = 0;
        this.frame = 0;
        this.fps = this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        this.fpsUpdateInterval = 1000;
        this.lastFpsUpdate = 0;
        this.framesSinceLastFpsUpdate = 0;
        this.started = false;
        this.paused = false;
        this.running = false;
        this.numUpdateSteps = 0;
    }
    getFPS() {
        return 0;
    }
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    updateFPS(timestamp) {
        this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1.default.log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1.default.updateFPS(this.fps);
    }
    /**
 * Changes the maximum allowed physics framerate of the game
 * @param initMax The max framerate
 */
    setMaxUpdateFPS(initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    }
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    setMaxFPS(maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    }
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    resetFrameDelta() {
        let oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    }
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    start() {
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame((timestamp) => this.doFirstFrame(timestamp));
        }
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    doFirstFrame(timestamp) {
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame((t) => this.doFrame(t));
    }
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    startFrame(timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    }
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    finishFrame(panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    }
}
exports.default = FixedUpdateGameLoop;
},{"../Debug/Debug":44,"../Debug/Stats":45,"./GameLoop":56}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventQueue_1 = require("../Events/EventQueue");
const Input_1 = require("../Input/Input");
const InputHandler_1 = require("../Input/InputHandler");
const Recorder_1 = require("../Playback/Recorder");
const Debug_1 = require("../Debug/Debug");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Viewport_1 = require("../SceneGraph/Viewport");
const SceneManager_1 = require("../Scene/SceneManager");
const AudioManager_1 = require("../Sound/AudioManager");
const Stats_1 = require("../Debug/Stats");
const CanvasRenderer_1 = require("../Rendering/CanvasRenderer");
const Color_1 = require("../Utils/Color");
const GameOptions_1 = require("./GameOptions");
const FixedUpdateGameLoop_1 = require("./FixedUpdateGameLoop");
const EnvironmentInitializer_1 = require("./EnvironmentInitializer");
const Vec2_1 = require("../DataTypes/Vec2");
const RegistryManager_1 = require("../Registry/RegistryManager");
const WebGLRenderer_1 = require("../Rendering/WebGLRenderer");
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
class Game {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    constructor(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1.default.setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1.default.parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1.default();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = document.getElementById("game-canvas");
        this.DEBUG_CANVAS = document.getElementById("debug-canvas");
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1.default();
        }
        else {
            this.renderingManager = new CanvasRenderer_1.default();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1.default(this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1.default.initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1.default.initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        const canvasSize = new Vec2_1.default(this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1.default(canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1.default.getInstance();
        this.inputHandler = new InputHandler_1.default(this.GAME_CANVAS);
        Input_1.default.initialize(this.viewport, this.gameOptions.inputs);
        this.recorder = new Recorder_1.default();
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.sceneManager = new SceneManager_1.default(this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1.default.getInstance();
    }
    /**
     * Set up the game window that holds the canvases
     */
    initializeGameWindow() {
        const gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    }
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    getSceneManager() {
        return this.sceneManager;
    }
    /**
     * Starts the game
     */
    start(InitialScene, options) {
        // Set the update function of the loop
        this.loop.doUpdate = (deltaT) => this.update(deltaT);
        // Set the render function of the loop
        this.loop.doRender = () => this.render();
        // Preload registry items
        RegistryManager_1.default.preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(() => {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            this.sceneManager.changeToScene(InitialScene, options);
            this.loop.start();
        });
    }
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    update(deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1.default.update(deltaT);
            // Update the recording of the game
            this.recorder.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    }
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    render() {
        try {
            // Clear the canvases
            Debug_1.default.clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1.default.isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug render
            if (this.showDebug) {
                Debug_1.default.render();
            }
            if (this.showStats) {
                Stats_1.default.render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    }
}
exports.default = Game;
},{"../DataTypes/Vec2":43,"../Debug/Debug":44,"../Debug/Stats":45,"../Events/EventQueue":47,"../Input/Input":51,"../Input/InputHandler":52,"../Playback/Recorder":80,"../Registry/RegistryManager":83,"../Rendering/CanvasRenderer":88,"../Rendering/WebGLRenderer":93,"../ResourceManager/ResourceManager":100,"../Scene/SceneManager":111,"../SceneGraph/Viewport":103,"../Sound/AudioManager":113,"../Utils/Color":116,"./EnvironmentInitializer":53,"./FixedUpdateGameLoop":54,"./GameOptions":57}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NullFunc_1 = require("../DataTypes/Functions/NullFunc");
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
class GameLoop {
    constructor() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1.default;
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1.default;
    }
    set doUpdate(update) {
        this._doUpdate = update;
    }
    set doRender(render) {
        this._doRender = render;
    }
}
exports.default = GameLoop;
},{"../DataTypes/Functions/NullFunc":25}],57:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
/** The options for initializing the @reference[GameLoop] */
class GameOptions {
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    static parse(options) {
        let gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    }
}
exports.default = GameOptions;
},{}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const GameNode_1 = require("./GameNode");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
class CanvasNode extends GameNode_1.default {
    constructor() {
        super();
        /** A flag for whether or not the CanvasNode is visible */
        this.visible = true;
        this._size = new Vec2_1.default(0, 0);
        this._size.setOnChange(() => this.sizeChanged());
        this._scale = new Vec2_1.default(1, 1);
        this._scale.setOnChange(() => this.scaleChanged());
        this._boundary = new AABB_1.default();
        this.updateBoundary();
        this._hasCustomShader = false;
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(a) {
        this._alpha = a;
    }
    get size() {
        return this._size;
    }
    set size(size) {
        this._size = size;
        // Enter as a lambda to bind "this"
        this._size.setOnChange(() => this.sizeChanged());
        this.sizeChanged();
    }
    get scale() {
        return this._scale;
    }
    set scale(scale) {
        this._scale = scale;
        // Enter as a lambda to bind "this"
        this._scale.setOnChange(() => this.scaleChanged());
        this.scaleChanged();
    }
    set scaleX(value) {
        this.scale.x = value;
    }
    set scaleY(value) {
        this.scale.y = value;
    }
    get hasCustomShader() {
        return this._hasCustomShader;
    }
    get customShaderKey() {
        return this._customShaderKey;
    }
    // @override
    positionChanged() {
        super.positionChanged();
        this.updateBoundary();
    }
    /** Called if the size vector is changed or replaced. */
    sizeChanged() {
        this.updateBoundary();
    }
    /** Called if the scale vector is changed or replaced */
    scaleChanged() {
        this.updateBoundary();
    }
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    updateBoundary() {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
    }
    get boundary() {
        return this._boundary;
    }
    get sizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.boundary.halfSize.clone().scaled(zoom, zoom);
    }
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    useCustomShader(key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    }
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    contains(x, y) {
        return this._boundary.containsPoint(new Vec2_1.default(x, y));
    }
    // @implemented
    debugRender() {
        Debug_1.default.drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1.default.BLUE);
        super.debugRender();
    }
}
exports.default = CanvasNode;
},{"../DataTypes/Shapes/AABB":36,"../DataTypes/Vec2":43,"../Debug/Debug":44,"../Utils/Color":116,"./GameNode":59}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenableProperties = void 0;
const Vec2_1 = require("../DataTypes/Vec2");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Region_1 = require("../DataTypes/Interfaces/Region");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const TweenController_1 = require("../Rendering/Animations/TweenController");
const Debug_1 = require("../Debug/Debug");
const Color_1 = require("../Utils/Color");
const Circle_1 = require("../DataTypes/Shapes/Circle");
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
class GameNode {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    constructor() {
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1.default(0, 0);
        this._position.setOnChange(() => this.positionChanged());
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tweens = new TweenController_1.default(this);
        this.rotation = 0;
    }
    destroy() {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    }
    /*---------- POSITIONED ----------*/
    get position() {
        return this._position;
    }
    set position(pos) {
        this._position = pos;
        this._position.setOnChange(() => this.positionChanged());
        this.positionChanged();
    }
    get relativePosition() {
        return this.inRelativeCoordinates(this.position);
    }
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    inRelativeCoordinates(point) {
        let origin = this.scene.getViewTranslation(this);
        let zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    }
    /*---------- UNIQUE ----------*/
    get id() {
        return this._id;
    }
    set id(id) {
        // id can only be set once
        if (this._id === undefined) {
            this._id = id;
        }
        else {
            throw "Attempted to assign id to object that already has id.";
        }
    }
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    move(velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    }
    ;
    moveOnPath(speed, path) {
        if (this.frozen)
            return;
        this.path = path;
        let dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    }
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    finishMove() {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    }
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    addPhysics(collisionShape, colliderOffset, isCollidable = true, isStatic = false) {
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = new AABB_1.default();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if (Region_1.isRegion(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1.default.ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    }
    /** Removes this object from the physics system */
    removePhysics() {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1.default.ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1.default.ZERO;
        this.sweptRect = null;
    }
    /** Disables physics movement for this node */
    freeze() {
        this.frozen = true;
    }
    /** Reenables physics movement for this node */
    unfreeze() {
        this.frozen = false;
    }
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    disablePhysics() {
        this.active = false;
    }
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    enablePhysics() {
        this.active = true;
    }
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    setCollisionShape(collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    }
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    setTrigger(group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        let layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn(`Trigger for GameNode ${this.id} not set - group "${group}" was not recognized by the physics manager.`);
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        let index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    }
    ;
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    setGroup(group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    }
    // @implemened
    getLastVelocity() {
        return this._velocity;
    }
    /*---------- ACTOR ----------*/
    get ai() {
        return this._ai;
    }
    set ai(ai) {
        if (!this._ai) {
            // If we haven't been previously had an ai, register us with the ai manager
            this.scene.getAIManager().registerActor(this);
        }
        this._ai = ai;
        this.aiActive = true;
    }
    // @implemented
    addAI(ai, options) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    }
    // @implemented
    setAIActive(active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    }
    /*---------- TWEENABLE PROPERTIES ----------*/
    set positionX(value) {
        this.position.x = value;
    }
    set positionY(value) {
        this.position.y = value;
    }
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
    */
    getScene() {
        return this.scene;
    }
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    setLayer(layer) {
        this.layer = layer;
    }
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
    */
    getLayer() {
        return this.layer;
    }
    /** Called if the position vector is modified or replaced */
    positionChanged() {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position.clone().add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    }
    ;
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    update(deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    }
    // @implemented
    debugRender() {
        // Draw the position of this GameNode
        Debug_1.default.drawPoint(this.relativePosition, Color_1.default.BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1.default.drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1.default.BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            let color = this.isColliding ? Color_1.default.RED : Color_1.default.GREEN;
            if (this.isTrigger) {
                color = Color_1.default.MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1.default) {
                Debug_1.default.drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1.default) {
                Debug_1.default.drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    }
}
exports.default = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));
},{"../DataTypes/Interfaces/Region":29,"../DataTypes/Shapes/AABB":36,"../DataTypes/Shapes/Circle":37,"../DataTypes/Vec2":43,"../Debug/Debug":44,"../Events/Emitter":46,"../Events/Receiver":50,"../Rendering/Animations/TweenController":86,"../Utils/Color":116}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
class Graphic extends CanvasNode_1.default {
    constructor() {
        super();
        this.color = Color_1.default.RED;
    }
    get alpha() {
        return this.color.a;
    }
    set alpha(a) {
        this.color.a = a;
    }
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    setColor(color) {
        this.color = color;
    }
}
exports.default = Graphic;
},{"../Utils/Color":116,"./CanvasNode":58}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));
},{}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
class Line extends Graphic_1.default {
    constructor(start, end) {
        super();
        this.start = start;
        this.end = end;
        this.thickness = 2;
        // Does this really have a meaning for lines?
        this.size.set(5, 5);
    }
    set start(pos) {
        this.position = pos;
    }
    get start() {
        return this.position;
    }
    set end(pos) {
        this._end = pos;
    }
    get end() {
        return this._end;
    }
}
exports.default = Line;
},{"../Graphic":60}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
/** A basic point to be drawn on the screen. */
class Point extends Graphic_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.size.set(5, 5);
    }
}
exports.default = Point;
},{"../Graphic":60}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Graphic");
const Color_1 = require("../../Utils/Color");
/** A basic rectangle to be drawn on the screen. */
class Rect extends Graphic_1.default {
    constructor(position, size) {
        super();
        this.position = position;
        this.size = size;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.borderWidth = 0;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    setBorderColor(color) {
        this.borderColor = color;
    }
    // @deprecated
    getBorderColor() {
        return this.borderColor;
    }
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    setBorderWidth(width) {
        this.borderWidth = width;
    }
    getBorderWidth() {
        return this.borderWidth;
    }
}
exports.default = Rect;
},{"../../Utils/Color":116,"../Graphic":60}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("./Sprite");
const AnimationManager_1 = require("../../Rendering/Animations/AnimationManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/** An sprite with specified animation frames. */
class AnimatedSprite extends Sprite_1.default {
    constructor(spritesheet) {
        super(spritesheet.name);
        this.numCols = spritesheet.columns;
        this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        this.animation = new AnimationManager_1.default(this);
        // Add the animations to the animated sprite
        for (let animation of spritesheet.animations) {
            this.animation.add(animation.name, animation);
        }
    }
    get cols() {
        return this.numCols;
    }
    get rows() {
        return this.numRows;
    }
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    getAnimationOffset(index) {
        return new Vec2_1.default((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
    }
}
exports.default = AnimatedSprite;
},{"../../DataTypes/Vec2":43,"../../Rendering/Animations/AnimationManager":84,"./Sprite":66}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("../CanvasNode");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * The representation of a sprite - an in-game image
 */
class Sprite extends CanvasNode_1.default {
    constructor(imageId) {
        super();
        this.imageId = imageId;
        let image = ResourceManager_1.default.getInstance().getImage(this.imageId);
        this.size = new Vec2_1.default(image.width, image.height);
        this.imageOffset = Vec2_1.default.ZERO;
        this.invertX = false;
        this.invertY = false;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    setImageOffset(offset) {
        this.imageOffset = offset;
    }
}
exports.default = Sprite;
},{"../../DataTypes/Vec2":43,"../../ResourceManager/ResourceManager":100,"../CanvasNode":58}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const CanvasNode_1 = require("./CanvasNode");
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
class Tilemap extends CanvasNode_1.default {
    // TODO: Make this no longer be specific to Tiled
    constructor(tilemapData, layer, tilesets, scale) {
        super();
        this.tilesets = tilesets;
        this.tileSize = new Vec2_1.default(0, 0);
        this.name = layer.name;
        let tilecount = 0;
        for (let tileset of tilesets) {
            tilecount += tileset.getTileCount() + 1;
        }
        this.collisionMap = new Array(tilecount);
        for (let i = 0; i < this.collisionMap.length; i++) {
            this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        this.parseTilemapData(tilemapData, layer);
        this.scale.set(scale.x, scale.y);
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    getTilesets() {
        return this.tilesets;
    }
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    getTileSize() {
        return this.tileSize.scaled(this.scale.x, this.scale.y);
    }
    /**
     * Gets the tile size taking zoom into account
     * @returns The tile size with zoom
    */
    getTileSizeWithZoom() {
        let zoom = this.scene.getViewScale();
        return this.getTileSize().scale(zoom);
    }
    /**
     * Adds this tilemap to the physics system
    */
    addPhysics() {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    }
}
exports.default = Tilemap;
},{"../DataTypes/Vec2":43,"./CanvasNode":58}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Tilemap_1 = require("../Tilemap");
const Vec2_1 = require("../../DataTypes/Vec2");
const Debug_1 = require("../../Debug/Debug");
const Color_1 = require("../../Utils/Color");
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
class OrthogonalTilemap extends Tilemap_1.default {
    // @override
    parseTilemapData(tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (let item of layer.properties) {
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (let i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    }
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    getDimensions() {
        return new Vec2_1.default(this.numCols, this.numRows);
    }
    /**
     * Gets the data value of the tile at the specified world position
     * @param worldCoords The coordinates in world space
     * @returns The data value of the tile
     */
    getTileAtWorldPosition(worldCoords) {
        let localCoords = this.getColRowAt(worldCoords);
        return this.getTileAtRowCol(localCoords);
    }
    /**
     * Get the tile at the specified row and column
     * @param rowCol The coordinates in tilemap space
     * @returns The data value of the tile
     */
    getTileAtRowCol(rowCol) {
        if (rowCol.x < 0 || rowCol.x >= this.numCols || rowCol.y < 0 || rowCol.y >= this.numRows) {
            return -1;
        }
        return this.data[rowCol.y * this.numCols + rowCol.x];
    }
    /**
     * Gets the world position of the tile at the specified index
     * @param index The index of the tile
     * @returns A Vec2 containing the world position of the tile
     */
    getTileWorldPosition(index) {
        // Get the local position
        let col = index % this.numCols;
        let row = Math.floor(index / this.numCols);
        // Get the world position
        let x = col * this.tileSize.x;
        let y = row * this.tileSize.y;
        return new Vec2_1.default(x, y);
    }
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    getTile(index) {
        return this.data[index];
    }
    // @override
    setTile(index, type) {
        this.data[index] = type;
    }
    /**
     * Sets the tile at the specified row and column
     * @param rowCol The position of the tile in tilemap space
     * @param type The new data value of the tile
     */
    setTileAtRowCol(rowCol, type) {
        let index = rowCol.y * this.numCols + rowCol.x;
        this.setTile(index, type);
    }
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param indexOrCol The index of the tile or the column it is in
     * @param row The row the tile is in
     * @returns A flag representing whether or not the tile is collidable.
     */
    isTileCollidable(indexOrCol, row) {
        // The value of the tile
        let tile = 0;
        if (row) {
            // We have a column and a row
            tile = this.getTileAtRowCol(new Vec2_1.default(indexOrCol, row));
            if (tile < 0) {
                return false;
            }
        }
        else {
            if (indexOrCol < 0 || indexOrCol >= this.data.length) {
                // Tiles that don't exist aren't collidable
                return false;
            }
            // We have an index
            tile = this.getTile(indexOrCol);
        }
        return this.collisionMap[tile];
    }
    /**
     * Takes in world coordinates and returns the row and column of the tile at that position
     * @param worldCoords The coordinates of the potential tile in world space
     * @returns A Vec2 containing the coordinates of the potential tile in tilemap space
     */
    getColRowAt(worldCoords) {
        let col = Math.floor(worldCoords.x / this.tileSize.x / this.scale.x);
        let row = Math.floor(worldCoords.y / this.tileSize.y / this.scale.y);
        return new Vec2_1.default(col, row);
    }
    // @override
    update(deltaT) { }
    // @override
    debugRender() {
        // Half of the tile size
        let zoomedHalfTileSize = this.getTileSizeWithZoom().scaled(0.5);
        let halfTileSize = this.getTileSize().scaled(0.5);
        // The center of the top left tile
        let topLeft = this.position.clone().sub(this.size.scaled(0.5));
        // A vec to store the center
        let center = Vec2_1.default.ZERO;
        for (let col = 0; col < this.numCols; col++) {
            // Calculate the x-position
            center.x = topLeft.x + col * 2 * halfTileSize.x + halfTileSize.x;
            for (let row = 0; row < this.numRows; row++) {
                if (this.isCollidable && this.isTileCollidable(col, row)) {
                    // Calculate the y-position
                    center.y = topLeft.y + row * 2 * halfTileSize.y + halfTileSize.y;
                    // Draw a box for this tile
                    Debug_1.default.drawBox(this.inRelativeCoordinates(center), zoomedHalfTileSize, false, Color_1.default.BLUE);
                }
            }
        }
    }
}
exports.default = OrthogonalTilemap;
},{"../../DataTypes/Vec2":43,"../../Debug/Debug":44,"../../Utils/Color":116,"../Tilemap":67}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNode_1 = require("./CanvasNode");
const Color_1 = require("../Utils/Color");
const Vec2_1 = require("../DataTypes/Vec2");
const Input_1 = require("../Input/Input");
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
class UIElement extends CanvasNode_1.default {
    constructor(position) {
        super();
        this.position = position;
        this.backgroundColor = new Color_1.default(0, 0, 0, 0);
        this.borderColor = new Color_1.default(0, 0, 0, 0);
        this.borderRadius = 5;
        this.borderWidth = 1;
        this.padding = Vec2_1.default.ZERO;
        this.onClick = null;
        this.onClickEventId = null;
        this.onRelease = null;
        this.onReleaseEventId = null;
        this.onEnter = null;
        this.onEnterEventId = null;
        this.onLeave = null;
        this.onLeaveEventId = null;
        this.isClicked = false;
        this.isEntered = false;
    }
    // @deprecated
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    // @deprecated
    setPadding(padding) {
        this.padding.copy(padding);
    }
    update(deltaT) {
        super.update(deltaT);
        // See of this object was just clicked
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    let data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1.default.isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        let mousePos = Input_1.default.getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                let data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    }
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    calculateBackgroundColor() {
        return this.backgroundColor;
    }
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    calculateBorderColor() {
        return this.borderColor;
    }
}
exports.default = UIElement;
},{"../DataTypes/Vec2":43,"../Input/Input":51,"../Utils/Color":116,"./CanvasNode":58}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Label_1 = require("./Label");
const Color_1 = require("../../Utils/Color");
/** A clickable button UIElement */
class Button extends Label_1.default {
    constructor(position, text) {
        super(position, text);
        this.backgroundColor = new Color_1.default(150, 75, 203);
        this.borderColor = new Color_1.default(41, 46, 30);
        this.textColor = new Color_1.default(255, 255, 255);
    }
    // @override
    calculateBackgroundColor() {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    }
}
exports.default = Button;
},{"../../Utils/Color":116,"./Label":71}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAlign = exports.VAlign = void 0;
const Vec2_1 = require("../../DataTypes/Vec2");
const Color_1 = require("../../Utils/Color");
const UIElement_1 = require("../UIElement");
/** A basic text-containing label */
class Label extends UIElement_1.default {
    constructor(position, text) {
        super(position);
        this.text = text;
        this.textColor = new Color_1.default(0, 0, 0, 1);
        this.font = "Arial";
        this.fontSize = 30;
        this.hAlign = "center";
        this.vAlign = "center";
        this.sizeAssigned = false;
    }
    // @deprecated
    setText(text) {
        this.text = text;
    }
    // @deprecated
    setTextColor(color) {
        this.textColor = color;
    }
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    getFontString() {
        return this.fontSize + "px " + this.font;
    }
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    calculateTextColor() {
        return this.textColor.toStringRGBA();
    }
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    calculateTextWidth(ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    }
    setHAlign(align) {
        this.hAlign = align;
    }
    setVAlign(align) {
        this.vAlign = align;
    }
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    calculateTextOffset(ctx) {
        let textWidth = this.calculateTextWidth(ctx);
        let offset = new Vec2_1.default(0, 0);
        let hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    }
    sizeChanged() {
        super.sizeChanged();
        this.sizeAssigned = true;
    }
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    autoSize(ctx) {
        let width = this.calculateTextWidth(ctx);
        let height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    }
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    handleInitialSizing(ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    }
    /** On the next render, size this element to it's current text using its current font size */
    sizeToText() {
        this.sizeAssigned = false;
    }
}
exports.default = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));
},{"../../DataTypes/Vec2":43,"../../Utils/Color":116,"../UIElement":69}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const Input_1 = require("../../Input/Input");
const Color_1 = require("../../Utils/Color");
const MathUtils_1 = require("../../Utils/MathUtils");
const UIElement_1 = require("../UIElement");
/** A slider UIElement */
class Slider extends UIElement_1.default {
    constructor(position, initValue) {
        super(position);
        this.value = initValue;
        this.nibColor = Color_1.default.RED;
        this.sliderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.TRANSPARENT;
        this.borderColor = Color_1.default.TRANSPARENT;
        this.nibSize = new Vec2_1.default(10, 20);
        // Set a default size
        this.size.set(200, 20);
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    getValue() {
        return this.value;
    }
    /** A method called in response to the value changing */
    valueChanged() {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
        }
    }
    update(deltaT) {
        super.update(deltaT);
        if (this.isClicked) {
            let val = MathUtils_1.default.invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1.default.getMousePosition().x);
            this.value = MathUtils_1.default.clamp01(val);
            this.valueChanged();
        }
    }
}
exports.default = Slider;
},{"../../DataTypes/Vec2":43,"../../Input/Input":51,"../../Utils/Color":116,"../../Utils/MathUtils":119,"../UIElement":69}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Color_1 = require("../../Utils/Color");
const Label_1 = require("./Label");
const Input_1 = require("../../Input/Input");
/** A text input UIElement */
class TextInput extends Label_1.default {
    constructor(position) {
        super(position, "");
        this.focused = false;
        this.cursorCounter = 0;
        // Give a default size to the x only
        this.size.set(200, this.fontSize);
        this.hAlign = "left";
        this.borderColor = Color_1.default.BLACK;
        this.backgroundColor = Color_1.default.WHITE;
    }
    update(deltaT) {
        super.update(deltaT);
        if (Input_1.default.isMouseJustPressed()) {
            let clickPos = Input_1.default.getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            let keys = Input_1.default.getKeysJustPressed();
            let nums = "1234567890";
            let specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            let letters = "qwertyuiopasdfghjklzxcvbnm";
            let mask = nums + specialChars + letters;
            keys = keys.filter(key => mask.includes(key));
            let shiftPressed = Input_1.default.isKeyPressed("shift");
            let backspacePressed = Input_1.default.isKeyJustPressed("backspace");
            let spacePressed = Input_1.default.isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    }
}
exports.default = TextInput;
},{"../../Input/Input":51,"../../Utils/Color":116,"./Label":71}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));
},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
class NavigationManager {
    constructor() {
        this.navigableEntities = new Map_1.default();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    addNavigableEntity(navName, nav) {
        this.navigableEntities.add(navName, nav);
    }
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    getPath(navName, fromPosition, toPosition) {
        let nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone());
    }
}
exports.default = NavigationManager;
},{"../DataTypes/Map":30}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
class NavigationPath {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    constructor(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1.default.ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    isDone() {
        return this.path.isEmpty();
    }
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    getMoveDirection(node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    }
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    handlePathProgress(node) {
        if (node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    }
    toString() {
        return this.path.toString();
    }
}
exports.default = NavigationPath;
},{"../DataTypes/Vec2":43}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Stack_1 = require("../DataTypes/Stack");
const GraphUtils_1 = require("../Utils/GraphUtils");
const NavigationPath_1 = require("./NavigationPath");
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
class Navmesh {
    /**
     * Creates a new Navmesh from the points in the speecified graph
     * @param graph The graph to construct a navmesh from
     */
    constructor(graph) {
        this.graph = graph;
    }
    // @implemented
    getNavigationPath(fromPosition, toPosition) {
        let start = this.getClosestNode(fromPosition);
        let end = this.getClosestNode(toPosition);
        let parent = GraphUtils_1.default.djikstra(this.graph, start);
        let pathStack = new Stack_1.default(this.graph.numVertices);
        // Push the final position and the final position in the graph
        pathStack.push(toPosition.clone());
        pathStack.push(this.graph.positions[end]);
        // Add all parents along the path
        let i = end;
        while (parent[i] !== -1) {
            pathStack.push(this.graph.positions[parent[i]]);
            i = parent[i];
        }
        return new NavigationPath_1.default(pathStack);
    }
    /**
     * Gets the closest node in this Navmesh to the specified position
     * @param position The position to query
     * @returns The index of the closest node in the Navmesh to the position
     */
    getClosestNode(position) {
        let n = this.graph.numVertices;
        let i = 1;
        let index = 0;
        let dist = position.distanceSqTo(this.graph.positions[0]);
        while (i < n) {
            let d = position.distanceSqTo(this.graph.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    }
}
exports.default = Navmesh;
},{"../DataTypes/Stack":39,"../Utils/GraphUtils":118,"./NavigationPath":76}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PhysicsManager_1 = require("./PhysicsManager");
const Vec2_1 = require("../DataTypes/Vec2");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const AreaCollision_1 = require("../DataTypes/Physics/AreaCollision");
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
class BasicPhysicsManager extends PhysicsManager_1.default {
    constructor(options) {
        super();
        this.staticNodes = new Array();
        this.dynamicNodes = new Array();
        this.tilemaps = new Array();
        this.collisionMasks = new Array(32);
        // Parse options
        this.parseOptions(options);
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    parseOptions(options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (let i = 0; i < options.groupNames.length; i++) {
                let group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                let collisionMask = 0;
                for (let j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    }
    // @override
    registerObject(node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    }
    // @override
    deregisterObject(node) {
        console.log("Deregistering physics object");
        if (node.isStatic) {
            // Remove the node from the static list
            const index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            const index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    }
    // @override
    registerTilemap(tilemap) {
        this.tilemaps.push(tilemap);
    }
    // @override
    deregisterTilemap(tilemap) {
        const index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    }
    // @override
    update(deltaT) {
        for (let node of this.dynamicNodes) {
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            let overlaps = new Array();
            let groupIndex = Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (let other of this.staticNodes) {
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (let other of this.dynamicNodes) {
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                let collider = other.collisionShape.getBoundingRect();
                let area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1.default(area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (let tilemap of this.tilemaps) {
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1.default) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort((a, b) => b.area - a.area);
            // Keep track of hits to use later
            let hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (let overlap of overlaps) {
                // Ignore nodes we don't interact with
                if (this.collisionMasks[groupIndex] !== undefined && (this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                const point = node.collisionShape.center;
                const delta = node._velocity;
                const padding = node.collisionShape.halfSize;
                const otherAABB = overlap.collider;
                const hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    let tnearx = hit.nearTimes.x;
                    let tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (let overlap of overlaps) {
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group)) {
                    // Get the bit that this group is represented by
                    let index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if ((this.collisionMasks[groupIndex] & overlap.other.group) === 0)
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    let collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    }
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    collideWithOrthogonalTilemap(node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        let min = new Vec2_1.default(node.sweptRect.left, node.sweptRect.top);
        let max = new Vec2_1.default(node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        let minIndex = tilemap.getColRowAt(min);
        let maxIndex = tilemap.getColRowAt(max);
        let tileSize = tilemap.getTileSize();
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (let col = minIndex.x; col <= maxIndex.x; col++) {
            for (let row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    let tilePos = new Vec2_1.default(col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a new collider for this tile
                    let collider = new AABB_1.default(tilePos, tileSize.scaled(1 / 2));
                    // Calculate collision area between the node and the tile
                    let area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1.default(area, collider, tilemap, "Tilemap", new Vec2_1.default(col, row)));
                    }
                }
            }
        }
    }
}
exports.default = BasicPhysicsManager;
},{"../DataTypes/Physics/AreaCollision":32,"../DataTypes/Shapes/AABB":36,"../DataTypes/Vec2":43,"../Nodes/Tilemaps/OrthogonalTilemap":68,"./PhysicsManager":79}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const Map_1 = require("../DataTypes/Map");
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
class PhysicsManager {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1.default();
        this.groupNames = new Array();
    }
    destroy() {
        this.receiver.destroy();
    }
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    setGroup(node, group) {
        node.group = this.groupMap.get(group);
    }
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    getGroupNumber(group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    }
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    getGroupNames(groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            let g = 1;
            let names = [];
            for (let i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    }
}
exports.default = PhysicsManager;
/** The default group name */
PhysicsManager.DEFAULT_GROUP = "Default";
},{"../DataTypes/Map":30,"../Events/Emitter":46,"../Events/Receiver":50}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../DataTypes/Queue");
const Receiver_1 = require("../Events/Receiver");
const EventQueue_1 = require("../Events/EventQueue");
const GameEventType_1 = require("../Events/GameEventType");
// @ignorePage
class Recorder {
    constructor() {
        this.receiver = new Receiver_1.default();
        this.log = new Queue_1.default(1000);
        this.recording = false;
        this.playing = false;
        this.frame = 0;
        this.eventQueue = EventQueue_1.default.getInstance();
        this.eventQueue.subscribe(this.receiver, "all");
    }
    update(deltaT) {
        if (this.recording) {
            this.frame += 1;
        }
        if (this.playing) {
            // If playing, ignore events, just feed the record to the event queue
            this.receiver.ignoreEvents();
            /*
                While there is a next item, and while it should occur in this frame,
                send the event. i.e., while current_frame * current_delta_t is greater
                than recorded_frame * recorded_delta_t
            */
            while (this.log.hasItems()
                && this.log.peekNext().frame * this.log.peekNext().delta < this.frame * deltaT) {
                let event = this.log.dequeue().event;
                console.log(event);
                this.eventQueue.addEvent(event);
            }
            if (!this.log.hasItems()) {
                this.playing = false;
            }
            this.frame += 1;
        }
        else {
            // If not playing, handle events
            while (this.receiver.hasNextEvent()) {
                let event = this.receiver.getNextEvent();
                if (event.type === GameEventType_1.GameEventType.STOP_RECORDING) {
                    this.recording = false;
                }
                if (this.recording) {
                    this.log.enqueue(new LogItem(this.frame, deltaT, event));
                }
                if (event.type === GameEventType_1.GameEventType.START_RECORDING) {
                    this.log.clear();
                    this.recording = true;
                    this.frame = 0;
                }
                if (event.type === GameEventType_1.GameEventType.PLAY_RECORDING) {
                    this.frame = 0;
                    this.recording = false;
                    this.playing = true;
                }
            }
        }
    }
}
exports.default = Recorder;
class LogItem {
    constructor(frame, deltaT, event) {
        this.frame = frame;
        this.delta = deltaT;
        this.event = event;
    }
}
},{"../DataTypes/Queue":34,"../Events/EventQueue":47,"../Events/GameEventType":49,"../Events/Receiver":50}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
class Registry extends Map_1.default {
}
exports.default = Registry;
},{"../../DataTypes/Map":30}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LabelShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType");
const PointShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType");
const RectShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType");
const SpriteShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Registry_1 = require("./Registry");
/**
 * A registry that handles shaders
 */
class ShaderRegistry extends Registry_1.default {
    constructor() {
        super(...arguments);
        this.registryItems = new Array();
    }
    /**
     * Preloads all built-in shaders
     */
    preload() {
        // Get the resourceManager and queue all built-in shaders for preloading
        const rm = ResourceManager_1.default.getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1.default, "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1.default, "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1.default, "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1.default, "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (let item of this.registryItems) {
            const shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    }
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    registerAndPreloadItem(key, constr, vshaderLocation, fshaderLocation) {
        let shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    }
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    registerItem(key, constr) {
        let registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    }
}
exports.default = ShaderRegistry;
// Shader names
ShaderRegistry.POINT_SHADER = "point";
ShaderRegistry.RECT_SHADER = "rect";
ShaderRegistry.SPRITE_SHADER = "sprite";
ShaderRegistry.LABEL_SHADER = "label";
class ShaderRegistryItem {
}
class ShaderPreload {
}
},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":95,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":96,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":98,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":99,"../../ResourceManager/ResourceManager":100,"./Registry":81}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const ShaderRegistry_1 = require("./Registries/ShaderRegistry");
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
class RegistryManager {
    static preload() {
        this.shaders.preload();
        this.registries.forEach((key) => this.registries.get(key).preload());
    }
    static addCustomRegistry(name, registry) {
        this.registries.add(name, registry);
    }
    static getRegistry(key) {
        return this.registries.get(key);
    }
}
exports.default = RegistryManager;
RegistryManager.shaders = new ShaderRegistry_1.default();
/** Additional custom registries to add to the registry manager */
RegistryManager.registries = new Map_1.default();
},{"../DataTypes/Map":30,"./Registries/ShaderRegistry":82}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const Emitter_1 = require("../../Events/Emitter");
const AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
class AnimationManager {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    constructor(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1.default();
        this.onEndEvent = null;
        this.emitter = new Emitter_1.default();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    add(key, animation) {
        this.animations.add(key, animation);
    }
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    getIndex() {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            console.warn(`Animation index was requested, but the current animation: ${this.currentAnimation} was invalid`);
            return 0;
        }
    }
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    isPlaying(key) {
        return this.currentAnimation === key && this.animationState === AnimationTypes_1.AnimationState.PLAYING;
    }
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    getIndexAndAdvanceAnimation() {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            let currentAnimation = this.animations.get(this.currentAnimation);
            let index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >= currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn(`Animation index and advance was requested, but the current animation (${this.currentAnimation}) in node with id: ${this.owner.id} was invalid`);
            return 0;
        }
    }
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    endCurrentAnimation() {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, { owner: this.owner.id, animation: this.currentAnimation });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    }
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    playIfNotAlready(animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    }
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    play(animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    }
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    queue(animation, loop = false, onEnd) {
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    }
    /** Pauses the current animation */
    pause() {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    }
    /** Resumes the current animation if possible */
    resume() {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /** Stops the current animation. The animation cannot be resumed after this. */
    stop() {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    }
}
exports.default = AnimationManager;
},{"../../DataTypes/Map":30,"../../Events/Emitter":46,"./AnimationTypes":85}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
class AnimationData {
    constructor() {
        this.repeat = false;
    }
}
exports.AnimationData = AnimationData;
class TweenEffect {
}
exports.TweenEffect = TweenEffect;
class TweenData {
}
exports.TweenData = TweenData;
},{}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../../DataTypes/Map");
const AnimationTypes_1 = require("./AnimationTypes");
const EaseFunctions_1 = require("../../Utils/EaseFunctions");
const MathUtils_1 = require("../../Utils/MathUtils");
const TweenManager_1 = require("./TweenManager");
const Emitter_1 = require("../../Events/Emitter");
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
class TweenController {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    constructor(owner) {
        this.owner = owner;
        this.tweens = new Map_1.default();
        this.emitter = new Emitter_1.default();
        // Give ourselves to the TweenManager
        TweenManager_1.default.getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    destroy() {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1.default.getInstance().deregisterTweenController(this);
    }
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    add(key, tween) {
        let typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    }
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    play(key, loop) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn(`Tried to play tween "${key}" on node with id ${this.owner.id}, but no such tween exists`);
        }
    }
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    pause(key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    }
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    resume(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    }
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    stop(key) {
        if (this.tweens.has(key)) {
            let tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (let effect of tween.effects) {
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    }
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    end(key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            let tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                this.emitter.fireEvent(tween.onEnd, { key: key, node: this.owner.id });
            }
        }
    }
    /**
     * Stops all currently playing tweens
     */
    stopAll() {
        this.tweens.forEach(key => this.stop(key));
    }
    update(deltaT) {
        this.tweens.forEach(key => {
            let tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1.default.clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1.default.clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (let effect of tween.effects) {
                        // Get the value from the ease function that corresponds to our progress
                        let ease = EaseFunctions_1.default[effect.ease](tween.progress);
                        // Use the value to lerp the property
                        let value = MathUtils_1.default.lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        this.owner[effect.property] = value;
                    }
                }
            }
        });
    }
}
exports.default = TweenController;
},{"../../DataTypes/Map":30,"../../Events/Emitter":46,"../../Utils/EaseFunctions":117,"../../Utils/MathUtils":119,"./AnimationTypes":85,"./TweenManager":87}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TweenManager {
    constructor() {
        this.tweenControllers = new Array();
    }
    static getInstance() {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    }
    registerTweenController(controller) {
        this.tweenControllers.push(controller);
    }
    deregisterTweenController(controller) {
        let index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    }
    clearTweenControllers() {
        this.tweenControllers = new Array();
    }
    update(deltaT) {
        for (let tweenController of this.tweenControllers) {
            tweenController.update(deltaT);
        }
    }
}
exports.default = TweenManager;
TweenManager.instance = null;
},{}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
const UIElement_1 = require("../Nodes/UIElement");
const GraphicRenderer_1 = require("./CanvasRendering/GraphicRenderer");
const RenderingManager_1 = require("./RenderingManager");
const TilemapRenderer_1 = require("./CanvasRendering/TilemapRenderer");
const UIElementRenderer_1 = require("./CanvasRendering/UIElementRenderer");
const Label_1 = require("../Nodes/UIElements/Label");
const Button_1 = require("../Nodes/UIElements/Button");
const Slider_1 = require("../Nodes/UIElements/Slider");
const TextInput_1 = require("../Nodes/UIElements/TextInput");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Vec2_1 = require("../DataTypes/Vec2");
const Line_1 = require("../Nodes/Graphics/Line");
const Debug_1 = require("../Debug/Debug");
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
class CanvasRenderer extends RenderingManager_1.default {
    constructor() {
        super();
    }
    // @override
    setScene(scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    }
    // @override
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1.default(width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1.default(this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1.default(this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1.default(this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    }
    // @override
    render(visibleSet, tilemaps, uiLayers) {
        // Sort by depth, then by visible set by y-value
        visibleSet.sort((a, b) => {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return (a.boundary.bottom) - (b.boundary.bottom);
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        let tilemapIndex = 0;
        let tilemapLength = tilemaps.length;
        let visibleSetIndex = 0;
        let visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                let node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        let sortedUILayers = new Array();
        uiLayers.forEach(key => sortedUILayers.push(uiLayers.get(key)));
        sortedUILayers = sortedUILayers.sort((ui1, ui2) => ui1.getDepth() - ui2.getDepth());
        sortedUILayers.forEach(uiLayer => {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(node => {
                    if (node.visible) {
                        this.renderNode(node);
                    }
                });
        });
    }
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        let xScale = 1;
        let yScale = 1;
        if (node instanceof Sprite_1.default) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        let globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1.default) {
            Debug_1.default.log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1.default) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1.default) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    // @override
    renderSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world
                image draw start -> x, y
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderAnimatedSprite(sprite) {
        // Get the image from the resource manager
        let image = this.resourceManager.getImage(sprite.imageId);
        let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        let animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world (given we moved)
                image draw start -> -w/2, -h/2
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    }
    // @override
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1.default) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1.default) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    }
    // @override
    renderTilemap(tilemap) {
        if (tilemap instanceof OrthogonalTilemap_1.default) {
            this.tilemapRenderer.renderOrthogonalTilemap(tilemap);
        }
    }
    // @override
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1.default) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1.default) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1.default) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    }
    clear(clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
}
exports.default = CanvasRenderer;
},{"../DataTypes/Vec2":43,"../Debug/Debug":44,"../Nodes/Graphic":60,"../Nodes/Graphics/Line":62,"../Nodes/Graphics/Point":63,"../Nodes/Graphics/Rect":64,"../Nodes/Sprites/AnimatedSprite":65,"../Nodes/Sprites/Sprite":66,"../Nodes/Tilemaps/OrthogonalTilemap":68,"../Nodes/UIElement":69,"../Nodes/UIElements/Button":70,"../Nodes/UIElements/Label":71,"../Nodes/UIElements/Slider":72,"../Nodes/UIElements/TextInput":73,"./CanvasRendering/GraphicRenderer":89,"./CanvasRendering/TilemapRenderer":90,"./CanvasRendering/UIElementRenderer":91,"./RenderingManager":92}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
class GraphicRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    renderPoint(point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    }
    renderLine(line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    }
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    renderRect(rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    }
}
exports.default = GraphicRenderer;
},{"../../ResourceManager/ResourceManager":100}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Vec2_1 = require("../../DataTypes/Vec2");
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
class TilemapRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    renderOrthogonalTilemap(tilemap) {
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        let origin = this.scene.getViewTranslation(tilemap);
        let size = this.scene.getViewport().getHalfSize();
        let zoom = this.scene.getViewScale();
        let bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            let minColRow = tilemap.getColRowAt(origin);
            let maxColRow = tilemap.getColRowAt(bottomRight);
            for (let x = minColRow.x; x <= maxColRow.x; x++) {
                for (let y = minColRow.y; y <= maxColRow.y; y++) {
                    // Get the tile at this position
                    let tile = tilemap.getTileAtRowCol(new Vec2_1.default(x, y));
                    // Extract the rot/flip parameters if there are any
                    const mask = (0xE << 28);
                    const rotFlip = ((mask & tile) >> 28) & 0xF;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (let tileset of tilemap.getTilesets()) {
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tileset, tile, x, y, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    renderTile(tileset, tileIndex, tilemapRow, tilemapCol, origin, scale, zoom, rotFlip) {
        let image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the true index
        let index = tileIndex - tileset.getStartIndex();
        // Get the row and col of the tile in image space
        let row = Math.floor(index / tileset.getNumCols());
        let col = index % tileset.getNumCols();
        let width = tileset.getTileSize().x;
        let height = tileset.getTileSize().y;
        // Calculate the position to start a crop in the tileset image
        let left = col * width;
        let top = row * height;
        // Calculate the position in the world to render the tile
        let x = Math.floor(tilemapRow * width * scale.x);
        let y = Math.floor(tilemapCol * height * scale.y);
        let worldX = Math.floor((x - origin.x) * zoom);
        let worldY = Math.floor((y - origin.y) * zoom);
        let worldWidth = Math.ceil(width * scale.x * zoom);
        let worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            let scaleX = 1;
            let scaleY = 1;
            let shearX = 0;
            let shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    }
}
exports.default = TilemapRenderer;
},{"../../DataTypes/Vec2":43,"../../ResourceManager/ResourceManager":100}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const MathUtils_1 = require("../../Utils/MathUtils");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
class UIElementRenderer {
    constructor(ctx) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    setScene(scene) {
        this.scene = scene;
    }
    /**
     * Renders a label
     * @param label The label to render
     */
    renderLabel(label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        let offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a button
     * @param button The button to render
     */
    renderButton(button) {
        this.renderLabel(button);
    }
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    renderSlider(slider) {
        // Grab the global alpha so we can adjust it for this render
        let previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        let sliderSize = new Vec2_1.default(slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        let x = MathUtils_1.default.lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    }
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    renderTextInput(textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    }
}
exports.default = UIElementRenderer;
},{"../../DataTypes/Vec2":43,"../../ResourceManager/ResourceManager":100,"../../Utils/MathUtils":119}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * An abstract framework to put all rendering in once place in the application
 */
class RenderingManager {
    constructor() {
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    setScene(scene) {
        this.scene = scene;
    }
}
exports.default = RenderingManager;
},{"../ResourceManager/ResourceManager":100}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const Graphic_1 = require("../Nodes/Graphic");
const Point_1 = require("../Nodes/Graphics/Point");
const Rect_1 = require("../Nodes/Graphics/Rect");
const AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
const Sprite_1 = require("../Nodes/Sprites/Sprite");
const UIElement_1 = require("../Nodes/UIElement");
const Label_1 = require("../Nodes/UIElements/Label");
const ShaderRegistry_1 = require("../Registry/Registries/ShaderRegistry");
const RegistryManager_1 = require("../Registry/RegistryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const RenderingManager_1 = require("./RenderingManager");
class WebGLRenderer extends RenderingManager_1.default {
    initializeCanvas(canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1.default.ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1.default.getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        let textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    }
    render(visibleSet, tilemaps, uiLayers) {
        for (let node of visibleSet) {
            this.renderNode(node);
        }
        uiLayers.forEach(key => {
            if (!uiLayers.get(key).isHidden())
                uiLayers.get(key).getItems().forEach(node => this.renderNode(node));
        });
    }
    clear(color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    }
    renderNode(node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1.default) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1.default) {
            if (node instanceof AnimatedSprite_1.default) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1.default) {
            this.renderUIElement(node);
        }
    }
    renderSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderAnimatedSprite(sprite) {
        let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.SPRITE_SHADER);
        let options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    }
    renderGraphic(graphic) {
        if (graphic instanceof Point_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.POINT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.RECT_SHADER);
            let options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    }
    renderTilemap(tilemap) {
        throw new Error("Method not implemented.");
    }
    renderUIElement(uiElement) {
        if (uiElement instanceof Label_1.default) {
            let shader = RegistryManager_1.default.shaders.get(ShaderRegistry_1.default.LABEL_SHADER);
            let options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            let globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            let offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
    renderCustom(node) {
        let shader = RegistryManager_1.default.shaders.get(node.customShaderKey);
        let options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    }
    addOptions(options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        let layer = node.getLayer();
        let parallax = new Vec2_1.default(1, 1);
        if (layer instanceof ParallaxLayer_1.default) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    }
}
exports.default = WebGLRenderer;
},{"../DataTypes/Vec2":43,"../Nodes/Graphic":60,"../Nodes/Graphics/Point":63,"../Nodes/Graphics/Rect":64,"../Nodes/Sprites/AnimatedSprite":65,"../Nodes/Sprites/Sprite":66,"../Nodes/UIElement":69,"../Nodes/UIElements/Label":71,"../Registry/Registries/ShaderRegistry":82,"../Registry/RegistryManager":83,"../ResourceManager/ResourceManager":100,"../Scene/Layers/ParallaxLayer":108,"./RenderingManager":92}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
class ShaderType {
    constructor(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    getOptions(node) { return {}; }
}
exports.default = ShaderType;
},{"../../ResourceManager/ResourceManager":100}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
class LabelShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const backgroundColor = options.backgroundColor.toWebGL();
        const borderColor = options.borderColor.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        const u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        const u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        const u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        const u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = LabelShaderType;
},{"../../../DataTypes/Mat4x4":31,"../../../DataTypes/Vec2":43,"../../../ResourceManager/ResourceManager":100,"./QuadShaderType":97}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RenderingUtils_1 = require("../../../Utils/RenderingUtils");
const ShaderType_1 = require("../ShaderType");
class PointShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
    }
    initBufferObject() {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        let position = RenderingUtils_1.default.toWebGLCoords(options.position, options.origin, options.worldSize);
        let color = RenderingUtils_1.default.toWebGLColor(options.color);
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = position;
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        const u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    }
    getOptions(point) {
        let options = {
            position: point.position,
            color: point.color,
            pointSize: point.size,
        };
        return options;
    }
}
exports.default = PointShaderType;
},{"../../../Utils/RenderingUtils":120,"../ShaderType":94}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const ShaderType_1 = require("../ShaderType");
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
class QuadShaderType extends ShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.scale = Mat4x4_1.default.IDENTITY;
        this.rotation = Mat4x4_1.default.IDENTITY;
        this.translation = Mat4x4_1.default.IDENTITY;
    }
}
exports.default = QuadShaderType;
},{"../../../DataTypes/Mat4x4":31,"../ShaderType":94}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
class RectShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const color = options.color.toWebGL();
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        const u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /*
        So as it turns out, WebGL has an issue with non-square quads.
        It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
        To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
        A diagram of the solution follows.

        There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
        The offset in the vertical direction is therefore 0.5, as it is normally.
        However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
        All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.

        So now we have our rect, in a space scaled with respect to the largest dimension.
        Rotations work as you would expect, even for long rectangles.

                    0.5
            __ __ __ __ __ __ __
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
        -0.5|_ _|88888888888|_ _|0.5
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
            |___|88888888888|___|
                    -0.5

        The getVertices function below does as described, and converts the range
    */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    }
    getOptions(rect) {
        let options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    }
}
exports.default = RectShaderType;
},{"../../../DataTypes/Mat4x4":31,"../../../DataTypes/Vec2":43,"../../../ResourceManager/ResourceManager":100,"./QuadShaderType":97}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Mat4x4_1 = require("../../../DataTypes/Mat4x4");
const Vec2_1 = require("../../../DataTypes/Vec2");
const AnimatedSprite_1 = require("../../../Nodes/Sprites/AnimatedSprite");
const ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
const QuadShaderType_1 = require("./QuadShaderType");
/** A shader for sprites and animated sprites */
class SpriteShaderType extends QuadShaderType_1.default {
    constructor(programKey) {
        super(programKey);
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    initBufferObject() {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    }
    render(gl, options) {
        const program = this.resourceManager.getShaderProgram(this.programKey);
        const buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        const texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        const vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        const FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        const a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        const a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        let maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        let size = new Vec2_1.default(maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        const translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        const translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        let transformation = Mat4x4_1.default.MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        const u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        const u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        const u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        const u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    getVertices(w, h, scale) {
        let x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x, y, 0.0, 0.0,
            -x, -y, 0.0, 1.0,
            x, y, 1.0, 0.0,
            x, -y, 1.0, 1.0
        ]);
    }
    getOptions(sprite) {
        let texShift;
        let texScale;
        if (sprite instanceof AnimatedSprite_1.default) {
            let animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            let offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
            texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        let options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift,
            texScale
        };
        return options;
    }
}
exports.default = SpriteShaderType;
},{"../../../DataTypes/Mat4x4":31,"../../../DataTypes/Vec2":43,"../../../Nodes/Sprites/AnimatedSprite":65,"../../../ResourceManager/ResourceManager":100,"./QuadShaderType":97}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("../DataTypes/Map");
const Queue_1 = require("../DataTypes/Queue");
const StringUtils_1 = require("../Utils/StringUtils");
const AudioManager_1 = require("../Sound/AudioManager");
const WebGLProgramType_1 = require("../DataTypes/Rendering/WebGLProgramType");
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
class ResourceManager {
    constructor() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1.default();
        this.images = new Map_1.default();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1.default();
        this.spritesheets = new Map_1.default();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1.default();
        this.tilemaps = new Map_1.default();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1.default();
        this.audioBuffers = new Map_1.default();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1.default();
        this.jsonObjects = new Map_1.default();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1.default();
        this.gl_ShaderPrograms = new Map_1.default();
        this.gl_Textures = new Map_1.default();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1.default();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    ;
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    }
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    useWebGL(flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    }
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    image(key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepImage(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    getImage(key) {
        let image = this.images.get(key);
        if (image === undefined) {
            console.log(this.images);
            throw `There is no image associated with key "${key}"`;
        }
        return image;
    }
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    spritesheet(key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepSpritesheet(key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    }
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    getSpritesheet(key) {
        return this.spritesheets.get(key);
    }
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    audio(key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepAudio(key) {
        this.keepResource(key, ResourceType.AUDIO);
    }
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    getAudio(key) {
        return this.audioBuffers.get(key);
    }
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param path The path to the tilemap to load
     */
    tilemap(key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepTilemap(key) {
        this.keepResource(key, ResourceType.TILEMAP);
    }
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    getTilemap(key) {
        return this.tilemaps.get(key);
    }
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    object(key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepObject(key) {
        this.keepResource(key, ResourceType.JSON);
    }
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    getObject(key) {
        return this.jsonObjects.get(key);
    }
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    loadResourcesFromQueue(callback) {
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(() => {
            console.log("Loaded Tilemaps");
            this.loadSpritesheetsFromQueue(() => {
                console.log("Loaded Spritesheets");
                this.loadImagesFromQueue(() => {
                    console.log("Loaded Images");
                    this.loadAudioFromQueue(() => {
                        console.log("Loaded Audio");
                        this.loadObjectsFromQueue(() => {
                            console.log("Loaded Objects");
                            if (this.gl_WebGLActive) {
                                this.gl_LoadShadersFromQueue(() => {
                                    console.log("Loaded Shaders");
                                    this.finishLoading(callback);
                                });
                            }
                            else {
                                this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    }
    finishLoading(callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    }
    /* ######################################## UNLOAD FUNCTION ########################################*/
    keepResource(key, type) {
        console.log("Keep resource...");
        for (let i = 0; i < this.resourcesToUnload.length; i++) {
            let resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                let resourceToMove = this.resourcesToUnload.splice(i, 1);
                this.resourcesToKeep.push(...resourceToMove);
                return;
            }
        }
    }
    /**
     * Deletes references to all resources in the resource manager
     */
    unloadAllResources() {
        this.loading = false;
        this.justLoaded = false;
        for (let resource of this.resourcesToUnload) {
            // Unload the resource
            this.unloadResource(resource);
        }
    }
    unloadResource(resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images.delete(resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures.delete(resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps.delete(resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets.delete(resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers.delete(resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects.delete(resource.key);
                break;
            case ResourceType.SHADER:
                this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                this.gl_ShaderPrograms.delete(resource.key);
                break;
        }
        // Delete any dependencies
        for (let dependency of resource.dependencies) {
            this.unloadResource(dependency);
        }
    }
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    loadTilemapsFromQueue(onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            let tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    loadTilemap(key, pathToTilemapJSON, callbackIfLast) {
        this.loadTextFile(pathToTilemapJSON, (fileText) => {
            let tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.tilemaps.add(key, tilemapObject);
            let resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (let tileset of tilemapObject.tilesets) {
                if (tileset.image) {
                    let key = tileset.image;
                    let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                    this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (let tile of tileset.tiles) {
                        let key = tile.image;
                        let path = StringUtils_1.default.getPathFromFilePath(pathToTilemapJSON) + key;
                        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingTilemap(callbackIfLast);
        });
    }
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    finishLoadingTilemap(callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    }
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    loadSpritesheetsFromQueue(onFinishLoading) {
        this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            let spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    loadSpritesheet(key, pathToSpritesheetJSON, callbackIfLast) {
        this.loadTextFile(pathToSpritesheetJSON, (fileText) => {
            let spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            this.spritesheets.add(key, spritesheet);
            let resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            let path = StringUtils_1.default.getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
            this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            this.resourcesToUnload.push(resource);
            // Finish loading
            this.finishLoadingSpritesheet(callbackIfLast);
        });
    }
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    finishLoadingSpritesheet(callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    }
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    loadImagesFromQueue(onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            let image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    }
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    loadImage(key, path, isDependency, callbackIfLast) {
        var image = new Image();
        image.onload = () => {
            // Add to loaded images
            this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (this.gl_WebGLActive) {
                this.createWebGLTexture(key, image);
            }
            // Finish image load
            this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    }
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    finishLoadingImage(callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    }
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    loadAudioFromQueue(onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            let audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    }
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    loadAudio(key, path, callbackIfLast) {
        let audioCtx = AudioManager_1.default.getInstance().getAudioContext();
        let request = new XMLHttpRequest();
        request.open('GET', path, true);
        request.responseType = 'arraybuffer';
        request.onload = () => {
            audioCtx.decodeAudioData(request.response, (buffer) => {
                // Add to list of audio buffers
                this.audioBuffers.add(key, buffer);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                this.finishLoadingAudio(callbackIfLast);
            }, (error) => {
                throw "Error loading sound";
            });
        };
        request.send();
    }
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    finishLoadingAudio(callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    }
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    loadObjectsFromQueue(onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            let obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    }
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    loadObject(key, path, callbackIfLast) {
        this.loadTextFile(path, (fileText) => {
            let obj = JSON.parse(fileText);
            this.jsonObjects.add(key, obj);
            this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            this.finishLoadingObject(callbackIfLast);
        });
    }
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    finishLoadingObject(callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    }
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    getTexture(key) {
        return this.gl_Textures.get(key);
    }
    getShaderProgram(key) {
        return this.gl_ShaderPrograms.get(key).program;
    }
    getBuffer(key) {
        return this.gl_Buffers.get(key);
    }
    createWebGLTexture(imageKey, image) {
        // Get the texture ID
        const textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        const texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    }
    getTextureID(id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0: return this.gl.TEXTURE0;
            case 1: return this.gl.TEXTURE1;
            case 2: return this.gl.TEXTURE2;
            case 3: return this.gl.TEXTURE3;
            case 4: return this.gl.TEXTURE4;
            case 5: return this.gl.TEXTURE5;
            case 6: return this.gl.TEXTURE6;
            case 7: return this.gl.TEXTURE7;
            case 8: return this.gl.TEXTURE8;
            default: return this.gl.TEXTURE9;
        }
    }
    createBuffer(key) {
        if (this.gl_WebGLActive) {
            let buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    }
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    shader(key, vShaderFilepath, fShaderFilepath) {
        let splitPath = vShaderFilepath.split(".");
        let end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw `${vShaderFilepath} is not a valid vertex shader - must end in ".vshader`;
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw `${fShaderFilepath} is not a valid vertex shader - must end in ".fshader`;
        }
        let paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    }
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    keepShader(key) {
        this.keepResource(key, ResourceType.IMAGE);
    }
    gl_LoadShadersFromQueue(onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            let shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    }
    gl_LoadShader(key, vpath, fpath, callbackIfLast) {
        this.loadTextFile(vpath, (vFileText) => {
            const vShader = vFileText;
            this.loadTextFile(fpath, (fFileText) => {
                const fShader = fFileText;
                // Extract the program and shaders
                const [shaderProgram, vertexShader, fragmentShader] = this.createShaderProgram(vShader, fShader);
                // Create a wrapper type
                const programWrapper = new WebGLProgramType_1.default();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                this.gl_ShaderPrograms.add(key, programWrapper);
                this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    }
    gl_FinishLoadingShader(callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    }
    createShaderProgram(vShaderSource, fShaderSource) {
        const vertexShader = this.loadVertexShader(vShaderSource);
        const fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        const program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            const error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    }
    loadVertexShader(shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    }
    loadFragmentShader(shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    }
    loadShader(type, shaderSource) {
        const shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            const error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    }
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    loadTextFile(textFilePath, callback) {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', textFilePath, true);
        xobj.onreadystatechange = function () {
            if ((xobj.readyState == 4) && (xobj.status == 200)) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
    /* ########## LOADING BAR INFO ########## */
    getLoadPercent() {
        return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
            + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
            + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
            + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
            / this.loadonly_typesToLoad;
    }
    update(deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    }
}
exports.default = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
class ResourceReference {
    constructor(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    addDependency(resource) {
        this.dependencies.push(resource);
    }
}
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
class KeyPathPair {
    constructor() {
        this.isDependency = false;
    }
}
class KeyPath_Shader {
}
},{"../DataTypes/Map":30,"../DataTypes/Queue":34,"../DataTypes/Rendering/WebGLProgramType":35,"../Sound/AudioManager":113,"../Utils/StringUtils":121}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
class SceneGraph {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    addNode(node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    }
    ;
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    removeNode(node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    }
    ;
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    getNode(id) {
        return this.nodeMap[id];
    }
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    getNodesAt(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    }
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    getAllNodes() {
        let arr = new Array();
        for (let i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    }
}
exports.default = SceneGraph;
},{"../DataTypes/Vec2":43}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SceneGraph_1 = require("./SceneGraph");
const Stats_1 = require("../Debug/Stats");
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
class SceneGraphArray extends SceneGraph_1.default {
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    constructor(viewport, scene) {
        super(viewport, scene);
        this.nodeList = new Array();
    }
    // @override
    addNodeSpecific(node, id) {
        this.nodeList.push(node);
    }
    // @override
    removeNodeSpecific(node, id) {
        let index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    }
    // @override
    getNodesAtCoords(x, y) {
        let results = [];
        for (let node of this.nodeList) {
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    }
    // @override
    getNodesInRegion(boundary) {
        let t0 = performance.now();
        let results = [];
        for (let node of this.nodeList) {
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgquery", (t1 - t0));
        return results;
    }
    update(deltaT) {
        let t0 = performance.now();
        for (let node of this.nodeList) {
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        let t1 = performance.now();
        Stats_1.default.log("sgupdate", (t1 - t0));
    }
    render(ctx) { }
    // @override
    getVisibleSet() {
        let visibleSet = new Array();
        for (let node of this.nodeList) {
            if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    }
}
exports.default = SceneGraphArray;
},{"../Debug/Stats":45,"./SceneGraph":101}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../DataTypes/Vec2");
const MathUtils_1 = require("../Utils/MathUtils");
const Queue_1 = require("../DataTypes/Queue");
const AABB_1 = require("../DataTypes/Shapes/AABB");
const Input_1 = require("../Input/Input");
const ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
const UILayer_1 = require("../Scene/Layers/UILayer");
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
class Viewport {
    constructor(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        this.view = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.boundary = new AABB_1.default(Vec2_1.default.ZERO, Vec2_1.default.ZERO);
        this.lastPositions = new Queue_1.default();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1.default.ZERO;
        this.focus = Vec2_1.default.ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    enableZoom() {
        this.scrollZoomEnabled = true;
    }
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    getCenter() {
        return this.view.center;
    }
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    getOrigin() {
        return new Vec2_1.default(this.view.left, this.view.top);
    }
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    getView() {
        return this.view;
    }
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    setCenter(vecOrX, y = null) {
        let pos;
        if (vecOrX instanceof Vec2_1.default) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1.default(vecOrX, y);
        }
        this.view.center = pos;
    }
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    getHalfSize() {
        return this.view.getHalfSize();
    }
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    setSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX / 2, y / 2));
        }
    }
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    setHalfSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1.default(vecOrX, y));
        }
    }
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    setCanvasSize(vecOrX, y = null) {
        if (vecOrX instanceof Vec2_1.default) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1.default(vecOrX, y);
        }
    }
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    setZoomLevel(zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    }
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    getZoomLevel() {
        return this.canvasSize.x / this.view.hw / 2;
    }
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    setSmoothingFactor(smoothingFactor) {
        if (smoothingFactor < 1)
            smoothingFactor = 1;
        this.smoothingFactor = smoothingFactor;
    }
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    setFocus(focus) {
        this.focus.copy(focus);
    }
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    includes(node) {
        let parallax = node.getLayer() instanceof ParallaxLayer_1.default || node.getLayer() instanceof UILayer_1.default ? node.getLayer().parallax : new Vec2_1.default(1, 1);
        let center = this.view.center.clone();
        this.view.center.mult(parallax);
        let overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    }
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    setBounds(lowerX, lowerY, upperX, upperY) {
        let hwidth = (upperX - lowerX) / 2;
        let hheight = (upperY - lowerY) / 2;
        let x = lowerX + hwidth;
        let y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    }
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    follow(node) {
        this.following = node;
    }
    updateView() {
        if (this.lastPositions.getSize() > this.smoothingFactor) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        let pos = Vec2_1.default.ZERO;
        this.lastPositions.forEach(position => pos.add(position));
        pos.scale(1 / this.lastPositions.getSize());
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1.default.clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1.default.clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    }
    update(deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1.default.didJustScroll()) {
                let currentSize = this.view.getHalfSize().clone();
                if (Input_1.default.getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    let factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    let factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    }
}
exports.default = Viewport;
},{"../DataTypes/Queue":34,"../DataTypes/Shapes/AABB":36,"../DataTypes/Vec2":43,"../Input/Input":51,"../Scene/Layers/ParallaxLayer":108,"../Scene/Layers/UILayer":109,"../Utils/MathUtils":119}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = require("../../Nodes/Sprites/Sprite");
const AnimatedSprite_1 = require("../../Nodes/Sprites/AnimatedSprite");
const GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
const UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
const Point_1 = require("../../Nodes/Graphics/Point");
const Vec2_1 = require("../../DataTypes/Vec2");
const Button_1 = require("../../Nodes/UIElements/Button");
const Label_1 = require("../../Nodes/UIElements/Label");
const Slider_1 = require("../../Nodes/UIElements/Slider");
const TextInput_1 = require("../../Nodes/UIElements/TextInput");
const Rect_1 = require("../../Nodes/Graphics/Rect");
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const Line_1 = require("../../Nodes/Graphics/Line");
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class CanvasNodeFactory {
    constructor() {
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = this.buildTextInput(options);
                    break;
                default:
                    throw `UIElementType '${type}' does not exist, or is registered incorrectly.`;
            }
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let instance = new Sprite_1.default(key);
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = (key, layerName) => {
            let layer = this.scene.getLayer(layerName);
            let spritesheet = this.resourceManager.getSpritesheet(key);
            let instance = new AnimatedSprite_1.default(spritesheet);
            // Add instance fo scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = (type, layerName, options) => {
            // Get the layer
            let layer = this.scene.getLayer(layerName);
            let instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = this.buildRect(options);
                    break;
                default:
                    throw `GraphicType '${type}' does not exist, or is registered incorrectly.`;
            }
            // Add instance to scene
            instance.setScene(this.scene);
            instance.id = this.scene.generateId();
            if (!(this.scene.isParallaxLayer(layerName) || this.scene.isUILayer(layerName))) {
                this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    init(scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
    /* ---------- BUILDERS ---------- */
    buildButton(options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1.default(options.position, options.text);
    }
    buildLabel(options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1.default(options.position, options.text);
    }
    buildSlider(options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1.default, "Vec2");
        let initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1.default(options.position, initValue);
    }
    buildTextInput(options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1.default, "Vec2");
        return new TextInput_1.default(options.position);
    }
    buildPoint(options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1.default, "Vec2");
        return new Point_1.default(options.position);
    }
    buildLine(options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1.default, "Vec2");
        return new Line_1.default(options.start, options.end);
    }
    buildRect(options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1.default, "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1.default, "Vec2");
        return new Rect_1.default(options.position, options.size);
    }
    /* ---------- ERROR HANDLING ---------- */
    checkIfPropExists(objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw `${objectName} object requires argument ${prop} of type ${typeName}, but none was provided.`;
        }
        else {
            // Check that the property has the correct type
            if ((typeof type) === "string") {
                if (!(typeof options[prop] === type)) {
                    throw `${objectName} object requires argument ${prop} of type ${type}, but provided ${prop} was not of type ${type}.`;
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
                }
            }
            else {
                throw `${objectName} object requires argument ${prop} of type ${typeName}, but provided ${prop} was not of type ${typeName}.`;
            }
        }
    }
}
exports.default = CanvasNodeFactory;
},{"../../DataTypes/Vec2":43,"../../Nodes/Graphics/GraphicTypes":61,"../../Nodes/Graphics/Line":62,"../../Nodes/Graphics/Point":63,"../../Nodes/Graphics/Rect":64,"../../Nodes/Sprites/AnimatedSprite":65,"../../Nodes/Sprites/Sprite":66,"../../Nodes/UIElements/Button":70,"../../Nodes/UIElements/Label":71,"../../Nodes/UIElements/Slider":72,"../../Nodes/UIElements/TextInput":73,"../../Nodes/UIElements/UIElementTypes":74,"../../ResourceManager/ResourceManager":100}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CanvasNodeFactory_1 = require("./CanvasNodeFactory");
const TilemapFactory_1 = require("./TilemapFactory");
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
class FactoryManager {
    constructor(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1.default();
        this.tilemapFactory = new TilemapFactory_1.default();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    uiElement(type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    }
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    sprite(key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    }
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    animatedSprite(key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(key, layerName);
    }
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    graphic(type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    }
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    tilemap(key, scale) {
        return this.tilemapFactory.add(key, scale);
    }
}
exports.default = FactoryManager;
},{"./CanvasNodeFactory":104,"./TilemapFactory":106}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../../ResourceManager/ResourceManager");
const OrthogonalTilemap_1 = require("../../Nodes/Tilemaps/OrthogonalTilemap");
const Tileset_1 = require("../../DataTypes/Tilesets/Tileset");
const Vec2_1 = require("../../DataTypes/Vec2");
const PositionGraph_1 = require("../../DataTypes/Graphs/PositionGraph");
const Navmesh_1 = require("../../Pathfinding/Navmesh");
// @ignorePage
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
class TilemapFactory {
    constructor() {
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = (key, scale = new Vec2_1.default(1, 1)) => {
            // Get Tilemap Data
            let tilemapData = this.resourceManager.getTilemap(key);
            // Set the constructor for this tilemap to either be orthographic or isometric
            let constr;
            if (tilemapData.orientation === "orthographic") {
                constr = OrthogonalTilemap_1.default;
            }
            else {
                // No isometric tilemap support right now, so Orthographic tilemap
                constr = OrthogonalTilemap_1.default;
            }
            // Initialize the return value array
            let sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            let tilesets = new Array();
            let collectionTiles = new Array();
            for (let tileset of tilemapData.tilesets) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1.default(tileset));
                }
                else {
                    tileset.tiles.forEach(tile => tile.id += tileset.firstgid);
                    collectionTiles.push(...tileset.tiles);
                }
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (let layer of tilemapData.layers) {
                let sceneLayer;
                let isParallaxLayer = false;
                let depth = 0;
                if (layer.properties) {
                    for (let prop of layer.properties) {
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = this.scene.addParallaxLayer(layer.name, new Vec2_1.default(1, 1), depth);
                }
                else {
                    sceneLayer = this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    let tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = this.scene.generateId();
                    tilemap.setScene(this.scene);
                    // Add tilemap to scene
                    this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (let item of layer.properties) {
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    let isNavmeshPoints = false;
                    let navmeshName;
                    let edges;
                    if (layer.properties) {
                        for (let prop of layer.properties) {
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        let g = new PositionGraph_1.default();
                        for (let obj of layer.objects) {
                            g.addPositionedNode(new Vec2_1.default(obj.x, obj.y));
                        }
                        for (let edge of edges) {
                            g.addEdge(edge.from, edge.to);
                        }
                        this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1.default(g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (let obj of layer.objects) {
                        // Check if obj is collidable
                        let hasPhysics = false;
                        let isCollidable = false;
                        let isTrigger = false;
                        let onEnter = null;
                        let onExit = null;
                        let triggerGroup = null;
                        let group = "";
                        if (obj.properties) {
                            for (let prop of obj.properties) {
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        let sprite;
                        // Check if obj is a tile from a tileset
                        for (let tileset of tilesets) {
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                let imageKey = tileset.getImageKey();
                                let offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = this.scene.add.sprite(imageKey, layer.name);
                                let size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (let tile of collectionTiles) {
                                if (obj.gid === tile.id) {
                                    let imageKey = tile.image;
                                    sprite = this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1.default.ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    init(scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1.default.getInstance();
    }
}
exports.default = TilemapFactory;
},{"../../DataTypes/Graphs/PositionGraph":28,"../../DataTypes/Tilesets/Tileset":42,"../../DataTypes/Vec2":43,"../../Nodes/Tilemaps/OrthogonalTilemap":68,"../../Pathfinding/Navmesh":77,"../../ResourceManager/ResourceManager":100}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("../Utils/MathUtils");
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
class Layer {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    getName() {
        return this.name;
    }
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    setPaused(pauseValue) {
        this.paused = pauseValue;
    }
    /**
     * Returns whether or not the layer is paused
     */
    isPaused() {
        return this.paused;
    }
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    setAlpha(alpha) {
        this.alpha = MathUtils_1.default.clamp(alpha, 0, 1);
    }
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    getAlpha() {
        return this.alpha;
    }
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    setHidden(hidden) {
        this.hidden = hidden;
    }
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    isHidden() {
        return this.hidden;
    }
    /** Pauses this scene and hides it */
    disable() {
        this.paused = true;
        this.hidden = true;
    }
    /** Unpauses this layer and makes it visible */
    enable() {
        this.paused = false;
        this.hidden = false;
    }
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    setYSort(ySort) {
        this.ySort = ySort;
    }
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    getYSort() {
        return this.ySort;
    }
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    setDepth(depth) {
        this.depth = depth;
    }
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    getDepth() {
        return this.depth;
    }
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    addNode(node) {
        this.items.push(node);
        node.setLayer(this);
    }
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    removeNode(node) {
        // Find and remove the node
        let index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    }
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    getItems() {
        return this.items;
    }
}
exports.default = Layer;
},{"../Utils/MathUtils":119}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("../Layer");
/**
 * An extension of a Layer that has a parallax value.
 */
class ParallaxLayer extends Layer_1.default {
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    constructor(scene, name, parallax) {
        super(scene, name);
        this.parallax = parallax;
    }
}
exports.default = ParallaxLayer;
},{"../Layer":107}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Vec2_1 = require("../../DataTypes/Vec2");
const ParallaxLayer_1 = require("./ParallaxLayer");
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
class UILayer extends ParallaxLayer_1.default {
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    constructor(scene, name) {
        super(scene, name, Vec2_1.default.ZERO);
    }
}
exports.default = UILayer;
},{"../../DataTypes/Vec2":43,"./ParallaxLayer":108}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Layer_1 = require("./Layer");
const Vec2_1 = require("../DataTypes/Vec2");
const BasicPhysicsManager_1 = require("../Physics/BasicPhysicsManager");
const SceneGraphArray_1 = require("../SceneGraph/SceneGraphArray");
const FactoryManager_1 = require("./Factories/FactoryManager");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const Receiver_1 = require("../Events/Receiver");
const Emitter_1 = require("../Events/Emitter");
const NavigationManager_1 = require("../Pathfinding/NavigationManager");
const AIManager_1 = require("../AI/AIManager");
const Map_1 = require("../DataTypes/Map");
const ParallaxLayer_1 = require("./Layers/ParallaxLayer");
const UILayer_1 = require("./Layers/UILayer");
const CanvasNode_1 = require("../Nodes/CanvasNode");
const SceneOptions_1 = require("./SceneOptions");
const Debug_1 = require("../Debug/Debug");
const TimerManager_1 = require("../Timing/TimerManager");
const TweenManager_1 = require("../Rendering/Animations/TweenManager");
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
class Scene {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    constructor(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1.default.parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1.default(500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1.default();
        this.emitter = new Emitter_1.default();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1.default(this.viewport, this);
        this.layers = new Map_1.default();
        this.uiLayers = new Map_1.default();
        this.parallaxLayers = new Map_1.default();
        this.physicsManager = new BasicPhysicsManager_1.default(this.sceneOptions.physics);
        this.navManager = new NavigationManager_1.default();
        this.aiManager = new AIManager_1.default();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1.default(this, this.tilemaps);
        this.load = ResourceManager_1.default.getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1.default.getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    initScene(init) { }
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    loadScene() { }
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    startScene() { }
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    updateScene(deltaT) { }
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    unloadScene() { }
    update(deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1.default.getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(tilemap => {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1.default.getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    }
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    render() {
        // Get the visible set of nodes
        let visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(key => {
            let pLayer = this.parallaxLayers.get(key);
            for (let node of pLayer.getItems()) {
                if (node instanceof CanvasNode_1.default) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        let nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(tilemap => tilemap.visible ? nodes.push(tilemap) : 0);
        Debug_1.default.setNodes(nodes);
    }
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    setRunning(running) {
        this.running = running;
    }
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    isRunning() {
        return this.running;
    }
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    remove(node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1.default) {
            this.sceneGraph.removeNode(node);
        }
    }
    /** Destroys this scene and all nodes in it */
    destroy() {
        for (let node of this.sceneGraph.getAllNodes()) {
            node.destroy();
        }
        for (let tilemap of this.tilemaps) {
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    }
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    addLayer(name, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new Layer_1.default(this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    addParallaxLayer(name, parallax, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new ParallaxLayer_1.default(this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    }
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    addUILayer(name) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw `Layer with name ${name} already exists`;
        }
        let layer = new UILayer_1.default(this, name);
        this.uiLayers.add(name, layer);
        return layer;
    }
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    getLayer(name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw `Requested layer ${name} does not exist.`;
        }
    }
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    isParallaxLayer(name) {
        return this.parallaxLayers.has(name);
    }
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    isUILayer(name) {
        return this.uiLayers.has(name);
    }
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    getViewTranslation(node) {
        let layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1.default || layer instanceof UILayer_1.default) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    }
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
    */
    getViewScale() {
        return this.viewport.getZoomLevel();
    }
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    getViewport() {
        return this.viewport;
    }
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    getWorldSize() {
        return this.worldSize;
    }
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    getSceneGraph() {
        return this.sceneGraph;
    }
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    getPhysicsManager() {
        return this.physicsManager;
    }
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    getNavigationManager() {
        return this.navManager;
    }
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    getAIManager() {
        return this.aiManager;
    }
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    generateId() {
        return this.sceneManager.generateId();
    }
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    getTilemap(name) {
        for (let tilemap of this.tilemaps) {
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    }
}
exports.default = Scene;
},{"../AI/AIManager":23,"../DataTypes/Map":30,"../DataTypes/Vec2":43,"../Debug/Debug":44,"../Events/Emitter":46,"../Events/Receiver":50,"../Nodes/CanvasNode":58,"../Pathfinding/NavigationManager":75,"../Physics/BasicPhysicsManager":78,"../Rendering/Animations/TweenManager":87,"../ResourceManager/ResourceManager":100,"../SceneGraph/SceneGraphArray":102,"../Timing/TimerManager":115,"./Factories/FactoryManager":105,"./Layer":107,"./Layers/ParallaxLayer":108,"./Layers/UILayer":109,"./SceneOptions":112}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
class SceneManager {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    constructor(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1.default.getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    changeToScene(constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    }
    doSceneChange() {
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(() => {
            console.log("Starting Scene");
            this.currentScene.startScene();
            this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    }
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    generateId() {
        return this.idCounter++;
    }
    /**
     * Renders the current Scene
     */
    render() {
        if (this.currentScene) {
            this.currentScene.render();
        }
    }
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    update(deltaT) {
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    }
}
exports.default = SceneManager;
},{"../ResourceManager/ResourceManager":100}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
class SceneOptions {
    static parse(options) {
        let sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    }
}
exports.default = SceneOptions;
},{}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
const Map_1 = require("../DataTypes/Map");
const Receiver_1 = require("../Events/Receiver");
const ResourceManager_1 = require("../ResourceManager/ResourceManager");
const GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
class AudioManager {
    constructor() {
        this.initAudio();
        this.receiver = new Receiver_1.default();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL
        ]);
        this.currentSounds = new Map_1.default();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    static getInstance() {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    }
    /**
     * Initializes the webAudio context
     */
    initAudio() {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
            this.audioCtx = new AudioContext();
            console.log('Web Audio API successfully loaded');
        }
        catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    }
    initGainNodes() {
        for (let i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    }
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    getAudioContext() {
        return this.audioCtx;
    }
    /*
        According to the MDN, create a new sound for every call:

        An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
        if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
        actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
        "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
        hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
        until sometime after the sound has finished playing.
    */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    createSound(key, holdReference, channel, options) {
        // Get audio buffer
        let buffer = ResourceManager_1.default.getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        const nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (let i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    }
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    playSound(key, loop, holdReference, channel, options) {
        let sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    }
    /**
     * Stop the sound specified by the key
     */
    stopSound(key) {
        let sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds.delete(key);
        }
    }
    muteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    }
    unmuteChannel(channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    }
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    static setVolume(channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        const am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    }
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    getChannelGainNode(channel) {
        return this.gainNodes[channel];
    }
    update(deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            let event = this.receiver.getNextEvent();
            if (event.type === GameEventType_1.GameEventType.PLAY_SOUND || event.type === GameEventType_1.GameEventType.PLAY_MUSIC || event.type === GameEventType_1.GameEventType.PLAY_SFX) {
                let soundKey = event.data.get("key");
                let loop = event.data.get("loop");
                let holdReference = event.data.get("holdReference");
                let channel = AudioChannelType.DEFAULT;
                if (event.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event.data.has("channel")) {
                    channel = event.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event.data);
            }
            if (event.type === GameEventType_1.GameEventType.STOP_SOUND) {
                let soundKey = event.data.get("key");
                this.stopSound(soundKey);
            }
            if (event.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event.data.get("channel"));
            }
            if (event.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event.data.get("channel"));
            }
        }
    }
}
exports.default = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;
},{"../DataTypes/Map":30,"../Events/GameEventType":49,"../Events/Receiver":50,"../ResourceManager/ResourceManager":100}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimerState = void 0;
const MathUtils_1 = require("../Utils/MathUtils");
const TimerManager_1 = require("./TimerManager");
class Timer {
    constructor(time, onEnd, loop = false) {
        // Register this timer
        TimerManager_1.default.getInstance().addTimer(this);
        this.totalTime = time;
        this.timeLeft = 0;
        this.onEnd = onEnd;
        this.loop = loop;
        this.state = TimerState.STOPPED;
        this.numRuns = 0;
    }
    isStopped() {
        return this.state === TimerState.STOPPED;
    }
    isPaused() {
        return this.state === TimerState.PAUSED;
    }
    /**
     * Returns whether or not this timer has been run before
     * @returns true if it has been run at least once (after the latest reset), and false otherwise
     */
    hasRun() {
        return this.numRuns > 0;
    }
    start(time) {
        if (time !== undefined) {
            this.totalTime = time;
        }
        this.state = TimerState.ACTIVE;
        this.timeLeft = this.totalTime;
    }
    /** Resets this timer. Sets the progress back to zero, and sets the number of runs back to zero */
    reset() {
        this.timeLeft = this.totalTime;
        this.numRuns = 0;
    }
    pause() {
        this.state = TimerState.PAUSED;
    }
    update(deltaT) {
        if (this.state === TimerState.ACTIVE) {
            this.timeLeft -= deltaT * 1000;
            if (this.timeLeft <= 0) {
                this.timeLeft = MathUtils_1.default.clampLow0(this.timeLeft);
                this.end();
            }
        }
    }
    end() {
        // Update the state
        this.state = TimerState.STOPPED;
        this.numRuns += 1;
        // Call the end function if there is one
        if (this.onEnd) {
            this.onEnd();
        }
        // Loop if we want to
        if (this.loop) {
            this.state = TimerState.ACTIVE;
            this.timeLeft = this.totalTime;
        }
    }
    toString() {
        return "Timer: " + this.state + " - Time Left: " + this.timeLeft + "ms of " + this.totalTime + "ms";
    }
}
exports.default = Timer;
var TimerState;
(function (TimerState) {
    TimerState["ACTIVE"] = "ACTIVE";
    TimerState["PAUSED"] = "PAUSED";
    TimerState["STOPPED"] = "STOPPED";
})(TimerState = exports.TimerState || (exports.TimerState = {}));
},{"../Utils/MathUtils":119,"./TimerManager":115}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TimerManager {
    constructor() {
        this.timers = new Array();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    }
    addTimer(timer) {
        this.timers.push(timer);
    }
    clearTimers() {
        this.timers = new Array();
    }
    update(deltaT) {
        this.timers.forEach(timer => timer.update(deltaT));
    }
}
exports.default = TimerManager;
},{}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
class Color {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Transparent color
     * @returns rgba(0, 0, 0, 0)
     */
    static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
    }
    /**
     * Red color
     * @returns rgb(255, 0, 0)
     */
    static get RED() {
        return new Color(255, 0, 0, 1);
    }
    /**
     * Green color
     * @returns rgb(0, 255, 0)
     */
    static get GREEN() {
        return new Color(0, 255, 0, 1);
    }
    /**
     * Blue color
     * @returns rgb(0, 0, 255)
     */
    static get BLUE() {
        return new Color(0, 0, 255, 1);
    }
    /**
     * Yellow color
     * @returns rgb(255, 255, 0)
     */
    static get YELLOW() {
        return new Color(255, 255, 0, 1);
    }
    /**
     * Magenta color
     * @returns rgb(255, 0, 255)
     */
    static get MAGENTA() {
        return new Color(255, 0, 255, 1);
    }
    /**
     * Cyan color
     * @returns rgb(0, 255, 255)
     */
    static get CYAN() {
        return new Color(0, 255, 255, 1);
    }
    /**
     * White color
     * @returns rgb(255, 255, 255)
     */
    static get WHITE() {
        return new Color(255, 255, 255, 1);
    }
    /**
     * Black color
     * @returns rgb(0, 0, 0)
     */
    static get BLACK() {
        return new Color(0, 0, 0, 1);
    }
    /**
     * Orange color
     * @returns rgb(255, 100, 0)
     */
    static get ORANGE() {
        return new Color(255, 100, 0, 1);
    }
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    set(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    lighten() {
        return new Color(MathUtils_1.default.clamp(this.r + 40, 0, 255), MathUtils_1.default.clamp(this.g + 40, 0, 255), MathUtils_1.default.clamp(this.b + 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    darken() {
        return new Color(MathUtils_1.default.clamp(this.r - 40, 0, 255), MathUtils_1.default.clamp(this.g - 40, 0, 255), MathUtils_1.default.clamp(this.b - 40, 0, 255), MathUtils_1.default.clamp(this.a + 10, 0, 255));
    }
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    toString() {
        return "#" + MathUtils_1.default.toHex(this.r, 2) + MathUtils_1.default.toHex(this.g, 2) + MathUtils_1.default.toHex(this.b, 2);
    }
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    toStringRGB() {
        return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
    }
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    toStringRGBA() {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
    }
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    toWebGL() {
        return new Float32Array([
            this.r / 255,
            this.g / 255,
            this.b / 255,
            this.a
        ]);
    }
    static fromStringHex(str) {
        let i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        let r = MathUtils_1.default.fromHex(str.substring(i, i + 2));
        let g = MathUtils_1.default.fromHex(str.substring(i + 2, i + 4));
        let b = MathUtils_1.default.fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    }
}
exports.default = Color;
},{"./MathUtils":119}],117:[function(require,module,exports){
"use strict";
// @ignorePage
Object.defineProperty(exports, "__esModule", { value: true });
exports.EaseFunctionType = void 0;
class EaseFunctions {
    static easeInOutSine(x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    }
    static easeOutInSine(x) {
        return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    }
    static easeOutSine(x) {
        return Math.sin((x * Math.PI) / 2);
    }
    static easeInSine(x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    }
    static easeInOutQuint(x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    }
    static easeInOutQuad(x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    static easeOutInQuad(x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    }
    static easeOutIn_OutPow(x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    }
    static easeOutIn_InPow(x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    }
}
exports.default = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));
},{}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class to provides some utility functions for graphs */
class GraphUtils {
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    static djikstra(g, start) {
        let i; // Counter
        let p; // Pointer to edgenode
        let inTree = new Array(g.numVertices);
        let distance = new Array(g.numVertices);
        let parent = new Array(g.numVertices);
        let v; // Current vertex to process
        let w; // Candidate for next vertex
        let weight; // Edge weight
        let dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    }
}
exports.default = GraphUtils;
},{}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** A class containing some utility functions for math operations */
class MathUtils {
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    static sign(x) {
        return x < 0 ? -1 : 1;
    }
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    static between(a, b, x, exclusive) {
        if (exclusive) {
            return (a < x) && (x < b);
        }
        else {
            return (a <= x) && (x <= b);
        }
    }
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    static clamp(x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    }
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    static clamp01(x) {
        return MathUtils.clamp(x, 0, 1);
    }
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    static clampLow(x, min) {
        return x < min ? min : x;
    }
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    static clampLow0(x) {
        return MathUtils.clampLow(x, 0);
    }
    static clampMagnitude(v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    }
    static changeRange(x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    }
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    static lerp(a, b, t) {
        return a + t * (b - a);
    }
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    static invLerp(a, b, value) {
        return (value - a) / (b - a);
    }
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    static floorToPlace(num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        let factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    }
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    static fromHex(str) {
        return parseInt(str, 16);
    }
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    static toHex(num, minLength = null) {
        let factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        let hexStr = "";
        while (factor >= 1) {
            let digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    }
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    static toHexDigit(num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    }
}
exports.default = MathUtils;
},{}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MathUtils_1 = require("./MathUtils");
class RenderingUtils {
    static toWebGLCoords(point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1.default.changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1.default.changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
        ]);
    }
    static toWebGLScale(size, worldSize) {
        return new Float32Array([
            2 * size.x / worldSize.x,
            2 * size.y / worldSize.y,
        ]);
    }
    static toWebGLColor(color) {
        return new Float32Array([
            MathUtils_1.default.changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1.default.changeRange(color.b, 0, 255, 0, 1),
            color.a
        ]);
    }
}
exports.default = RenderingUtils;
},{"./MathUtils":119}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Some utility functions for dealing with strings */
class StringUtils {
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    static getPathFromFilePath(filePath) {
        let splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    }
}
exports.default = StringUtils;
},{}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Game_1 = require("./Wolfie2D/Loop/Game");
const SplashScreen_1 = require("./Scenes/SplashScreen");
const RegistryManager_1 = require("./Wolfie2D/Registry/RegistryManager");
const WeaponRegistry_1 = require("./GameSystems/Registry/WeaponRegistry");
const WeaponTypeRegistry_1 = require("./GameSystems/Registry/WeaponTypeRegistry");
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    let options = {
        canvasSize: { x: 1280, y: 720 },
        clearColor: { r: 0, g: 0, b: 0 },
        inputs: [
            { name: "up", keys: ["w"] },
            { name: "down", keys: ["s"] },
            { name: "left", keys: ["a"] },
            { name: "right", keys: ["d"] },
            { name: "interact", keys: ["e"] },
            { name: "pause", keys: ["escape"] },
        ]
    };
    // setup custom weapon registry
    let weaponTemplateRegistry = new WeaponRegistry_1.default();
    RegistryManager_1.default.addCustomRegistry("weaponTemplates", weaponTemplateRegistry);
    let weaponTypeRegistry = new WeaponTypeRegistry_1.default();
    RegistryManager_1.default.addCustomRegistry("weaponTypes", weaponTypeRegistry);
    // Create a game with the options specified
    const game = new Game_1.default(options);
    // Start our game
    game.start(SplashScreen_1.default, {});
})();
function runTests() { }
;
},{"./GameSystems/Registry/WeaponRegistry":14,"./GameSystems/Registry/WeaponTypeRegistry":15,"./Scenes/SplashScreen":22,"./Wolfie2D/Loop/Game":55,"./Wolfie2D/Registry/RegistryManager":83}]},{},[122])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvQUkvQmF0QUkudHMiLCJzcmMvQUkvQmF0U3RhdGVzL0F0dGFjay50cyIsInNyYy9BSS9CYXRTdGF0ZXMvRGFtYWdlZC50cyIsInNyYy9BSS9CYXRTdGF0ZXMvRW5lbXlTdGF0ZS50cyIsInNyYy9BSS9CYXRTdGF0ZXMvSWRsZS50cyIsInNyYy9BSS9HbHV0dG9ueUFJLnRzIiwic3JjL0FJL0dsdXR0b255U3RhdGVzL0F0dGFjay50cyIsInNyYy9BSS9HbHV0dG9ueVN0YXRlcy9Cb3NzU3RhdGUudHMiLCJzcmMvQUkvR2x1dHRvbnlTdGF0ZXMvRGFtYWdlLnRzIiwic3JjL0FJL0dsdXR0b255U3RhdGVzL0lkbGUudHMiLCJzcmMvQUkvUGxheWVyQ29udHJvbGxlci50cyIsInNyYy9HYW1lU3lzdGVtcy9CYXR0bGVNYW5hZ2VyLnRzIiwic3JjL0dhbWVTeXN0ZW1zL0l0ZW0udHMiLCJzcmMvR2FtZVN5c3RlbXMvUmVnaXN0cnkvV2VhcG9uUmVnaXN0cnkudHMiLCJzcmMvR2FtZVN5c3RlbXMvUmVnaXN0cnkvV2VhcG9uVHlwZVJlZ2lzdHJ5LnRzIiwic3JjL0dhbWVTeXN0ZW1zL1dlYXBvbi50cyIsInNyYy9HYW1lU3lzdGVtcy9XZWFwb25UeXBlcy9QdW5jaC50cyIsInNyYy9HYW1lU3lzdGVtcy9XZWFwb25UeXBlcy9XZWFwb25UeXBlLnRzIiwic3JjL0dhbWVTeXN0ZW1zL2dhbWVfZW51bXMudHMiLCJzcmMvU2NlbmVzL0dsdXR0b255TGV2ZWwudHMiLCJzcmMvU2NlbmVzL01haW5NZW51LnRzIiwic3JjL1NjZW5lcy9TcGxhc2hTY3JlZW4udHMiLCJzcmMvV29sZmllMkQvQUkvQUlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9GdW5jdGlvbnMvTnVsbEZ1bmMudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9FZGdlTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL01hcC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvTWF0NHg0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1BoeXNpY3MvSGl0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9RdWV1ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1N0YWNrLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL0RlYnVnLnRzIiwic3JjL1dvbGZpZTJEL0RlYnVnL1N0YXRzLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FbWl0dGVyLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9FdmVudFF1ZXVlLnRzIiwic3JjL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnQudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFR5cGUudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL1JlY2VpdmVyLnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0LnRzIiwic3JjL1dvbGZpZTJEL0lucHV0L0lucHV0SGFuZGxlci50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0Vudmlyb25tZW50SW5pdGlhbGl6ZXIudHMiLCJzcmMvV29sZmllMkQvTG9vcC9GaXhlZFVwZGF0ZUdhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZS50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0dhbWVMb29wLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvQ2FudmFzTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9HcmFwaGljcy9MaW5lLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1BvaW50LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL1JlY3QudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZS50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvbi50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvU2xpZGVyLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVGV4dElucHV0LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXMudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2aWdhdGlvblBhdGgudHMiLCJzcmMvV29sZmllMkQvUGF0aGZpbmRpbmcvTmF2bWVzaC50cyIsInNyYy9Xb2xmaWUyRC9QaHlzaWNzL0Jhc2ljUGh5c2ljc01hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUGh5c2ljcy9QaHlzaWNzTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QbGF5YmFjay9SZWNvcmRlci50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyaWVzL1JlZ2lzdHJ5LnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnkudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL0FuaW1hdGlvbk1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvQW5pbWF0aW9uVHlwZXMudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9HcmFwaGljUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9UaWxlbWFwUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvTGFiZWxTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9Qb2ludFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1F1YWRTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvU3ByaXRlU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1ZpZXdwb3J0LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9DYW52YXNOb2RlRmFjdG9yeS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL1RpbGVtYXBGYWN0b3J5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9VSUxheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvU291bmQvQXVkaW9NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1RpbWluZy9UaW1lci50cyIsInNyYy9Xb2xmaWUyRC9UaW1pbmcvVGltZXJNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0NvbG9yLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL0Vhc2VGdW5jdGlvbnMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvR3JhcGhVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9NYXRoVXRpbHMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvUmVuZGVyaW5nVXRpbHMudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvU3RyaW5nVXRpbHMudHMiLCJzcmMvbWFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztBQ0FBLG9FQUE2RDtBQUM3RCw4REFBdUQ7QUFFdkQsdURBQWdEO0FBTWhELCtDQUF3QztBQUN4QywyQ0FBb0M7QUFDcEMsNERBQTBEO0FBQzFELGlEQUF5QztBQUV6QyxNQUFxQixLQUFNLFNBQVEsd0JBQWM7SUFBakQ7O1FBT0ksNENBQTRDO1FBQzVDLFVBQUssR0FBVyxFQUFFLENBQUM7UUFpRm5CLGtFQUFrRTtRQUNsRSxrQ0FBa0M7SUFDdEMsQ0FBQztJQTlFRyxZQUFZLENBQUMsS0FBcUIsRUFBRSxPQUE0QjtRQUM1RCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUVuQixJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxjQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFD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QUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUMzQixFQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUM7WUFDM0IsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQzVCLEVBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBQztZQUMvQixFQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUM7U0FDcEM7S0FDSixDQUFBO0lBRUQsK0JBQStCO0lBQy9CLElBQUksc0JBQXNCLEdBQUcsSUFBSSx3QkFBYyxFQUFFLENBQUM7SUFDbEQseUJBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBaUIsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO0lBRTdFLElBQUksa0JBQWtCLEdBQUcsSUFBSSw0QkFBa0IsRUFBRSxDQUFDO0lBQ2xELHlCQUFlLENBQUMsaUJBQWlCLENBQUMsYUFBYSxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFFckUsMkNBQTJDO0lBQzNDLE1BQU0sSUFBSSxHQUFHLElBQUksY0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRS9CLGlCQUFpQjtJQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLHNCQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDakMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUVMLFNBQVMsUUFBUSxLQUFHLENBQUM7QUFBQSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiaW1wb3J0IFN0YXRlTWFjaGluZUFJIGZyb20gXCIuLy4uL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4vQmF0dGxlckFJXCI7XHJcbmltcG9ydCBBdHRhY2sgZnJvbSBcIi4vQmF0U3RhdGVzL0F0dGFja1wiO1xyXG5pbXBvcnQgSWRsZSBmcm9tIFwiLi9CYXRTdGF0ZXMvSWRsZVwiO1xyXG5pbXBvcnQgeyBHYW1lX0V2ZW50cyB9IGZyb20gXCIuLy4uL0dhbWVTeXN0ZW1zL2dhbWVfZW51bXNcIjtcclxuaW1wb3J0IERhbWFnZWQgZnJvbSBcIi4vQmF0U3RhdGVzL0RhbWFnZWRcIlxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmF0QUkgZXh0ZW5kcyBTdGF0ZU1hY2hpbmVBSSBpbXBsZW1lbnRzIEJhdHRsZXJBSSB7XHJcbiAgICAvKiogVGhlIG93bmVyIG9mIHRoaXMgQUkgKi9cclxuICAgIG93bmVyOiBBbmltYXRlZFNwcml0ZTtcclxuXHJcbiAgICAvKiogVGhlIGFtb3VudCBvZiBoZWFsdGggdGhpcyBlbnRpdHkgaGFzICovXHJcbiAgICBoZWFsdGg6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGRlZmF1bHQgbW92ZW1lbnQgc3BlZWQgb2YgdGhpcyBBSSAqL1xyXG4gICAgc3BlZWQ6IG51bWJlciA9IDIwO1xyXG5cclxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyIG9iamVjdCAqL1xyXG4gICAgcGxheWVyOiBHYW1lTm9kZTtcclxuXHJcbiAgICBpbml0aWFsaXplQUkob3duZXI6IEFuaW1hdGVkU3ByaXRlLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG5cclxuICAgICAgICB0aGlzLmFkZFN0YXRlKEVuZW15U3RhdGVzLkRFRkFVTFQsIG5ldyBJZGxlKHRoaXMsIG93bmVyKSk7XHJcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShFbmVteVN0YXRlcy5BVFRBQ0tJTkcsIG5ldyBBdHRhY2sodGhpcywgb3duZXIpKTtcclxuICAgICAgICB0aGlzLmFkZFN0YXRlKEVuZW15U3RhdGVzLkRBTUFHRUQsIG5ldyBEYW1hZ2VkKHRoaXMsIG93bmVyKSk7XHJcbiAgICAgICAgdGhpcy5oZWFsdGggPSBvcHRpb25zLmhlYWx0aDtcclxuXHJcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBvcHRpb25zLnBsYXllcjtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byB0aGUgZGVmYXVsdCBzdGF0ZVxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShFbmVteVN0YXRlcy5ERUZBVUxUKTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRQbGF5ZXJQb3NpdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIGFjdGl2YXRlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgIH1cclxuXHJcbiAgICBkYW1hZ2UoZGFtYWdlOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmhlYWx0aCAtPSBkYW1hZ2U7XHJcbiAgICBcclxuICAgICAgICBpZih0aGlzLmhlYWx0aCA8PSAwKXtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5zZXRBSUFjdGl2ZShmYWxzZSwge30pO1xyXG4gICAgICAgICAgICB0aGlzLm93bmVyLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZighdGhpcy5vd25lci5hbmltYXRpb24uaXNQbGF5aW5nKFwiRFlJTkdcIikpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheShcIkRZSU5HXCIsIGZhbHNlLCBHYW1lX0V2ZW50cy5FTkVNWV9ESUVEKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKEVuZW15U3RhdGVzLkRBTUFHRUQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRQbGF5ZXJQb3NpdGlvbigpOiBWZWMyIHtcclxuICAgICAgICBsZXQgcG9zID0gdGhpcy5wbGF5ZXIucG9zaXRpb247XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgbmV3IHBsYXllciBsb2NhdGlvblxyXG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMub3duZXIucG9zaXRpb24uY2xvbmUoKTtcclxuICAgICAgICBsZXQgZGVsdGEgPSBwb3MuY2xvbmUoKS5zdWIoc3RhcnQpO1xyXG5cclxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHRpbGVtYXAgcmVnaW9uIHVudGlsIHdlIGZpbmQgYSBjb2xsaXNpb25cclxuICAgICAgICBsZXQgbWluWCA9IE1hdGgubWluKHN0YXJ0LngsIHBvcy54KTtcclxuICAgICAgICBsZXQgbWF4WCA9IE1hdGgubWF4KHN0YXJ0LngsIHBvcy54KTtcclxuICAgICAgICBsZXQgbWluWSA9IE1hdGgubWluKHN0YXJ0LnksIHBvcy55KTtcclxuICAgICAgICBsZXQgbWF4WSA9IE1hdGgubWF4KHN0YXJ0LnksIHBvcy55KTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB3YWxsIHRpbGVtYXBcclxuICAgICAgICBsZXQgd2FsbHMgPSA8T3J0aG9nb25hbFRpbGVtYXA+dGhpcy5vd25lci5nZXRTY2VuZSgpLmdldExheWVyKFwiV2FsbFwiKS5nZXRJdGVtcygpWzBdO1xyXG5cclxuICAgICAgICBsZXQgbWluSW5kZXggPSB3YWxscy5nZXRDb2xSb3dBdChuZXcgVmVjMihtaW5YLCBtaW5ZKSk7XHJcbiAgICAgICAgbGV0IG1heEluZGV4ID0gd2FsbHMuZ2V0Q29sUm93QXQobmV3IFZlYzIobWF4WCwgbWF4WSkpO1xyXG5cclxuICAgICAgICBsZXQgdGlsZVNpemUgPSB3YWxscy5nZXRUaWxlU2l6ZSgpO1xyXG5cclxuICAgICAgICBmb3IobGV0IGNvbCA9IG1pbkluZGV4Lng7IGNvbCA8PSBtYXhJbmRleC54OyBjb2wrKyl7XHJcbiAgICAgICAgICAgIGZvcihsZXQgcm93ID0gbWluSW5kZXgueTsgcm93IDw9IG1heEluZGV4Lnk7IHJvdysrKXtcclxuICAgICAgICAgICAgICAgIGlmKHdhbGxzLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdGlsZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aWxlUG9zID0gbmV3IFZlYzIoY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLngvMiwgcm93ICogdGlsZVNpemUueSArIHRpbGVTaXplLnkvMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbGxpZGVyIGZvciB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGlkZXIgPSBuZXcgQUFCQih0aWxlUG9zLCB0aWxlU2l6ZS5zY2FsZWQoMS8yKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoaXQgPSBjb2xsaWRlci5pbnRlcnNlY3RTZWdtZW50KHN0YXJ0LCBkZWx0YSwgVmVjMi5aRVJPKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaGl0ICE9PSBudWxsICYmIHN0YXJ0LmRpc3RhbmNlU3FUbyhoaXQucG9zKSA8IHN0YXJ0LmRpc3RhbmNlU3FUbyhwb3MpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGl0IGEgd2FsbCwgd2UgY2FuJ3Qgc2VlIHRoZSBwbGF5ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRlIG1hY2hpbmUgZGVmZXJzIHVwZGF0ZXMgYW5kIGV2ZW50IGhhbmRsaW5nIHRvIGl0cyBjaGlsZHJlblxyXG4gICAgLy8gQ2hlY2sgc3VwZXIgY2xhc3NlcyBmb3IgZGV0YWlsc1xyXG59XHJcblxyXG5leHBvcnQgZW51bSBFbmVteVN0YXRlcyB7XHJcbiAgICBERUZBVUxUID0gXCJkZWZhdWx0XCIsXHJcbiAgICBBVFRBQ0tJTkcgPSBcImF0dGFja2luZ1wiLFxyXG4gICAgREFNQUdFRCA9IFwiZGFtYWdlZFwiLFxyXG4gICAgUFJFVklPVVMgPSBcInByZXZpb3VzXCJcclxufSIsImltcG9ydCBBQUJCIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCBCYXRBSSwgeyBFbmVteVN0YXRlcyB9IGZyb20gXCIuLi9CYXRBSVwiO1xyXG5pbXBvcnQgRW5lbXlTdGF0ZSBmcm9tIFwiLi9FbmVteVN0YXRlXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0YWNrIGV4dGVuZHMgRW5lbXlTdGF0ZSB7XHJcbiAgICAvLyBUaW1lcnMgZm9yIG1hbmFnaW5nIHRoaXMgc3RhdGVcclxuICAgIGV4aXRUaW1lcjogVGltZXI7XHJcblxyXG4gICAgcmVzZXRUaW1lcjogVGltZXI7XHJcblxyXG4gICAgLy8gVGhlIGxhc3Qga25vd24gcG9zaXRpb24gb2YgdGhlIHBsYXllclxyXG4gICAgbGFzdFBsYXllclBvczogVmVjMjtcclxuXHJcbiAgICAvLyBUaGUgcmV0dXJuIG9iamVjdCBmb3IgdGhpcyBzdGF0ZVxyXG4gICAgcmV0T2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG5cclxuICAgIC8vRG9uZSBNb3ZpbmdcclxuICAgIGRvbmVNb3Zpbmc6IGJvb2xlYW47XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBCYXRBSSwgb3duZXI6IEdhbWVOb2RlKXtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIG93bmVyKTtcclxuXHJcbiAgICAgICAgLy8gUmVndWxhcmx5IHVwZGF0ZSB0aGUgcGxheWVyIGxvY2F0aW9uXHJcbiAgICAgICAgdGhpcy5leGl0VGltZXIgPSBuZXcgVGltZXIoMTAwMCk7XHJcbiAgICAgICAgdGhpcy5yZXNldFRpbWVyID0gbmV3IFRpbWVyKDMwMDApO1xyXG4gICAgfVxyXG5cclxuICAgIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucmVzZXRUaW1lci5zdGFydCgpO1xyXG4gICAgICAgICg8QW5pbWF0ZWRTcHJpdGU+IHRoaXMub3duZXIpLmFuaW1hdGlvbi5wbGF5KFwiQVRUQUNLXCIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMubGFzdFBsYXllclBvcyA9IG5ldyBWZWMyKHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCkueCwgdGhpcy5wYXJlbnQuZ2V0UGxheWVyUG9zaXRpb24oKS55KTtcclxuICAgICAgICAvLyBSZXNldCB0aGUgcmV0dXJuIG9iamVjdFxyXG4gICAgICAgIHRoaXMucmV0T2JqID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge31cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLnBhcmVudC5nZXRQbGF5ZXJQb3NpdGlvbigpICE9PSBudWxsKXtcclxuICAgICAgICAgICAgLy8gUGxheWVyIGlzIHZpc2libGUsIHJlc3RhcnQgdGhlIGV4aXRUaW1lclxyXG4gICAgICAgICAgICB0aGlzLmV4aXRUaW1lci5zdGFydCgpO1xyXG4gICAgICAgICAgICBpZighdGhpcy5kb25lTW92aW5nKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMucmVzZXRUaW1lci5pc1N0b3BwZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoRW5lbXlTdGF0ZXMuREVGQVVMVCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm93bmVyLnBvc2l0aW9uLmRpc3RhbmNlVG8odGhpcy5sYXN0UGxheWVyUG9zKSA8IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbmVNb3ZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5tb3ZlKHRoaXMub3duZXIucG9zaXRpb24uZGlyVG8odGhpcy5sYXN0UGxheWVyUG9zKS5zY2FsZSgzLjUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUaW1lci5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb25lTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RQbGF5ZXJQb3MgPSBuZXcgVmVjMih0aGlzLnBhcmVudC5nZXRQbGF5ZXJQb3NpdGlvbigpLngsIHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCkueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZXhpdFRpbWVyLmlzU3RvcHBlZCgpKXtcclxuICAgICAgICAgICAgLy8gV2UgaGF2ZW4ndCBzZWVuIHRoZSBwbGF5ZXIgaW4gYSB3aGlsZSwgZ28gY2hlY2sgb3V0IHdoZXJlIHdlIGxhc3Qgc2F3IHRoZW0sIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEVuZW15U3RhdGVzLkRFRkFVTFQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0T2JqO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBBQUJCIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCBFbmVteVN0YXRlIGZyb20gXCIuL0VuZW15U3RhdGVcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBCYXRBSSwgeyBFbmVteVN0YXRlcyB9IGZyb20gXCIuLi9CYXRBSVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGFtYWdlZCBleHRlbmRzIEVuZW15U3RhdGUge1xyXG5cclxuICAgIC8vIFRoZSBjdXJyZW50IGtub3duIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXJcclxuICAgIHBsYXllclBvczogVmVjMjtcclxuXHJcbiAgICAvLyBUaGUgbGFzdCBrbm93biBwb3NpdGlvbiBvZiB0aGUgcGxheWVyXHJcbiAgICBsYXN0UGxheWVyUG9zOiBWZWMyO1xyXG5cclxuICAgIC8vIFRoZSByZXR1cm4gb2JqZWN0IGZvciB0aGlzIHN0YXRlXHJcbiAgICByZXRPYmo6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBCYXRBSSwgb3duZXI6IEdhbWVOb2RlKXtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIG93bmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICAoPEFuaW1hdGVkU3ByaXRlPiB0aGlzLm93bmVyKS5hbmltYXRpb24ucGxheShcIkRBTUFHRVwiLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5sYXN0UGxheWVyUG9zID0gdGhpcy5wYXJlbnQuZ2V0UGxheWVyUG9zaXRpb24oKTtcclxuICAgICAgICAvLyBSZXNldCB0aGUgcmV0dXJuIG9iamVjdFxyXG4gICAgICAgIHRoaXMucmV0T2JqID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge31cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZighKDxBbmltYXRlZFNwcml0ZT4gdGhpcy5vd25lcikuYW5pbWF0aW9uLmlzUGxheWluZyhcIkRBTUFHRVwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEVuZW15U3RhdGVzLkRFRkFVTFQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICAgICAgKDxBbmltYXRlZFNwcml0ZT4gdGhpcy5vd25lcikuYW5pbWF0aW9uLnN0b3AoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXRPYmo7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IFN0YXRlIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZVwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IEVuZW15QUkgZnJvbSBcIi4uL0JhdEFJXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBFbmVteVN0YXRlIGV4dGVuZHMgU3RhdGUge1xyXG4gICAgcHJvdGVjdGVkIHBhcmVudDogRW5lbXlBSTtcclxuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBFbmVteUFJLCBvd25lcjogR2FtZU5vZGUpe1xyXG4gICAgICBzdXBlcihwYXJlbnQpO1xyXG4gICAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5pbXBvcnQgQmF0QUksIHsgRW5lbXlTdGF0ZXMgfSBmcm9tIFwiLi4vQmF0QUlcIjtcclxuaW1wb3J0IEVuZW15U3RhdGUgZnJvbSBcIi4vRW5lbXlTdGF0ZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkbGUgZXh0ZW5kcyBFbmVteVN0YXRlIHtcclxuICAgIHByaXZhdGUgc3RhcnRQb3NpdGlvbjogVmVjMjtcclxuXHJcbiAgICBwcml2YXRlIGF3YXlGcm9tU3RhcnRQb3NpdGlvbjogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIHJldE9iajogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBCYXRBSSwgb3duZXI6IEdhbWVOb2RlKXtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIG93bmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICAoPEFuaW1hdGVkU3ByaXRlPiB0aGlzLm93bmVyKS5hbmltYXRpb24ucGxheShcIklETEVcIiwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlSW5wdXQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCkgIT09IG51bGwgJiYgdGhpcy5vd25lci5wb3NpdGlvbi5kaXN0YW5jZVRvKHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCkpIDwgMjAwKXtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChFbmVteVN0YXRlcy5BVFRBQ0tJTkcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkV4aXQoKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcbiAgICAgICAgKDxBbmltYXRlZFNwcml0ZT4gdGhpcy5vd25lcikuYW5pbWF0aW9uLnN0b3AoKTtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IFN0YXRlTWFjaGluZUFJIGZyb20gXCIuLy4uL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBCYXR0bGVyQUkgZnJvbSBcIi4vQmF0dGxlckFJXCI7XHJcbmltcG9ydCBBdHRhY2sgZnJvbSBcIi4vR2x1dHRvbnlTdGF0ZXMvQXR0YWNrXCI7XHJcbmltcG9ydCBJZGxlIGZyb20gXCIuL0dsdXR0b255U3RhdGVzL0lkbGVcIjtcclxuaW1wb3J0IEJvc3NTdGF0ZSBmcm9tIFwiLi9HbHV0dG9ueVN0YXRlcy9Cb3NzU3RhdGVcIjtcclxuaW1wb3J0IERhbWFnZSBmcm9tIFwiLi9HbHV0dG9ueVN0YXRlcy9EYW1hZ2VcIjtcclxuaW1wb3J0IHsgR2FtZV9FdmVudHMgfSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvZ2FtZV9lbnVtc1wiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdsdXR0b255QUkgZXh0ZW5kcyBTdGF0ZU1hY2hpbmVBSSBpbXBsZW1lbnRzIEJhdHRsZXJBSSB7XHJcbiAgICAvKiogVGhlIG93bmVyIG9mIHRoaXMgQUkgKi9cclxuICAgIG93bmVyOiBBbmltYXRlZFNwcml0ZTtcclxuXHJcbiAgICAvKiogVGhlIGFtb3VudCBvZiBoZWFsdGggdGhpcyBlbnRpdHkgaGFzICovXHJcbiAgICBoZWFsdGg6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGRlZmF1bHQgbW92ZW1lbnQgc3BlZWQgb2YgdGhpcyBBSSAqL1xyXG4gICAgc3BlZWQ6IG51bWJlciA9IDIwO1xyXG5cclxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgcGxheWVyIG9iamVjdCAqL1xyXG4gICAgcGxheWVyOiBHYW1lTm9kZTtcclxuXHJcbiAgICBpbml0aWFsaXplQUkob3duZXI6IEFuaW1hdGVkU3ByaXRlLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJJbml0aWFsaXplIEdsdXR0b255XCIpO1xyXG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShCb3NzU3RhdGVzLkRFRkFVTFQsIG5ldyBJZGxlKHRoaXMsIG93bmVyKSk7XHJcbiAgICAgICAgdGhpcy5hZGRTdGF0ZShCb3NzU3RhdGVzLkFUVEFDS0lORywgbmV3IEF0dGFjayh0aGlzLCBvd25lcikpO1xyXG4gICAgICAgIHRoaXMuYWRkU3RhdGUoQm9zc1N0YXRlcy5EQU1BR0UsIG5ldyBEYW1hZ2UodGhpcywgb3duZXIpKTtcclxuXHJcbiAgICAgICAgdGhpcy5oZWFsdGggPSBvcHRpb25zLmhlYWx0aDtcclxuXHJcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBvcHRpb25zLnBsYXllcjtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byB0aGUgZGVmYXVsdCBzdGF0ZVxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShCb3NzU3RhdGVzLkRFRkFVTFQpO1xyXG5cclxuICAgICAgICB0aGlzLmdldFBsYXllclBvc2l0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWN0aXZhdGUob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgfVxyXG5cclxuICAgIGRhbWFnZShkYW1hZ2U6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaGVhbHRoIC09IGRhbWFnZTtcclxuICAgICAgICBcclxuICAgICAgICBpZih0aGlzLmhlYWx0aCA8PSAwKXtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5zZXRBSUFjdGl2ZShmYWxzZSwge30pO1xyXG4gICAgICAgICAgICB0aGlzLm93bmVyLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZighdGhpcy5vd25lci5hbmltYXRpb24uaXNQbGF5aW5nKFwiRFlJTkdcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXkoXCJEWUlOR1wiLCBmYWxzZSwgR2FtZV9FdmVudHMuQk9TU19ESUVEKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJkZWQgZ2x1dHRvbnlcIik7XHJcbiAgICAgICAgICAgIC8vIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXkoXCJEWUlOR1wiKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5vd25lci52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKEJvc3NTdGF0ZXMuREFNQUdFKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UGxheWVyUG9zaXRpb24oKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucGxheWVyLnBvc2l0aW9uO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG5ldyBwbGF5ZXIgbG9jYXRpb25cclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLm93bmVyLnBvc2l0aW9uLmNsb25lKCk7XHJcbiAgICAgICAgbGV0IGRlbHRhID0gcG9zLmNsb25lKCkuc3ViKHN0YXJ0KTtcclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSB0aWxlbWFwIHJlZ2lvbiB1bnRpbCB3ZSBmaW5kIGEgY29sbGlzaW9uXHJcbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihzdGFydC54LCBwb3MueCk7XHJcbiAgICAgICAgbGV0IG1heFggPSBNYXRoLm1heChzdGFydC54LCBwb3MueCk7XHJcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBwb3MueSk7XHJcbiAgICAgICAgbGV0IG1heFkgPSBNYXRoLm1heChzdGFydC55LCBwb3MueSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgd2FsbCB0aWxlbWFwXHJcbiAgICAgICAgbGV0IHdhbGxzID0gPE9ydGhvZ29uYWxUaWxlbWFwPnRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXRMYXllcihcIldhbGxcIikuZ2V0SXRlbXMoKVswXTtcclxuXHJcbiAgICAgICAgbGV0IG1pbkluZGV4ID0gd2FsbHMuZ2V0Q29sUm93QXQobmV3IFZlYzIobWluWCwgbWluWSkpO1xyXG4gICAgICAgIGxldCBtYXhJbmRleCA9IHdhbGxzLmdldENvbFJvd0F0KG5ldyBWZWMyKG1heFgsIG1heFkpKTtcclxuXHJcbiAgICAgICAgbGV0IHRpbGVTaXplID0gd2FsbHMuZ2V0VGlsZVNpemUoKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBjb2wgPSBtaW5JbmRleC54OyBjb2wgPD0gbWF4SW5kZXgueDsgY29sKyspe1xyXG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IG1pbkluZGV4Lnk7IHJvdyA8PSBtYXhJbmRleC55OyByb3crKyl7XHJcbiAgICAgICAgICAgICAgICBpZih3YWxscy5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZVBvcyA9IG5ldyBWZWMyKGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54LzIsIHJvdyAqIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55LzIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjb2xsaWRlciBmb3IgdGhpcyB0aWxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbGxpZGVyID0gbmV3IEFBQkIodGlsZVBvcywgdGlsZVNpemUuc2NhbGVkKDEvMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGl0ID0gY29sbGlkZXIuaW50ZXJzZWN0U2VnbWVudChzdGFydCwgZGVsdGEsIFZlYzIuWkVSTyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhpdCAhPT0gbnVsbCAmJiBzdGFydC5kaXN0YW5jZVNxVG8oaGl0LnBvcykgPCBzdGFydC5kaXN0YW5jZVNxVG8ocG9zKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhpdCBhIHdhbGwsIHdlIGNhbid0IHNlZSB0aGUgcGxheWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0ZSBtYWNoaW5lIGRlZmVycyB1cGRhdGVzIGFuZCBldmVudCBoYW5kbGluZyB0byBpdHMgY2hpbGRyZW5cclxuICAgIC8vIENoZWNrIHN1cGVyIGNsYXNzZXMgZm9yIGRldGFpbHNcclxufVxyXG5cclxuZXhwb3J0IGVudW0gQm9zc1N0YXRlcyB7XHJcbiAgICBERUZBVUxUID0gXCJkZWZhdWx0XCIsXHJcbiAgICBEQU1BR0UgPSBcImRhbWFnZVwiLFxyXG4gICAgQVRUQUNLSU5HID0gXCJhdHRhY2tpbmdcIixcclxuICAgIFBSRVZJT1VTID0gXCJwcmV2aW91c1wiLFxyXG4gICAgRFlJTkcgPSBcImR5aW5nXCJcclxufSIsImltcG9ydCBBQUJCIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCBCb3NzU3RhdGUgZnJvbSBcIi4vQm9zc1N0YXRlXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgR2x1dHRvbnlBSSwgeyBCb3NzU3RhdGVzIH0gZnJvbSBcIi4uL0dsdXR0b255QUlcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dGFjayBleHRlbmRzIEJvc3NTdGF0ZSB7XHJcbiAgICAvLyBUaW1lcnMgZm9yIG1hbmFnaW5nIHRoaXMgc3RhdGVcclxuICAgIHBvbGxUaW1lcjogVGltZXI7XHJcbiAgICBleGl0VGltZXI6IFRpbWVyO1xyXG5cclxuICAgIC8vIFRoZSBjdXJyZW50IGtub3duIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXJcclxuICAgIHBsYXllclBvczogVmVjMjtcclxuXHJcbiAgICAvLyBUaGUgbGFzdCBrbm93biBwb3NpdGlvbiBvZiB0aGUgcGxheWVyXHJcbiAgICBsYXN0UGxheWVyUG9zOiBWZWMyO1xyXG5cclxuICAgIC8vIFRoZSByZXR1cm4gb2JqZWN0IGZvciB0aGlzIHN0YXRlXHJcbiAgICByZXRPYmo6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcblxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBHbHV0dG9ueUFJLCBvd25lcjogR2FtZU5vZGUpe1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgb3duZXIpO1xyXG5cclxuICAgICAgICAvLyBSZWd1bGFybHkgdXBkYXRlIHRoZSBwbGF5ZXIgbG9jYXRpb25cclxuICAgICAgICB0aGlzLnBvbGxUaW1lciA9IG5ldyBUaW1lcigxMDApO1xyXG5cclxuICAgICAgICB0aGlzLmV4aXRUaW1lciA9IG5ldyBUaW1lcigxMDAwKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICAoPEFuaW1hdGVkU3ByaXRlPiB0aGlzLm93bmVyKS5hbmltYXRpb24ucGxheShcIkFUVEFDS1wiLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmxhc3RQbGF5ZXJQb3MgPSB0aGlzLnBhcmVudC5nZXRQbGF5ZXJQb3NpdGlvbigpO1xyXG4gICAgICAgIC8vIFJlc2V0IHRoZSByZXR1cm4gb2JqZWN0XHJcbiAgICAgICAgdGhpcy5yZXRPYmogPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7fVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMucG9sbFRpbWVyLmlzU3RvcHBlZCgpKXtcclxuICAgICAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXJcclxuICAgICAgICAgICAgdGhpcy5wb2xsVGltZXIuc3RhcnQoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucGxheWVyUG9zID0gdGhpcy5wYXJlbnQuZ2V0UGxheWVyUG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMucGxheWVyUG9zICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHNlZSBhIG5ldyBwbGF5ZXIgcG9zaXRpb24sIHVwZGF0ZSB0aGUgbGFzdCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UGxheWVyUG9zID0gdGhpcy5wbGF5ZXJQb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCkgIT09IG51bGwgJiYgdGhpcy5vd25lci5wb3NpdGlvbi5kaXN0YW5jZVRvKHRoaXMucGFyZW50LmdldFBsYXllclBvc2l0aW9uKCkpIDwgMjAwKXtcclxuICAgICAgICAgICAgLy8gUGxheWVyIGlzIG5lYXJieSwgcmVzdGFydCB0aGUgZXhpdFRpbWVyXHJcbiAgICAgICAgICAgIHRoaXMuZXhpdFRpbWVyLnN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLmV4aXRUaW1lci5pc1N0b3BwZWQoKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWQoQm9zc1N0YXRlcy5ERUZBVUxUKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldE9iajtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgU3RhdGUgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1N0YXRlL1N0YXRlXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgRW5lbXlBSSBmcm9tIFwiLi4vQmF0QUlcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEJvc3NTdGF0ZSBleHRlbmRzIFN0YXRlIHtcclxuICAgIHByb3RlY3RlZCBwYXJlbnQ6IEVuZW15QUk7XHJcbiAgICBwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogRW5lbXlBSSwgb3duZXI6IEdhbWVOb2RlKXtcclxuICAgICAgc3VwZXIocGFyZW50KTtcclxuICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEFBQkIgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4vLi4vLi4vV29sZmllMkQvTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9UaW1pbmcvVGltZXJcIjtcclxuaW1wb3J0IEJvc3NTdGF0ZSBmcm9tIFwiLi9Cb3NzU3RhdGVcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBHbHV0dG9ueUFJLCB7IEJvc3NTdGF0ZXMgfSBmcm9tIFwiLi4vR2x1dHRvbnlBSVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGFtYWdlIGV4dGVuZHMgQm9zc1N0YXRlIHtcclxuXHJcbiAgICAvLyBUaGUgcmV0dXJuIG9iamVjdCBmb3IgdGhpcyBzdGF0ZVxyXG4gICAgcmV0T2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhcmVudDogR2x1dHRvbnlBSSwgb3duZXI6IEdhbWVOb2RlKXtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIG93bmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICAoPEFuaW1hdGVkU3ByaXRlPiB0aGlzLm93bmVyKS5hbmltYXRpb24ucGxheShcIkRBTUFHRVwiLCBmYWxzZSk7XHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIHJldHVybiBvYmplY3RcclxuICAgICAgICB0aGlzLnJldE9iaiA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZUlucHV0KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHt9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYoISg8QW5pbWF0ZWRTcHJpdGU+IHRoaXMub3duZXIpLmFuaW1hdGlvbi5pc1BsYXlpbmcoXCJEQU1BR0VcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hlZChCb3NzU3RhdGVzLkFUVEFDS0lORyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uRXhpdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuICAgICAgICAoPEFuaW1hdGVkU3ByaXRlPiB0aGlzLm93bmVyKS5hbmltYXRpb24uc3RvcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldE9iajtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLy4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi8uLi8uLi9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5pbXBvcnQgQm9zc1N0YXRlIGZyb20gXCIuL0Jvc3NTdGF0ZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IEdsdXR0b255QUksIHsgQm9zc1N0YXRlcyB9IGZyb20gXCIuLi9HbHV0dG9ueUFJXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZGxlIGV4dGVuZHMgQm9zc1N0YXRlIHtcclxuICAgIHByaXZhdGUgc3RhcnRQb3NpdGlvbjogVmVjMjtcclxuXHJcbiAgICBwcml2YXRlIGF3YXlGcm9tU3RhcnRQb3NpdGlvbjogYm9vbGVhbjtcclxuXHJcbiAgICBwcml2YXRlIHJldE9iajogUmVjb3JkPHN0cmluZywgYW55PjtcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBHbHV0dG9ueUFJLCBvd25lcjogR2FtZU5vZGUpe1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgb3duZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uRW50ZXIob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgICg8QW5pbWF0ZWRTcHJpdGU+IHRoaXMub3duZXIpLmFuaW1hdGlvbi5wbGF5KFwiSURMRVwiLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5wYXJlbnQuZ2V0UGxheWVyUG9zaXRpb24oKSAhPT0gbnVsbCAmJiB0aGlzLm93bmVyLnBvc2l0aW9uLmRpc3RhbmNlVG8odGhpcy5wYXJlbnQuZ2V0UGxheWVyUG9zaXRpb24oKSkgPCAyMDApe1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkKEJvc3NTdGF0ZXMuQVRUQUNLSU5HKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG4gICAgICAgICg8QW5pbWF0ZWRTcHJpdGU+IHRoaXMub3duZXIpLmFuaW1hdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0T2JqO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBTdGF0ZU1hY2hpbmVBSSBmcm9tIFwiLi4vV29sZmllMkQvQUkvU3RhdGVNYWNoaW5lQUlcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgSW5wdXRIYW5kbGVyIGZyb20gXCIuLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dEhhbmRsZXJcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCBJdGVtIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9JdGVtXCI7XHJcbmltcG9ydCBXZWFwb24gZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL1dlYXBvblwiO1xyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuL0JhdHRsZXJBSVwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vV29sZmllMkQvRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IHsgR2FtZV9FdmVudHMgfSBmcm9tIFwiLi4vR2FtZVN5c3RlbXMvZ2FtZV9lbnVtc1wiXHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcblxyXG5leHBvcnQgZW51bSBQbGF5ZXJTdGF0ZXMge1xyXG4gICAgSURMRSA9IFwiaWRsZVwiLFxyXG4gICAgV0FMSyA9IFwid2Fsa1wiLFxyXG4gICAgQVRUQUNLID0gXCJhdHRhY2tcIixcclxuICAgIERBTUFHRSA9IFwiZGFtYWdlXCJcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyQ29udHJvbGxlciBpbXBsZW1lbnRzIEJhdHRsZXJBSSB7XHJcbiAgICAvLyBmaWVsZHMgZnJvbSBCYXR0bGVyQUlcclxuICAgIGhlYWx0aDogbnVtYmVyO1xyXG4gICAgaGVhbHRoX3Nwcml0ZXM6IFNwcml0ZVtdO1xyXG5cclxuICAgIC8vIHBsYXllciBzcHJpdGVcclxuICAgIG93bmVyOiBBbmltYXRlZFNwcml0ZTtcclxuXHJcbiAgICAvLyBmaXN0IGl0ZW0gKGZvciBwdW5jaGluZylcclxuICAgIGZpc3Q6IFdlYXBvbjtcclxuXHJcbiAgICAvLyBNb3ZlbWVudFxyXG4gICAgZGlyZWN0aW9uOiBWZWMyO1xyXG4gICAgY3Vycl92ZWxvY2l0eTogVmVjMjtcclxuICAgIHNwZWVkOiBudW1iZXI7XHJcblxyXG4gICAgLy8gQXR0YWNraW5nXHJcbiAgICBhdHRhY2tfZGlyZWN0aW9uOiBWZWMyO1xyXG5cclxuICAgIC8vIGNvaW4gY291bnRcclxuICAgIGNvaW5zOiBudW1iZXI7XHJcblxyXG4gICAgLy8gdW5pcXVlIGxldmVsIGZ1bmN0aW9uYWxpdGllc1xyXG4gICAgc2xpcHBlcnk6IGJvb2xlYW47XHJcblxyXG4gICAgLy8gZm9yIGktZnJhbWVzXHJcbiAgICBpbnZpbmNpYmxlOiBib29sZWFuO1xyXG5cclxuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAgIGluaXRpYWxpemVBSShvd25lcjogQW5pbWF0ZWRTcHJpdGUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm93bmVyID0gb3duZXJcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IFZlYzIuWkVSTztcclxuICAgICAgICB0aGlzLmN1cnJfdmVsb2NpdHkgPSBWZWMyLlpFUk87ICAgICAgICAgLy8gZm9yIHVzZSB3aXRoIHNsaXBwZXJ5IG1vdmVtZW50XHJcbiAgICAgICAgdGhpcy5hdHRhY2tfZGlyZWN0aW9uID0gVmVjMi5aRVJPO1xyXG4gICAgICAgIHRoaXMuc3BlZWQgPSBvcHRpb25zLnNwZWVkO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5oZWFsdGhfc3ByaXRlcyA9IG9wdGlvbnMuaGVhbHRoX3Nwcml0ZXM7XHJcbiAgICAgICAgdGhpcy5oZWFsdGggPSBvcHRpb25zLmhlYWx0aDtcclxuICAgICAgICB0aGlzLmNvaW5zID0gb3B0aW9ucy5jb2lucztcclxuICAgICAgICB0aGlzLnNsaXBwZXJ5ID0gb3B0aW9ucy5zbGlwcGVyeSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zbGlwcGVyeSA6IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZmlzdCA9IG9wdGlvbnMuZmlzdDtcclxuICAgIH1cclxuXHJcbiAgICBhY3RpdmF0ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG5cclxuICAgIGhhbmRsZUV2ZW50KGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lX0V2ZW50cy5CQVRfQ09MTElTSU9OKSB7XHJcbiAgICAgICAgICAgIC8vIHRha2UgMSBkYW1hZ2VcclxuICAgICAgICAgICAgdGhpcy5kYW1hZ2UoMSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW52aW5jaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZXZlbnQudHlwZSA9PT0gR2FtZV9FdmVudHMuQk9TU19DT0xMSVNJT04pIHtcclxuICAgICAgICAgICAgLy8gdGFrZSAxIGRhbWFnZVxyXG4gICAgICAgICAgICB0aGlzLmRhbWFnZSgxKTtcclxuICAgICAgICAgICAgdGhpcy5pbnZpbmNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihldmVudC50eXBlID09PSBHYW1lX0V2ZW50cy5JRlJBTUVTX09WRVIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJub3QgaW52aW5jaWJsZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5pbnZpbmNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIC8vIGdldCB0aGUgbW92ZW1lbnQgZGlyZWN0aW9uXHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24ueCA9IChJbnB1dC5pc1ByZXNzZWQoXCJsZWZ0XCIpID8gLTEgOiAwKSArIChJbnB1dC5pc1ByZXNzZWQoXCJyaWdodFwiKSA/IDEgOiAwKTtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbi55ID0gKElucHV0LmlzUHJlc3NlZChcInVwXCIpID8gLTEgOiAwKSArIChJbnB1dC5pc1ByZXNzZWQoXCJkb3duXCIpID8gMSA6IDApO1xyXG5cclxuICAgICAgICBsZXQgZG9udF9pbnRlcnJ1cHQ6IGJvb2xlYW4gPSB0aGlzLm93bmVyLmFuaW1hdGlvbi5pc1BsYXlpbmcoXCJBVFRBQ0tcIikgfHwgdGhpcy5vd25lci5hbmltYXRpb24uaXNQbGF5aW5nKFwiREFNQUdFXCIpO1xyXG5cclxuICAgICAgICBpZighdGhpcy5kaXJlY3Rpb24uaXNaZXJvKCkgJiYgIXRoaXMub3duZXIuYW5pbWF0aW9uLmlzUGxheWluZyhcIkFUVEFDS1wiKSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLnNsaXBwZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzbGlwcGVyeSBtb3ZlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kaXJlY3Rpb24ueCAhPT0gMCkge3RoaXMuY3Vycl92ZWxvY2l0eS54ICs9IHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS54IC8gMjA7fVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7dGhpcy5jdXJyX3ZlbG9jaXR5LnggLT0gdGhpcy5jdXJyX3ZlbG9jaXR5Lm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS54IC8gNDA7fVxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kaXJlY3Rpb24ueSAhPT0gMCkge3RoaXMuY3Vycl92ZWxvY2l0eS55ICs9IHRoaXMuZGlyZWN0aW9uLm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS55IC8gMjA7fVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7dGhpcy5jdXJyX3ZlbG9jaXR5LnkgLT0gdGhpcy5jdXJyX3ZlbG9jaXR5Lm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS55IC8gNDA7fVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMub3duZXIubW92ZSh0aGlzLmN1cnJfdmVsb2NpdHkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIG1vdmVtZW50XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLm1vdmUodGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplZCgpLnNjYWxlKHRoaXMuc3BlZWQgKiBkZWx0YVQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWRvbnRfaW50ZXJydXB0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5SWZOb3RBbHJlYWR5KFwiV0FMS1wiLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBtb3ZlbWVudCBpbnB1dFxyXG4gICAgICAgICAgICBpZih0aGlzLnNsaXBwZXJ5ICYmIChNYXRoLmFicyh0aGlzLmN1cnJfdmVsb2NpdHkueCkgPiAwIHx8IE1hdGguYWJzKHRoaXMuY3Vycl92ZWxvY2l0eS55KSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzbGlkZSBhIGJpdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyX3ZlbG9jaXR5LnggLT0gdGhpcy5jdXJyX3ZlbG9jaXR5Lm5vcm1hbGl6ZWQoKS5zY2FsZSh0aGlzLnNwZWVkICogZGVsdGFUKS54IC8gNDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJfdmVsb2NpdHkueSAtPSB0aGlzLmN1cnJfdmVsb2NpdHkubm9ybWFsaXplZCgpLnNjYWxlKHRoaXMuc3BlZWQgKiBkZWx0YVQpLnkgLyA0MDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyh0aGlzLmN1cnJfdmVsb2NpdHkueCkgPCAuMDUpIHt0aGlzLmN1cnJfdmVsb2NpdHkueCA9IDA7fVxyXG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnModGhpcy5jdXJyX3ZlbG9jaXR5LnkpIDwgLjA1KSB7dGhpcy5jdXJyX3ZlbG9jaXR5LnkgPSAwO31cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLm1vdmUodGhpcy5jdXJyX3ZlbG9jaXR5KTtcclxuICAgICAgICAgICAgICAgIGlmKCFkb250X2ludGVycnVwdCkge3RoaXMub3duZXIuYW5pbWF0aW9uLnBsYXlJZk5vdEFscmVhZHkoXCJJRExFXCIsIHRydWUpO31cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHBsYXkgaWRsZSBhbmltYXRpb25cclxuICAgICAgICAgICAgICAgIGlmKCFkb250X2ludGVycnVwdCkge3RoaXMub3duZXIuYW5pbWF0aW9uLnBsYXlJZk5vdEFscmVhZHkoXCJJRExFXCIsIHRydWUpO31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB1bml0IHZlY3RvciBpbiB0aGUgYXR0YWNrIGRpcmVjdGlvblxyXG4gICAgICAgIHRoaXMuYXR0YWNrX2RpcmVjdGlvbiA9IHRoaXMub3duZXIucG9zaXRpb24uZGlyVG8oSW5wdXQuZ2V0R2xvYmFsTW91c2VQb3NpdGlvbigpKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHJvdGF0aW9uIGZvciBhdHRhY2tpbmdcclxuICAgICAgICB0aGlzLm93bmVyLmF0dGFja19kaXJlY3Rpb24gPSBWZWMyLlVQLmFuZ2xlVG9DQ1codGhpcy5hdHRhY2tfZGlyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gcHVuY2ggYXR0YWNrXHJcbiAgICAgICAgaWYoIXRoaXMub3duZXIuYW5pbWF0aW9uLmlzUGxheWluZyhcIkFUVEFDS1wiKSAmJiBJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBpbXBsZW1lbnQgcHVuY2ggYXR0YWNrIGhlcmVcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBhdHRhY2tfc3VjY2VzcyA9IHRoaXMuZmlzdC51c2UodGhpcy5vd25lciwgXCJwbGF5ZXJcIiwgdGhpcy5hdHRhY2tfZGlyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGF0dGFja19zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInB1bmNoIGV2ZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheShcIkFUVEFDS1wiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGhhdmUgcGxheWVyIGZhY2UgbGVmdCBvciByaWdodFxyXG4gICAgICAgIGlmKCF0aGlzLm93bmVyLmFuaW1hdGlvbi5pc1BsYXlpbmcoXCJBVFRBQ0tcIikpIHtcclxuICAgICAgICAgICAgbGV0IG1vdXNlX3Bvc2l0aW9uID0gSW5wdXQuZ2V0R2xvYmFsTW91c2VQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICBpZihtb3VzZV9wb3NpdGlvbi54IDwgdGhpcy5vd25lci5wb3NpdGlvbi54KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLmludmVydFggPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vd25lci5pbnZlcnRYID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGFtYWdlKGRhbWFnZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYoIXRoaXMuaW52aW5jaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aCAtPSBkYW1hZ2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoX3Nwcml0ZXNbdGhpcy5oZWFsdGhfc3ByaXRlcy5sZW5ndGggLSAxXS5nZXRMYXllcigpLnJlbW92ZU5vZGUodGhpcy5oZWFsdGhfc3ByaXRlc1t0aGlzLmhlYWx0aF9zcHJpdGVzLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGhfc3ByaXRlcy5zcGxpY2UodGhpcy5oZWFsdGhfc3ByaXRlcy5sZW5ndGggLSAxLCAxKTtcclxuICAgICAgICAgICAgaWYodGhpcy5oZWFsdGggPD0gMCl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdhbWUgT3ZlclwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoR2FtZV9FdmVudHMuR0FNRV9PVkVSLCB7fSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5KFwiREFNQUdFXCIsIGZhbHNlLCBHYW1lX0V2ZW50cy5JRlJBTUVTX09WRVIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnZpbmNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW52aW5jaWJsZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm93bmVyO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuLi9BSS9CYXR0bGVyQUlcIjtcclxuaW1wb3J0IFdlYXBvbiBmcm9tIFwiLi9XZWFwb25cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhdHRsZU1hbmFnZXIge1xyXG4gICAgcGxheWVyOiBCYXR0bGVyQUk7XHJcblxyXG4gICAgZW5lbWllczogQXJyYXk8QmF0dGxlckFJPjtcclxuXHJcbiAgICBoYW5kbGVJbnRlcmFjdGlvbihhdHRhY2tlclR5cGU6IHN0cmluZywgd2VhcG9uOiBXZWFwb24pe1xyXG4gICAgICAgIGlmKGF0dGFja2VyVHlwZSA9PT0gXCJwbGF5ZXJcIil7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjb2xsaXNpb25zIHdpdGggZW5lbWllc1xyXG4gICAgICAgICAgICBmb3IobGV0IGVuZW15IG9mIHRoaXMuZW5lbWllcyl7XHJcbiAgICAgICAgICAgICAgICBpZih3ZWFwb24uaGl0cyhlbmVteS5vd25lcikpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZW15LmRhbWFnZSh3ZWFwb24udHlwZS5kYW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbGxpc2lvbiB3aXRoIHBsYXllclxyXG4gICAgICAgICAgICBpZih3ZWFwb24uaGl0cyh0aGlzLnBsYXllci5vd25lcikpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIuZGFtYWdlKHdlYXBvbi50eXBlLmRhbWFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGxheWVyKHBsYXllcjogQmF0dGxlckFJKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RW5lbWllcyhlbmVtaWVzOiBBcnJheTxCYXR0bGVyQUk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5lbmVtaWVzID0gZW5lbWllcztcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBJdGVtIHtcclxuICAgIC8qKiBUaGUgc3ByaXRlIHRoYXQgcmVwcmVzZW50cyB0aGlzIHdlYXBvbiBpbiB0aGUgd29ybGQgb3IgaW4gYW4gaW52ZW50b3J5ICovXHJcbiAgICBzcHJpdGU6IFNwcml0ZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGU6IFNwcml0ZSl7XHJcbiAgICAgICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XHJcbiAgICB9XHJcblxyXG4gICAgbW92ZVNwcml0ZShwb3NpdGlvbjogVmVjMiwgbGF5ZXI/OiBzdHJpbmcpe1xyXG4gICAgICAgIC8vIENoYW5nZSB0aGUgbGF5ZXIgaWYgbmVlZGVkXHJcbiAgICAgICAgaWYobGF5ZXIpe1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudExheWVyID0gdGhpcy5zcHJpdGUuZ2V0TGF5ZXIoKTtcclxuICAgICAgICAgICAgY3VycmVudExheWVyLnJlbW92ZU5vZGUodGhpcy5zcHJpdGUpO1xyXG4gICAgICAgICAgICBsZXQgbmV3TGF5ZXIgPSB0aGlzLnNwcml0ZS5nZXRTY2VuZSgpLmdldExheWVyKGxheWVyKTtcclxuICAgICAgICAgICAgbmV3TGF5ZXIuYWRkTm9kZSh0aGlzLnNwcml0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnNldExheWVyKG5ld0xheWVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1vdmUgdGhlIHNwcml0ZVxyXG4gICAgICAgIHRoaXMuc3ByaXRlLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGFic3RyYWN0IHVzZSh1c2VyOiBHYW1lTm9kZSwgLi4uYXJnczogYW55KTogdm9pZDtcclxufSIsImltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi4vLi4vV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cmllcy9SZWdpc3RyeVwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBXZWFwb25UeXBlIGZyb20gXCIuLi9XZWFwb25UeXBlcy9XZWFwb25UeXBlXCI7XHJcbmltcG9ydCBQdW5jaCBmcm9tIFwiLi4vV2VhcG9uVHlwZXMvUHVuY2hcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYXBvblJlZ2lzdHJ5IGV4dGVuZHMgUmVnaXN0cnk8V2VhcG9uQ29uc3RydWN0b3I+IHtcclxuICAgIHB1YmxpYyBwcmVsb2FkKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHJtID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgICAgIHJtLmltYWdlKFwiZmlzdFwiLCBcImdhbWVfYXNzZXRzL2ltYWdlcy9zcGxhc2hfc2NyZWVuLnBuZ1wiKTtcclxuXHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIC8vIGxvYWQgc3ByaXRlc2hlZXRzXHJcbiAgICAgICAgLy8gVE9ETyBQUk9KRUNUIC0gaW1wb3J0IHB1bmNoIHNwcml0ZXNoZWV0XHJcbiAgICAgICAgcm0uc3ByaXRlc2hlZXQoXCJmaXN0XCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlc2hlZXRzL2ltcGFjdC5qc29uXCIpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcImxvYWRlZCBzcHJpdGVcIik7XHJcblxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJJdGVtKFwiZmlzdFwiLCBQdW5jaCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHt9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVySXRlbShrZXk6IHN0cmluZywgY29uc3RyOiBXZWFwb25Db25zdHJ1Y3Rvcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYWRkKGtleSwgY29uc3RyKTtcclxuICAgIH1cclxufVxyXG5cclxudHlwZSBXZWFwb25Db25zdHJ1Y3RvciA9IG5ldyAoLi4uYXJnczogYW55KSA9PiBXZWFwb25UeXBlOyIsImltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi4vLi4vV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cmllcy9SZWdpc3RyeVwiO1xyXG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi4vV2VhcG9uVHlwZXMvV2VhcG9uVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2VhcG9uVHlwZVJlZ2lzdHJ5IGV4dGVuZHMgUmVnaXN0cnk8V2VhcG9uVHlwZT4ge1xyXG4gICAgXHJcbiAgICBwdWJsaWMgcHJlbG9hZCgpOiB2b2lkIHt9XHJcblxyXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0aGlzIGZvciB0aGlzIGFzc2lnbm1lbnRcclxuICAgIHB1YmxpYyByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7fVxyXG5cclxuICAgIHB1YmxpYyByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIHR5cGU6IFdlYXBvblR5cGUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFkZChrZXksIHR5cGUpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9Xb2xmaWUyRC9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi4vV29sZmllMkQvVGltaW5nL1RpbWVyXCI7XHJcbmltcG9ydCBCYXR0bGVNYW5hZ2VyIGZyb20gXCIuL0JhdHRsZU1hbmFnZXJcIjtcclxuaW1wb3J0IEl0ZW0gZnJvbSBcIi4vSXRlbVwiO1xyXG5pbXBvcnQgV2VhcG9uVHlwZSBmcm9tIFwiLi9XZWFwb25UeXBlcy9XZWFwb25UeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWFwb24gZXh0ZW5kcyBJdGVtIHtcclxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIHdlYXBvbiAqL1xyXG4gICAgdHlwZTogV2VhcG9uVHlwZTtcclxuXHJcbiAgICAvKiogQSBsaXN0IG9mIGFzc2V0cyB0aGlzIHdlYXBvbiBuZWVkcyB0byBiZSBhbmltYXRlZCAqL1xyXG4gICAgYXNzZXRzOiBBcnJheTxhbnk+O1xyXG5cclxuICAgIC8qKiBBbiBldmVudCBlbWl0dGVyIHRvIGhvb2sgaW50byB0aGUgRXZlbnRRdWV1ZSAqL1xyXG4gICAgZW1pdHRlcjogRW1pdHRlclxyXG5cclxuICAgIC8qKiBUaGUgYmF0dGxlIG1hbmFnZXIgKi9cclxuICAgIGJhdHRsZU1hbmFnZXI6IEJhdHRsZU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSBjb29sZG93biB0aW1lciBmb3IgdGhpcyB3ZWFwb24ncyB1c2UgKi9cclxuICAgIGNvb2xkb3duVGltZXI6IFRpbWVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNwcml0ZTogU3ByaXRlLCB0eXBlOiBXZWFwb25UeXBlLCBiYXR0bGVNYW5hZ2VyOiBCYXR0bGVNYW5hZ2VyKXtcclxuICAgICAgICBzdXBlcihzcHJpdGUpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHdlYXBvbiB0eXBlXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3ByaXRlIG9mIHRoaXMgd2VhcG9uXHJcbiAgICAgICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XHJcblxyXG4gICAgICAgIC8vIFJlbHkgb24gdGhlIHdlYXBvbiB0eXBlIHRvIGNyZWF0ZSBhbnkgbmVjZXNzYXJ5IGFzc2V0c1xyXG4gICAgICAgIHRoaXMuYXNzZXRzID0gdGhpcy50eXBlLmNyZWF0ZVJlcXVpcmVkQXNzZXRzKHRoaXMuc3ByaXRlLmdldFNjZW5lKCkpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgZW1pdHRlclxyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcblxyXG4gICAgICAgIC8vIFNhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGJhdHRsZXIgbWFuYWdlclxyXG4gICAgICAgIHRoaXMuYmF0dGxlTWFuYWdlciA9IGJhdHRsZU1hbmFnZXI7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgY29vbGRvd24gdGltZXJcclxuICAgICAgICB0aGlzLmNvb2xkb3duVGltZXIgPSBuZXcgVGltZXIodHlwZS5jb29sZG93bik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICAvKipcclxuICAgICAqIFVzZXMgdGhpcyB3ZWFwb24gaW4gdGhlIHNwZWNpZmllZCBkaXJlY3Rpb24uXHJcbiAgICAgKiBUaGlzIG9ubHkgd29ya3MgaWYgdGhlIGNvb2xkb3duIHRpbWVyIGhhcyBlbmRlZFxyXG4gICAgICovXHJcbiAgICB1c2UodXNlcjogR2FtZU5vZGUsIHVzZXJUeXBlOiBzdHJpbmcsIGRpcmVjdGlvbjogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIElmIHRoZSBjb29sZG93biB0aW1lciBpcyBzdGlsbCBydW5uaW5nLCB3ZSBjYW4ndCB1c2UgdGhlIHdlYXBvblxyXG4gICAgICAgIGlmKCF0aGlzLmNvb2xkb3duVGltZXIuaXNTdG9wcGVkKCkpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBhIHR5cGUgc3BlY2lmaWMgd2VhcG9uIGFuaW1hdGlvblxyXG4gICAgICAgIHRoaXMudHlwZS5kb0FuaW1hdGlvbih1c2VyLCBkaXJlY3Rpb24sIC4uLnRoaXMuYXNzZXRzKTtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgZGFtYWdlXHJcbiAgICAgICAgdGhpcy5iYXR0bGVNYW5hZ2VyLmhhbmRsZUludGVyYWN0aW9uKHVzZXJUeXBlLCB0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCBvdXQgYW4gZXZlbnQgdG8gYWxlcnQgZW5lbWllc1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoXCJQVU5DSFwiLCB7cG9zaXRpb246IHVzZXIucG9zaXRpb24uY2xvbmUoKSwgdm9sdW1lOiB0aGlzLnR5cGUudXNlX3ZvbHVtZX0pO1xyXG4gICAgXHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIGNvb2xkb3duIHRpbWVyXHJcbiAgICAgICAgdGhpcy5jb29sZG93blRpbWVyLnN0YXJ0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjaGVjayBmb3Igd2hldGhlciBvciBub3QgdGhpcyB3ZWFwb24gaGl0IGEgbm9kZVxyXG4gICAgICovXHJcbiAgICBoaXRzKG5vZGU6IEdhbWVOb2RlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5oaXRzKG5vZGUsIC4uLnRoaXMuYXNzZXRzKTtcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBXZWFwb25UeXBlIGZyb20gXCIuL1dlYXBvblR5cGVcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdW5jaCBleHRlbmRzIFdlYXBvblR5cGUge1xyXG4gICAgc3ByaXRlX2tleTogc3RyaW5nO1xyXG4gICAgZGFtYWdlOiBudW1iZXI7XHJcbiAgICBkaXNwbGF5X25hbWU6IHN0cmluZztcclxuICAgIGNvb2xkb3duOiBudW1iZXI7XHJcbiAgICB1c2Vfdm9sdW1lOiBudW1iZXI7XHJcblxyXG4gICAgaW5pdGlhbGl6ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kYW1hZ2UgPSBvcHRpb25zLmRhbWFnZTtcclxuICAgICAgICB0aGlzLmNvb2xkb3duID0gb3B0aW9ucy5jb29sZG93bjtcclxuICAgICAgICB0aGlzLmRpc3BsYXlfbmFtZSA9IG9wdGlvbnMuZGlzcGxheU5hbWU7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVfa2V5ID0gb3B0aW9ucy5zcHJpdGVLZXk7XHJcbiAgICAgICAgdGhpcy51c2Vfdm9sdW1lID0gb3B0aW9ucy51c2VWb2x1bWU7XHJcbiAgICB9XHJcblxyXG4gICAgZG9BbmltYXRpb24oYXR0YWNrZXI6IEdhbWVOb2RlLCBkaXJlY3Rpb246IFZlYzIsIHB1bmNoX3Nwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcclxuICAgICAgICAvLyByb3RhdGUgdGhpcyB3aXRoIHRoZSBnYW1lIG5vZGVcclxuICAgICAgICBwdW5jaF9zcHJpdGUucm90YXRpb24gPSBhdHRhY2tlci5hdHRhY2tfZGlyZWN0aW9uO1xyXG5cclxuICAgICAgICAvLyBtb3ZlIHRoZSBwdW5jaCBvdXQgZnJvbSB0aGUgcGxheWVyXHJcbiAgICAgICAgcHVuY2hfc3ByaXRlLnBvc2l0aW9uID0gYXR0YWNrZXIucG9zaXRpb24uY2xvbmUoKS5hZGQoZGlyZWN0aW9uLnNjYWxlZCgzMCkpO1xyXG5cclxuICAgICAgICAvLyBwbGF5IHRoZSBwdW5jaCBhbmltYXRpb24gYnV0IHF1ZXVlIHRoZSBub3JtYWwgYW5pbWF0aW9uXHJcbiAgICAgICAgcHVuY2hfc3ByaXRlLmFuaW1hdGlvbi5wbGF5KFwiUFVOQ0hcIik7XHJcbiAgICAgICAgcHVuY2hfc3ByaXRlLmFuaW1hdGlvbi5xdWV1ZShcIk5PUk1BTFwiLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVSZXF1aXJlZEFzc2V0cyhzY2VuZTogU2NlbmUpOiBbQW5pbWF0ZWRTcHJpdGVdIHtcclxuICAgICAgICBsZXQgcHVuY2ggPSBzY2VuZS5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJmaXN0XCIsIFwicHJpbWFyeVwiKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhwdW5jaC5nZXRMYXllcigpKTtcclxuICAgICAgICBwdW5jaC5hbmltYXRpb24ucGxheShcIk5PUk1BTFwiLCB0cnVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFtwdW5jaF07XHJcbiAgICB9XHJcblxyXG4gICAgaGl0cyhub2RlOiBHYW1lTm9kZSwgcHVuY2hfc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBwdW5jaF9zcHJpdGUuYm91bmRhcnkub3ZlcmxhcHMobm9kZS5jb2xsaXNpb25TaGFwZSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFdlYXBvblR5cGUge1xyXG4gICAgc3ByaXRlX2tleTogc3RyaW5nO1xyXG4gICAgZGFtYWdlOiBudW1iZXI7XHJcbiAgICBkaXNwbHlfbmFtZTogc3RyaW5nO1xyXG4gICAgY29vbGRvd246IG51bWJlcjtcclxuICAgIHVzZV92b2x1bWU6IG51bWJlcjtcclxuXHJcbiAgICBhYnN0cmFjdCBpbml0aWFsaXplKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xyXG4gICAgYWJzdHJhY3QgZG9BbmltYXRpb24oLi4uYXJnczogYW55KTogdm9pZDtcclxuICAgIGFic3RyYWN0IGNyZWF0ZVJlcXVpcmVkQXNzZXRzKHNjZW5lOiBTY2VuZSk6IEFycmF5PGFueT47XHJcbiAgICBhYnN0cmFjdCBoaXRzKG5vZGU6IEdhbWVOb2RlLCAuLi5hcmdzOiBhbnkpOiBib29sZWFuO1xyXG59IiwiZXhwb3J0IGVudW0gR2FtZV9FdmVudHMge1xyXG4gICAgRU5FTVlfRElFRCA9IFwiRW5lbXlEaWVkXCIsXHJcbiAgICBFTkVNWV9EQU1BR0VEID0gXCJFbmVteURhbWFnZWRcIixcclxuICAgIEJPU1NfREFNQUdFRCA9IFwiQm9zc0RhbWFnZWRcIixcclxuICAgIEJPU1NfRElFRCA9IFwiQm9zc0RpZWRcIixcclxuICAgIEJBVF9DT0xMSVNJT04gPSBcIkJhdENvbGxpc2lvblwiLFxyXG4gICAgR0FNRV9PVkVSID0gXCJHYW1lT3ZlclwiLFxyXG4gICAgSUZSQU1FU19PVkVSID0gXCJJZnJhbWVzT3ZlclwiLFxyXG4gICAgQk9TU19DT0xMSVNJT04gPSBcIkJvc3NDb2xsaXNpb25cIlxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vV29sZmllMkQvTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBQb3NpdGlvbkdyYXBoIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL1Bvc2l0aW9uR3JhcGhcIjtcclxuaW1wb3J0IE5hdm1lc2ggZnJvbSBcIi4uL1dvbGZpZTJEL1BhdGhmaW5kaW5nL05hdm1lc2hcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vV29sZmllMkQvSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IFBsYXllckNvbnRyb2xsZXIgZnJvbSBcIi4uL0FJL1BsYXllckNvbnRyb2xsZXJcIjtcclxuaW1wb3J0IEJhdEFJIGZyb20gXCIuLi9BSS9CYXRBSVwiO1xyXG5pbXBvcnQgV2VhcG9uIGZyb20gXCIuLi9HYW1lU3lzdGVtcy9XZWFwb25cIjtcclxuaW1wb3J0IEJhdHRsZU1hbmFnZXIgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL0JhdHRsZU1hbmFnZXJcIjtcclxuaW1wb3J0IFdlYXBvblR5cGUgZnJvbSBcIi4uL0dhbWVTeXN0ZW1zL1dlYXBvblR5cGVzL1dlYXBvblR5cGVcIlxyXG5pbXBvcnQgQmF0dGxlckFJIGZyb20gXCIuLi9BSS9CYXR0bGVyQUlcIjtcclxuaW1wb3J0IEdsdXR0b255QUkgZnJvbSBcIi4uL0FJL0dsdXR0b255QUlcIjtcclxuaW1wb3J0IHsgR2FtZV9FdmVudHMgfSBmcm9tIFwiLi8uLi9HYW1lU3lzdGVtcy9nYW1lX2VudW1zXCI7XHJcbmltcG9ydCBHYW1lIGZyb20gXCIuLi9Xb2xmaWUyRC9Mb29wL0dhbWVcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2x1dHRvbnlMZXZlbCBleHRlbmRzIFNjZW5lIHtcclxuICAgIHByaXZhdGUgcGxheWVyOiBBbmltYXRlZFNwcml0ZTsgICAgICAgICAvLyB0aGUgcGxheWVyXHJcbiAgICBwcml2YXRlIHBsYXllcl9oZWFsdGg6IG51bWJlcjsgICAgICAgICAgLy8gcGxheWVycyBoZWFsdGhcclxuICAgIHByaXZhdGUgcGxheWVyX2NvaW5zOiBudW1iZXI7ICAgICAgICAgICAvLyBQUk9KRUNUIFRPRE8gLSBpbXBsZW1lbnQgY29pbiBmdW5jdGlvbmFsaXR5XHJcbiAgICBwcml2YXRlIGVuZW1pZXM6IEFycmF5PEFuaW1hdGVkU3ByaXRlPiA7IC8vIGxpc3Qgb2YgZW5lbWllc1xyXG4gICAgcHJpdmF0ZSB3YWxsczogT3J0aG9nb25hbFRpbGVtYXAgOyAgICAgICAvLyB0aGUgd2FsbCBsYXllclxyXG4gICAgcHJpdmF0ZSBiYXR0bGVfbWFuYWdlcjogQmF0dGxlTWFuYWdlcjsgICAvLyBiYXR0bGUgbWFuYWdlclxyXG4gICAgcHJpdmF0ZSBoZWFsdGhfc3ByaXRlczogU3ByaXRlW107ICAgICAgICAgICAgICAgIC8vc3ByaXRlcyBmb3IgaGVhbHRoXHJcblxyXG4gICAgLy8gdXNlIGluaXRTY2VuZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbGV2ZWwgc2VsZWN0IHN0YXJ0IGFuZCBnYW1lIGNvbnRpbnVlP1xyXG4gICAgaW5pdFNjZW5lKGluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBsYXllcl9oZWFsdGggPSBpbml0LmhlYWx0aDtcclxuICAgICAgICB0aGlzLnBsYXllcl9jb2lucyA9IGluaXQuY29pbnM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGxvYWRTY2VuZSgpIHtcclxuICAgICAgICAvLyBsb2FkIHRoZSBwbGF5ZXIgYW5kIGVuZW15IHNwcml0ZXNoZWV0c1xyXG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcInBsYXllclwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXNoZWV0cy96YXJhLmpzb25cIik7XHJcbiAgICAgICAgLy9Mb2FkIFphcmFzIEhlYXJ0IGltYWdlXHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiaGVhcnRcIiwgXCJnYW1lX2Fzc2V0cy9pbWFnZXMvaGVhcnQucG5nXCIpO1xyXG4gICAgICAgIC8vIFRPRE8gUFJPSkVDVCAtIGFkZCBlbmVteSBzcHJpdGVzaGVldHNcclxuICAgICAgICAvLyBMb2FkIGluIHRoZSBlbmVteSBpbmZvXHJcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiaGVsbGJhdFwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXNoZWV0cy9oZWxsYmF0Lmpzb25cIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiZ2x1dHRvbnlcIiwgXCJnYW1lX2Fzc2V0cy9zcHJpdGVzaGVldHMvZ2x1dHRvbnkuanNvblwiKTtcclxuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJib3NzX2hpdGJveFwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXNoZWV0cy9ib3NzX2hpdGJveC5qc29uXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5vYmplY3QoXCJlbmVteURhdGFcIiwgXCJnYW1lX2Fzc2V0cy9kYXRhL2VuZW15Lmpzb25cIik7XHJcblxyXG4gICAgICAgIC8vIGxvYWQgdGhlIHRpbGVtYXBcclxuICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBzd2l0Y2ggd2l0aCBjb3JyZWN0IHRpbGVtYXBcclxuICAgICAgICB0aGlzLmxvYWQudGlsZW1hcChcImdsdXR0b255TGV2ZWxcIiwgXCJnYW1lX2Fzc2V0cy90aWxlbWFwcy9oZWxsc19mdXJ5Lmpzb25cIik7XHJcblxyXG4gICAgICAgIC8vIGxvYWQgd2VhcG9uIGluZm9cclxuICAgICAgICB0aGlzLmxvYWQub2JqZWN0KFwid2VhcG9uRGF0YVwiLCBcImdhbWVfYXNzZXRzL2RhdGEvd2VhcG9uX2RhdGEuanNvblwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiZmlzdFwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXNoZWV0cy9pbXBhY3QucG5nXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcImZpc3RcIiwgXCJnYW1lX2Fzc2V0cy9zcHJpdGVzaGVldHMvaW1wYWN0Lmpzb25cIik7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRTY2VuZSgpIHtcclxuICAgICAgICAvLyBBZGQgaW4gdGhlIHRpbGVtYXBcclxuICAgICAgICBsZXQgdGlsZW1hcF9sYXllcnMgPSB0aGlzLmFkZC50aWxlbWFwKFwiZ2x1dHRvbnlMZXZlbFwiKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IHRoZSB3YWxsIGxheWVyXHJcbiAgICAgICAgdGhpcy53YWxscyA9IDxPcnRob2dvbmFsVGlsZW1hcD50aWxlbWFwX2xheWVyc1sxXS5nZXRJdGVtcygpWzBdO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIHZpZXdwb3J0IGJvdW5kcyB0byB0aGUgdGlsZW1hcFxyXG4gICAgICAgIGxldCB0aWxlbWFwX3NpemU6IFZlYzIgPSB0aGlzLndhbGxzLnNpemU7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgdGlsZW1hcF9zaXplLngsIHRpbGVtYXBfc2l6ZS55KTtcclxuXHJcbiAgICAgICAgLy8gYWRkIHByaW1hcnkgbGF5ZXJcclxuICAgICAgICB0aGlzLmFkZExheWVyKFwicHJpbWFyeVwiLCAxMCk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBhIGxheWVyIGZvciBVSVxyXG4gICAgICAgIHRoaXMuYWRkVUlMYXllcihcIlVJXCIpO1xyXG4gICAgICAgIHRoaXMuYWRkVUkoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYXR0bGVfbWFuYWdlciA9IG5ldyBCYXR0bGVNYW5hZ2VyO1xyXG5cclxuICAgICAgICB0aGlzLmluaXRpYWxpemVXZWFwb25zKCk7XHJcblxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVBsYXllcigpO1xyXG5cclxuICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSB3cml0ZSBpbml0aWFsaXplRW5lbWllcygpXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplRW5lbWllcygpO1xyXG5cclxuICAgICAgICB0aGlzLmJhdHRsZV9tYW5hZ2VyLnNldFBsYXllcig8QmF0dGxlckFJPnRoaXMucGxheWVyLl9haSk7XHJcbiAgICAgICAgdGhpcy5iYXR0bGVfbWFuYWdlci5zZXRFbmVtaWVzKHRoaXMuZW5lbWllcy5tYXAoZW5lbXkgPT4gPEJhdHRsZXJBST5lbmVteS5fYWkpKTtcclxuXHJcblxyXG4gICAgICAgIC8vIHNldHVwIHZpZXdwb3J0XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydC5mb2xsb3codGhpcy5wbGF5ZXIpO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQuc2V0Wm9vbUxldmVsKDIpO1xyXG5cclxuICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSByZWNlaXZlciBzdWJzY3JpYmUgdG8gZXZlbnRzXHJcbiAgICAgICAgLy8gdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoRVZFTlRTVFJJTkcpO1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9FdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuICAgICAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBHYW1lX0V2ZW50cy5CQVRfQ09MTElTSU9OOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnNjZW5lR3JhcGguZ2V0Tm9kZShldmVudC5kYXRhLmdldChcIm5vZGVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnNjZW5lR3JhcGguZ2V0Tm9kZShldmVudC5kYXRhLmdldChcIm90aGVyXCIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYmF0IGNvbGxpc2lvblwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiYXRfcG9zID0gVmVjMi5aRVJPO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlID09PSB0aGlzLnBsYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXIgaXMgYmF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRfcG9zID0gb3RoZXIucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlIGlzIGJhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0X3BvcyA9IG5vZGUucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuYWRkKFwiYmF0UG9zaXRpb25cIiwgYmF0X3Bvcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9haS5oYW5kbGVFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLl9haS5oYW5kbGVFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgR2FtZV9FdmVudHMuQk9TU19DT0xMSVNJT046XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMuc2NlbmVHcmFwaC5nZXROb2RlKGV2ZW50LmRhdGEuZ2V0KFwibm9kZVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IHRoaXMuc2NlbmVHcmFwaC5nZXROb2RlKGV2ZW50LmRhdGEuZ2V0KFwib3RoZXJcIikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJib3NzIGNvbGxpc2lvblwiKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm9zc19wb3MgPSBWZWMyLlpFUk87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGUgPT09IHRoaXMucGxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBpcyBiYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvc3NfcG9zID0gb3RoZXIucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlIGlzIGJhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9zc19wb3MgPSBub2RlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5hZGQoXCJib3NzUG9zaXRpb25cIiwgYm9zc19wb3MpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuX2FpLmhhbmRsZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuX2FpLmhhbmRsZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBHYW1lX0V2ZW50cy5FTkVNWV9EQU1BR0VEOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgR2FtZV9FdmVudHMuRU5FTVlfRElFRDpcclxuICAgICAgICAgICAgICAgICAgICB7ICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5zY2VuZUdyYXBoLmdldE5vZGUoZXZlbnQuZGF0YS5nZXQoXCJvd25lclwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmVuZW1pZXMubGVuZ3RoIDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5lbWllc1tpXS5pZCA9PT0gKDxBbmltYXRlZFNwcml0ZT4gbm9kZSkuaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5lbWllcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXR0bGVfbWFuYWdlci5zZXRFbmVtaWVzKHRoaXMuZW5lbWllcy5tYXAoZW5lbXkgPT4gPEJhdHRsZXJBST5lbmVteS5fYWkpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmVuZW1pZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2codGhpcy5lbmVtaWVzW2ldLmltYWdlSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZW5lbWllcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIEdhbWVfRXZlbnRzLkJPU1NfREFNQUdFRDpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgR2FtZV9FdmVudHMuQk9TU19ESUVEOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnNjZW5lR3JhcGguZ2V0Tm9kZShldmVudC5kYXRhLmdldChcIm93bmVyXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZW5lbWllcy5sZW5ndGggOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5lbmVtaWVzW2ldLmlkID09PSAoPEFuaW1hdGVkU3ByaXRlPiBub2RlKS5pZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmVtaWVzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdHRsZV9tYW5hZ2VyLnNldEVuZW1pZXModGhpcy5lbmVtaWVzLm1hcChlbmVteSA9PiA8QmF0dGxlckFJPmVuZW15Ll9haSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZW5lbWllcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZyh0aGlzLmVuZW1pZXNbaV0uaW1hZ2VJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5lbmVtaWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgR2FtZV9FdmVudHMuSUZSQU1FU19PVkVSOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIuX2FpLmhhbmRsZUV2ZW50KG5ldyBHYW1lRXZlbnQoR2FtZV9FdmVudHMuSUZSQU1FU19PVkVSLCB7fSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBHYW1lX0V2ZW50cy5HQU1FX09WRVI6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdBTUUgT1ZFUlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbGl6ZVBsYXllcigpOiB2b2lkIHtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBsYXllclxyXG4gICAgICAgIHRoaXMucGxheWVyID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJwbGF5ZXJcIiwgXCJwcmltYXJ5XCIpO1xyXG4gICAgICAgIHRoaXMucGxheWVyLnBvc2l0aW9uLnNldCgzMCoxNiwgNjIqMTYpO1xyXG4gICAgICAgIHRoaXMucGxheWVyLmFkZFBoeXNpY3MobmV3IEFBQkIobmV3IFZlYzIoMCwgMTQpLCBuZXcgVmVjMigxNiwgMTUpKSwgbmV3IFZlYzIoMCwgMTUpKTtcclxuICAgICAgICBsZXQgZmlzdCA9IHRoaXMuY3JlYXRlV2VhcG9uKFwicHVuY2hcIik7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIuYWRkQUkoUGxheWVyQ29udHJvbGxlcixcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3BlZWQ6IDE1MCxcclxuICAgICAgICAgICAgICAgIGZpc3Q6IGZpc3QsXHJcbiAgICAgICAgICAgICAgICBzbGlwcGVyeTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWx0aDogdGhpcy5wbGF5ZXJfaGVhbHRoLFxyXG4gICAgICAgICAgICAgICAgY29pbnM6IHRoaXMucGxheWVyX2NvaW5zLFxyXG4gICAgICAgICAgICAgICAgaGVhbHRoX3Nwcml0ZXM6IHRoaXMuaGVhbHRoX3Nwcml0ZXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIuYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIsIHRydWUpO1xyXG4gICAgICAgIHRoaXMucGxheWVyLnNldEdyb3VwKFwicGxheWVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRpYWxpemVFbmVtaWVzKCl7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBlbmVteSBkYXRhXHJcbiAgICAgICAgY29uc3QgZW5lbXlEYXRhID0gdGhpcy5sb2FkLmdldE9iamVjdChcImVuZW15RGF0YVwiKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGVuZW1pZXMgYXJyYXlcclxuICAgICAgICB0aGlzLmVuZW1pZXMgPSBuZXcgQXJyYXkoZW5lbXlEYXRhLm51bUVuZW1pZXMpO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBlbmVtaWVzXHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGVuZW15RGF0YS5udW1FbmVtaWVzOyBpKyspe1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGVuZW15RGF0YS5lbmVtaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGVuZW15XHJcbiAgICAgICAgICAgIHRoaXMuZW5lbWllc1tpXSA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKGRhdGEuZW5lbXlfdHlwZSwgXCJwcmltYXJ5XCIpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0ucG9zaXRpb24uc2V0KGRhdGEucG9zaXRpb25bMF0sIGRhdGEucG9zaXRpb25bMV0pO1xyXG4gICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0uYW5pbWF0aW9uLnBsYXkoXCJJRExFXCIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGVuZW15T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIGhlYWx0aDogZGF0YS5oZWFsdGgsXHJcbiAgICAgICAgICAgICAgICBwbGF5ZXI6IHRoaXMucGxheWVyLFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBY3RpdmF0ZSBwaHlzaWNzXHJcbiAgICAgICAgICAgIC8vT25seSBvbmUgZW5lbXkgZm9yIG5vd1xyXG4gICAgICAgICAgICBpZihkYXRhLmVuZW15X3R5cGUgPT09IFwiaGVsbGJhdFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0uYWRkUGh5c2ljcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldLmFkZEFJKEJhdEFJLCBlbmVteU9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmVuZW1pZXNbaV0uYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDksIDcpKSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5lbWllc1tpXS5zZXRHcm91cChcImVuZW15XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldLnNldFRyaWdnZXIoXCJwbGF5ZXJcIiwgR2FtZV9FdmVudHMuQkFUX0NPTExJU0lPTiwgXCJiYXQgaGl0IHBsYXllclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGRhdGEuZW5lbXlfdHlwZSA9PT0gIFwiZ2x1dHRvbnlcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldLmFkZEFJKEdsdXR0b255QUksIGVuZW15T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0uYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDU2LCA1NikpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5lbWllc1tpXS5zZXRHcm91cChcImVuZW15XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldLnNldFRyaWdnZXIoXCJwbGF5ZXJcIiwgR2FtZV9FdmVudHMuQk9TU19DT0xMSVNJT04sIFwiYm9zcyBoaXQgcGxheWVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmVtaWVzW2ldLmFkZEFJKEdsdXR0b255QUksIGVuZW15T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZW1pZXNbaV0uYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDUwLCA1MCkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbGl6ZVdlYXBvbnMoKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHdlYXBvbl9kYXRhID0gdGhpcy5sb2FkLmdldE9iamVjdChcIndlYXBvbkRhdGFcIik7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB3ZWFwb25fZGF0YS5udW1XZWFwb25zOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHdlYXBvbiA9IHdlYXBvbl9kYXRhLndlYXBvbnNbaV07XHJcblxyXG4gICAgICAgICAgICBsZXQgY29uc3RyID0gUmVnaXN0cnlNYW5hZ2VyLmdldFJlZ2lzdHJ5KFwid2VhcG9uVGVtcGxhdGVzXCIpLmdldCh3ZWFwb24ud2VhcG9uVHlwZSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgd2VhcG9uVHlwZSA9IG5ldyBjb25zdHIoKTtcclxuXHJcbiAgICAgICAgICAgIHdlYXBvblR5cGUuaW5pdGlhbGl6ZSh3ZWFwb24pO1xyXG5cclxuICAgICAgICAgICAgUmVnaXN0cnlNYW5hZ2VyLmdldFJlZ2lzdHJ5KFwid2VhcG9uVHlwZXNcIikucmVnaXN0ZXJJdGVtKHdlYXBvbi5uYW1lLCB3ZWFwb25UeXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlV2VhcG9uKHR5cGU6IHN0cmluZyk6IFdlYXBvbiB7XHJcbiAgICAgICAgbGV0IHdlYXBvblR5cGUgPSA8V2VhcG9uVHlwZT5SZWdpc3RyeU1hbmFnZXIuZ2V0UmVnaXN0cnkoXCJ3ZWFwb25UeXBlc1wiKS5nZXQodHlwZSk7XHJcblxyXG4gICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLmFkZC5zcHJpdGUod2VhcG9uVHlwZS5zcHJpdGVfa2V5LCBcInByaW1hcnlcIik7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgV2VhcG9uKHNwcml0ZSwgd2VhcG9uVHlwZSwgdGhpcy5iYXR0bGVfbWFuYWdlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFkZFVJKCl7XHJcbiAgICAgICAgLy8gWmFyYSBIZWFsdGhcclxuICAgICAgICBsZXQgcHJldl9sb2MgPSBuZXcgVmVjMigyLCAyMCk7XHJcbiAgICAgICAgdGhpcy5oZWFsdGhfc3ByaXRlcyA9IG5ldyBBcnJheTxTcHJpdGU+KCk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucGxheWVyX2hlYWx0aDsgaSsrKXtcclxuICAgICAgICAgICAgbGV0IHNwcml0ZVRvQWRkID0gdGhpcy5hZGQuc3ByaXRlKFwiaGVhcnRcIiwgXCJVSVwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coc3ByaXRlVG9BZGQpO1xyXG4gICAgICAgICAgICBzcHJpdGVUb0FkZC5wb3NpdGlvbiA9IG5ldyBWZWMyKHByZXZfbG9jLnggKyAyNSwgcHJldl9sb2MueSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHNwcml0ZVRvQWRkKTtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGhfc3ByaXRlcy5wdXNoKHNwcml0ZVRvQWRkKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ5b29vXCIpO1xyXG4gICAgICAgICAgICBwcmV2X2xvYyA9IG5ldyBWZWMyKHByZXZfbG9jLnggKyAyNSwgcHJldl9sb2MueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3Vic2NyaWJlVG9FdmVudHMoKXtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShbXHJcbiAgICAgICAgICAgR2FtZV9FdmVudHMuRU5FTVlfREFNQUdFRCxcclxuICAgICAgICAgICBHYW1lX0V2ZW50cy5FTkVNWV9ESUVELFxyXG4gICAgICAgICAgIEdhbWVfRXZlbnRzLkJPU1NfREFNQUdFRCxcclxuICAgICAgICAgICBHYW1lX0V2ZW50cy5CT1NTX0RJRUQsXHJcbiAgICAgICAgICAgR2FtZV9FdmVudHMuQkFUX0NPTExJU0lPTixcclxuICAgICAgICAgICBHYW1lX0V2ZW50cy5HQU1FX09WRVIsXHJcbiAgICAgICAgICAgR2FtZV9FdmVudHMuSUZSQU1FU19PVkVSLFxyXG4gICAgICAgICAgIEdhbWVfRXZlbnRzLkJPU1NfQ09MTElTSU9OXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgR2x1dHRvbnlMZXZlbCBmcm9tIFwiLi9HbHV0dG9ueUxldmVsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluTWVudSBleHRlbmRzIFNjZW5lIHtcclxuICAgIHByaXZhdGUgbWFpbl9tZW51OiBMYXllcjtcclxuICAgIHByaXZhdGUgbGV2ZWxfc2VsZWN0OiBMYXllcjtcclxuICAgIHByaXZhdGUgaGVscDogTGF5ZXI7XHJcbiAgICBwcml2YXRlIGNvbnRyb2xzOiBMYXllcjtcclxuXHJcbiAgICBsb2FkU2NlbmUoKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwibWFpbk1lbnVJbWFnZVwiLCBcImdhbWVfYXNzZXRzL2ltYWdlcy9tYWluX21lbnVfYmFja2dyb3VuZC5wbmdcIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwibGV2ZWxTZWxlY3RJbWFnZVwiLCBcImdhbWVfYXNzZXRzL2ltYWdlcy9sZXZlbF9zZWxlY3RfYmFja2dyb3VuZC5wbmdcIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiaGVscEltYWdlXCIsIFwiZ2FtZV9hc3NldHMvaW1hZ2VzL2hlbHBfYmFja2dyb3VuZC5wbmdcIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiY29udHJvbHNJbWFnZVwiLCBcImdhbWVfYXNzZXRzL2ltYWdlcy9jb250cm9sc19iYWNrZ3JvdW5kLnBuZ1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGFydFNjZW5lKCkge1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMudmlld3BvcnQuZ2V0Q2VudGVyKCk7XHJcblxyXG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBidXR0b24gZXZlbnRzXHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJuZXdHYW1lXCIpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwibGV2ZWxTZWxlY3RcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJoZWxwXCIpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiY29udHJvbHNcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJtYWluTWVudVwiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImxldmVsR2x1dHRvbnlcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJsZXZlbEx1c3RcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJsZXZlbFdyYXRoXCIpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwibGV2ZWxHcmVlZFwiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcImxldmVsU2xvdGhcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJsZXZlbEVudnlcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJsZXZlbFByaWRlXCIpO1xyXG5cclxuICAgICAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIE1BSU4gTUVOVSAjIyMjIyMjIyMjIyMjIyMjICovXHJcbiAgICAgICAgLy8gY3JlYXRlIG1haW4gbWVudSBsYXllclxyXG4gICAgICAgIHRoaXMubWFpbl9tZW51ID0gdGhpcy5hZGRVSUxheWVyKFwibWFpbk1lbnVcIik7XHJcblxyXG4gICAgICAgIC8vIGFkZCBtYWluIG1lbnUgYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgICAgIGxldCBtbWIgPSB0aGlzLmFkZC5zcHJpdGUoXCJtYWluTWVudUltYWdlXCIsIFwibWFpbk1lbnVcIik7XHJcbiAgICAgICAgbW1iLnBvc2l0aW9uLnNldChtbWIuc2l6ZS54LzIsIG1tYi5zaXplLnkvMik7XHJcblxyXG4gICAgICAgIC8vIEFkZCBuZXcgZ2FtZSBidXR0b24sIGFuZCBnaXZlIGl0IGFuIGV2ZW50IHRvIGVtaXQgb24gcHJlc3NcclxuICAgICAgICBjb25zdCBuZXdfZ2FtZV9idXR0b24gPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibWFpbk1lbnVcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDE0LCBjZW50ZXIueSAtIDE3MCksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBuZXdfZ2FtZV9idXR0b24uc2l6ZS5zZXQoMzMwLCA3MCk7XHJcbiAgICAgICAgbmV3X2dhbWVfYnV0dG9uLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBuZXdfZ2FtZV9idXR0b24uYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBuZXdfZ2FtZV9idXR0b24uYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbmV3X2dhbWVfYnV0dG9uLm9uQ2xpY2tFdmVudElkID0gXCJuZXdHYW1lXCI7XHJcblxyXG4gICAgICAgIC8vIEFkZCBsZXZlbCBzZWxlY3QgYnV0dG9uXHJcbiAgICAgICAgY29uc3QgbGV2ZWxfc2VsZWN0X2J1dHRvbiA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMTMsIGNlbnRlci55IC0gNjApLCB0ZXh0OiBcIlwifSk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2J1dHRvbi5zaXplLnNldCg0MjAsIDcwKTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfYnV0dG9uLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfYnV0dG9uLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2J1dHRvbi5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfYnV0dG9uLm9uQ2xpY2tFdmVudElkID0gXCJsZXZlbFNlbGVjdFwiO1xyXG5cclxuICAgICAgICAvLyBBZGQgaGVscCBidXR0b25cclxuICAgICAgICBjb25zdCBoZWxwX2J1dHRvbiA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMjEsIGNlbnRlci55ICsgNTUpLCB0ZXh0OiBcIlwifSk7XHJcbiAgICAgICAgaGVscF9idXR0b24uc2l6ZS5zZXQoMTQ1LCA3NSk7XHJcbiAgICAgICAgaGVscF9idXR0b24uYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGhlbHBfYnV0dG9uLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgaGVscF9idXR0b24uYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgaGVscF9idXR0b24ub25DbGlja0V2ZW50SWQgPSBcImhlbHBcIjtcclxuXHJcbiAgICAgICAgLy8gQWRkIGNvbnRyb2xzXHJcbiAgICAgICAgY29uc3QgY29udHJvbHNfYnV0dG9uID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcIm1haW5NZW51XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAxMywgY2VudGVyLnkgKyAxNTApLCB0ZXh0OiBcIlwifSk7XHJcbiAgICAgICAgY29udHJvbHNfYnV0dG9uLnNpemUuc2V0KDI2OCwgNzApO1xyXG4gICAgICAgIGNvbnRyb2xzX2J1dHRvbi5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgY29udHJvbHNfYnV0dG9uLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgY29udHJvbHNfYnV0dG9uLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGNvbnRyb2xzX2J1dHRvbi5vbkNsaWNrRXZlbnRJZCA9IFwiY29udHJvbHNcIjtcclxuXHJcblxyXG4gICAgICAgIC8qICMjIyMjIyMjIyMjIyMjIyMgTEVWRUwgU0VMRUNUICMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgICAgICAvLyBjcmVhdGUgbGV2ZWwgc2VsZWN0IGxheWVyXHJcbiAgICAgICAgdGhpcy5sZXZlbF9zZWxlY3QgPSB0aGlzLmFkZFVJTGF5ZXIoXCJsZXZlbFNlbGVjdFwiKTtcclxuICAgICAgICB0aGlzLmxldmVsX3NlbGVjdC5zZXRIaWRkZW4odHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIGFkZCBsZXZlbCBzZWxlY3QgYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgICAgIGxldCBsc2IgPSB0aGlzLmFkZC5zcHJpdGUoXCJsZXZlbFNlbGVjdEltYWdlXCIsIFwibGV2ZWxTZWxlY3RcIik7XHJcbiAgICAgICAgbHNiLnBvc2l0aW9uLnNldChsc2Iuc2l6ZS54LzIsIGxzYi5zaXplLnkvMik7XHJcblxyXG4gICAgICAgIGNvbnN0IGxldmVsX3NlbGVjdF9iYWNrID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsU2VsZWN0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggKyA1MTgsIGNlbnRlci55ICsgMzA4KSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9iYWNrLnNpemUuc2V0KDE2OCwgNjUpO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9iYWNrLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfYmFjay5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9iYWNrLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9iYWNrLm9uQ2xpY2tFdmVudElkID0gXCJtYWluTWVudVwiO1xyXG5cclxuICAgICAgICBjb25zdCBsZXZlbF9zZWxlY3RfZ2x1dHRvbnkgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxTZWxlY3RcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDIwLCBjZW50ZXIueSAtIDE5NSksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZ2x1dHRvbnkuc2l6ZS5zZXQoMjg1LCA3NSk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2dsdXR0b255LmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZ2x1dHRvbnkuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfZ2x1dHRvbnkuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2dsdXR0b255Lm9uQ2xpY2tFdmVudElkID0gXCJsZXZlbEdsdXR0b255XCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGxldmVsX3NlbGVjdF9sdXN0ID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsU2VsZWN0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAyNywgY2VudGVyLnkgLSA5NSksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfbHVzdC5zaXplLnNldCgxNDAsIDU4KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfbHVzdC5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2x1c3QuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfbHVzdC5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfbHVzdC5vbkNsaWNrRXZlbnRJZCA9IFwibGV2ZWxMdXN0XCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGxldmVsX3NlbGVjdF93cmF0aCA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbFNlbGVjdFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMjEsIGNlbnRlci55ICsgMyksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfd3JhdGguc2l6ZS5zZXQoMTY0LCA1NCk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X3dyYXRoLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfd3JhdGguYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfd3JhdGguYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X3dyYXRoLm9uQ2xpY2tFdmVudElkID0gXCJsZXZlbFdyYXRoXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGxldmVsX3NlbGVjdF9ncmVlZCA9IHRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbFNlbGVjdFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMjEsIGNlbnRlci55ICsgODUpLCB0ZXh0OiBcIlwifSk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2dyZWVkLnNpemUuc2V0KDE1MCwgNTApO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9ncmVlZC5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2dyZWVkLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2dyZWVkLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9ncmVlZC5vbkNsaWNrRXZlbnRJZCA9IFwibGV2ZWxHcmVlZFwiO1xyXG5cclxuICAgICAgICBjb25zdCBsZXZlbF9zZWxlY3Rfc2xvdGggPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxTZWxlY3RcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDE5LCBjZW50ZXIueSArIDE2MCksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfc2xvdGguc2l6ZS5zZXQoMTM1LCA1MCk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X3Nsb3RoLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfc2xvdGguYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3Rfc2xvdGguYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X3Nsb3RoLm9uQ2xpY2tFdmVudElkID0gXCJsZXZlbFNsb3RoXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGxldmVsX3NlbGVjdF9lbnZ5ID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsU2VsZWN0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAyMCwgY2VudGVyLnkgKyAyMzApLCB0ZXh0OiBcIlwifSk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2Vudnkuc2l6ZS5zZXQoMTE0LCA1MCk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2VudnkuYm9yZGVyV2lkdGggPSAyO1xyXG4gICAgICAgIGxldmVsX3NlbGVjdF9lbnZ5LmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2VudnkuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X2Vudnkub25DbGlja0V2ZW50SWQgPSBcImxldmVsRW52eVwiO1xyXG5cclxuICAgICAgICBjb25zdCBsZXZlbF9zZWxlY3RfcHJpZGUgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxTZWxlY3RcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDIyLCBjZW50ZXIueSArIDI5NSksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfcHJpZGUuc2l6ZS5zZXQoMTA3LCA0Nyk7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X3ByaWRlLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfcHJpZGUuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBsZXZlbF9zZWxlY3RfcHJpZGUuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgbGV2ZWxfc2VsZWN0X3ByaWRlLm9uQ2xpY2tFdmVudElkID0gXCJsZXZlbFByaWRlXCI7XHJcblxyXG4gICAgICAgIC8qICMjIyMjIyMjIyMjIyMjIyMgSEVMUCAjIyMjIyMjIyMjIyMjIyMjICovXHJcbiAgICAgICAgLy8gY3JlYXRlIGhlbHAgbGF5ZXJcclxuICAgICAgICB0aGlzLmhlbHAgPSB0aGlzLmFkZFVJTGF5ZXIoXCJoZWxwXCIpO1xyXG4gICAgICAgIHRoaXMuaGVscC5zZXRIaWRkZW4odHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIGFkZCBoZWxwIGJhY2tncm91bmQgaW1hZ2VcclxuICAgICAgICBsZXQgaGIgPSB0aGlzLmFkZC5zcHJpdGUoXCJoZWxwSW1hZ2VcIiwgXCJoZWxwXCIpO1xyXG4gICAgICAgIGhiLnBvc2l0aW9uLnNldChoYi5zaXplLngvMiwgaGIuc2l6ZS55LzIpO1xyXG5cclxuICAgICAgICBjb25zdCBoZWxwX2JhY2sgPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwiaGVscFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54ICsgNTE4LCBjZW50ZXIueSArIDMwOCksIHRleHQ6IFwiXCJ9KTtcclxuICAgICAgICBoZWxwX2JhY2suc2l6ZS5zZXQoMTY4LCA2NSk7XHJcbiAgICAgICAgaGVscF9iYWNrLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBoZWxwX2JhY2suYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBoZWxwX2JhY2suYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgaGVscF9iYWNrLm9uQ2xpY2tFdmVudElkID0gXCJtYWluTWVudVwiO1xyXG5cclxuICAgICAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIENPTlRST0xTICMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgICAgICAvLyBjcmVhdGUgY29udHJvbHMgbGF5ZXJcclxuICAgICAgICB0aGlzLmNvbnRyb2xzID0gdGhpcy5hZGRVSUxheWVyKFwiY29udHJvbHNcIik7XHJcbiAgICAgICAgdGhpcy5jb250cm9scy5zZXRIaWRkZW4odHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIGFkZCBjb250cm9scyBiYWNrZ3JvdW5kIGltYWdlXHJcbiAgICAgICAgbGV0IGNiID0gdGhpcy5hZGQuc3ByaXRlKFwiY29udHJvbHNJbWFnZVwiLCBcImNvbnRyb2xzXCIpO1xyXG4gICAgICAgIGNiLnBvc2l0aW9uLnNldChjYi5zaXplLngvMiwgY2Iuc2l6ZS55LzIpO1xyXG5cclxuICAgICAgICBjb25zdCBjb250cm9sc19iYWNrID0gdGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImNvbnRyb2xzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggKyA1MTgsIGNlbnRlci55ICsgMzA4KSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGNvbnRyb2xzX2JhY2suc2l6ZS5zZXQoMTY4LCA2NSk7XHJcbiAgICAgICAgY29udHJvbHNfYmFjay5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgY29udHJvbHNfYmFjay5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIGNvbnRyb2xzX2JhY2suYmFja2dyb3VuZENvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgY29udHJvbHNfYmFjay5vbkNsaWNrRXZlbnRJZCA9IFwibWFpbk1lbnVcIjtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY2VuZSgpIHtcclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKSB7XHJcbiAgICAgICAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgc2NlbmVPcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgcGh5c2ljczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwTmFtZXM6IFtcImdyb3VuZFwiLCBcInBsYXllclwiLCBcImVuZW15XCJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpc2lvbnM6XHJcbiAgICAgICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbMCwgMSwgMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFsxLCAwLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgWzEsIDAsIDBdXHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcIm5ld0dhbWVcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQUk9KRUNUIC0gc2V0dXAgbmV3IGdhbWUgc2NlbmUgZnJvbSBoZXJlIChtYXliZSBhZGQgb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTmV3IEdhbWUgRXZlbnRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKEdsdXR0b255TGV2ZWwsIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFsdGg6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29pbnM6IDBcclxuICAgICAgICAgICAgICAgIH0sIHNjZW5lT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibWFpbk1lbnVcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYWluIE1lbnUgRXZlbnRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5fbWVudS5zZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbF9zZWxlY3Quc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwLnNldEhpZGRlbih0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImxldmVsU2VsZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTGV2ZWwgU2VsZWN0IEV2ZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluX21lbnUuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZXZlbF9zZWxlY3Quc2V0SGlkZGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJoZWxwXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSGVscCBFdmVudFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbl9tZW51LnNldEhpZGRlbih0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVscC5zZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImNvbnRyb2xzXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29udHJvbHMgRXZlbnRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5fbWVudS5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNldEhpZGRlbihmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibGV2ZWxHbHV0dG9ueVwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBnbyB0byBnbHV0dG9ueSBsZXZlbCAobGV2ZWwgMSlcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR2x1dHRvbnkgTGV2ZWxcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKEdsdXR0b255TGV2ZWwsIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFsdGg6IDUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29pbnM6IDBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibGV2ZWxMdXN0XCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gUFJPSkVDVCAtIGdvIHRvIGx1c3QgbGV2ZWwgKGxldmVsIDIpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkx1c3QgTGV2ZWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJsZXZlbFdyYXRoXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gUFJPSkVDVCAtIGdvIHRvIHdyYXRoIGxldmVsIChsZXZlbCAzKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXcmF0aCBMZXZlbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImxldmVsR3JlZWRcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQUk9KRUNUIC0gZ28gdG8gZ3JlZWQgbGV2ZWwgKGxldmVsIDQpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdyZWVkIExldmVsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwibGV2ZWxTbG90aFwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFBST0pFQ1QgLSBnbyB0byBzbG90aCBsZXZlbCAobGV2ZWwgNSlcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2xvdGggTGV2ZWxcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJsZXZlbEVudnlcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQUk9KRUNUIC0gZ28gdG8gZW52eSBsZXZlbCAobGV2ZWwgNilcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRW52eSBMZXZlbFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImxldmVsUHJpZGVcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQUk9KRUNUIC0gZ28gdG8gcHJpZGUgbGV2ZWwgKGxldmVsIDcpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlByaWRlIExldmVsXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgTGF5ZXIgZnJvbSBcIi4uL1dvbGZpZTJEL1NjZW5lL0xheWVyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vV29sZmllMkQvU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9Xb2xmaWUyRC9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IE1haW5NZW51IGZyb20gXCIuL01haW5NZW51XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxhc2hTY3JlZW4gZXh0ZW5kcyBTY2VuZSB7XHJcbiAgICBwcml2YXRlIHNwbGFzaDogTGF5ZXI7XHJcbiAgICBwcml2YXRlIHNwbGFzaF9iYWNrZ3JvdW5kOiBMYXllcjtcclxuXHJcbiAgICBsb2FkU2NlbmUoKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwic3BsYXNoSW1hZ2VcIiwgXCJnYW1lX2Fzc2V0cy9pbWFnZXMvc3BsYXNoX3NjcmVlbi5wbmdcIik7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhcnRTY2VuZSgpIHtcclxuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLnZpZXdwb3J0LmdldENlbnRlcigpO1xyXG5cclxuICAgICAgICAvLyBUaGUgc3BsYXNoIHNjcmVlblxyXG4gICAgICAgIHRoaXMuc3BsYXNoID0gdGhpcy5hZGRVSUxheWVyKFwic3BsYXNoU2NyZWVuXCIpO1xyXG5cclxuICAgICAgICAvLyBBZGQgYSBiYWNrZ3JvdW5kIHRvIHRoZSBzY2VuZVxyXG4gICAgICAgIHRoaXMuc3BsYXNoX2JhY2tncm91bmQgPSB0aGlzLmFkZFBhcmFsbGF4TGF5ZXIoXCJzcGxhc2hfYmFja2dyb3VuZFwiLCBuZXcgVmVjMigwLjUsIDEpLCAtMSk7XHJcbiAgICAgICAgbGV0IHNiID0gdGhpcy5hZGQuc3ByaXRlKFwic3BsYXNoSW1hZ2VcIiwgXCJzcGxhc2hfYmFja2dyb3VuZFwiKTtcclxuICAgICAgICBzYi5wb3NpdGlvbi5zZXQoc2Iuc2l6ZS54LzIsIHNiLnNpemUueS8yKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRyYW5zcGFyZW50IGJ1dHRvblxyXG4gICAgICAgIGNvbnN0IGNvbmZpcm0gPSB0aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwic3BsYXNoU2NyZWVuXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55KSwgdGV4dDogXCJcIn0pO1xyXG4gICAgICAgIGNvbmZpcm0uc2l6ZS5zZXQoMTI4MCwgNzIwKTtcclxuICAgICAgICBjb25maXJtLmJvcmRlcldpZHRoID0gMDtcclxuICAgICAgICBjb25maXJtLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgY29uZmlybS5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICBjb25maXJtLm9uQ2xpY2tFdmVudElkID0gXCJjb25maXJtXCI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBidXR0b24gZXZlbnRzXHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJjb25maXJtXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVNjZW5lKCkge1xyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpIHtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwiY29uZmlybVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGFzaF9iYWNrZ3JvdW5kLmRpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTWFpbk1lbnUsIHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuIiwiaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xyXG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5pbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1hbmFnZXIgY2xhc3MgZm9yIGFsbCBvZiB0aGUgQUkgaW4gYSBzY2VuZS5cclxuICogS2VlcHMgYSBsaXN0IG9mIHJlZ2lzdGVyZWQgYWN0b3JzIGFuZCBoYW5kbGVzIEFJIGdlbmVyYXRpb24gZm9yIGFjdG9ycy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFJTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG5cdC8qKiBUaGUgYXJyYXkgb2YgcmVnaXN0ZXJlZCBhY3RvcnMgKi9cclxuXHRhY3RvcnM6IEFycmF5PEFjdG9yPjtcclxuXHQvKiogTWFwcyBBSSBuYW1lcyB0byB0aGVpciBjb25zdHJ1Y3RvcnMgKi9cclxuXHRyZWdpc3RlcmVkQUk6IE1hcDxBSUNvbnN0cnVjdG9yPjtcclxuXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMuYWN0b3JzID0gbmV3IEFycmF5KCk7XHJcblx0XHR0aGlzLnJlZ2lzdGVyZWRBSSA9IG5ldyBNYXAoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhbiBhY3RvciB3aXRoIHRoZSBBSU1hbmFnZXJcclxuXHQgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIHJlZ2lzdGVyXHJcblx0ICovXHJcblx0cmVnaXN0ZXJBY3RvcihhY3RvcjogQWN0b3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuYWN0b3JzLnB1c2goYWN0b3IpO1xyXG5cdH1cclxuXHJcblx0cmVtb3ZlQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XHJcblx0XHRsZXQgaW5kZXggPSB0aGlzLmFjdG9ycy5pbmRleE9mKGFjdG9yKTtcclxuXHJcblx0XHRpZihpbmRleCAhPT0gLTEpe1xyXG5cdFx0XHR0aGlzLmFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIGFuIEFJIHdpdGggdGhlIEFJTWFuYWdlciBmb3IgdXNlIGxhdGVyIG9uXHJcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIHJlZ2lzdGVyXHJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBBSVxyXG5cdCAqL1xyXG5cdHJlZ2lzdGVyQUkobmFtZTogc3RyaW5nLCBjb25zdHI6IG5ldyA8VCBleHRlbmRzIEFJPigpID0+IFQgKTogdm9pZCB7XHJcblx0XHR0aGlzLnJlZ2lzdGVyZWRBSS5hZGQobmFtZSwgY29uc3RyKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhbiBBSSBpbnN0YW5jZSBmcm9tIGl0cyBuYW1lXHJcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIGFkZFxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFJIGluc3RhbmNlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVBSShuYW1lOiBzdHJpbmcpOiBBSSB7XHJcblx0XHRpZih0aGlzLnJlZ2lzdGVyZWRBSS5oYXMobmFtZSkpe1xyXG5cdFx0XHRyZXR1cm4gbmV3ICh0aGlzLnJlZ2lzdGVyZWRBSS5nZXQobmFtZSkpKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBgQ2Fubm90IGNyZWF0ZSBBSSB3aXRoIG5hbWUgJHtuYW1lfSwgbm8gQUkgd2l0aCB0aGF0IG5hbWUgaXMgcmVnaXN0ZXJlZGA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIFJ1biB0aGUgYWkgZm9yIGV2ZXJ5IGFjdGl2ZSBhY3RvclxyXG5cdFx0dGhpcy5hY3RvcnMuZm9yRWFjaChhY3RvciA9PiB7IGlmKGFjdG9yLmFpQWN0aXZlKSBhY3Rvci5haS51cGRhdGUoZGVsdGFUKSB9KTtcclxuXHR9XHJcbn1cclxuXHJcbnR5cGUgQUlDb25zdHJ1Y3RvciA9IG5ldyA8VCBleHRlbmRzIEFJPigpID0+IFQ7IiwiaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xyXG5pbXBvcnQgU3RhdGVNYWNoaW5lIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHZlcnNpb24gb2YgYSBAcmVmZXJlbmNlW1N0YXRlTWFjaGluZV0gdGhhdCBpcyBjb25maWd1cmVkIHRvIHdvcmsgYXMgYW4gQUkgY29udHJvbGxlciBmb3IgYSBAcmVmZXJlbmNlW0dhbWVOb2RlXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVNYWNoaW5lQUkgZXh0ZW5kcyBTdGF0ZU1hY2hpbmUgaW1wbGVtZW50cyBBSSB7XHJcblx0LyoqXHRUaGUgR2FtZU5vZGUgdGhhdCB1c2VzIHRoaXMgU3RhdGVNYWNoaW5lIGZvciBpdHMgQUkgKi9cclxuXHRwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRpbml0aWFsaXplQUkob3duZXI6IEdhbWVOb2RlLCBjb25maWc6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGRlc3Ryb3koKXtcclxuXHRcdC8vIEdldCByaWQgb2Ygb3VyIHJlZmVyZW5jZSB0byB0aGUgb3duZXJcclxuXHRcdGRlbGV0ZSB0aGlzLm93bmVyO1xyXG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRhY3RpdmF0ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG59IiwiLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBBIHBsYWNlaG9sZGVyIGZ1bmN0aW9uIGZvciBObyBPcGVyYXRpb24uIERvZXMgbm90aGluZ1xyXG4gKi9cclxuY29uc3QgTnVsbEZ1bmMgPSAoKSA9PiB7fTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE51bGxGdW5jOyIsIi8qKlxyXG4gKiBBIGxpbmtlZC1saXN0IGZvciB0aGUgZWRnZXMgaW4gYSBAcmVmZXJlbmNlW0dyYXBoXS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkZ2VOb2RlIHtcclxuICAgIC8qKiBUaGUgbm9kZSBpbiB0aGUgR3JhcGggdGhpcyBlZGdlIGNvbm5lY3RzIHRvICovXHJcbiAgICB5OiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHdlaWdodCBvZiB0aGlzIEVkZ2VOb2RlICovXHJcblx0d2VpZ2h0OiBudW1iZXI7XHJcbiAgICAvKiogVGhlIG5leHQgRWRnZU5vZGUgaW4gdGhlIGxpbmtlZC1saXN0ICovXHJcbiAgICBuZXh0OiBFZGdlTm9kZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgRWRnZU5vZGVcclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdGhpcyBlZGdlIGNvbm5lY3RzIHRvXHJcbiAgICAgKiBAcGFyYW0gd2VpZ2h0IFRoZSB3ZWlnaHQgb2YgdGhpcyBlZGdlXHJcbiAgICAgKi9cclxuXHRjb25zdHJ1Y3RvcihpbmRleDogbnVtYmVyLCB3ZWlnaHQ/OiBudW1iZXIpe1xyXG5cdFx0dGhpcy55ID0gaW5kZXg7XHJcblx0XHR0aGlzLm5leHQgPSBudWxsO1xyXG5cdFx0dGhpcy53ZWlnaHQgPSB3ZWlnaHQgPyB3ZWlnaHQgOiAxO1xyXG5cdH1cclxufSIsImltcG9ydCBFZGdlTm9kZSBmcm9tIFwiLi9FZGdlTm9kZVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9WID0gMTAwO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgZ3JhcGggZGF0YSBzdHJ1Y3R1cmUgdXNpbmcgZWRnZSBsaXN0cy4gSW5zcGlyZWQgYnkgVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGgge1xyXG5cdC8qKiBBbiBhcnJheSBvZiBlZGdlcyBhdCB0aGUgbm9kZSBzcGVjaWZpZWQgYnkgdGhlIGluZGV4ICovXHJcblx0ZWRnZXM6IEFycmF5PEVkZ2VOb2RlPjtcclxuXHQvKiogQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBkZWdyZWUgb2YgdGhlIG5vZGUgc3BlY2lmaWVkIGJ5IHRoZSBpbmRleCAqL1xyXG5cdGRlZ3JlZTogQXJyYXk8bnVtYmVyPjtcclxuXHQvKiogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZ3JhcGggKi9cclxuXHRudW1WZXJ0aWNlczogbnVtYmVyO1xyXG5cdC8qKiBUaGUgbnVtYmVyIG9mIGVkZ2VzIGluIHRoZSBncmFwaCAqL1xyXG5cdG51bUVkZ2VzOiBudW1iZXI7XHJcblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZSBncmFwaCBpcyBkaXJlY3RlZCAqL1xyXG5cdGRpcmVjdGVkOiBib29sZWFuO1xyXG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgd2VpZ2h0ZWQgKi9cclxuXHR3ZWlnaHRlZDogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBncmFwaFxyXG5cdCAqIEBwYXJhbSBkaXJlY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIGdyYXBoIGlzIGRpcmVjdGVkXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSl7XHJcblx0XHR0aGlzLmRpcmVjdGVkID0gZGlyZWN0ZWQ7XHJcblx0XHR0aGlzLndlaWdodGVkID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5udW1WZXJ0aWNlcyA9IDA7XHJcblx0XHR0aGlzLm51bUVkZ2VzID0gMDtcclxuXHJcblx0XHR0aGlzLmVkZ2VzID0gbmV3IEFycmF5KE1BWF9WKTtcclxuXHRcdHRoaXMuZGVncmVlID0gbmV3IEFycmF5KE1BWF9WKTtcclxuXHR9XHJcblxyXG5cdC8qKiBBZGRzIGEgbm9kZSB0byB0aGlzIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiBpdFxyXG5cdCAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgbmV3IG5vZGVcclxuXHQqL1xyXG5cdGFkZE5vZGUoKTogbnVtYmVyIHtcclxuXHRcdHRoaXMubnVtVmVydGljZXMrKztcclxuXHRcdHJldHVybiB0aGlzLm51bVZlcnRpY2VzO1xyXG5cdH1cclxuXHJcblx0LyoqIEFkZHMgYW4gZWRnZSBiZXR3ZWVuIG5vZGUgeCBhbmQgeSwgd2l0aCBhbiBvcHRpb25hbCB3ZWlnaHRcclxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIHN0YXJ0IG9mIHRoZSBlZGdlXHJcblx0ICogQHBhcmFtIHkgVGhlIGluZGV4IG9mIHRoZSBlbmQgb2YgdGhlIGVkZ2VcclxuXHQgKiBAcGFyYW0gd2VpZ2h0IFRoZSBvcHRpb25hbCB3ZWlnaHQgb2YgdGhlIG5ldyBlZGdlXHJcblx0Ki9cclxuXHRhZGRFZGdlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3ZWlnaHQ/OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGxldCBlZGdlID0gbmV3IEVkZ2VOb2RlKHksIHdlaWdodCk7XHJcblxyXG5cclxuXHJcblx0XHRpZih0aGlzLmVkZ2VzW3hdKXtcclxuXHRcdFx0ZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t4XTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0dGhpcy5lZGdlc1t4XSA9IGVkZ2U7XHJcblxyXG5cdFx0aWYoIXRoaXMuZGlyZWN0ZWQpe1xyXG5cdFx0XHRlZGdlID0gbmV3IEVkZ2VOb2RlKHgsIHdlaWdodCk7XHJcblxyXG5cdFx0XHRpZih0aGlzLmVkZ2VzW3ldKXtcclxuXHRcdFx0XHRlZGdlLm5leHQgPSB0aGlzLmVkZ2VzW3ldO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmVkZ2VzW3ldID0gZWRnZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm51bUVkZ2VzICs9IDE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYW4gZWRnZSBleGlzdHMgYmV0d2VlbiB0d28gbm9kZXMuXHJcblx0ICogVGhpcyBjaGVjayBpcyBkaXJlY3Rpb25hbCBpZiB0aGlzIGlzIGEgZGlyZWN0ZWQgZ3JhcGguXHJcblx0ICogQHBhcmFtIHggVGhlIGZpcnN0IG5vZGVcclxuXHQgKiBAcGFyYW0geSBUaGUgc2Vjb25kIG5vZGVcclxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVkZ2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRlZGdlRXhpc3RzKHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbeF07XHJcblxyXG5cdFx0d2hpbGUoZWRnZSAhPT0gbnVsbCl7XHJcblx0XHRcdGlmKGVkZ2UueSA9PT0geSl7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGVkZ2UgbGlzdCBhc3NvY2lhdGVkIHdpdGggbm9kZSB4XHJcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXHJcblx0ICogQHJldHVybnMgVGhlIGhlYWQgb2YgYSBsaW5rZWQtbGlzdCBvZiBlZGdlc1xyXG5cdCAqL1xyXG5cdGdldEVkZ2VzKHg6IG51bWJlcik6IEVkZ2VOb2RlIHtcclxuXHRcdHJldHVybiB0aGlzLmVkZ2VzW3hdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZGVncmVlIGFzc29jaWF0ZWQgd2l0aCBub2RlIHhcclxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuXHQgKi9cclxuXHRnZXREZWdyZWUoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmRlZ3JlZVt4XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIHRoZSBzcGVjaWZlZCBub2RlIGludG8gYSBzdHJpbmdcclxuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmdcclxuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlOiBcIk5vZGUgeFwiXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIG5vZGVUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIHRoZSBHcmFwaCBpbnRvIGEgc3RyaW5nIGZvcm1hdFxyXG5cdCAqIEByZXR1cm5zIFRoZSBncmFwaCBhcyBhIHN0cmluZ1xyXG5cdCAqL1xyXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRsZXQgcmV0dmFsID0gXCJcIjtcclxuXHJcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1WZXJ0aWNlczsgaSsrKXtcclxuXHRcdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xyXG5cdFx0XHRsZXQgZWRnZVN0ciA9IFwiXCI7XHJcblx0XHRcdHdoaWxlKGVkZ2UgIT09IG51bGwpe1xyXG5cdFx0XHRcdGVkZ2VTdHIgKz0gZWRnZS55LnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0aWYodGhpcy53ZWlnaHRlZCl7XHJcblx0XHRcdFx0XHRlZGdlU3RyICs9IFwiIChcIiArIGVkZ2Uud2VpZ2h0ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGVkZ2UubmV4dCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0XHRlZGdlU3RyICs9IFwiLCBcIjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHZhbCArPSB0aGlzLm5vZGVUb1N0cmluZyhpKSArIFwiOiBcIiArIGVkZ2VTdHIgKyBcIlxcblwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXR2YWw7XHJcblx0fVxyXG59IiwiaW1wb3J0IEdyYXBoLCB7IE1BWF9WIH0gZnJvbSBcIi4vR3JhcGhcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IERlYnVnUmVuZGVyYWJsZSBmcm9tIFwiLi4vSW50ZXJmYWNlcy9EZWJ1Z1JlbmRlcmFibGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBleHRlbnNpb24gb2YgR3JhcGggdGhhdCBoYXMgbm9kZXMgd2l0aCBwb3NpdGlvbnMgaW4gMkQgc3BhY2UuXHJcbiAqIFRoaXMgaXMgYSB3ZWlnaHRlZCBncmFwaCAodGhvdWdoIG5vdCBpbmhlcmVudGx5IGRpcmVjdGQpXHJcbiovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc2l0aW9uR3JhcGggZXh0ZW5kcyBHcmFwaCBpbXBsZW1lbnRzIERlYnVnUmVuZGVyYWJsZSB7XHJcblx0LyoqIEFuIGFycmF5IG9mIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzIGluIHRoaXMgZ3JhcGggKi9cclxuXHRwb3NpdGlvbnM6IEFycmF5PFZlYzI+O1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVlcyBhIG5ldyBQb3NpdGlvbkdyYXBoXHJcblx0ICogQHBhcmFtIGRpcmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoaXMgZ3JhcGggaXMgZGlyZWN0ZWRcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihkaXJlY3RlZDogYm9vbGVhbiA9IGZhbHNlKXtcclxuXHRcdHN1cGVyKGRpcmVjdGVkKTtcclxuXHRcdHRoaXMucG9zaXRpb25zID0gbmV3IEFycmF5KE1BWF9WKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBwb3NpdGlvbmVkIG5vZGUgdG8gdGhpcyBncmFwaFxyXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgdG8gYWRkXHJcblx0ICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBhZGRlZCBub2RlXHJcblx0ICovXHJcblx0YWRkUG9zaXRpb25lZE5vZGUocG9zaXRpb246IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0dGhpcy5wb3NpdGlvbnNbdGhpcy5udW1WZXJ0aWNlc10gPSBwb3NpdGlvbjtcclxuXHRcdHJldHVybiB0aGlzLmFkZE5vZGUoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZS5cclxuXHQgKiBBdXRvbWF0aWNhbGx5IGFkanVzdHMgdGhlIHdlaWdodHMgb2YgdGhlIGdyYXBoIHRpZWQgdG8gdGhpcyBub2RlLlxyXG5cdCAqIEFzIHN1Y2gsIGJlIHdhcm5lZCB0aGF0IHRoaXMgZnVuY3Rpb24gaGFzIGFuIE8obiArIG0pIHJ1bm5pbmcgdGltZSwgYW5kIHVzZSBpdCBzcGFyaW5nbHkuXHJcblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxyXG5cdCAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBub2RlXHJcblx0ICovXHJcblx0c2V0Tm9kZVBvc2l0aW9uKGluZGV4OiBudW1iZXIsIHBvc2l0aW9uOiBWZWMyKTogdm9pZCB7XHJcblx0XHR0aGlzLnBvc2l0aW9uc1tpbmRleF0gPSBwb3NpdGlvbjtcclxuXHJcblx0XHQvLyBSZWNhbGN1bGF0ZSBhbGwgd2VpZ2h0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmRleFxyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubnVtRWRnZXM7IGkrKyl7XHJcblxyXG5cdFx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbaV07XHJcblxyXG5cdFx0XHR3aGlsZShlZGdlICE9PSBudWxsKXtcclxuXHRcdFx0XHQvLyBJZiB0aGlzIG5vZGUgaXMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGVkZ2UsIHJlY2FsY3VsYXRlIHdlaWdodFxyXG5cdFx0XHRcdGlmKGkgPT09IGluZGV4IHx8IGVkZ2UueSA9PT0gaW5kZXgpe1xyXG5cdFx0XHRcdFx0ZWRnZS53ZWlnaHQgPSB0aGlzLnBvc2l0aW9uc1tpXS5kaXN0YW5jZVRvKHRoaXMucG9zaXRpb25zW2VkZ2UueV0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgYSBub2RlXHJcblx0ICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZVxyXG5cdCAqL1xyXG5cdGdldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5wb3NpdGlvbnNbaW5kZXhdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhbiBlZGdlIHRvIHRoaXMgZ3JhcGggYmV0d2VlbiBub2RlIHggYW5kIHkuXHJcblx0ICogQXV0b21hdGljYWxseSBjYWxjdWxhdGVzIHRoZSB3ZWlnaHQgb2YgdGhlIGVkZ2UgYXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vZGVzLlxyXG5cdCAqIEBwYXJhbSB4IFRoZSBiZWdpbm5pbmcgb2YgdGhlIGVkZ2VcclxuXHQgKiBAcGFyYW0geSBUaGUgZW5kIG9mIHRoZSBlZGdlXHJcblx0ICovXHJcblx0YWRkRWRnZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYoIXRoaXMucG9zaXRpb25zW3hdIHx8ICF0aGlzLnBvc2l0aW9uc1t5XSl7XHJcblx0XHRcdHRocm93IFwiQ2FuJ3QgYWRkIGVkZ2UgdG8gdW4tcG9zaXRpb25lZCBub2RlIVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdlaWdodCBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbm9kZXNcclxuXHRcdGxldCB3ZWlnaHQgPSB0aGlzLnBvc2l0aW9uc1t4XS5kaXN0YW5jZVRvKHRoaXMucG9zaXRpb25zW3ldKTtcclxuXHJcblx0XHRzdXBlci5hZGRFZGdlKHgsIHksIHdlaWdodCk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgbm9kZVRvU3RyaW5nKGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiTm9kZSBcIiArIGluZGV4ICsgXCIgLSBcIiArIHRoaXMucG9zaXRpb25zW2luZGV4XS50b1N0cmluZygpO1xyXG5cdH1cclxuXHJcblx0ZGVidWdSZW5kZXIgPSAoKTogdm9pZCA9PiB7XHJcblx0XHQvLyBmb3IobGV0IHBvaW50IG9mIHRoaXMucG9zaXRpb25zKXtcclxuXHRcdC8vIFx0Y3R4LmZpbGxSZWN0KChwb2ludC54IC0gb3JpZ2luLnggLSA0KSp6b29tLCAocG9pbnQueSAtIG9yaWdpbi55IC0gNCkqem9vbSwgOCwgOCk7XHJcblx0XHQvLyB9XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL1NoYXBlcy9BQUJCXCI7XHJcblxyXG4vKiogQW4gb2JqZWN0IHRoYXQgaXMgYSByZWdpb24sIHdpdGggYSBzaXplLCBzY2FsZSwgYW5kIGJvdW5kYXJ5LiAqL1xyXG5leHBvcnQgZGVmYXVsdCBpbnRlcmZhY2UgUmVnaW9uIHtcclxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGlzIG9iamVjdC4gKi9cclxuICAgIHNpemU6IFZlYzI7XHJcblxyXG4gICAgLyoqIFRoZSBzY2FsZSBvZiB0aGlzIG9iamVjdC4gKi9cclxuICAgIHNjYWxlOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGFjY291bnQgdGhlIHpvb20gYW5kIHNjYWxlICovXHJcbiAgICByZWFkb25seSBzaXplV2l0aFpvb206IFZlYzI7XHJcblxyXG4gICAgLyoqIFRoZSBib3VuZGluZyBib3ggb2YgdGhpcyBvYmplY3QuICovXHJcbiAgICBib3VuZGFyeTogQUFCQjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnaW9uKGFyZzogYW55KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gYXJnICYmIGFyZy5zaXplICYmIGFyZy5zY2FsZSAmJiBhcmcuYm91bmRhcnk7XHJcbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi9Db2xsZWN0aW9uXCI7XHJcblxyXG4vKipcclxuICogQXNzb2NpYXRlcyBzdHJpbmdzIHdpdGggZWxlbWVudHMgb2YgdHlwZSBUXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXA8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcclxuXHRwcml2YXRlIG1hcDogUmVjb3JkPHN0cmluZywgVD47XHJcblxyXG5cdC8qKiBDcmVhdGVzIGEgbmV3IG1hcCAqL1xyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLm1hcCA9IHt9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIHZhbHVlIFQgc3RvcmVkIGF0IGEga2V5LlxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBiZSBzdG9yZWRcclxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXHJcblx0ICovXHJcblx0YWRkKGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xyXG5cdFx0dGhpcy5tYXBba2V5XSA9IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBrZXkuXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtXHJcblx0ICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGtleSBvciB1bmRlZmluZWRcclxuXHQgKi9cclxuXHRnZXQoa2V5OiBzdHJpbmcpOiBUIHtcclxuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQW4gYWxpYXMgb2YgYWRkLiBTZXRzIHRoZSB2YWx1ZSBzdG9yZWQgYXQga2V5IHRvIHRoZSBuZXcgc3BlY2lmaWVkIHZhbHVlXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGJlIHN0b3JlZFxyXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgaXRlbSB0byBiZSBzdG9yZWRcclxuXHQgKi9cclxuXHRzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBUKTogdm9pZCB7XHJcblx0XHR0aGlzLmFkZChrZXksIHZhbHVlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhIHZhbHVlIHN0b3JlZCBhdCB0aGUgc3BlY2lmaWVkIGtleSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBjaGVja1xyXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGUgZ2l2ZW4ga2V5LlxyXG5cdCAqL1xyXG5cdGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMubWFwW2tleV0gIT09IHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBrZXlzIGluIHRoaXMgbWFwLlxyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIGtleXMgaW4gdGhlIG1hcC5cclxuXHQgKi9cclxuXHRrZXlzKCk6IEFycmF5PHN0cmluZz4ge1xyXG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKTtcclxuXHR9XHJcblx0XHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0Zm9yRWFjaChmdW5jOiAoa2V5OiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcclxuXHRcdE9iamVjdC5rZXlzKHRoaXMubWFwKS5mb3JFYWNoKGtleSA9PiBmdW5jKGtleSkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVsZXRlcyBhbiBpdGVtIGFzc29jaWF0ZWQgd2l0aCBhIGtleVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBhdCB3aGljaCB0byBkZWxldGUgYW4gaXRlbVxyXG5cdCAqL1xyXG5cdGRlbGV0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0ZGVsZXRlIHRoaXMubWFwW2tleV07XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRjbGVhcigpOiB2b2lkIHtcclxuXHRcdHRoaXMuZm9yRWFjaChrZXkgPT4gZGVsZXRlIHRoaXMubWFwW2tleV0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgdGhpcyBtYXAgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcblx0ICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG1hcC5cclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0bGV0IHN0ciA9IFwiXCI7XHJcblxyXG5cdFx0dGhpcy5mb3JFYWNoKChrZXkpID0+IHN0ciArPSBrZXkgKyBcIiAtPiBcIiArIHRoaXMuZ2V0KGtleSkudG9TdHJpbmcoKSArIFwiXFxuXCIpO1xyXG5cclxuXHRcdHJldHVybiBzdHI7XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4vVmVjMlwiO1xyXG5cclxuLyoqIEEgNHg0IG1hdHJpeDAgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0NHg0IHtcclxuXHRwcml2YXRlIG1hdDogRmxvYXQzMkFycmF5O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5tYXQgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuXHRcdFx0MCwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMFxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHQvLyBTdGF0aWMgbWVtYmVyc1xyXG5cdHN0YXRpYyBnZXQgSURFTlRJVFkoKTogTWF0NHg0IHtcclxuXHRcdHJldHVybiBuZXcgTWF0NHg0KCkuaWRlbnRpdHkoKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXQgWkVSTygpOiBNYXQ0eDQge1xyXG5cdFx0cmV0dXJuIG5ldyBNYXQ0eDQoKS56ZXJvKCk7XHJcblx0fVxyXG5cclxuXHQvLyBBY2Nlc3NvcnNcclxuXHRzZXQgXzAwKHg6IG51bWJlcikge1xyXG5cdFx0dGhpcy5tYXRbMF0gPSB4O1xyXG5cdH1cclxuXHJcblx0c2V0KGNvbDogbnVtYmVyLCByb3c6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IE1hdDR4NCB7XHJcblx0XHRpZihjb2wgPCAwIHx8IGNvbCA+IDMgfHwgcm93IDwgMCB8fCByb3cgPiAzKXtcclxuXHRcdFx0dGhyb3cgYEVycm9yIC0gaW5kZXggKCR7Y29sfSwgJHtyb3d9KSBpcyBvdXQgb2YgYm91bmRzIGZvciBNYXQ0eDRgXHJcblx0XHR9XHJcblx0XHR0aGlzLm1hdFtyb3cqNCArIGNvbF0gPSB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdGdldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF0W3Jvdyo0ICsgY29sXTtcclxuXHR9XHJcblxyXG5cdHNldEFsbCguLi5pdGVtczogQXJyYXk8bnVtYmVyPik6IE1hdDR4NCB7XHJcblx0XHR0aGlzLm1hdC5zZXQoaXRlbXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRpZGVudGl0eSgpOiBNYXQ0eDQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblx0XHQpXHJcblx0fVxyXG5cclxuXHR6ZXJvKCk6IE1hdDR4NCB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDBcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNYWtlcyB0aGlzIE1hdDR4NCBhIHJvdGF0aW9uIG1hdHJpeCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiByYWRpYW5zIGNjd1xyXG5cdCAqIEBwYXJhbSB6UmFkaWFucyBUaGUgbnVtYmVyIG9mIHJhZGlhbnMgdG8gcm90YXRlXHJcblx0ICogQHJldHVybnMgdGhpcyBNYXQ0eDRcclxuXHQgKi9cclxuXHRyb3RhdGUoelJhZGlhbnM6IG51bWJlcik6IE1hdDR4NCB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXHJcblx0XHRcdE1hdGguY29zKHpSYWRpYW5zKSwgLU1hdGguc2luKHpSYWRpYW5zKSwgXHQwLCAwLFxyXG5cdFx0XHRNYXRoLnNpbih6UmFkaWFucyksIE1hdGguY29zKHpSYWRpYW5zKSwgXHQwLCAwLFxyXG5cdFx0XHQwLCBcdFx0XHRcdFx0MCwgXHRcdFx0XHRcdFx0MSwgMCxcclxuXHRcdFx0MCwgXHRcdFx0XHRcdDAsIFx0XHRcdFx0XHRcdDAsIDFcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUdXJucyB0aGlzIE1hdDR4NCBpbnRvIGEgdHJhbnNsYXRpb24gbWF0cml4IG9mIHRoZSBzcGVjaWZpZWQgdHJhbnNsYXRpb25cclxuXHQgKiBAcGFyYW0gdHJhbnNsYXRpb24gVGhlIHRyYW5zbGF0aW9uIGluIHggYW5kIHlcclxuXHQgKiBAcmV0dXJucyB0aGlzIE1hdDR4NFxyXG5cdCAqL1xyXG5cdHRyYW5zbGF0ZSh0cmFuc2xhdGlvbjogVmVjMiB8IEZsb2F0MzJBcnJheSk6IE1hdDR4NCB7XHJcblx0XHQvLyBJZiB0cmFuc2xhdGlvbiBpcyBhIHZlYywgZ2V0IGl0cyBhcnJheVxyXG5cdFx0aWYodHJhbnNsYXRpb24gaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0dHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbi50b0FycmF5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHQxLCAwLCAwLCB0cmFuc2xhdGlvblswXSxcclxuXHRcdFx0MCwgMSwgMCwgdHJhbnNsYXRpb25bMV0sXHJcblx0XHRcdDAsIDAsIDEsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRzY2FsZShzY2FsZTogVmVjMiB8IEZsb2F0MzJBcnJheSB8IG51bWJlcik6IE1hdDR4NCB7XHJcblx0XHQvLyBNYWtlIHN1cmUgc2NhbGUgaXMgYSBmbG9hdDMyQXJyYXlcclxuXHRcdGlmKHNjYWxlIGluc3RhbmNlb2YgVmVjMil7XHJcblx0XHRcdHNjYWxlID0gc2NhbGUudG9BcnJheSgpO1xyXG5cdFx0fSBlbHNlIGlmKCEoc2NhbGUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKXtcclxuXHRcdFx0c2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFtzY2FsZSwgc2NhbGVdKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRBbGwoXHJcblx0XHRcdHNjYWxlWzBdLCAwLCBcdFx0MCwgMCxcclxuXHRcdFx0MCwgXHRcdCAgc2NhbGVbMV0sIDAsIDAsXHJcblx0XHRcdDAsIFx0XHQgIDAsXHRcdDEsIDAsXHJcblx0XHRcdDAsIFx0XHQgIDAsXHRcdDAsIDFcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IE1hdDR4NCB0aGF0IHJlcHJlc2VudHMgdGhlIHJpZ2h0IHNpZGUgbXVsdGlwbGljYXRpb24gVEhJUyB4IE9USEVSXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBNYXQ0eDQgdG8gbXVsdGlwbHkgYnlcclxuXHQgKiBAcmV0dXJucyBhIG5ldyBNYXQ0eDQgY29udGFpbmluZyB0aGUgcHJvZHVjdCBvZiB0aGVzZSB0d28gTWF0NHg0c1xyXG5cdCAqL1xyXG5cdG11bHQob3RoZXI6IE1hdDR4NCwgb3V0PzogTWF0NHg0KTogTWF0NHg0IHtcclxuXHRcdGxldCB0ZW1wID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IDQ7IGkrKyl7XHJcblx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCA0OyBqKyspe1xyXG5cdFx0XHRcdGxldCB2YWx1ZSA9IDA7XHJcblx0XHRcdFx0Zm9yKGxldCBrID0gMDsgayA8IDQ7IGsrKyl7XHJcblx0XHRcdFx0XHR2YWx1ZSArPSB0aGlzLmdldChrLCBpKSAqIG90aGVyLmdldChqLCBrKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGVtcFtqKjQgKyBpXSAgPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmKG91dCAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0cmV0dXJuIG91dC5zZXRBbGwoLi4udGVtcCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLnNldEFsbCguLi50ZW1wKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE11bHRpcGxpZXMgYWxsIGdpdmVuIG1hdHJpY2llcyBpbiBvcmRlci4gZS5nLiBNVUxUKEEsIEIsIEMpIC0+IEEqQipDXHJcblx0ICogQHBhcmFtIG1hdHMgQSBsaXN0IG9mIE1hdDR4NHMgdG8gbXVsdGlwbHkgaW4gb3JkZXJcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBNYXQ0eDQgaG9sZGluZyB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cclxuXHQgKi9cclxuXHRzdGF0aWMgTVVMVCguLi5tYXRzOiBBcnJheTxNYXQ0eDQ+KTogTWF0NHg0IHtcclxuXHRcdC8vIENyZWF0ZSBhIG5ldyBhcnJheVxyXG5cdFx0bGV0IHRlbXAgPSBNYXQ0eDQuSURFTlRJVFk7XHJcblxyXG5cdFx0Ly8gTXVsdGlwbHkgYnkgZXZlcnkgYXJyYXkgaW4gb3JkZXIsIGluIHBsYWNlXHJcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgbWF0cy5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdHRlbXAubXVsdChtYXRzW2ldLCB0ZW1wKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGVtcDtcclxuXHR9XHJcblxyXG5cdHRvQXJyYXkoKTogRmxvYXQzMkFycmF5IHtcclxuXHRcdHJldHVybiB0aGlzLm1hdDtcclxuXHR9XHJcblxyXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gIGB8JHt0aGlzLm1hdFswXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsyXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFszXS50b0ZpeGVkKDIpfXxcXG5gICsgXHJcblx0XHRcdFx0YHwke3RoaXMubWF0WzRdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzVdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzZdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzddLnRvRml4ZWQoMil9fFxcbmAgK1xyXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFs4XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs5XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxMF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTFdLnRvRml4ZWQoMil9fFxcbmAgK1xyXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFsxMl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTNdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzE0XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxNV0udG9GaXhlZCgyKX18YDtcclxuXHR9XHJcbn0iLCJpbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBIaXQgZnJvbSBcIi4vSGl0XCI7XHJcblxyXG4vKipcclxuICogQSBjbGFzcyB0aGF0IGNvbnRhaW5zIHRoZSBhcmVhIG9mIG92ZXJsYXAgb2YgdHdvIGNvbGxpZGluZyBvYmplY3RzIHRvIGFsbG93IGZvciBzb3J0aW5nIGJ5IHRoZSBwaHlzaWNzIHN5c3RlbS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFyZWFDb2xsaXNpb24ge1xyXG4gICAgLyoqIFRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGZvciB0aGUgY29sbGlkaW5nIG9iamVjdHMgKi9cclxuICAgIGFyZWE6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIEFBQkIgb2YgdGhlIG90aGVyIGNvbGxpZGVyIGluIHRoaXMgY29sbGlzaW9uICovXHJcbiAgICBjb2xsaWRlcjogQUFCQjtcclxuXHJcbiAgICAvKiogVHlwZSBvZiB0aGUgY29sbGlzaW9uICovXHJcbiAgICB0eXBlOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIFRoZXIgb3RoZXIgb2JqZWN0IGluIHRoZSBjb2xsaXNpb24gKi9cclxuICAgIG90aGVyOiBQaHlzaWNhbDtcclxuXHJcbiAgICAvKiogVGhlIHRpbGUsIGlmIHRoaXMgd2FzIGEgdGlsZW1hcCBjb2xsaXNpb24gKi9cclxuICAgIHRpbGU6IFZlYzI7XHJcblxyXG4gICAgLyoqIFRoZSBwaHlzaWNzIGhpdCBmb3IgdGhpcyBvYmplY3QgKi9cclxuICAgIGhpdDogSGl0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBcmVhQ29sbGlzaW9uIG9iamVjdFxyXG4gICAgICogQHBhcmFtIGFyZWEgVGhlIGFyZWEgb2YgdGhlIGNvbGxpc2lvblxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyIFRoZSBvdGhlciBjb2xsaWRlclxyXG4gICAgICovXHJcblx0Y29uc3RydWN0b3IoYXJlYTogbnVtYmVyLCBjb2xsaWRlcjogQUFCQiwgb3RoZXI6IFBoeXNpY2FsLCB0eXBlOiBzdHJpbmcsIHRpbGU6IFZlYzIpe1xyXG5cdFx0dGhpcy5hcmVhID0gYXJlYTtcclxuICAgICAgICB0aGlzLmNvbGxpZGVyID0gY29sbGlkZXI7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy50aWxlID0gdGlsZTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGRhdGEgY29sbGVjdGVkIGZyb20gYSBwaHlzaWNzIGhpdCBiZXR3ZWVuIHR3byBnZW9tZXRyaWMgb2JqZWN0cy5cclxuICogSW5zcGlyZWQgYnkgdGhlIGhlbHBmdWwgY29sbGlzaW9uIGRvY3VtZW50YXRpb24gQGxpbmsoaGVyZSkoaHR0cHM6Ly9ub29uYXQuZ2l0aHViLmlvL2ludGVyc2VjdC8pLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGl0IHtcclxuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgY29sbGlzaW9uLiBPbmx5IG51bWJlcnMgMCB0aHJvdWdoIDEgaGFwcGVuIGluIHRoaXMgZnJhbWUuICovXHJcbiAgICB0aW1lOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIG5lYXIgdGltZXMgb2YgdGhlIGNvbGxpc2lvbiAqL1xyXG4gICAgbmVhclRpbWVzOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gICAgLyoqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY29sbGlzaW9uICovXHJcbiAgICBwb3M6IFZlYzIgPSBWZWMyLlpFUk87XHJcbiAgICAvKiogVGhlIG92ZXJsYXAgZGlzdGFuY2Ugb2YgdGhlIGhpdCAqL1xyXG4gICAgZGVsdGE6IFZlYzIgPSBWZWMyLlpFUk87XHJcbiAgICAvKiogVGhlIG5vcm1hbCB2ZWN0b3Igb2YgdGhlIGhpdCAqL1xyXG4gICAgbm9ybWFsOiBWZWMyID0gVmVjMi5aRVJPO1xyXG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgRklGTyBxdWV1ZSB3aXRoIGVsZW1lbnRzIG9mIHR5cGUgVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVldWU8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcclxuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIFF1ZXVlICovXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IE1BWF9FTEVNRU5UUzogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXVlICovXHJcbiAgICBwcml2YXRlIHE6IEFycmF5PFQ+O1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGhlYWQgb2YgdGhlIHF1ZXVlICovXHJcbiAgICBwcml2YXRlIGhlYWQ6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSB0YWlsIG9mIHRoZSBxdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSB0YWlsOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBjdXJyZW50IG51bWJlciBvZiBpdGVtcyBpbiB0aGUgcXVldWUgKi9cclxuICAgIHByaXZhdGUgc2l6ZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBxdWV1ZVxyXG4gICAgICogQHBhcmFtIG1heEVsZW1lbnRzIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHN0YWNrXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzOiBudW1iZXIgPSAxMDApe1xyXG4gICAgICAgIHRoaXMuTUFYX0VMRU1FTlRTID0gbWF4RWxlbWVudHM7XHJcbiAgICAgICAgdGhpcy5xID0gbmV3IEFycmF5KHRoaXMuTUFYX0VMRU1FTlRTKTtcclxuICAgICAgICB0aGlzLmhlYWQgPSAwO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IDA7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcclxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZShpdGVtOiBUKTogdm9pZHtcclxuICAgICAgICBpZigodGhpcy50YWlsICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUyA9PT0gdGhpcy5oZWFkKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgZnVsbCAtIGNhbm5vdCBhZGQgZWxlbWVudFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2l6ZSArPSAxO1xyXG4gICAgICAgIHRoaXMucVt0aGlzLnRhaWxdID0gaXRlbTtcclxuICAgICAgICB0aGlzLnRhaWwgPSAodGhpcy50YWlsICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbiBpdGVtIGZyb20gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxyXG4gICAgICovXHJcbiAgICBkZXF1ZXVlKCk6IFQge1xyXG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gdGhpcy50YWlsKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgZW1wdHkgLSBjYW5ub3QgcmVtb3ZlIGVsZW1lbnRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5zaXplIC09IDE7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcclxuICAgICAgICAvLyBOb3cgZGVsZXRlIHRoZSBpdGVtXHJcbiAgICAgICAgZGVsZXRlIHRoaXMucVt0aGlzLmhlYWRdO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9ICh0aGlzLmhlYWQgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlLCBidXQgZG9lcyBub3QgcmVtb3ZlIGl0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXHJcbiAgICAgKi9cclxuICAgIHBlZWtOZXh0KCk6IFQge1xyXG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gdGhpcy50YWlsKXtcclxuICAgICAgICAgICAgdGhyb3cgXCJRdWV1ZSBlbXB0eSAtIGNhbm5vdCBnZXQgZWxlbWVudFwiXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaXRlbSA9IHRoaXMucVt0aGlzLmhlYWRdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBxdWV1ZSBoYXMgaXRlbXMgaW4gaXQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHF1ZXVlIGhhcyBpdGVtc1xyXG4gICAgICovXHJcbiAgICBoYXNJdGVtcygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWFkICE9PSB0aGlzLnRhaWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHNpemUgb2YgdGhlIHF1ZXVlXHJcbiAgICAgKi9cclxuICAgIGdldFNpemUoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gZGVsZXRlIHRoaXMucVtpbmRleF0pO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgZm9yRWFjaChmdW5jOiAoaXRlbTogVCwgaW5kZXg/OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaSA9IHRoaXMuaGVhZDtcclxuICAgICAgICB3aGlsZShpICE9PSB0aGlzLnRhaWwpe1xyXG4gICAgICAgICAgICBmdW5jKHRoaXMucVtpXSwgaSk7XHJcbiAgICAgICAgICAgIGkgPSAoaSArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBxdWV1ZSBpbnRvIGEgc3RyaW5nIGZvcm1hdFxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgcXVldWVcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgcmV0dmFsID0gXCJcIjtcclxuXHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKCAoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN0ciA9IGl0ZW0udG9TdHJpbmcoKVxyXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIgLT4gXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR2YWwgPSBzdHIgKyByZXR2YWw7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBcIlRvcCAtPiBcIiArIHJldHZhbDtcclxuICAgIH1cclxufSIsIi8qKiBBIGNvbnRhaW5lciBmb3IgaW5mbyBhYm91dCBhIHdlYkdMIHNoYWRlciBwcm9ncmFtICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMUHJvZ3JhbVR5cGUge1xyXG5cdC8qKiBBIHdlYkdMIHByb2dyYW0gKi9cclxuXHRwcm9ncmFtOiBXZWJHTFByb2dyYW07XHJcblx0XHJcblx0LyoqIEEgdmVydGV4IHNoYWRlciAqL1xyXG5cdHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXI7XHJcblxyXG5cdC8qKiBBIGZyYWdtZW50IHNoYWRlciAqL1xyXG5cdGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlcjtcclxuXHJcblx0LyoqXHJcblx0ICogRGVsZXRlcyB0aGlzIHNoYWRlciBwcm9ncmFtXHJcblx0ICovXHJcblx0ZGVsZXRlKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiB2b2lkIHtcclxuXHRcdC8vIENsZWFuIHVwIGFsbCBhc3BlY3RzIG9mIHRoaXMgcHJvZ3JhbVxyXG5cdFx0aWYodGhpcy5wcm9ncmFtKXtcclxuXHRcdFx0Z2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG5cdFx0fVxyXG5cdFx0XHRcclxuXHRcdGlmKHRoaXMudmVydGV4U2hhZGVyKXtcclxuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLmZyYWdtZW50U2hhZGVyKXtcclxuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKHRoaXMuZnJhZ21lbnRTaGFkZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBTaGFwZSBmcm9tIFwiLi9TaGFwZVwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcclxuaW1wb3J0IEhpdCBmcm9tIFwiLi4vUGh5c2ljcy9IaXRcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBBeGlzLUFsaWduZWQgQm91bmRpbmcgQm94LiBJbiBvdGhlciB3b3JkcywgYSByZWN0YW5nbGUgdGhhdCBpcyBhbHdheXMgYWxpZ25lZCB0byB0aGUgeC15IGdyaWQuXHJcbiAqIEluc3BpcmVkIGJ5IHRoZSBoZWxwZnVsIGNvbGxpc2lvbiBkb2N1bWVudGF0aW9uIEBsaW5rKGhlcmUpKGh0dHBzOi8vbm9vbmF0LmdpdGh1Yi5pby9pbnRlcnNlY3QvKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFBQkIgZXh0ZW5kcyBTaGFwZSB7XHJcbiAgICBjZW50ZXI6IFZlYzI7XHJcbiAgICBoYWxmU2l6ZTogVmVjMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgQUFCQlxyXG4gICAgICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBBQUJCXHJcbiAgICAgKiBAcGFyYW0gaGFsZlNpemUgVGhlIGhhbGYgc2l6ZSBvZiB0aGUgQUFCQiAtIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgdG8gYW4gZWRnZSBpbiB4IGFuZCB5XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNlbnRlcj86IFZlYzIsIGhhbGZTaXplPzogVmVjMil7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgICAgIHRoaXMuaGFsZlNpemUgPSBoYWxmU2l6ZSA/IGhhbGZTaXplIDogbmV3IFZlYzIoMCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgQUFCQiAqL1xyXG4gICAgZ2V0IHRvcExlZnQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubGVmdCwgdGhpcy50b3ApXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICAgIGdldCB0b3BSaWdodCgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5yaWdodCwgdGhpcy50b3ApXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgQUFCQiAqL1xyXG4gICAgZ2V0IGJvdHRvbUxlZnQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubGVmdCwgdGhpcy5ib3R0b20pXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybnMgYSBwb2ludCByZXByZXNlbnRpbmcgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICAgIGdldCBib3R0b21SaWdodCgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBnZXRCb3VuZGluZ1JlY3QoKTogQUFCQiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZSB7XHJcbiAgICAgICAgbGV0IHIgPSBNYXRoLm1heCh0aGlzLmh3LCB0aGlzLmhoKVxyXG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuY2VudGVyLmNsb25lKCksIHIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBkZXByZWNhdGVkXHJcbiAgICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYWxmU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgc2V0SGFsZlNpemUoaGFsZlNpemU6IFZlYzIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyAtIG1vdmUgdGhlc2UgYWxsIHRvIHRoZSBTaGFwZSBjbGFzc1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPj0gdGhpcy54IC0gdGhpcy5odyAmJiBwb2ludC54IDw9IHRoaXMueCArIHRoaXMuaHdcclxuICAgICAgICAgICAgJiYgcG9pbnQueSA+PSB0aGlzLnkgLSB0aGlzLmhoICYmIHBvaW50LnkgPD0gdGhpcy55ICsgdGhpcy5oaFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludFxyXG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdFBvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IGR4ID0gcG9pbnQueCAtIHRoaXMueDtcclxuICAgICAgICBsZXQgcHggPSB0aGlzLmh3IC0gTWF0aC5hYnMoZHgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHB4IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggLSBNYXRoLmFicyhkeSk7XHJcblxyXG4gICAgICAgIGlmKHB5IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50IHdpdGggc29mdCBsZWZ0IGFuZCB0b3AgYm91bmRhcmllcy5cclxuICAgICAqIEluIG90aGVyIHdvcmRzLCBpZiB0aGUgdG9wIGxlZnQgaXMgKDAsIDApLCB0aGUgcG9pbnQgKDAsIDApIGlzIG5vdCBpbiB0aGUgQUFCQlxyXG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyB0aGUgc3BlY2lmaWVkIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zUG9pbnRTb2Z0KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPiB0aGlzLnggLSB0aGlzLmh3ICYmIHBvaW50LnggPD0gdGhpcy54ICsgdGhpcy5od1xyXG4gICAgICAgICAgICAmJiBwb2ludC55ID4gdGhpcy55IC0gdGhpcy5oaCAmJiBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRhIGZyb20gdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIEFBQkIgd2l0aCBhIGxpbmUgc2VnbWVudCBmcm9tIGEgcG9pbnQgaW4gYSBkaXJlY3Rpb25cclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdGhhdCB0aGUgbGluZSBzZWdtZW50IHN0YXJ0cyBmcm9tXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIGRpcmVjdGlvbiBhbmQgZGlzdGFuY2Ugb2YgdGhlIHNlZ21lbnRcclxuICAgICAqIEBwYXJhbSBwYWRkaW5nIFBhZHMgdGhlIEFBQkIgdG8gbWFrZSBpdCB3aWRlciBmb3IgdGhlIGludGVyc2VjdGlvbiB0ZXN0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgSGl0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGludGVyc2VjdGlvbiwgb3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdFNlZ21lbnQocG9pbnQ6IFZlYzIsIGRlbHRhOiBWZWMyLCBwYWRkaW5nPzogVmVjMik6IEhpdCB7XHJcbiAgICAgICAgbGV0IHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmcueCA6IDA7XHJcbiAgICAgICAgbGV0IHBhZGRpbmdZID0gcGFkZGluZyA/IHBhZGRpbmcueSA6IDA7XHJcblxyXG4gICAgICAgIGxldCBzY2FsZVggPSAxL2RlbHRhLng7XHJcbiAgICAgICAgbGV0IHNjYWxlWSA9IDEvZGVsdGEueTtcclxuXHJcbiAgICAgICAgbGV0IHNpZ25YID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVYKTtcclxuICAgICAgICBsZXQgc2lnblkgPSBNYXRoVXRpbHMuc2lnbihzY2FsZVkpO1xyXG5cclxuICAgICAgICBsZXQgdG5lYXJ4ID0gc2NhbGVYKih0aGlzLnggLSBzaWduWCoodGhpcy5odyArIHBhZGRpbmdYKSAtIHBvaW50LngpO1xyXG4gICAgICAgIGxldCB0bmVhcnkgPSBzY2FsZVkqKHRoaXMueSAtIHNpZ25ZKih0aGlzLmhoICsgcGFkZGluZ1kpIC0gcG9pbnQueSk7XHJcbiAgICAgICAgbGV0IHRmYXJ4ID0gc2NhbGVYKih0aGlzLnggKyBzaWduWCoodGhpcy5odyArIHBhZGRpbmdYKSAtIHBvaW50LngpO1xyXG4gICAgICAgIGxldCB0ZmFyeSA9IHNjYWxlWSoodGhpcy55ICsgc2lnblkqKHRoaXMuaGggKyBwYWRkaW5nWSkgLSBwb2ludC55KTtcclxuICAgICAgICBcclxuICAgICAgICBpZih0bmVhcnggPiB0ZmFyeSB8fCB0bmVhcnkgPiB0ZmFyeCl7XHJcbiAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBjb2xsaWRpbmcgLSB3ZSBjbGVhciBvbmUgYXhpcyBiZWZvcmUgaW50ZXJzZWN0aW5nIGFub3RoZXJcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdG5lYXIgPSBNYXRoLm1heCh0bmVhcngsIHRuZWFyeSk7XHJcblxyXG4gICAgICAgIC8vIERvdWJsZSBjaGVjayBmb3IgTmFOc1xyXG4gICAgICAgIGlmKHRuZWFyeCAhPT0gdG5lYXJ4KXtcclxuICAgICAgICAgICAgdG5lYXIgPSB0bmVhcnk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0bmVhcnkgIT09IHRuZWFyeSl7XHJcbiAgICAgICAgICAgIHRuZWFyID0gdG5lYXJ4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRmYXIgPSBNYXRoLm1pbih0ZmFyeCwgdGZhcnkpO1xyXG5cclxuICAgICAgICBpZih0bmVhciA9PT0gLUluZmluaXR5KXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0bmVhciA+PSAxIHx8IHRmYXIgPD0gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2UgYXJlIGNvbGxpZGluZ1xyXG4gICAgICAgIGxldCBoaXQgPSBuZXcgSGl0KCk7XHJcbiAgICAgICAgaGl0LnRpbWUgPSBNYXRoVXRpbHMuY2xhbXAwMSh0bmVhcik7XHJcbiAgICAgICAgaGl0Lm5lYXJUaW1lcy54ID0gdG5lYXJ4O1xyXG4gICAgICAgIGhpdC5uZWFyVGltZXMueSA9IHRuZWFyeTtcclxuXHJcbiAgICAgICAgaWYodG5lYXJ4ID4gdG5lYXJ5KXtcclxuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpemVcclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC54ID0gLXNpZ25YO1xyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZihNYXRoLmFicyh0bmVhcnggLSB0bmVhcnkpIDwgMC4wMDAxKXtcclxuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSBjb3JuZXJcclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC54ID0gLXNpZ25YO1xyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV2UgaGl0IG9uIHRoZSB0b3Agb3IgYm90dG9tXHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IDA7XHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueSA9IC1zaWduWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGhpdC5kZWx0YS54ID0gKDEuMCAtIGhpdC50aW1lKSAqIC1kZWx0YS54O1xyXG4gICAgICAgIGhpdC5kZWx0YS55ID0gKDEuMCAtIGhpdC50aW1lKSAqIC1kZWx0YS55O1xyXG4gICAgICAgIGhpdC5wb3MueCA9IHBvaW50LnggKyBkZWx0YS54ICogaGl0LnRpbWU7XHJcbiAgICAgICAgaGl0LnBvcy55ID0gcG9pbnQueSArIGRlbHRhLnkgKiBoaXQudGltZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhpdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIG92ZXJsYXBzKG90aGVyOiBTaGFwZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmKG90aGVyIGluc3RhbmNlb2YgQUFCQil7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXBzQUFCQihvdGhlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IFwiT3ZlcmxhcCBub3QgZGVmaW5lZCBiZXR3ZWVuIHRoZXNlIHNoYXBlcy5cIlxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBvdmVybGFwcyBhbm90aGVyXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIEFBQkIgb3ZlcmxhcHMgdGhlIG90aGVyLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG92ZXJsYXBzQUFCQihvdGhlcjogQUFCQik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XHJcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHB4IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xyXG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcclxuXHJcbiAgICAgICAgaWYocHkgPD0gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXNlIEFBQkJzIGFyZSBKVVNUIHRvdWNoaW5nIC0gbm90IG92ZXJsYXBwaW5nLlxyXG4gICAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXHJcbiAgICAgKiBMaWtld2lzZSwgVmVjMi55IGlzIC0xIGlmIHRoZSBvdGhlciBpcyBvbiB0b3AsIDEgaWYgb24gYm90dG9tLlxyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29sbGlzaW9uIHNpZGVzIHN0b3JlZCBpbiBhIFZlYzIgaWYgdGhlIEFBQkJzIGFyZSB0b3VjaGluZywgbnVsbCBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgdG91Y2hlc0FBQkIob3RoZXI6IEFBQkIpOiBWZWMyIHtcclxuICAgICAgICBsZXQgZHggPSBvdGhlci54IC0gdGhpcy54O1xyXG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcclxuXHJcbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcclxuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XHJcblxyXG4gICAgICAgIC8vIElmIG9uZSBheGlzIGlzIGp1c3QgdG91Y2hpbmcgYW5kIHRoZSBvdGhlciBpcyBvdmVybGFwcGluZywgdHJ1ZVxyXG4gICAgICAgIGlmKChweCA9PT0gMCAmJiBweSA+PSAwKSB8fCAocHkgPT09IDAgJiYgcHggPj0gMCkpe1xyXG4gICAgICAgICAgICBsZXQgcmV0ID0gbmV3IFZlYzIoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHB4ID09PSAwKXtcclxuICAgICAgICAgICAgICAgIHJldC54ID0gb3RoZXIueCA8IHRoaXMueCA/IC0xIDogMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYocHkgPT09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0LnkgPSBvdGhlci55IDwgdGhpcy55ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGVzZSBBQUJCcyBhcmUgSlVTVCB0b3VjaGluZyAtIG5vdCBvdmVybGFwcGluZy5cclxuICAgICAqIEFsc28sIGlmIHRoZXkgYXJlIG9ubHkgdG91Y2hpbmcgY29ybmVycywgdGhleSBhcmUgY29uc2lkZXJlZCBub3QgdG91Y2hpbmcuXHJcbiAgICAgKiBWZWMyLnggaXMgLTEgaWYgdGhlIG90aGVyIGlzIHRvIHRoZSBsZWZ0LCAxIGlmIHRvIHRoZSByaWdodC5cclxuICAgICAqIExpa2V3aXNlLCBWZWMyLnkgaXMgLTEgaWYgdGhlIG90aGVyIGlzIG9uIHRvcCwgMSBpZiBvbiBib3R0b20uXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkIgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIFRoZSBzaWRlIG9mIHRoZSB0b3VjaCwgc3RvcmVkIGFzIGEgVmVjMiwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyB0b3VjaFxyXG4gICAgICovXHJcbiAgICB0b3VjaGVzQUFCQldpdGhvdXRDb3JuZXJzKG90aGVyOiBBQUJCKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcclxuICAgICAgICBsZXQgcHggPSB0aGlzLmh3ICsgb3RoZXIuaHcgLSBNYXRoLmFicyhkeCk7XHJcblxyXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XHJcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgICAgICAvLyBJZiBvbmUgYXhpcyBpcyB0b3VjaGluZywgYW5kIHRoZSBvdGhlciBpcyBzdHJpY3RseSBvdmVybGFwcGluZ1xyXG4gICAgICAgIGlmKChweCA9PT0gMCAmJiBweSA+IDApIHx8IChweSA9PT0gMCAmJiBweCA+IDApKXtcclxuICAgICAgICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XHJcblxyXG4gICAgICAgICAgICBpZihweCA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXQueSA9IG90aGVyLnkgPCB0aGlzLnkgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgYmV0d2VlbiB0aGlzIEFBQkIgYW5kIGFub3RoZXJcclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQlxyXG4gICAgICogQHJldHVybnMgVGhlIGFyZWEgb2YgdGhlIG92ZXJsYXAgYmV0d2VlbiB0aGUgQUFCQnNcclxuICAgICAqL1xyXG4gICAgb3ZlcmxhcEFyZWEob3RoZXI6IEFBQkIpOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBsZWZ0eCA9IE1hdGgubWF4KHRoaXMueCAtIHRoaXMuaHcsIG90aGVyLnggLSBvdGhlci5odyk7XHJcbiAgICAgICAgbGV0IHJpZ2h0eCA9IE1hdGgubWluKHRoaXMueCArIHRoaXMuaHcsIG90aGVyLnggKyBvdGhlci5odyk7XHJcbiAgICAgICAgbGV0IGR4ID0gcmlnaHR4IC0gbGVmdHg7XHJcblxyXG4gICAgICAgIGxldCBsZWZ0eSA9IE1hdGgubWF4KHRoaXMueSAtIHRoaXMuaGgsIG90aGVyLnkgLSBvdGhlci5oaCk7XHJcbiAgICAgICAgbGV0IHJpZ2h0eSA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGgsIG90aGVyLnkgKyBvdGhlci5oaCk7XHJcbiAgICAgICAgbGV0IGR5ID0gcmlnaHR5IC0gbGVmdHk7XHJcblxyXG4gICAgICAgIGlmKGR4IDwgMCB8fCBkeSA8IDApIHJldHVybiAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBkeCpkeTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIGFuZCByZXNpemVzIHRoaXMgcmVjdCBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uIHRvIHRoZSBwb3NpdGlvbiBzcGVjaWZpZWRcclxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgbW92ZW1lbnQgb2YgdGhlIHJlY3QgZnJvbSBpdHMgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSBmcm9tUG9zaXRpb24gQSBwb3NpdGlvbiBzcGVjaWZpZWQgdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHN3ZWVwaW5nXHJcbiAgICAgKiBAcGFyYW0gaGFsZlNpemUgVGhlIGhhbGZTaXplIG9mIHRoZSBzd2VlcGluZyByZWN0IFxyXG4gICAgICovXHJcbiAgICBzd2VlcCh2ZWxvY2l0eTogVmVjMiwgZnJvbVBvc2l0aW9uPzogVmVjMiwgaGFsZlNpemU/OiBWZWMyKTogdm9pZCB7XHJcbiAgICAgICAgaWYoIWZyb21Qb3NpdGlvbil7XHJcbiAgICAgICAgICAgIGZyb21Qb3NpdGlvbiA9IHRoaXMuY2VudGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIWhhbGZTaXplKXtcclxuICAgICAgICAgICAgaGFsZlNpemUgPSB0aGlzLmhhbGZTaXplO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNlbnRlclggPSBmcm9tUG9zaXRpb24ueCArIHZlbG9jaXR5LngvMjtcclxuICAgICAgICBsZXQgY2VudGVyWSA9IGZyb21Qb3NpdGlvbi55ICsgdmVsb2NpdHkueS8yO1xyXG5cclxuICAgICAgICBsZXQgbWluWCA9IE1hdGgubWluKGZyb21Qb3NpdGlvbi54IC0gaGFsZlNpemUueCwgZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54IC0gaGFsZlNpemUueCk7XHJcbiAgICAgICAgbGV0IG1pblkgPSBNYXRoLm1pbihmcm9tUG9zaXRpb24ueSAtIGhhbGZTaXplLnksIGZyb21Qb3NpdGlvbi55ICsgdmVsb2NpdHkueSAtIGhhbGZTaXplLnkpO1xyXG5cclxuICAgICAgICB0aGlzLmNlbnRlci5zZXQoY2VudGVyWCwgY2VudGVyWSk7XHJcbiAgICAgICAgdGhpcy5oYWxmU2l6ZS5zZXQoY2VudGVyWCAtIG1pblgsIGNlbnRlclkgLSBtaW5ZKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBjbG9uZSgpOiBBQUJCIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFBQkIodGhpcy5jZW50ZXIuY2xvbmUoKSwgdGhpcy5oYWxmU2l6ZS5jbG9uZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgQUFCQiB0byBhIHN0cmluZyBmb3JtYXRcclxuICAgICAqIEByZXR1cm5zIChjZW50ZXI6ICh4LCB5KSwgaGFsZlNpemU6ICh4LCB5KSlcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gXCIoY2VudGVyOiBcIiArIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgKyBcIiwgaGFsZi1zaXplOiBcIiArIHRoaXMuaGFsZlNpemUudG9TdHJpbmcoKSArIFwiKVwiXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi9BQUJCXCI7XHJcbmltcG9ydCBTaGFwZSBmcm9tIFwiLi9TaGFwZVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgQ2lyY2xlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBTaGFwZSB7XHJcblx0cHJpdmF0ZSBfY2VudGVyOiBWZWMyO1xyXG5cdHJhZGl1czogbnVtYmVyO1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgQ2lyY2xlXHJcblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcclxuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKGNlbnRlcjogVmVjMiwgcmFkaXVzOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2VudGVyID0gY2VudGVyID8gY2VudGVyIDogbmV3IFZlYzIoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXMgPyByYWRpdXMgOiAwO1xyXG5cdH1cclxuXHJcblx0Z2V0IGNlbnRlcigpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLl9jZW50ZXI7XHJcblx0fVxyXG5cclxuXHRzZXQgY2VudGVyKGNlbnRlcjogVmVjMikge1xyXG5cdFx0dGhpcy5fY2VudGVyID0gY2VudGVyO1xyXG5cdH1cclxuXHJcblx0Z2V0IGhhbGZTaXplKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyk7XHJcblx0fVxyXG5cclxuXHRnZXQgcigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMucmFkaXVzO1xyXG5cdH1cclxuXHJcblx0c2V0IHIocmFkaXVzOiBudW1iZXIpIHtcclxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0LyoqXHJcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLmRpc3RhbmNlU3FUbyhwb2ludCkgPD0gdGhpcy5yYWRpdXMqdGhpcy5yYWRpdXM7XHJcbiAgICB9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCIHtcclxuXHRcdHJldHVybiBuZXcgQUFCQih0aGlzLl9jZW50ZXIuY2xvbmUoKSwgbmV3IFZlYzIodGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzKSk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKTtcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdG92ZXJsYXBzKG90aGVyOiBTaGFwZSk6IGJvb2xlYW4ge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRjbG9uZSgpOiBDaXJjbGUge1xyXG5cdFx0cmV0dXJuIG5ldyBDaXJjbGUodGhpcy5fY2VudGVyLmNsb25lKCksIHRoaXMucmFkaXVzKTtcclxuXHR9XHJcblxyXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCIoY2VudGVyOiBcIiArIHRoaXMuY2VudGVyLnRvU3RyaW5nKCkgKyBcIiwgcmFkaXVzOiBcIiArIHRoaXMucmFkaXVzICsgXCIpXCI7XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xyXG5pbXBvcnQgQ2lyY2xlIGZyb20gXCIuL0NpcmNsZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IFNoYXBlIGNsYXNzIHRoYXQgYWN0cyBhcyBhbiBpbnRlcmZhY2UgZm9yIGJldHRlciBpbnRlcmFjdGlvbnMgd2l0aCBzdWJjbGFzc2VzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhcGUge1xyXG4gICAgYWJzdHJhY3QgZ2V0IGNlbnRlcigpOiBWZWMyO1xyXG5cclxuICAgIGFic3RyYWN0IHNldCBjZW50ZXIoY2VudGVyOiBWZWMyKTtcclxuXHJcbiAgICBhYnN0cmFjdCBnZXQgaGFsZlNpemUoKTogVmVjMjtcclxuXHJcbiAgICBnZXQgeCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci54O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB5KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLnk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGh3KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemUueDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYWxmU2l6ZS55O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB0b3AoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55IC0gdGhpcy5oaDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYm90dG9tKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGxlZnQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54IC0gdGhpcy5odztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgcmlnaHQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy5odztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBib3VuZGluZyByZWN0YW5nbGUgZm9yIHRoaXMgc2hhcGUuIFdhcm5pbmcgLSBtYXkgYmUgdGhlIHNhbWUgYXMgdGhpcyBTaGFwZS5cclxuICAgICAqIEZvciBpbnN0YW5jZSwgdGhlIGJvdW5kaW5nIGNpcmNsZSBvZiBhbiBBQUJCIGlzIGl0c2VsZi4gVXNlIGNsb25lKCkgaWYgeW91IG5lZWQgYSBuZXcgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBBQUJCIHRoYXQgYm91bmRzIHRoaXMgc2hhcGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0Qm91bmRpbmdSZWN0KCk6IEFBQkI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgYm91bmRpbmcgY2lyY2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXHJcbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRoZSBib3VuZGluZyBjaXJjbGUgb2YgYSBDaXJjbGUgaXMgaXRzZWxmLiBVc2UgY2xvbmUoKSBpZiB5b3UgbmVlZCBhIG5ldyBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIEEgQ2lyY2xlIHRoYXQgYm91bmRzIHRoaXMgc2hhcGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBTaGFwZVxyXG4gICAgICogQHJldHVybnMgQSBuZXcgY29weSBvZiB0aGlzIHNoYXBlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGNsb25lKCk6IFNoYXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgc2hhcGUgb3ZlcmxhcHMgYW5vdGhlclxyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBzaGFwZSB0byBjaGVjayBhZ2FpbnN0XHJcbiAgICAgKiBAcmV0dXJucyBhIGJvb2xlYW4gdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBTaGFwZSBvdmVybGFwcyB0aGUgb3RoZXIgb25lXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG92ZXJsYXBzKG90aGVyOiBTaGFwZSk6IGJvb2xlYW47XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgU2hhcGUgY29udGFpbnMgYSBwb2ludFxyXG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgU2hhcGUgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjb250YWluc1BvaW50KHBvaW50OiBWZWMyKTogYm9vbGVhbjtcclxuXHJcbiAgICBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uKEE6IFNoYXBlLCB2ZWxBOiBWZWMyLCBCOiBTaGFwZSwgdmVsQjogVmVjMik6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XHJcblx0XHRpZihBIGluc3RhbmNlb2YgQUFCQiAmJiBCIGluc3RhbmNlb2YgQUFCQil7XHJcblx0XHRcdHJldHVybiBTaGFwZS5nZXRUaW1lT2ZDb2xsaXNpb25fQUFCQl9BQUJCKEEsIHZlbEEsIEIsIHZlbEIpO1xyXG5cdFx0fVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRUaW1lT2ZDb2xsaXNpb25fQUFCQl9BQUJCKEE6IEFBQkIsIHZlbEE6IFZlYzIsIEI6IFNoYXBlLCB2ZWxCOiBWZWMyKTogW1ZlYzIsIFZlYzIsIGJvb2xlYW4sIGJvb2xlYW5dIHtcclxuICAgICAgICBsZXQgcG9zU21hbGxlciA9IEEuY2VudGVyO1xyXG4gICAgICAgIGxldCBwb3NMYXJnZXIgPSBCLmNlbnRlcjtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgc2l6ZVNtYWxsZXIgPSBBLmhhbGZTaXplO1xyXG4gICAgICAgIGxldCBzaXplTGFyZ2VyID0gQi5oYWxmU2l6ZTtcclxuICAgIFxyXG4gICAgICAgIGxldCBmaXJzdENvbnRhY3QgPSBuZXcgVmVjMigwLCAwKTtcclxuICAgICAgICBsZXQgbGFzdENvbnRhY3QgPSBuZXcgVmVjMigwLCAwKTtcclxuICAgIFxyXG4gICAgICAgIGxldCBjb2xsaWRpbmdYID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGNvbGxpZGluZ1kgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgICAgIC8vIFNvcnQgYnkgcG9zaXRpb25cclxuICAgICAgICBpZihwb3NMYXJnZXIueCA8IHBvc1NtYWxsZXIueCl7XHJcbiAgICAgICAgICAgIC8vIFN3YXAsIGJlY2F1c2Ugc21hbGxlciBpcyBmdXJ0aGVyIHJpZ2h0IHRoYW4gbGFyZ2VyXHJcbiAgICAgICAgICAgIGxldCB0ZW1wOiBWZWMyO1xyXG4gICAgICAgICAgICB0ZW1wID0gc2l6ZVNtYWxsZXI7XHJcbiAgICAgICAgICAgIHNpemVTbWFsbGVyID0gc2l6ZUxhcmdlcjtcclxuICAgICAgICAgICAgc2l6ZUxhcmdlciA9IHRlbXA7XHJcbiAgICBcclxuICAgICAgICAgICAgdGVtcCA9IHBvc1NtYWxsZXI7XHJcbiAgICAgICAgICAgIHBvc1NtYWxsZXIgPSBwb3NMYXJnZXI7XHJcbiAgICAgICAgICAgIHBvc0xhcmdlciA9IHRlbXA7XHJcbiAgICBcclxuICAgICAgICAgICAgdGVtcCA9IHZlbEE7XHJcbiAgICAgICAgICAgIHZlbEEgPSB2ZWxCO1xyXG4gICAgICAgICAgICB2ZWxCID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBBIGlzIGxlZnQsIEIgaXMgcmlnaHRcclxuICAgICAgICBmaXJzdENvbnRhY3QueCA9IEluZmluaXR5O1xyXG4gICAgICAgIGxhc3RDb250YWN0LnggPSBJbmZpbml0eTtcclxuICAgIFxyXG4gICAgICAgIGlmIChwb3NMYXJnZXIueCAtIHNpemVMYXJnZXIueCA+PSBwb3NTbWFsbGVyLnggKyBzaXplU21hbGxlci54KXtcclxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlbid0IGN1cnJlbnRseSBjb2xsaWRpbmdcclxuICAgICAgICAgICAgbGV0IHJlbFZlbCA9IHZlbEEueCAtIHZlbEIueDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHJlbFZlbCA+IDApe1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhleSBhcmUgbW92aW5nIHRvd2FyZHMgZWFjaCBvdGhlclxyXG4gICAgICAgICAgICAgICAgZmlyc3RDb250YWN0LnggPSAoKHBvc0xhcmdlci54IC0gc2l6ZUxhcmdlci54KSAtIChwb3NTbWFsbGVyLnggKyBzaXplU21hbGxlci54KSkvKHJlbFZlbCk7XHJcbiAgICAgICAgICAgICAgICBsYXN0Q29udGFjdC54ID0gKChwb3NMYXJnZXIueCArIHNpemVMYXJnZXIueCkgLSAocG9zU21hbGxlci54IC0gc2l6ZVNtYWxsZXIueCkpLyhyZWxWZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29sbGlkaW5nWCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaWYocG9zTGFyZ2VyLnkgPCBwb3NTbWFsbGVyLnkpe1xyXG4gICAgICAgICAgICAvLyBTd2FwLCBiZWNhdXNlIHNtYWxsZXIgaXMgZnVydGhlciB1cCB0aGFuIGxhcmdlclxyXG4gICAgICAgICAgICBsZXQgdGVtcDogVmVjMjtcclxuICAgICAgICAgICAgdGVtcCA9IHNpemVTbWFsbGVyO1xyXG4gICAgICAgICAgICBzaXplU21hbGxlciA9IHNpemVMYXJnZXI7XHJcbiAgICAgICAgICAgIHNpemVMYXJnZXIgPSB0ZW1wO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xyXG4gICAgICAgICAgICBwb3NTbWFsbGVyID0gcG9zTGFyZ2VyO1xyXG4gICAgICAgICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRlbXAgPSB2ZWxBO1xyXG4gICAgICAgICAgICB2ZWxBID0gdmVsQjtcclxuICAgICAgICAgICAgdmVsQiA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gQSBpcyB0b3AsIEIgaXMgYm90dG9tXHJcbiAgICAgICAgZmlyc3RDb250YWN0LnkgPSBJbmZpbml0eTtcclxuICAgICAgICBsYXN0Q29udGFjdC55ID0gSW5maW5pdHk7XHJcbiAgICBcclxuICAgICAgICBpZiAocG9zTGFyZ2VyLnkgLSBzaXplTGFyZ2VyLnkgPj0gcG9zU21hbGxlci55ICsgc2l6ZVNtYWxsZXIueSl7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXHJcbiAgICAgICAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnkgLSB2ZWxCLnk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihyZWxWZWwgPiAwKXtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgICAgIGZpcnN0Q29udGFjdC55ID0gKChwb3NMYXJnZXIueSAtIHNpemVMYXJnZXIueSkgLSAocG9zU21hbGxlci55ICsgc2l6ZVNtYWxsZXIueSkpLyhyZWxWZWwpO1xyXG4gICAgICAgICAgICAgICAgbGFzdENvbnRhY3QueSA9ICgocG9zTGFyZ2VyLnkgKyBzaXplTGFyZ2VyLnkpIC0gKHBvc1NtYWxsZXIueSAtIHNpemVTbWFsbGVyLnkpKS8ocmVsVmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGluZ1kgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIHJldHVybiBbZmlyc3RDb250YWN0LCBsYXN0Q29udGFjdCwgY29sbGlkaW5nWCwgY29sbGlkaW5nWV07XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQ29sbGVjdGlvbiBmcm9tIFwiLi9Db2xsZWN0aW9uXCI7XHJcblxyXG4vKipcclxuICogQSBMSUZPIHN0YWNrIHdpdGggaXRlbXMgb2YgdHlwZSBUXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGFjazxUPiBpbXBsZW1lbnRzIENvbGxlY3Rpb24ge1xyXG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgU3RhY2sgKi9cclxuICAgIHByaXZhdGUgTUFYX0VMRU1FTlRTOiBudW1iZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0YWNrICovXHJcbiAgICBwcml2YXRlIHN0YWNrOiBBcnJheTxUPjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBoZWFkIG9mIHRoZSBzdGFjayAqL1xyXG5cdHByaXZhdGUgaGVhZDogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBzdGFja1xyXG4gICAgICogQHBhcmFtIG1heEVsZW1lbnRzIFRoZSBtYXhpbXVtIHNpemUgb2YgdGhlIHN0YWNrXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1heEVsZW1lbnRzOiBudW1iZXIgPSAxMDApe1xyXG4gICAgICAgIHRoaXMuTUFYX0VMRU1FTlRTID0gbWF4RWxlbWVudHM7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBBcnJheTxUPih0aGlzLk1BWF9FTEVNRU5UUyk7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gLTE7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBpdGVtIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgbmV3IGl0ZW0gdG8gYWRkIHRvIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBwdXNoKGl0ZW06IFQpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgKyAxID09PSB0aGlzLk1BWF9FTEVNRU5UUyl7XHJcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZnVsbCAtIGNhbm5vdCBhZGQgZWxlbWVudFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhlYWQgKz0gMTtcclxuICAgICAgICB0aGlzLnN0YWNrW3RoaXMuaGVhZF0gPSBpdGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgKi9cclxuICAgIHBvcCgpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IC0xKXtcclxuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCByZW1vdmUgZWxlbWVudFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhlYWQgLT0gMTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWQgKyAxXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBwZWVrKCk6IFQge1xyXG4gICAgICAgIGlmKHRoaXMuaGVhZCA9PT0gLTEpe1xyXG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGVtcHR5IC0gY2Fubm90IGdldCBlbGVtZW50XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuaGVhZF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHN0YWNrIGlzIGVtcHR5XHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgb3Igbm90IHRoZSBzdGFjayBpcyBlbXB0eVxyXG4gICAgKi9cclxuICAgIGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCA9PT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGltcGxlbWVudGVkXHJcbiAgICBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiBkZWxldGUgdGhpcy5zdGFja1tpbmRleF0pO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGN1cnJlbnRseSBpbiB0aGUgc3RhY2tcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHN0YWNrXHJcbiAgICAgKi9cclxuICAgIHNpemUoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWFkICsgMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUoaSA8PSB0aGlzLmhlYWQpe1xyXG4gICAgICAgICAgICBmdW5jKHRoaXMuc3RhY2tbaV0sIGkpO1xyXG4gICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBzdGFjayBpbnRvIGEgc3RyaW5nIGZvcm1hdFxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgc3RhY2tcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgcmV0dmFsID0gXCJcIjtcclxuXHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKCAoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN0ciA9IGl0ZW0udG9TdHJpbmcoKVxyXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIgLT4gXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR2YWwgPSBzdHIgKyByZXR2YWw7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBcIlRvcCAtPiBcIiArIHJldHZhbDtcclxuICAgIH1cclxufSIsImltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi8uLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi8uLi9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFN0YXRlTWFjaGluZSBmcm9tIFwiLi9TdGF0ZU1hY2hpbmVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIHN0YXRlIGZvciBhIEByZWZlcmVuY2VbU3RhdGVNYWNoaW5lXS5cclxuICogVGhpcyBjbGFzcyBzaG91bGQgYmUgZXh0ZW5kZWQgdG8gYWxsb3cgZm9yIGN1c3RvbSBzdGF0ZSBiZWhhdmlvcnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTdGF0ZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gICAgLyoqIFRoZSBTdGF0ZU1hY2hpbmUgdGhhdCB1c2VzIHRoaXMgU3RhdGUgKi9cclxuICAgIHByb3RlY3RlZCBwYXJlbnQ6IFN0YXRlTWFjaGluZTtcclxuXHJcbiAgICAvKiogQW4gZXZlbnQgZW1pdHRlciAqL1xyXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFN0YXRlXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50IFRoZSBwYXJlbnQgU3RhdGVNYWNoaW5lIG9mIHRoaXMgc3RhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBTdGF0ZU1hY2hpbmUpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGlzIHN0YXRlIGlzIGVudGVyZWQuIFVzZSB0aGlzIHRvIGluaXRpYWxpemUgYW55IHZhcmlhYmxlcyBiZWZvcmUgdXBkYXRlcyBvY2N1ci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEluZm9ybWF0aW9uIHRvIHBhc3MgdG8gdGhpcyBzdGF0ZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBvbkVudGVyKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgaGFuZGxlcyBhbiBpbnB1dCBldmVudCwgc3VjaCBhcyB0YWtpbmcgZGFtYWdlLlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBHYW1lRXZlbnQgdG8gcHJvY2Vzc1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBoYW5kbGVJbnB1dChldmVudDogR2FtZUV2ZW50KTogdm9pZDtcclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIGFic3RyYWN0IHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgc3RhdGUgbWFjaGluZSB0aGF0IHRoaXMgc3RhdGUgaGFzIGVuZGVkLCBhbmQgbWFrZXMgaXQgdHJhbnNpdGlvbiB0byB0aGUgbmV3IHN0YXRlIHNwZWNpZmllZFxyXG4gICAgICogQHBhcmFtIHN0YXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0b1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZmluaXNoZWQoc3RhdGVOYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhcmVudC5jaGFuZ2VTdGF0ZShzdGF0ZU5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBzdGF0ZSBpcyBlbmRpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBpbmZvIHRvIHBhc3MgdG8gdGhlIG5leHQgc3RhdGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgb25FeGl0KCk6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uL1N0YWNrXCI7XHJcbmltcG9ydCBTdGF0ZSBmcm9tIFwiLi9TdGF0ZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9NYXBcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgUHVzaCBEb3duIEF1dG9tYXRhIFN0YXRlIG1hY2hpbmUuIFN0YXRlcyBjYW4gYWxzbyBiZSBoaWVyYXJjaGljYWxcclxuICogZm9yIG1vcmUgZmxleGliaWxpdHksIGFzIGRlc2NyaWJlZCBpbiBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9zdGF0ZS5odG1sKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTWFjaGluZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gICAgLyoqIEEgc3RhY2sgb2YgdGhlIGN1cnJlbnQgc3RhdGVzICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhY2s6IFN0YWNrPFN0YXRlPjtcclxuICAgIC8qKiBBIG1hcGUgb2Ygc3RhdGUga2V5cyB0byBhY3R1YWwgc3RhdGUgaW5zdGFuY2VzICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGVNYXA6IE1hcDxTdGF0ZT47XHJcbiAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgKi9cclxuICAgIHByb3RlY3RlZCBjdXJyZW50U3RhdGU6IFN0YXRlO1xyXG4gICAgLyoqIEFuIGV2ZW50IHJlY2VpdmVyICovXHJcbiAgICBwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cclxuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG4gICAgLyoqIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBTdGF0ZU1hY2hpbmUgaXMgY3VycmVudGx5IGFjdGl2ZSAqL1xyXG4gICAgcHJvdGVjdGVkIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIC8qKiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgU3RhdGVNYWNoaW5lIHNob3VsZCBlbWl0IGFuIGV2ZW50IG9uIHN0YXRlIGNoYW5nZSAqL1xyXG4gICAgcHJvdGVjdGVkIGVtaXRFdmVudE9uU3RhdGVDaGFuZ2U6IGJvb2xlYW47XHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGVtaXR0ZWQgb24gc3RhdGUgY2hhbmdlICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGVDaGFuZ2VFdmVudE5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RhdGVNYWNoaW5lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIHRoaXMuc3RhdGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhY3Rpdml0eSBzdGF0ZSBvZiB0aGlzIHN0YXRlIG1hY2hpbmVcclxuICAgICAqIEBwYXJhbSBmbGFnIFRydWUgaWYgeW91IHdhbnQgdG8gc2V0IHRoaXMgbWFjaGluZSBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgc2V0QWN0aXZlKGZsYWc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZsYWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGlzIHN0YXRlIG1hY2hpbmUgZW1pdCBhbiBldmVudCBhbnkgdGltZSBpdHMgc3RhdGUgY2hhbmdlc1xyXG4gICAgICogQHBhcmFtIHN0YXRlQ2hhbmdlRXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBlbWl0XHJcbiAgICAgKi9cclxuICAgIHNldEVtaXRFdmVudE9uU3RhdGVDaGFuZ2Uoc3RhdGVDaGFuZ2VFdmVudE5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSA9IHN0YXRlQ2hhbmdlRXZlbnROYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhpcyBzdGF0ZSBtYWNoaW5lIGZyb20gZW1pdHRpbmcgZXZlbnRzIG9uIHN0YXRlIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgY2FuY2VsRW1pdEV2ZW50T25TdGF0ZUNoYW5nZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmVtaXRFdmVudE9uU3RhdGVDaGFuZ2UgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCBhbiBpbml0aWFsIHN0YXRlIGFuZCBzZXRzIGl0IHJ1bm5pbmdcclxuICAgICAqIEBwYXJhbSBpbml0aWFsU3RhdGUgVGhlIG5hbWUgb2YgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgc3RhdGUgbWFjaGluZVxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXplKGluaXRpYWxTdGF0ZTogc3RyaW5nLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5zdGF0ZU1hcC5nZXQoaW5pdGlhbFN0YXRlKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB0aGlzLnN0YWNrLnBlZWsoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5vbkVudGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHN0YXRlIHRvIHRoaXMgc3RhdGUgbWFjaGluZVxyXG4gICAgICogQHBhcmFtIHN0YXRlTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gYWRkXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBhZGRTdGF0ZShzdGF0ZU5hbWU6IHN0cmluZywgc3RhdGU6IFN0YXRlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZU1hcC5hZGQoc3RhdGVOYW1lLCBzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBzdGF0ZSBvZiB0aGlzIHN0YXRlIG1hY2hpbmUgdG8gdGhlIHByb3ZpZGVkIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgc3RhdGUgdG8gY2hhbmdlIHRvXHJcbiAgICAgKi9cclxuICAgIGNoYW5nZVN0YXRlKHN0YXRlOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICAvLyBFeGl0IHRoZSBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB0aGlzLmN1cnJlbnRTdGF0ZS5vbkV4aXQoKTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjb3JyZWN0IHN0YXRlIGlzIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgICAgaWYoc3RhdGUgPT09IFwicHJldmlvdXNcIil7XHJcbiAgICAgICAgICAgIC8vIFBvcCB0aGUgY3VycmVudCBzdGF0ZSBvZmYgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIG5ldyBzdGF0ZSBmcm9tIHRoZSBzdGF0ZW1hcCBhbmQgcHV0IGl0IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlTWFwLmdldChzdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0cmVpdmUgdGhlIG5ldyBzdGF0ZSBmcm9tIHRoZSBzdGFja1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gdGhpcy5zdGFjay5wZWVrKCk7XHJcblxyXG4gICAgICAgIC8vIEVtaXQgYW4gZXZlbnQgaWYgdHVybmVkIG9uXHJcbiAgICAgICAgaWYodGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlKXtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLnN0YXRlQ2hhbmdlRXZlbnROYW1lLCB7c3RhdGU6IHRoaXMuY3VycmVudFN0YXRlfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbnRlciB0aGUgbmV3IHN0YXRlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUub25FbnRlcihvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgaW5wdXQuIFRoaXMgaGFwcGVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhpcyBzdGF0ZSBtYWNoaW5lJ3MgdXBkYXRlIGN5Y2xlLlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBnYW1lIGV2ZW50IHRvIHByb2Nlc3NcclxuICAgICAqL1xyXG4gICAgaGFuZGxlRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMuYWN0aXZlKXtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuaGFuZGxlSW5wdXQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIC8vIERpc3RyaWJ1dGUgZXZlbnRzXHJcbiAgICAgICAgd2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XHJcbiAgICAgICAgICAgIGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVsZWdhdGUgdGhlIHVwZGF0ZSB0byB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5pbXBvcnQgeyBUaWxlZFRpbGVzZXREYXRhIH0gZnJvbSBcIi4vVGlsZWREYXRhXCI7XHJcblxyXG4vKipcclxuICogVGhlIGRhdGEgcmVwcmVzZW50YXRpb24gb2YgYSBUaWxlc2V0IGZvciB0aGUgZ2FtZSBlbmdpbmUuIFRoaXMgcmVwcmVzZW50cyBvbmUgaW1hZ2UsXHJcbiAqIHdpdGggYSBzdGFydEluZGV4IGlmIHJlcXVpcmVkIChhcyBpdCBpcyB3aXRoIFRpbGVkIHVzaW5nIHR3byBpbWFnZXMgaW4gb25lIHRpbHNldCkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlc2V0IHtcclxuICAgIC8qKiBUaGUga2V5IG9mIHRoZSBpbWFnZSB1c2VkIGJ5IHRoaXMgdGlsZXNldCAqL1xyXG4gICAgcHJvdGVjdGVkIGltYWdlS2V5OiBzdHJpbmc7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIHRpbGVzZXQgaW1hZ2UgKi9cclxuICAgIHByb3RlY3RlZCBpbWFnZVNpemU6IFZlYzI7XHJcbiAgICAvKiogVGhlIGluZGV4IG9mIDB0aCBpbWFnZSBvZiB0aGlzIHRpbGVzZXQgKi9cclxuICAgIHByb3RlY3RlZCBzdGFydEluZGV4OiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGluZGV4IG9mIHRoZSBsYXN0IGltYWdlIG9mIHRoaXMgdGlsc2V0ICovXHJcbiAgICBwcm90ZWN0ZWQgZW5kSW5kZXg6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdGlsZXMgaW4gdGhpcyB0aWxlc2V0ICovXHJcbiAgICBwcm90ZWN0ZWQgdGlsZVNpemU6IFZlYzI7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiByb3dzIGluIHRoaXMgdGlsZXNldCAqL1xyXG4gICAgcHJvdGVjdGVkIG51bVJvd3M6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhpcyB0aWxlc2V0ICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xyXG5cclxuICAgIC8vIFRPRE86IENoYW5nZSB0aGlzIHRvIGJlIG1vcmUgZ2VuZXJhbCBhbmQgd29yayB3aXRoIG90aGVyIHRpbGVzZXQgZm9ybWF0c1xyXG4gICAgY29uc3RydWN0b3IodGlsZXNldERhdGE6IFRpbGVkVGlsZXNldERhdGEpe1xyXG4gICAgICAgIC8vIERlZmVyIGhhbmRsaW5nIG9mIHRoZSBkYXRhIHRvIGEgaGVscGVyIGNsYXNzXHJcbiAgICAgICAgdGhpcy5pbml0RnJvbVRpbGVkRGF0YSh0aWxlc2V0RGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHRoZSB0aWxlc2V0IGZyb20gdGhlIGRhdGEgZnJvbSBhIFRpbGVkIGpzb24gZmlsZVxyXG4gICAgICogQHBhcmFtIHRpbGVkRGF0YSBUaGUgcGFyc2VkIG9iamVjdCBmcm9tIGEgVGlsZWQganNvbiBmaWxlXHJcbiAgICAgKi9cclxuICAgIGluaXRGcm9tVGlsZWREYXRhKHRpbGVkRGF0YTogVGlsZWRUaWxlc2V0RGF0YSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubnVtUm93cyA9IHRpbGVkRGF0YS50aWxlY291bnQvdGlsZWREYXRhLmNvbHVtbnM7XHJcbiAgICAgICAgdGhpcy5udW1Db2xzID0gdGlsZWREYXRhLmNvbHVtbnM7XHJcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gdGlsZWREYXRhLmZpcnN0Z2lkO1xyXG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSB0aGlzLnN0YXJ0SW5kZXggKyB0aWxlZERhdGEudGlsZWNvdW50IC0gMTtcclxuICAgICAgICB0aGlzLnRpbGVTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLnRpbGV3aWR0aCwgdGlsZWREYXRhLnRpbGV3aWR0aCk7XHJcbiAgICAgICAgdGhpcy5pbWFnZUtleSA9IHRpbGVkRGF0YS5pbWFnZTtcclxuICAgICAgICB0aGlzLmltYWdlU2l6ZSA9IG5ldyBWZWMyKHRpbGVkRGF0YS5pbWFnZXdpZHRoLCB0aWxlZERhdGEuaW1hZ2VoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBcclxuICAgICAqIEdldHMgdGhlIGltYWdlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0aWxlbWFwXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaW1hZ2Uga2V5IG9mIHRoaXMgdGlsZW1hcFxyXG4gICAgICovXHJcbiAgICBnZXRJbWFnZUtleSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlS2V5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFZlYzIgY29udGFpbmluZyB0aGUgbGVmdCBhbmQgdG9wIG9mZnNldCBmcm9tIHRoZSBpbWFnZSBvcmlnaW4gZm9yIHRoaXMgdGlsZS5cclxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGZyb20gc3RhcnRJbmRleCB0byBlbmRJbmRleCBvZiB0aGlzIHRpbGVzZXRcclxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBvZmZzZXQgZm9yIHRoZSBzcGVjaWZpZWQgdGlsZS5cclxuICAgICAqL1xyXG4gICAgZ2V0SW1hZ2VPZmZzZXRGb3JUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogVmVjMiB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSB0cnVlIGluZGV4XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGlsZUluZGV4IC0gdGhpcy5zdGFydEluZGV4O1xyXG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcclxuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy50aWxlU2l6ZS54O1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gdG8gc3RhcnQgYSBjcm9wIGluIHRoZSB0aWxlc2V0IGltYWdlXHJcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcclxuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIobGVmdCwgdG9wKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHN0YXJ0IGluZGV4XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhcnQgaW5kZXhcclxuICAgICAqL1xyXG4gICAgZ2V0U3RhcnRJbmRleCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0SW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB0aWxlIHNldFxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHRpbGUgc2l6ZVxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlU2l6ZSgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSB0aWxlc2V0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHJvd3NcclxuICAgICAqL1xyXG4gICAgZ2V0TnVtUm93cygpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bVJvd3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGlsc2V0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNvbHVtbnNcclxuICAgICAqL1xyXG4gICAgZ2V0TnVtQ29scygpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bUNvbHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGlsZUNvdW50KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXggKyAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgdGlsc2V0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgdGlsZSBpbmRleC4gVGhpcyBpcyB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdGlsZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbHNldCB1c2VzIHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgICAqL1xyXG4gICAgaGFzVGlsZSh0aWxlSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aWxlSW5kZXggPj0gdGhpcy5zdGFydEluZGV4ICYmIHRpbGVJbmRleCA8PSB0aGlzLmVuZEluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIGEgc2luZ3VsYXIgdGlsZSB3aXRoIGluZGV4IHRpbGVJbmRleCBmcm9tIHRoZSB0aWxlc2V0IGxvY2F0ZWQgYXQgcG9zaXRpb24gZGF0YUluZGV4XHJcbiAgICAgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgdmFsdWUgb2YgdGhlIHRpbGUgdG8gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0gZGF0YUluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZSBpbiB0aGUgZGF0YSBhcnJheVxyXG4gICAgICogQHBhcmFtIHdvcmxkU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgd29ybGRcclxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIHZpZXdwb3J0IG9yaWdpbiBpbiB0aGUgY3VycmVudCBsYXllclxyXG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgdGlsZW1hcFxyXG4gICAgICovXHJcbiAgICByZW5kZXJUaWxlKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB0aWxlSW5kZXg6IG51bWJlciwgZGF0YUluZGV4OiBudW1iZXIsIG1heENvbHM6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGltYWdlID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0SW1hZ2UodGhpcy5pbWFnZUtleSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgdHJ1ZSBpbmRleFxyXG4gICAgICAgIGxldCBpbmRleCA9IHRpbGVJbmRleCAtIHRoaXMuc3RhcnRJbmRleDtcclxuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMubnVtQ29scyk7XHJcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMudGlsZVNpemUueDtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy50aWxlU2l6ZS55O1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIHRvIHN0YXJ0IGEgY3JvcCBpbiB0aGUgdGlsZXNldCBpbWFnZVxyXG4gICAgICAgIGxldCBsZWZ0ID0gY29sICogd2lkdGg7XHJcbiAgICAgICAgbGV0IHRvcCA9IHJvdyAqIGhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBpbiB0aGUgd29ybGQgdG8gcmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgICAgbGV0IHggPSBNYXRoLmZsb29yKChkYXRhSW5kZXggJSBtYXhDb2xzKSAqIHdpZHRoICogc2NhbGUueCk7XHJcbiAgICAgICAgbGV0IHkgPSBNYXRoLmZsb29yKE1hdGguZmxvb3IoZGF0YUluZGV4IC8gbWF4Q29scykgKiBoZWlnaHQgKiBzY2FsZS55KTtcclxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIE1hdGguZmxvb3IoKHggLSBvcmlnaW4ueCkqem9vbSksIE1hdGguZmxvb3IoKHkgLSBvcmlnaW4ueSkqem9vbSksIE1hdGguY2VpbCh3aWR0aCAqIHNjYWxlLnggKiB6b29tKSwgTWF0aC5jZWlsKGhlaWdodCAqIHNjYWxlLnkgKiB6b29tKSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHR3by1kaW1lbnNpb25hbCB2ZWN0b3IgKHgsIHkpXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWMyIHtcclxuXHJcblx0Ly8gU3RvcmUgeCBhbmQgeSBpbiBhbiBhcnJheVxyXG5cdC8qKiBUaGUgYXJyYXkgdGhhdCBzdG9yZXMgdGhlIGFjdHVhbCB2ZWN0b3IgdmFsdWVzIHggYW5kIHkgKi9cclxuXHRwcml2YXRlIHZlYzogRmxvYXQzMkFycmF5O1xyXG5cclxuXHQvKipcdFxyXG5cdCAqIFdoZW4gdGhpcyB2ZWN0b3IgY2hhbmdlcyBpdHMgdmFsdWUsIGRvIHNvbWV0aGluZ1xyXG5cdCAqL1xyXG5cdHByaXZhdGUgb25DaGFuZ2U6IEZ1bmN0aW9uID0gKCkgPT4ge307XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgVmVjMlxyXG5cdCAqIEBwYXJhbSB4IFRoZSB4IHZhbHVlIG9mIHRoZSB2ZWN0b3JcclxuXHQgKiBAcGFyYW0geSBUaGUgeSB2YWx1ZSBvZiB0aGUgdmVjdG9yXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoeDogbnVtYmVyID0gMCwgeTogbnVtYmVyID0gMCkge1xyXG5cdFx0dGhpcy52ZWMgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG5cdFx0dGhpcy52ZWNbMF0gPSB4O1xyXG5cdFx0dGhpcy52ZWNbMV0gPSB5O1xyXG5cdH1cclxuXHJcblx0Ly8gRXhwb3NlIHggYW5kIHkgd2l0aCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXHJcblx0Z2V0IHgoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy52ZWNbMF07XHJcblx0fVxyXG5cclxuXHRzZXQgeCh4OiBudW1iZXIpIHtcclxuXHRcdHRoaXMudmVjWzBdID0geDtcclxuXHJcblx0XHRpZih0aGlzLm9uQ2hhbmdlKXtcclxuXHRcdFx0dGhpcy5vbkNoYW5nZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0IHkoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy52ZWNbMV07XHJcblx0fVxyXG5cclxuXHRzZXQgeSh5OiBudW1iZXIpIHtcclxuXHRcdHRoaXMudmVjWzFdID0geTtcclxuXHJcblx0XHRpZih0aGlzLm9uQ2hhbmdlKXtcclxuXHRcdFx0dGhpcy5vbkNoYW5nZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldCBaRVJPKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDApO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIHJlYWRvbmx5IFpFUk9fU1RBVElDID0gbmV3IFZlYzIoMCwgMCk7XHJcblxyXG5cdHN0YXRpYyBnZXQgSU5GKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKEluZmluaXR5LCBJbmZpbml0eSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IFVQKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIC0xKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXQgRE9XTigpIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMigwLCAxKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXQgTEVGVCgpIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMigtMSwgMCk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IFJJR0hUKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKDEsIDApO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuIFRoaXMgdGVuZHMgdG8gYmUgZmFzdGVyLCBzbyB1c2UgaXQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0YWtpbmcgdGhlXHJcblx0ICogc3F1YXJlIHJvb3QgZG9lc24ndCBtYXR0ZXIsIGxpa2UgZm9yIGNvbXBhcmluZyBkaXN0YW5jZXMuXHJcblx0ICogQHJldHVybnMgVGhlIHNxdWFyZWQgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3JcclxuXHQgKi9cclxuXHRtYWdTcSgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMueCp0aGlzLnggKyB0aGlzLnkqdGhpcy55O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLlxyXG5cdCAqIEByZXR1cm5zIFRoZSBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci5cclxuXHQgKi9cclxuXHRtYWcoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5tYWdTcSgpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpdmRlcyB4IGFuZCB5IGJ5IHRoZSBtYWduaXR1ZGUgdG8gb2J0YWluIHRoZSB1bml0IHZlY3RvciBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoaXMgdmVjdG9yLlxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFzIGEgdW5pdCB2ZWN0b3IuXHJcblx0ICovXHJcblx0bm9ybWFsaXplKCk6IFZlYzIge1xyXG5cdFx0aWYodGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMCkgcmV0dXJuIHRoaXM7XHJcblx0XHRsZXQgbWFnID0gdGhpcy5tYWcoKTtcclxuXHRcdHRoaXMueCAvPSBtYWc7XHJcblx0XHR0aGlzLnkgLz0gbWFnO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXb3JrcyBsaWtlIG5vcm1hbGl6ZSgpLCBidXQgcmV0dXJucyBhIG5ldyBWZWMyXHJcblx0ICogQHJldHVybnMgQSBuZXcgdmVjdG9yIHRoYXQgaXMgdGhlIHVuaXQgdmVjdG9yIGZvciB0aGlzIG9uZVxyXG5cdCAqL1xyXG5cdG5vcm1hbGl6ZWQoKTogVmVjMiB7XHJcblx0XHRpZih0aGlzLmlzWmVybygpKXtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGxldCBtYWcgPSB0aGlzLm1hZygpO1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKHRoaXMueC9tYWcsIHRoaXMueS9tYWcpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgeCBhbmQgeSBlbGVtZW50cyBvZiB0aGlzIHZlY3RvciB0byB6ZXJvLlxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yLCB3aXRoIHggYW5kIHkgc2V0IHRvIHplcm8uXHJcblx0ICovXHJcblx0emVybygpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLnNldCgwLCAwKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHZlY3RvcidzIHggYW5kIHkgYmFzZWQgb24gdGhlIGFuZ2xlIHByb3ZpZGVkLiBHb2VzIGNvdW50ZXIgY2xvY2t3aXNlLlxyXG5cdCAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xyXG5cdCAqIEBwYXJhbSByYWRpdXMgVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yIGF0IHRoZSBzcGVjaWZpZWQgYW5nbGVcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3Rvci5cclxuXHQgKi9cclxuXHRzZXRUb0FuZ2xlKGFuZ2xlOiBudW1iZXIsIHJhZGl1czogbnVtYmVyID0gMSk6IFZlYzIge1xyXG5cdFx0dGhpcy54ID0gTWF0aFV0aWxzLmZsb29yVG9QbGFjZShNYXRoLmNvcyhhbmdsZSkqcmFkaXVzLCA1KTtcclxuXHRcdHRoaXMueSA9IE1hdGhVdGlscy5mbG9vclRvUGxhY2UoLU1hdGguc2luKGFuZ2xlKSpyYWRpdXMsIDUpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgdmVjdG9yIHRoYXQgcG9pbnQgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyIG9uZVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIHBvaW50IHRvXHJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB0aGF0IHBvaW50cyBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvbmUgcHJvdmlkZWRcclxuXHQgKi9cclxuXHR2ZWNUbyhvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKG90aGVyLnggLSB0aGlzLngsIG90aGVyLnkgLSB0aGlzLnkpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIGRpcmVjdGlvbiBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXJcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBwb2ludCB0b1xyXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgdGhhdCBwb2ludHMgZnJvbSB0aGlzIHZlY3RvciB0byB0aGUgb25lIHByb3ZpZGVkLiBUaGlzIG5ldyBWZWMyIHdpbGwgYmUgYSB1bml0IHZlY3Rvci5cclxuXHQgKi9cclxuXHRkaXJUbyhvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMudmVjVG8ob3RoZXIpLm5vcm1hbGl6ZSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogS2VlcHMgdGhlIHZlY3RvcidzIGRpcmVjdGlvbiwgYnV0IHNldHMgaXRzIG1hZ25pdHVkZSB0byBiZSB0aGUgcHJvdmlkZWQgbWFnbml0dWRlXHJcblx0ICogQHBhcmFtIG1hZ25pdHVkZSBUaGUgbWFnbml0dWRlIHRoZSB2ZWN0b3Igc2hvdWxkIGJlXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3Igd2l0aCBpdHMgbWFnbml0dWRlIHNldCB0byB0aGUgbmV3IG1hZ25pdHVkZVxyXG5cdCAqL1xyXG5cdHNjYWxlVG8obWFnbml0dWRlOiBudW1iZXIpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1hZ25pdHVkZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTY2FsZXMgeCBhbmQgeSBieSB0aGUgbnVtYmVyIHByb3ZpZGVkLCBvciBpZiB0d28gbnVtYmVyIGFyZSBwcm92aWRlZCwgc2NhbGVzIHRoZW0gaW5kaXZpZHVhbGx5LlxyXG5cdCAqIEBwYXJhbSBmYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgdmVjdG9yLCBvciBmb3Igb25seSB0aGUgeC1jb21wb25lbnQgaWYgeUZhY3RvciBpcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSB5RmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBzY2FsaW5nXHJcblx0ICovXHJcblx0c2NhbGUoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcclxuXHRcdGlmKHlGYWN0b3IgIT09IG51bGwpe1xyXG5cdFx0XHR0aGlzLnggKj0gZmFjdG9yO1xyXG5cdFx0XHR0aGlzLnkgKj0geUZhY3RvcjtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHR0aGlzLnggKj0gZmFjdG9yO1xyXG5cdFx0dGhpcy55ICo9IGZhY3RvcjtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHNjYWxlZCB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHdpdGhvdXQgbW9kaWZ5aW5nIGl0LlxyXG5cdCAqIEBwYXJhbSBmYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgdmVjdG9yLCBvciBmb3Igb25seSB0aGUgeC1jb21wb25lbnQgaWYgeUZhY3RvciBpcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSB5RmFjdG9yIFRoZSBzY2FsaW5nIGZhY3RvciBmb3IgdGhlIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBoYXMgdGhlIHZhbHVlcyBvZiB0aGlzIHZlY3RvciBhZnRlciBzY2FsaW5nXHJcblx0ICovXHJcblx0c2NhbGVkKGZhY3RvcjogbnVtYmVyLCB5RmFjdG9yOiBudW1iZXIgPSBudWxsKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlKGZhY3RvciwgeUZhY3Rvcik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSb3RhdGVzIHRoZSB2ZWN0b3IgY291bnRlci1jbG9ja3dpc2UgYnkgdGhlIGFuZ2xlIGFtb3VudCBzcGVjaWZpZWRcclxuXHQgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBieSBpbiByYWRpYW5zXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgcm90YXRpb24uXHJcblx0ICovXHJcblx0cm90YXRlQ0NXKGFuZ2xlOiBudW1iZXIpOiBWZWMyIHtcclxuXHRcdGxldCBjcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuXHRcdGxldCBzbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuXHRcdGxldCB0ZW1wWCA9IHRoaXMueCpjcyAtIHRoaXMueSpzbjtcclxuXHRcdGxldCB0ZW1wWSA9IHRoaXMueCpzbiArIHRoaXMueSpjcztcclxuXHRcdHRoaXMueCA9IHRlbXBYO1xyXG5cdFx0dGhpcy55ID0gdGVtcFk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHZlY3RvcnMgY29vcmRpbmF0ZXMgdG8gYmUgdGhlIG9uZXMgcHJvdmlkZWRcclxuXHQgKiBAcGFyYW0geCBUaGUgbmV3IHggdmFsdWUgZm9yIHRoaXMgdmVjdG9yXHJcblx0ICogQHBhcmFtIHkgVGhlIG5ldyB5IHZhbHVlIGZvciB0aGlzIHZlY3RvclxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yXHJcblx0ICovXHJcblx0c2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogVmVjMiB7XHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIG90aGVyIFZlYzIgaW50byB0aGlzIG9uZS5cclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gY29weVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIHdpdGggaXRzIHZhbHVlcyBzZXQgdG8gdGhlIHZlY3RvciBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdGNvcHkob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLnNldChvdGhlci54LCBvdGhlci55KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgdGhpcyB2ZWN0b3IgdGhlIGFub3RoZXIgdmVjdG9yXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSBWZWMyIHRvIGFkZCB0byB0aGlzIG9uZVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGFkZGluZyB0aGUgb25lIHByb3ZpZGVkXHJcblx0ICovXHJcblx0YWRkKG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHR0aGlzLnggKz0gb3RoZXIueDtcclxuXHRcdHRoaXMueSArPSBvdGhlci55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbmNyZW1lbnRzIHRoZSBmaWVsZHMgb2YgdGhpcyB2ZWN0b3IuIEJvdGggYXJlIGluY3JlbWVudGVkIHdpdGggYSwgaWYgb25seSBhIGlzIHByb3ZpZGVkLlxyXG5cdCAqIEBwYXJhbSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gaW5jcmVtZW50IGJ5XHJcblx0ICogQHBhcmFtIGIgVGhlIHNlY29uZCBudW1iZXIgdG8gaW5jcmVtZW50IGJ5XHJcblx0ICogQHJldHVybnNzIFRoaXMgdmVjdG9yIGFmdGVyIGluY3JlbWVudGluZ1xyXG5cdCAqL1xyXG5cdGluYyhhOiBudW1iZXIsIGI/OiBudW1iZXIpOiBWZWMyIHtcclxuXHRcdGlmKGIgPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdHRoaXMueCArPSBhO1xyXG5cdFx0XHR0aGlzLnkgKz0gYTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMueCArPSBhO1xyXG5cdFx0XHR0aGlzLnkgKz0gYjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU3VidHJhY3RzIGFub3RoZXIgdmVjdG9yIGZyb20gdGhpcyB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gc3VidHJhY3QgZnJvbSB0aGlzIG9uZVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIHN1YnRyYWN0aW5nIHRoZSBvbmUgcHJvdmlkZWRcclxuXHQgKi9cclxuXHRzdWIob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHRoaXMueCAtPSBvdGhlci54O1xyXG5cdFx0dGhpcy55IC09IG90aGVyLnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBlbGVtZW50LXdpc2UuIEluIG90aGVyIHdvcmRzLCB0aGlzLnggKj0gb3RoZXIueCBhbmQgdGhpcy55ICo9IG90aGVyLnlcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gbXVsdGlwbHkgdGhpcyBvbmUgYnlcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBtdWx0aXBseWluZyBpdHMgY29tcG9uZW50cyBieSB0aGlzIG9uZVxyXG5cdCAqL1xyXG5cdG11bHQob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHRoaXMueCAqPSBvdGhlci54O1xyXG5cdFx0dGhpcy55ICo9IG90aGVyLnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpdmlkZXMgdGhpcyB2ZWN0b3Igd2l0aCBhbm90aGVyIHZlY3RvciBlbGVtZW50LXdpc2UuIEluIG90aGVyIHdvcmRzLCB0aGlzLnggLz0gb3RoZXIueCBhbmQgdGhpcy55IC89IG90aGVyLnlcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBkaXZpZGUgdGhpcyBvbmUgYnlcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciBkaXZpc2lvblxyXG5cdCAqL1xyXG5cdGRpdihvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0aWYob3RoZXIueCA9PT0gMCB8fCBvdGhlci55ID09PSAwKSB0aHJvdyBcIkRpdmlkZSBieSB6ZXJvIGVycm9yXCI7XHJcblx0XHR0aGlzLnggLz0gb3RoZXIueDtcclxuXHRcdHRoaXMueSAvPSBvdGhlci55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEb2VzIGFuIGVsZW1lbnQgd2lzZSByZW1haW5kZXIgb3BlcmF0aW9uIG9uIHRoaXMgdmVjdG9yLiB0aGlzLnggJT0gb3RoZXIueCBhbmQgdGhpcy55ICU9IG90aGVyLnlcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIHZlY3RvclxyXG5cdCAqIEByZXR1cm5zIHRoaXMgdmVjdG9yXHJcblx0ICovXHJcblx0cmVtYWluZGVyKG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHR0aGlzLnggPSB0aGlzLnggJSBvdGhlci54O1xyXG5cdFx0dGhpcy55ID0gdGhpcy55ICUgb3RoZXIueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyIHZlY3RvclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgZGlzdGFuY2Ugc3F1YXJlZCB0b1xyXG5cdCAqIEByZXR1cm5zIFRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWRcclxuXHQgKi9cclxuXHRkaXN0YW5jZVNxVG8ob3RoZXI6IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuICh0aGlzLnggLSBvdGhlci54KSoodGhpcy54IC0gb3RoZXIueCkgKyAodGhpcy55IC0gb3RoZXIueSkqKHRoaXMueSAtIG90aGVyLnkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlciB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIGRpc3RhbmNlIHRvXHJcblx0ICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIHRoZSBvbmUgcHJvdmlkZWRcclxuXHQgKi9cclxuXHRkaXN0YW5jZVRvKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxVG8ob3RoZXIpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSB0aGUgZG90IHByb2R1Y3Qgd2l0aFxyXG5cdCAqIEByZXR1cm5zIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIG9uZSBwcm92aWRlZC5cclxuXHQgKi9cclxuXHRkb3Qob3RoZXI6IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMueCpvdGhlci54ICsgdGhpcy55Km90aGVyLnk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBhbmdsZSBjb3VudGVyLWNsb2Nrd2lzZSBpbiByYWRpYW5zIGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlciB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBhbmdsZSB0b1xyXG5cdCAqIEByZXR1cm5zIFRoZSBhbmdsZSwgcm90YXRpbmcgQ0NXLCBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvdGhlciB2ZWN0b3JcclxuXHQgKi9cclxuXHRhbmdsZVRvQ0NXKG90aGVyOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdGxldCBkb3QgPSB0aGlzLmRvdChvdGhlcik7XHJcblx0XHRsZXQgZGV0ID0gdGhpcy54Km90aGVyLnkgLSB0aGlzLnkqb3RoZXIueDtcclxuXHRcdGxldCBhbmdsZSA9IC1NYXRoLmF0YW4yKGRldCwgZG90KTtcclxuXHJcblx0XHRpZihhbmdsZSA8IDApe1xyXG5cdFx0XHRhbmdsZSArPSAyKk1hdGguUEk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFuZ2xlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvciByb3VuZGVkIHRvIDEgZGVjaW1hbCBwb2ludFxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFzIGEgc3RyaW5nXHJcblx0ICovXHJcblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLnRvRml4ZWQoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3Igcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBkZWNpbWFsIHBvaW50c1xyXG5cdCAqIEBwYXJhbSBudW1EZWNpbWFsUG9pbnRzIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMgdG8gY3JlYXRlIGEgc3RyaW5nIHRvXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSBzdHJpbmdcclxuXHQgKi9cclxuXHR0b0ZpeGVkKG51bURlY2ltYWxQb2ludHM6IG51bWJlciA9IDEpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiKFwiICsgdGhpcy54LnRvRml4ZWQobnVtRGVjaW1hbFBvaW50cykgKyBcIiwgXCIgKyB0aGlzLnkudG9GaXhlZChudW1EZWNpbWFsUG9pbnRzKSArIFwiKVwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG5ldyB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBjb29yZGluYXRlcyBhcyB0aGlzIG9uZS5cclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lXHJcblx0ICovXHJcblx0Y2xvbmUoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIodGhpcy54LCB0aGlzLnkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGFuZCBvdGhlciBoYXZlIHRoZSBFWEFDVCBzYW1lIHggYW5kIHkgKG5vdCBhc3N1cmVkIHRvIGJlIHNhZmUgZm9yIGZsb2F0cylcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjaGVjayBhZ2FpbnN0XHJcblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhlIHR3byB2ZWN0b3JzXHJcblx0ICovXHJcblx0c3RyaWN0RXF1YWxzKG90aGVyOiBWZWMyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHZlY3RvciBhbmQgb3RoZXIgaGF2ZSB0aGUgc2FtZSB4IGFuZCB5XHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY2hlY2sgYWdhaW5zdFxyXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoZSB0d28gdmVjdG9yc1xyXG5cdCAqL1xyXG5cdGVxdWFscyhvdGhlcjogVmVjMik6IGJvb2xlYW4ge1xyXG5cdFx0bGV0IHhFcSA9IE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpIDwgMC4wMDAwMDAxO1xyXG5cdFx0bGV0IHlFcSA9IE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgMC4wMDAwMDAxO1xyXG5cclxuXHRcdHJldHVybiB4RXEgJiYgeUVxO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGlzIHRoZSB6ZXJvIHZlY3RvciBleGFjdGx5IChub3QgYXNzdXJlZCB0byBiZSBzYWZlIGZvciBmbG9hdHMpLlxyXG5cdCAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgdGhlIGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgemVybyB2ZWN0b3JcclxuXHQgKi9cclxuXHRzdHJpY3RJc1plcm8oKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy54ID09PSAwICYmIHRoaXMueSA9PT0gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHggYW5kIHkgZm9yIHRoaXMgdmVjdG9yIGFyZSBib3RoIHplcm8uXHJcblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSB6ZXJvIHZlY3RvclxyXG5cdCAqL1xyXG5cdGlzWmVybygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiBNYXRoLmFicyh0aGlzLngpIDwgMC4wMDAwMDAxICYmIE1hdGguYWJzKHRoaXMueSkgPCAwLjAwMDAwMDE7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIHRoaXMgdmVjdG9yIGlzIGNoYW5nZWQuXHJcblx0ICogQHBhcmFtIGYgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxyXG5cdCAqL1xyXG5cdHNldE9uQ2hhbmdlKGY6IEZ1bmN0aW9uKTogdm9pZCB7XHJcblx0XHR0aGlzLm9uQ2hhbmdlID0gZjtcclxuXHR9XHJcblxyXG5cdHRvQXJyYXkoKTogRmxvYXQzMkFycmF5IHtcclxuXHRcdHJldHVybiB0aGlzLnZlYztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlY3RvcnNcclxuXHQgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yXHJcblx0ICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gdCBUaGUgdGltZSBvZiB0aGUgbGVycCwgd2l0aCAwIGJlaW5nIHZlY3RvciBBLCBhbmQgMSBiZWluZyB2ZWN0b3IgQlxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgcmVwcmVzZW50aW5nIHRoZSBsZXJwIGJldHdlZW4gdmVjdG9yIGEgYW5kIGIuXHJcblx0ICovXHJcblx0c3RhdGljIGxlcnAoYTogVmVjMiwgYjogVmVjMiwgdDogbnVtYmVyKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoTWF0aFV0aWxzLmxlcnAoYS54LCBiLngsIHQpLCBNYXRoVXRpbHMubGVycChhLnksIGIueSwgdCkpO1xyXG5cdH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbCBjbGFzcyBmb3IgcmVuZGVyaW5nIERlYnVnIG1lc3NhZ2VzIHRvIHRoZSBjYW52YXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWJ1ZyB7XHJcblxyXG5cdC8qKiBBIG1hcCBvZiBsb2cgbWVzc2FnZXMgdG8gZGlzcGxheSBvbiB0aGUgc2NyZWVuICovIFxyXG5cdHByaXZhdGUgc3RhdGljIGxvZ01lc3NhZ2VzOiBNYXA8c3RyaW5nPiA9IG5ldyBNYXAoKTtcclxuXHJcblx0LyoqIEFuIGFycmF5IG9mIGdhbWUgbm9kZXMgdG8gcmVuZGVyIGRlYnVnIGluZm8gZm9yICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgbm9kZXM6IEFycmF5PEdhbWVOb2RlPjtcclxuXHJcblx0LyoqIFRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgYW55IGRlYnVnIG1lc3NhZ2VzICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgZGVidWdSZW5kZXJpbmdDb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG5cdC8qKlx0VGhlIHNpemUgb2YgdGhlIGRlYnVnIGNhbnZhcyAqL1xyXG5cdHByaXZhdGUgc3RhdGljIGRlYnVnQ2FudmFzU2l6ZTogVmVjMjtcclxuXHJcblx0LyoqIFRoZSByZW5kZXJpbmcgY29sb3IgZm9yIHRleHQgKi9cclxuXHRwcml2YXRlIHN0YXRpYyBkZWZhdWx0VGV4dENvbG9yOiBDb2xvciA9IENvbG9yLldISVRFO1xyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gdGhlIGRlYnVnIHNjcmVlblxyXG5cdCAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBJRCBmb3IgdGhpcyBtZXNzYWdlXHJcblx0ICogQHBhcmFtIG1lc3NhZ2VzIFRoZSBtZXNzYWdlcyB0byBwcmludCB0byB0aGUgZGVidWcgc2NyZWVuXHJcblx0ICovXHJcblx0c3RhdGljIGxvZyhpZDogc3RyaW5nLCAuLi5tZXNzYWdlczogYW55KTogdm9pZCB7XHJcblx0XHQvLyBsZXQgbWVzc2FnZSA9IFwiXCI7XHJcblx0XHQvLyBmb3IobGV0IGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspe1xyXG5cdFx0Ly8gXHRtZXNzYWdlICs9IG1lc3NhZ2VzW2ldLnRvU3RyaW5nKCk7XHJcblx0XHQvLyB9XHJcblx0XHQvLyBKb2luIGFsbCBtZXNzYWdlcyB3aXRoIHNwYWNlc1xyXG5cdFx0bGV0IG1lc3NhZ2UgPSBtZXNzYWdlcy5tYXAoKG06IGFueSkgPT4gbS50b1N0cmluZygpKS5qb2luKFwiIFwiKTtcclxuXHRcdHRoaXMubG9nTWVzc2FnZXMuYWRkKGlkLCBtZXNzYWdlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlbGV0ZXMgYSBhIGtleSBmcm9tIHRoZSBsb2cgYW5kIHN0b3BzIGl0IGZyb20ga2VlcGluZyB1cCBzcGFjZSBvbiB0aGUgc2NyZWVuXHJcblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbG9nIGl0ZW0gdG8gY2xlYXJcclxuXHQgKi9cclxuXHRzdGF0aWMgY2xlYXJMb2dJdGVtKGlkOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdHRoaXMubG9nTWVzc2FnZXMuZGVsZXRlKGlkKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGxpc3Qgb2Ygbm9kZXMgdG8gcmVuZGVyIHdpdGggdGhlIGRlYnVnZ2VyXHJcblx0ICogQHBhcmFtIG5vZGVzIFRoZSBuZXcgbGlzdCBvZiBub2Rlc1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBzZXROb2Rlcyhub2RlczogQXJyYXk8R2FtZU5vZGU+KTogdm9pZCB7XHJcblx0XHR0aGlzLm5vZGVzID0gbm9kZXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyBhIGJveCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBib3hcclxuXHQgKiBAcGFyYW0gaGFsZlNpemUgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJveFxyXG5cdCAqIEBwYXJhbSBmaWxsZWQgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgYm94IGlzIGZpbGxlZFxyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIGJveCB0byBkcmF3XHJcblx0ICovXHJcblx0c3RhdGljIGRyYXdCb3goY2VudGVyOiBWZWMyLCBoYWxmU2l6ZTogVmVjMiwgZmlsbGVkOiBib29sZWFuLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdGxldCBhbHBoYSA9IHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBjb2xvci5hO1xyXG5cclxuXHRcdGlmKGZpbGxlZCl7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxSZWN0KGNlbnRlci54IC0gaGFsZlNpemUueCwgY2VudGVyLnkgLSBoYWxmU2l6ZS55LCBoYWxmU2l6ZS54KjIsIGhhbGZTaXplLnkqMik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgbGluZVdpZHRoID0gMjtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVJlY3QoY2VudGVyLnggLSBoYWxmU2l6ZS54LCBjZW50ZXIueSAtIGhhbGZTaXplLnksIGhhbGZTaXplLngqMiwgaGFsZlNpemUueSoyKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgYSBjaXJjbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgYm94XHJcblx0ICogQHBhcmFtIGZpbGxlZCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBjaXJjbGUgaXMgZmlsbGVkXHJcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgY2lyY2xlXHJcblx0ICovXHJcblx0c3RhdGljIGRyYXdDaXJjbGUoY2VudGVyOiBWZWMyLCByYWRpdXM6IG51bWJlciwgZmlsbGVkOiBib29sZWFuLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdGxldCBhbHBoYSA9IHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBjb2xvci5hO1xyXG5cclxuXHRcdGlmKGZpbGxlZCl7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5hcmMoY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGwoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBsaW5lV2lkdGggPSAyO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIGEgcmF5IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gZnJvbSBUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIHJheVxyXG5cdCAqIEBwYXJhbSB0byBUaGUgZW5kaW5nIHBvc2l0aW9uIG9mIHRoZSByYXlcclxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSByYXlcclxuXHQgKi9cclxuXHRzdGF0aWMgZHJhd1JheShmcm9tOiBWZWMyLCB0bzogVmVjMiwgY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSAyO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG5cclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubW92ZVRvKGZyb20ueCwgZnJvbS55KTtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVUbyh0by54LCB0by55KTtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyBhIHBvaW50IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcclxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBwb2ludFxyXG5cdCAqL1xyXG5cdHN0YXRpYyBkcmF3UG9pbnQocG9zOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdGxldCBwb2ludFNpemUgPSA2O1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxSZWN0KHBvcy54IC0gcG9pbnRTaXplLzIsIHBvcy55IC0gcG9pbnRTaXplLzIsIHBvaW50U2l6ZSwgcG9pbnRTaXplKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIGNvbG9yIGZvciB0ZXh0IGZvciB0aGUgZGVidWdnZXJcclxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIHRvIHJlbmRlciB0aGUgdGV4dFxyXG5cdCAqL1xyXG5cdHN0YXRpYyBzZXREZWZhdWx0VGV4dENvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0dGhpcy5kZWZhdWx0VGV4dENvbG9yID0gY29sb3I7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBhbnkgbmVjZXNzYXJ5IHNldHVwIG9wZXJhdGlvbnMgb24gdGhlIERlYnVnIGNhbnZhc1xyXG5cdCAqIEBwYXJhbSBjYW52YXMgVGhlIGRlYnVnIGNhbnZhc1xyXG5cdCAqIEBwYXJhbSB3aWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgY2FudmFzXHJcblx0ICogQHBhcmFtIGhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xyXG5cdCAqIEByZXR1cm5zIFRoZSByZW5kZXJpbmcgY29udGV4dCBleHRyYWN0ZWQgZnJvbSB0aGUgY2FudmFzXHJcblx0ICovXHJcblx0c3RhdGljIGluaXRpYWxpemVEZWJ1Z0NhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0XHJcblx0XHR0aGlzLmRlYnVnQ2FudmFzU2l6ZSA9IG5ldyBWZWMyKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dDtcclxuXHR9XHJcblxyXG5cdC8qKiBDbGVhcnMgdGhlIGRlYnVnIGNhbnZhcyAqL1xyXG5cdHN0YXRpYyBjbGVhckNhbnZhcygpOiB2b2lkIHtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmRlYnVnQ2FudmFzU2l6ZS54LCB0aGlzLmRlYnVnQ2FudmFzU2l6ZS55KTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZW5kZXJzIHRoZSB0ZXh0IGFuZCBub2RlcyBzZW50IHRvIHRoZSBEZWJ1ZyBzeXN0ZW0gKi9cclxuXHRzdGF0aWMgcmVuZGVyKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5yZW5kZXJUZXh0KCk7XHJcblx0XHR0aGlzLnJlbmRlck5vZGVzKCk7XHJcblx0fVxyXG5cclxuXHQvKiogUmVuZGVycyB0aGUgdGV4dCBzZW50IHRvIHRoZSBEZWJ1ZyBjYW52YXMgKi9cclxuXHRzdGF0aWMgcmVuZGVyVGV4dCgpOiB2b2lkIHtcclxuXHRcdGxldCB5ID0gMjA7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5mb250ID0gXCIyMHB4IEFyaWFsXCI7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmRlZmF1bHRUZXh0Q29sb3IudG9TdHJpbmcoKTtcclxuXHJcblx0XHQvLyBEcmF3IGFsbCBvZiB0aGUgdGV4dFxyXG5cdFx0dGhpcy5sb2dNZXNzYWdlcy5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4ge1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsVGV4dCh0aGlzLmxvZ01lc3NhZ2VzLmdldChrZXkpLCAxMCwgeSlcclxuXHRcdFx0eSArPSAzMDtcdFxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKiogUmVuZGVycyB0aGUgbm9kZXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBkZWJ1ZyBjYW52YXMgKi9cclxuXHRzdGF0aWMgcmVuZGVyTm9kZXMoKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLm5vZGVzKXtcclxuXHRcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG5cdFx0XHRcdG5vZGUuZGVidWdSZW5kZXIoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59IiwiaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5cclxuLy8gQGlnbm9yZVBhZ2VcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdHMgZXh0ZW5kcyBPYmplY3Qge1xyXG4gICAgLy8gVGhlIGZwcyBvZiB0aGUgZ2FtZS5cclxuICAgIHByaXZhdGUgc3RhdGljIHByZXZmcHM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBOVU1fUE9JTlRTOiBudW1iZXIgPSA2MDtcclxuICAgIHByaXZhdGUgc3RhdGljIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgQ0FOVkFTX1dJRFRIOiBudW1iZXIgPSAzMDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBDQU5WQVNfSEVJR0hUOiBudW1iZXIgPSAzMDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBzdGF0c0RpdjogSFRNTERpdkVsZW1lbnQ7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBncmFwaENob2ljZXM6IEhUTUxTZWxlY3RFbGVtZW50O1xyXG5cclxuICAgIC8vIFF1YWR0cmVlIHN0YXRzXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2Q2xlYXJUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIFNHQ2xlYXJUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHQ2xlYXJUaW1lOiBudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldkZpbGxUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIFNHRmlsbFRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dGaWxsVGltZTogbnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByZXZVcGRhdGVUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIFNHVXBkYXRlVGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR1VwZGF0ZVRpbWU6IG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2UXVlcnlUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIFNHUXVlcnlUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHUXVlcnlUaW1lOiBudW1iZXI7XHJcblxyXG4gICAgc3RhdGljIGluaXRTdGF0cygpOiB2b2lkIHtcclxuICAgICAgICBsZXQgY2FudmFzID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHMtY2FudmFzXCIpO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuQ0FOVkFTX1dJRFRIO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLkNBTlZBU19IRUlHSFQ7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRzRGl2ID0gPEhUTUxEaXZFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHMtZGlzcGxheVwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcmV2ZnBzID0gbmV3IEFycmF5KCk7XHJcblxyXG4gICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuYXZnU0dDbGVhclRpbWUgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLlNHRmlsbFRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5hdmdTR0ZpbGxUaW1lID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLlNHVXBkYXRlVGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLmF2Z1NHVXBkYXRlVGltZSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuYXZnU0dRdWVyeVRpbWUgPSAwO1xyXG5cclxuICAgICAgICBsZXQgY2xlYXJUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgY2xlYXJUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2djbGVhclwiKTtcclxuICAgICAgICBsZXQgZmlsbFRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICBmaWxsVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNnZmlsbFwiKTtcclxuICAgICAgICBsZXQgdXBkYXRlVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIHVwZGF0ZVRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ3VwZGF0ZVwiKTtcclxuICAgICAgICBsZXQgcXVlcnlUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgcXVlcnlUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2dxdWVyeVwiKTtcclxuICAgICAgICBsZXQgYnIxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xyXG4gICAgICAgIGxldCBicjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XHJcbiAgICAgICAgbGV0IGJyMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0c0Rpdi5hcHBlbmQoY2xlYXJUaW1lLCBicjEsIGZpbGxUaW1lLCBicjIsIHVwZGF0ZVRpbWUsIGJyMywgcXVlcnlUaW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5ncmFwaENob2ljZXMgPSA8SFRNTFNlbGVjdEVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjaGFydC1vcHRpb25cIik7XHJcbiAgICAgICAgbGV0IG9wdGlvbjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgICAgIG9wdGlvbjEudmFsdWUgPSBcInByZXZmcHNcIjtcclxuICAgICAgICBvcHRpb24xLmxhYmVsID0gXCJGUFNcIjtcclxuICAgICAgICBsZXQgb3B0aW9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uMi52YWx1ZSA9IFwicHJldkNsZWFyVGltZXNcIjtcclxuICAgICAgICBvcHRpb24yLmxhYmVsID0gXCJDbGVhciBUaW1lXCI7XHJcbiAgICAgICAgbGV0IG9wdGlvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xyXG4gICAgICAgIG9wdGlvbjMudmFsdWUgPSBcInByZXZGaWxsVGltZXNcIjtcclxuICAgICAgICBvcHRpb24zLmxhYmVsID0gXCJGaWxsIHRpbWVcIjtcclxuICAgICAgICBsZXQgb3B0aW9uNCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uNC52YWx1ZSA9IFwicHJldlVwZGF0ZVRpbWVzXCI7XHJcbiAgICAgICAgb3B0aW9uNC5sYWJlbCA9IFwiVXBkYXRlIHRpbWVcIjtcclxuICAgICAgICBsZXQgb3B0aW9uNSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uNS52YWx1ZSA9IFwicHJldlF1ZXJ5VGltZXNcIjtcclxuICAgICAgICBvcHRpb241LmxhYmVsID0gXCJRdWVyeSBUaW1lXCI7XHJcbiAgICAgICAgbGV0IG9wdGlvbkFsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uQWxsLnZhbHVlID0gXCJhbGxcIjtcclxuICAgICAgICBvcHRpb25BbGwubGFiZWwgPSBcIkFsbFwiO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhDaG9pY2VzLmFwcGVuZChvcHRpb24xLCBvcHRpb24yLCBvcHRpb24zLCBvcHRpb240LCBvcHRpb241LCBvcHRpb25BbGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyB1cGRhdGVGUFMoZnBzOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnByZXZmcHMucHVzaChmcHMpO1xyXG4gICAgICAgIGlmKHRoaXMucHJldmZwcy5sZW5ndGggPiBTdGF0cy5OVU1fUE9JTlRTKXtcclxuICAgICAgICAgICAgdGhpcy5wcmV2ZnBzLnNoaWZ0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcy5wdXNoKHRoaXMuYXZnU0dDbGVhclRpbWUpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnByZXZDbGVhclRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5wcmV2RmlsbFRpbWVzLnB1c2godGhpcy5hdmdTR0ZpbGxUaW1lKTtcclxuICAgICAgICAgICAgaWYodGhpcy5wcmV2RmlsbFRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMucHJldlVwZGF0ZVRpbWVzLnB1c2godGhpcy5hdmdTR1VwZGF0ZVRpbWUpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnByZXZVcGRhdGVUaW1lcy5sZW5ndGggPiB0aGlzLk5VTV9QT0lOVFMpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcy5wdXNoKHRoaXMuYXZnU0dRdWVyeVRpbWUpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnByZXZRdWVyeVRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXBkYXRlU0dTdGF0cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBsb2coa2V5OiBzdHJpbmcsIGRhdGE6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmKGtleSA9PT0gXCJzZ2NsZWFyXCIpe1xyXG4gICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAxMDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TR0NsZWFyVGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZihrZXkgPT09IFwic2dmaWxsXCIpe1xyXG4gICAgICAgICAgICB0aGlzLlNHRmlsbFRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMTAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuU0dGaWxsVGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZihrZXkgPT09IFwic2d1cGRhdGVcIil7XHJcbiAgICAgICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICBpZih0aGlzLlNHVXBkYXRlVGltZXMubGVuZ3RoID4gMTAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKGtleSA9PT0gXCJzZ3F1ZXJ5XCIpe1xyXG4gICAgICAgICAgICB0aGlzLlNHUXVlcnlUaW1lcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICBpZih0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAxMDAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuU0dRdWVyeVRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyByZW5kZXIoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRGlzcGxheSBzdGF0c1xyXG4gICAgICAgIHRoaXMuZHJhd0NoYXJ0cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkcmF3Q2hhcnRzKCl7XHJcbiAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuQ0FOVkFTX1dJRFRILCB0aGlzLkNBTlZBU19IRUlHSFQpO1xyXG5cclxuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSB0aGlzLmdyYXBoQ2hvaWNlcy52YWx1ZTtcclxuXHJcbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldmZwc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2ZnBzO1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5CTFVFLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZDbGVhclRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xyXG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZDbGVhclRpbWVzO1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5SRUQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldkZpbGxUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2RmlsbFRpbWVzO1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5HUkVFTi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2VXBkYXRlVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldlVwZGF0ZVRpbWVzO1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5DWUFOLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZRdWVyeVRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xyXG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZRdWVyeVRpbWVzO1xyXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBDb2xvci5PUkFOR0UudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRyYXdDaGFydChwYXJhbTogQXJyYXk8bnVtYmVyPiwgY29sb3I6IHN0cmluZyl7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBDb2xvci5CTEFDSy50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygxMCwgMTApO1xyXG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbygxMCwgdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTApO1xyXG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbygxMCwgdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTApO1xyXG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLkNBTlZBU19XSURUSCAtIDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XHJcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgIGxldCBtYXggPSBNYXRoLm1heCguLi5wYXJhbSk7XHJcbiAgICAgICAgbGV0IHByZXZYID0gMTA7XHJcbiAgICAgICAgbGV0IHByZXZZID0gdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTAgLSBwYXJhbVswXS9tYXgqKHRoaXMuQ0FOVkFTX0hFSUdIVC0yMCk7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbGV0IGZwcyA9IHBhcmFtW2ldO1xyXG4gICAgICAgICAgICBsZXQgeCA9IDEwICsgaSoodGhpcy5DQU5WQVNfV0lEVEggLSAyMCkvdGhpcy5OVU1fUE9JTlRTO1xyXG4gICAgICAgICAgICBsZXQgeSA9IHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwIC0gZnBzL21heCoodGhpcy5DQU5WQVNfSEVJR0hULTIwKVxyXG4gICAgICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5jdHgubW92ZVRvKHByZXZYLCBwcmV2WSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICAgICAgcHJldlggPSB4O1xyXG4gICAgICAgICAgICBwcmV2WSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyB1cGRhdGVTR1N0YXRzKCl7XHJcbiAgICAgICAgaWYodGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuYXZnU0dDbGVhclRpbWUgPSB0aGlzLlNHQ2xlYXJUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dDbGVhclRpbWVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuU0dGaWxsVGltZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuYXZnU0dGaWxsVGltZSA9IHRoaXMuU0dGaWxsVGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHRmlsbFRpbWVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICB0aGlzLmF2Z1NHVXBkYXRlVGltZSA9IHRoaXMuU0dVcGRhdGVUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5hdmdTR1F1ZXJ5VGltZSA9IHRoaXMuU0dRdWVyeVRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR1F1ZXJ5VGltZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ2NsZWFyXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIGNsZWFyIHRpbWU6IFwiICsgdGhpcy5hdmdTR0NsZWFyVGltZTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnZmlsbFwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyBmaWxsIHRpbWU6IFwiICsgdGhpcy5hdmdTR0ZpbGxUaW1lO1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2d1cGRhdGVcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgdXBkYXRlIHRpbWU6IFwiICsgdGhpcy5hdmdTR1VwZGF0ZVRpbWU7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ3F1ZXJ5XCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIHF1ZXJ5IHRpbWU6IFwiICsgdGhpcy5hdmdTR1F1ZXJ5VGltZTtcclxuICAgIH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4vRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGV2ZW50IGVtaXR0ZXIgb2JqZWN0IG90aGVyIHN5c3RlbXMgY2FuIHVzZSB0byBob29rIGludG8gdGhlIEV2ZW50UXVldWUuXHJcbiAqIFByb3ZpZGVzIGFuIGVhc3kgaW50ZXJmYWNlIGZvciBmaXJpbmcgb2ZmIGV2ZW50cy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVtaXR0ZXIge1xyXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgRXZlbnRRdWV1ZSAqL1xyXG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuXHJcblx0LyoqIENyZWF0ZXMgYSBuZXcgRW1pdHRlciAqL1xyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0IGFuZCBldmVudCBvZiB0eXBlIGV2ZW50VHlwZSB3aXRoIHRoZSBkYXRhIHBhY2tldCBkYXRhXHJcblx0ICogQHBhcmFtIGV2ZW50VHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBvZmZcclxuXHQgKiBAcGFyYW0gZGF0YSBBIEByZWZlcmVuY2VbTWFwXSBvciByZWNvcmQgY29udGFpbmluZyBhbnkgZGF0YSBhYm91dCB0aGUgZXZlbnRcclxuXHQgKi9cclxuXHRmaXJlRXZlbnQoZXZlbnRUeXBlOiBzdHJpbmcsIGRhdGE6IE1hcDxhbnk+IHwgUmVjb3JkPHN0cmluZywgYW55PiA9IG51bGwpOiB2b2lkIHtcclxuXHRcdHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChuZXcgR2FtZUV2ZW50KGV2ZW50VHlwZSwgZGF0YSkpO1xyXG5cdH1cclxufSIsImltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuL1JlY2VpdmVyXCI7XHJcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi9HYW1lRXZlbnRUeXBlXCI7XHJcblxyXG4vKipcclxuICogVGhlIG1haW4gZXZlbnQgc3lzdGVtIG9mIHRoZSBnYW1lIGVuZ2luZS5cclxuICogRXZlbnRzIGFyZSBzZW50IHRvIHRoZSBFdmVudFF1ZXVlLCB3aGljaCBoYW5kbGVzIGRpc3RyaWJ1dGlvbiB0byBhbnkgc3lzdGVtcyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIHRob3NlIGV2ZW50cy5cclxuICogVGhpcyBhbGxvd3MgZm9yIGhhbmRsaW5nIG9mIGlucHV0IHdpdGhvdXQgaGF2aW5nIGNsYXNzZXMgZGlyZWN0bHkgaG9vayBpbnRvIGphdmFzY3JpcHQgZXZlbnQgaGFuZGxlcywgXHJcbiAqIGFuZCBhbGxvd3Mgb3RoZXJ3aXNlIHNlcGFyYXRlIGNsYXNzZXMgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyIGNsZWFubHksIHN1Y2ggYXMgYSBQbGF5ZXIgb2JqZWN0IFxyXG4gKiByZXF1ZXN0aW5nIGEgc291bmQgYmUgcGxheWVkIGJ5IHRoZSBhdWRpbyBzeXN0ZW0uXHJcbiAqIFxyXG4gKiBUaGUgZGlzdHJpYnV0aW9uIG9mIEByZWZlcmVuY2VbR2FtZUV2ZW50XXMgaGFwcGVucyBhcyBmb2xsb3dzOlxyXG4gKiBcclxuICogRXZlbnRzIGFyZSByZWNpZXZlZCB0aHJvdWdob3V0IGEgZnJhbWUgYW5kIGFyZSBxdWV1ZWQgdXAgYnkgdGhlIEV2ZW50UXVldWUuXHJcbiAqIEF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZnJhbWUsIGV2ZW50cyBhcmUgc2VudCBvdXQgdG8gYW55IHJlY2VpdmVycyB0aGF0IGFyZSBob29rZWQgaW50byB0aGUgZXZlbnQgdHlwZS5cclxuICogQHJlZmVyZW5jZVtSZWNlaXZlcl1zIGFyZSB0aGVuIGZyZWUgdG8gcHJvY2VzcyBldmVudHMgYXMgdGhleSBzZWUgZml0LlxyXG4gKiBcclxuICogT3ZlcmFsbCwgdGhlIEV2ZW50UXVldWUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgc29tZXRoaW5nIHNpbWlsYXIgdG8gYW4gZW1haWwgc2VydmVyLFxyXG4gKiBhbmQgdGhlIEByZWZlcmVuY2VbUmVjZWl2ZXJdcyBjYW4gYmUgY29uc2lkZXJlZCBhcyB0aGUgY2xpZW50IGluYm94ZXMuXHJcbiAqIFxyXG4gKiBTZWUgQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vZXZlbnQtcXVldWUuaHRtbCkgZm9yIG1vcmUgZGlzY3Vzc2lvbiBvbiBFdmVudFF1ZXVlc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRRdWV1ZSB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRXZlbnRRdWV1ZSA9IG51bGw7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHZpc2libGUgKi9cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgTUFYX1NJWkU6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBhY3R1YWwgcXVldWUgb2YgZXZlbnRzICovXHJcbiAgICBwcml2YXRlIHE6IFF1ZXVlPEdhbWVFdmVudD47XHJcbiAgICBcclxuICAgIC8qKiBUaGUgbWFwIG9mIHJlY2VpdmVycyByZWdpc3RlcmVkIGZvciBhbiBldmVudCBuYW1lICovXHJcblx0cHJpdmF0ZSByZWNlaXZlcnM6IE1hcDxBcnJheTxSZWNlaXZlcj4+O1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLk1BWF9TSVpFID0gMTAwO1xyXG4gICAgICAgIHRoaXMucSA9IG5ldyBRdWV1ZTxHYW1lRXZlbnQ+KHRoaXMuTUFYX1NJWkUpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXJzID0gbmV3IE1hcDxBcnJheTxSZWNlaXZlcj4+KCk7XHJcblx0fVxyXG4gICAgXHJcbiAgICAvKiogUmV0cmlldmVzIHRoZSBpbnN0YW5jZSBvZiB0aGUgU2luZ2xldG9uIEV2ZW50UXVldWUgKi9cclxuXHRzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRXZlbnRRdWV1ZSB7XHJcblx0XHRpZih0aGlzLmluc3RhbmNlID09PSBudWxsKXtcclxuXHRcdFx0dGhpcy5pbnN0YW5jZSA9IG5ldyBFdmVudFF1ZXVlKCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG5cdH1cclxuXHJcbiAgICAvKiogQWRkcyBhbiBldmVudCB0byB0aGUgRXZlbnRRdWV1ZS5cclxuICAgICAqIFRoaXMgaXMgZXhwb3NlZCB0byB0aGUgcmVzdCBvZiB0aGUgZ2FtZSBlbmdpbmUgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFbWl0dGVyXSBjbGFzcyAqL1xyXG4gICAgYWRkRXZlbnQoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucS5lbnF1ZXVlKGV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzc29jaWF0ZXMgYSByZWNlaXZlciB3aXRoIGEgdHlwZSBvZiBldmVudC4gRXZlcnkgdGltZSB0aGlzIGV2ZW50IGFwcGVhcnMgaW4gdGhlIGZ1dHVyZSxcclxuICAgICAqIGl0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIHJlY2VpdmVyIChhbmQgYW55IG90aGVycyB3YXRjaGluZyB0aGF0IHR5cGUpLlxyXG4gICAgICogVGhpcyBpcyBleHBvc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBnYW1lIGVuZ2luZSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW1JlY2VpdmVyXSBjbGFzc1xyXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIFRoZSBldmVudCByZWNlaXZlclxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb3IgdHlwZXMgb2YgZXZlbnRzIHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICovXHJcbiAgICBzdWJzY3JpYmUocmVjZWl2ZXI6IFJlY2VpdmVyLCB0eXBlOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcbiAgICAgICAgaWYodHlwZSBpbnN0YW5jZW9mIEFycmF5KXtcclxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgYW4gYXJyYXksIHN1YnNjcmliZSB0byBhbGwgZXZlbnQgdHlwZXNcclxuICAgICAgICAgICAgZm9yKGxldCB0IG9mIHR5cGUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMaXN0ZW5lcihyZWNlaXZlciwgdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFkZExpc3RlbmVyKHJlY2VpdmVyLCB0eXBlKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmVzIHRoZSBzcGVjaWZpZWQgcmVjZWl2ZXIgZnJvbSBhbGwgZXZlbnRzLCBvciBmcm9tIHdoYXRldmVyIGV2ZW50cyBhcmUgcHJvdmlkZWRcclxuICAgICAqIEBwYXJhbSByZWNlaXZlciBUaGUgcmVjZWl2ZXIgdG8gdW5zdWJzY3JpYmVcclxuICAgICAqIEBwYXJhbSBrZXlzIFRoZSBldmVudHMgdG8gdW5zdWJzY3JpYmUgZnJvbS4gSWYgbm9uZSBhcmUgcHJvdmlkZWQsIHVuc3Vic2NyaWJlIGZyb20gYWxsXHJcbiAgICAgKi9cclxuICAgIHVuc3Vic2NyaWJlKHJlY2VpdmVyOiBSZWNlaXZlciwgLi4uZXZlbnRzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlcnMuZm9yRWFjaChldmVudE5hbWUgPT4ge1xyXG4gICAgICAgICAgICAvLyBJZiBrZXlzIHdlcmUgcHJvdmlkZWQsIG9ubHkgY29udGludWUgaWYgdGhpcyBrZXkgaXMgb25lIG9mIHRoZW1cclxuICAgICAgICAgICAgaWYoZXZlbnRzLmxlbmd0aCA+IDAgJiYgZXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSA9PT0gLTEpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIG91ciByZWNlaXZlciBmb3IgdGhpcyBrZXlcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50TmFtZSkuaW5kZXhPZihyZWNlaXZlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhbiBpbmRleCB3YXMgZm91bmQsIHJlbW92ZSB0aGUgcmVjZWl2ZXJcclxuICAgICAgICAgICAgaWYoaW5kZXggIT09IC0xKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2ZXJzLmdldChldmVudE5hbWUpLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBc3NvY2lhdGUgdGhlIHJlY2VpdmVyIGFuZCB0aGUgdHlwZVxyXG5cdHByaXZhdGUgYWRkTGlzdGVuZXIocmVjZWl2ZXI6IFJlY2VpdmVyLCB0eXBlOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGlmKHRoaXMucmVjZWl2ZXJzLmhhcyh0eXBlKSl7XHJcblx0XHRcdHRoaXMucmVjZWl2ZXJzLmdldCh0eXBlKS5wdXNoKHJlY2VpdmVyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMucmVjZWl2ZXJzLmFkZCh0eXBlLCBbcmVjZWl2ZXJdKTtcclxuXHRcdH1cclxuXHR9XHJcbiAgICBcclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHdoaWxlKHRoaXMucS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgLy8gUmV0cmlldmUgZWFjaCBldmVudFxyXG5cdFx0XHRsZXQgZXZlbnQgPSB0aGlzLnEuZGVxdWV1ZSgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gSWYgYSByZWNlaXZlciBoYXMgdGhpcyBldmVudCB0eXBlLCBzZW5kIGl0IHRoZSBldmVudFxyXG4gICAgICAgICAgICBpZih0aGlzLnJlY2VpdmVycy5oYXMoZXZlbnQudHlwZSkpe1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCByZWNlaXZlciBvZiB0aGlzLnJlY2VpdmVycy5nZXQoZXZlbnQudHlwZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLnJlY2VpdmUoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cdFx0XHR9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiBhIHJlY2VpdmVyIGlzIHN1YnNjcmliZWQgdG8gYWxsIGV2ZW50cywgc2VuZCBpdCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgaWYodGhpcy5yZWNlaXZlcnMuaGFzKEdhbWVFdmVudFR5cGUuQUxMKSl7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChHYW1lRXZlbnRUeXBlLkFMTCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLnJlY2VpdmUoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiXHJcblxyXG4vKipcclxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbi1nYW1lIGV2ZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWVFdmVudCB7XHJcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGV2ZW50ICovXHJcbiAgICBwdWJsaWMgdHlwZTogc3RyaW5nO1xyXG4gICAgLyoqIFRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgZXZlbnQgKi9cclxuICAgIHB1YmxpYyBkYXRhOiBNYXA8YW55PjtcclxuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgZXZlbnQgaW4gbXMgKi9cclxuXHRwdWJsaWMgdGltZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHYW1lRXZlbnQuXHJcbiAgICAgKiBUaGlzIGlzIGhhbmRsZWQgaW1wbGljaXRseSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0VtaXR0ZXJdIGNsYXNzXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgR2FtZUV2ZW50XHJcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSBjb250YWluZWQgYnkgdGhlIEdhbWVFdmVudFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlOiBzdHJpbmcsIGRhdGE6IE1hcDxhbnk+IHwgUmVjb3JkPHN0cmluZywgYW55PiA9IG51bGwpIHtcclxuICAgICAgICAvLyBQYXJzZSB0aGUgZ2FtZSBldmVudCBkYXRhXHJcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcDxhbnk+KCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghKGRhdGEgaW5zdGFuY2VvZiBNYXApKXtcclxuICAgICAgICAgICAgLy8gZGF0YSBpcyBhIHJhdyBvYmplY3QsIHVucGFja1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwPGFueT4oKTtcclxuICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gZGF0YSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYWRkKGtleSwgZGF0YVtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdGhlIHR5cGUgb2YgdGhlIEdhbWVFdmVudFxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIEdhbWVFdmVudCBpcyB0aGUgc3BlY2lmaWVkIHR5cGUsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNUeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgR2FtZUV2ZW50IGFzIGEgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHYW1lRXZlbnRcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgXCI6IEBcIiArIHRoaXMudGltZTtcclxuICAgIH1cclxufSIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZW51bSBHYW1lRXZlbnRUeXBlIHtcclxuXHQvKipcclxuXHQgKiBNb3VzZSBEb3duIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XHJcblx0ICovXHJcblx0TU9VU0VfRE9XTiA9IFwibW91c2VfZG93blwiLFxyXG5cdC8qKlxyXG5cdCAqIE1vdXNlIFVwIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XHJcblx0ICovXHJcblx0TU9VU0VfVVAgPSBcIm1vdXNlX3VwXCIsXHJcblx0LyoqXHJcblx0ICogTW91c2UgTW92ZSBldmVudC4gSGFzIGRhdGE6IHtwb3NpdGlvbjogVmVjMiAtIE1vdXNlIFBvc2l0aW9ufVxyXG5cdCAqL1xyXG5cdE1PVVNFX01PVkUgPSBcIm1vdXNlX21vdmVcIixcclxuXHJcblx0LyoqXHJcblx0ICogS2V5IERvd24gZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcgLSBUaGUga2V5IHRoYXQgaXMgZG93bn1cclxuXHQgKi9cclxuXHRLRVlfRE9XTiA9IFwia2V5X2Rvd25cIixcclxuXHJcblx0LyoqXHJcblx0ICogS2V5IFVwIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nIC0gVGhlIGtleSB0aGF0IGlzIHVwfVxyXG5cdCAqL1xyXG5cdEtFWV9VUCA9IFwia2V5X3VwXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbnZhcyBCbHVyIGV2ZW50LiBIYXMgZGF0YToge31cclxuXHQgKi9cclxuXHRDQU5WQVNfQkxVUiA9IFwiY2FudmFzX2JsdXJcIixcclxuXHJcblx0LyoqXHJcblx0ICogTW91c2Ugd2hlZWwgdXAgZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdFdIRUVMX1VQID0gXCJ3aGVlbF91cFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBNb3VzZSB3aGVlbCBkb3duIGV2ZW50LiBIYXMgZGF0YToge31cclxuXHQgKi9cclxuXHRXSEVFTF9ET1dOID0gXCJ3aGVlbF9kb3duXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFN0YXJ0IFJlY29yZGluZyBldmVudC4gSGFzIGRhdGE6IHt9XHJcblx0ICovXHJcblx0U1RBUlRfUkVDT1JESU5HID0gXCJzdGFydF9yZWNvcmRpbmdcIixcclxuXHJcblx0LyoqXHJcblx0ICogU3RvcCBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdFNUT1BfUkVDT1JESU5HID0gXCJzdG9wX3JlY29yZGluZ1wiLFxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFBsYXkgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cclxuXHQgKi9cclxuXHRQTEFZX1JFQ09SRElORyA9IFwicGxheV9yZWNvcmRpbmdcIixcclxuXHJcblx0LyoqXHJcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiB9XHJcblx0ICovXHJcblx0UExBWV9TT1VORCA9IFwicGxheV9zb3VuZFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nfVxyXG5cdCAqL1xyXG5cdFNUT1BfU09VTkQgPSBcInN0b3Bfc291bmRcIixcclxuXHJcblx0LyoqXHJcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSB9XHJcblx0ICovXHJcbiBcdFBMQVlfU0ZYID0gXCJwbGF5X3NmeFwiLFxyXG5cclxuIFx0LyoqXHJcblx0ICogUGxheSBTb3VuZCBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiB9XHJcblx0ICovXHJcbiAgXHRQTEFZX01VU0lDID0gXCJwbGF5X211c2ljXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIE11dGUgYXVkaW8gY2hhbm5lbCBldmVudC4gSGFzIGRhdGE6IHtjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlfVxyXG5cdCAqL1xyXG5cdE1VVEVfQ0hBTk5FTCA9IFwibXV0ZV9jaGFubmVsXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVubXV0ZSBhdWRpbyBjaGFubmVsIGV2ZW50LiBIYXMgZGF0YToge2NoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGV9XHJcblx0ICovXHJcblx0VU5NVVRFX0NIQU5ORUwgPSBcInVubXV0ZV9jaGFubmVsXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVuY29tcGFzc2VzIGFsbCBldmVudCB0eXBlcy4gVXNlZCBmb3IgcmVjZWl2ZXJzIG9ubHkuXHJcblx0ICovXHJcblx0QUxMID0gXCJhbGxcIixcclxufSIsImltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XHJcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi9HYW1lRXZlbnRcIjtcclxuXHJcbi8qKlxyXG4gKiBSZWNlaXZlcyBzdWJzY3JpYmVkIGV2ZW50cyBmcm9tIHRoZSBFdmVudFF1ZXVlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjZWl2ZXIge1xyXG5cdC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzIHRoaXMgUmVjZWl2ZXIgY2FuIGhvbGQgYXQgb25lIHRpbWUgKi9cclxuXHRyZWFkb25seSBNQVhfU0laRTogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIGluYm94IG9mIHRoZSBSZWNlaXZlciAqL1xyXG5cdHByaXZhdGUgcTogUXVldWU8R2FtZUV2ZW50PjtcclxuXHJcblx0LyoqIENyZWF0ZXMgYSBuZXcgUmVjZWl2ZXIgKi9cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5NQVhfU0laRSA9IDEwMDtcclxuICAgICAgICB0aGlzLnEgPSBuZXcgUXVldWUodGhpcy5NQVhfU0laRSk7XHJcblx0fVxyXG5cclxuXHRkZXN0cm95KCl7XHJcblx0XHRFdmVudFF1ZXVlLmdldEluc3RhbmNlKCkudW5zdWJzY3JpYmUodGhpcyk7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgdGhlc2UgdHlwZXMgb2YgZXZlbnRzIHRvIHRoaXMgcmVjZWl2ZXIncyBxdWV1ZSBldmVyeSB1cGRhdGUuXHJcblx0ICogQHBhcmFtIGV2ZW50VHlwZXMgVGhlIHR5cGVzIG9mIGV2ZW50cyB0aGlzIHJlY2VpdmVyIHdpbGwgYmUgc3Vic2NyaWJlZCB0b1xyXG5cdCAqL1xyXG5cdHN1YnNjcmliZShldmVudFR5cGVzOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcblx0XHRFdmVudFF1ZXVlLmdldEluc3RhbmNlKCkuc3Vic2NyaWJlKHRoaXMsIGV2ZW50VHlwZXMpO1xyXG5cdFx0dGhpcy5xLmNsZWFyKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGFuIGV2ZW50IHRvIHRoZSBxdWV1ZSBvZiB0aGlzIHJlY2lldmVyLiBUaGlzIGlzIHVzZWQgYnkgdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV0gdG8gZGlzdHJpYnV0ZSBldmVudHNcclxuXHQgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHJlY2VpdmVcclxuXHQgKi9cclxuXHRyZWNlaXZlKGV2ZW50OiBHYW1lRXZlbnQpOiB2b2lkIHtcclxuXHRcdHRyeXtcclxuXHRcdHRoaXMucS5lbnF1ZXVlKGV2ZW50KTtcclxuXHRcdH0gY2F0Y2goZSl7XHJcblx0XHRcdGNvbnNvbGUud2FybihcIlJlY2VpdmVyIG92ZXJmbG93IGZvciBldmVudCBcIiArIGV2ZW50LnRvU3RyaW5nKCkpO1xyXG5cdFx0XHR0aHJvdyBlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0cmlldmVzIHRoZSBuZXh0IGV2ZW50IGZyb20gdGhlIHJlY2VpdmVyJ3MgcXVldWVcclxuXHQgKiBAcmV0dXJucyBUaGUgbmV4dCBHYW1lRXZlbnRcclxuXHQgKi9cclxuXHRnZXROZXh0RXZlbnQoKTogR2FtZUV2ZW50IHtcclxuXHRcdHJldHVybiB0aGlzLnEuZGVxdWV1ZSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTG9va3MgYXQgdGhlIG5leHQgZXZlbnQgaW4gdGhlIHJlY2VpdmVyJ3MgcXVldWUsIGJ1dCBkb2Vzbid0IHJlbW92ZSBpdCBmcm9tIHRoZSBxdWV1ZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBuZXh0IEdhbWVFdmVudFxyXG5cdCAqL1xyXG5cdHBlZWtOZXh0RXZlbnQoKTogR2FtZUV2ZW50IHtcclxuXHRcdHJldHVybiB0aGlzLnEucGVla05leHQoKVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSByZWNlaXZlciBoYXMgYW55IGV2ZW50cyBpbiBpdHMgcXVldWVcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSByZWNlaXZlciBoYXMgYW5vdGhlciBldmVudCwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0aGFzTmV4dEV2ZW50KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMucS5oYXNJdGVtcygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSWdub3JlIGFsbCBldmVudHMgdGhpcyBmcmFtZVxyXG5cdCAqL1xyXG5cdGlnbm9yZUV2ZW50cygpOiB2b2lkIHtcclxuXHRcdHRoaXMucS5jbGVhcigpO1xyXG5cdH1cclxufSIsImltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4uL1NjZW5lR3JhcGgvVmlld3BvcnRcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XHJcblxyXG4vKipcclxuICogUmVjZWl2ZXMgaW5wdXQgZXZlbnRzIGZyb20gdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV0gYW5kIGFsbG93cyBmb3IgZWFzeSBhY2Nlc3Mgb2YgaW5mb3JtYXRpb24gYWJvdXQgaW5wdXQgYnkgb3RoZXIgc3lzdGVtc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQge1xyXG5cdHByaXZhdGUgc3RhdGljIG1vdXNlUHJlc3NlZDogYm9vbGVhbjtcclxuXHRwcml2YXRlIHN0YXRpYyBtb3VzZUp1c3RQcmVzc2VkOiBib29sZWFuO1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBrZXlKdXN0UHJlc3NlZDogTWFwPGJvb2xlYW4+O1xyXG5cdHByaXZhdGUgc3RhdGljIGtleVByZXNzZWQ6IE1hcDxib29sZWFuPjtcclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQb3NpdGlvbjogVmVjMjtcclxuXHRwcml2YXRlIHN0YXRpYyBtb3VzZVByZXNzUG9zaXRpb246IFZlYzI7XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIHNjcm9sbERpcmVjdGlvbjogbnVtYmVyO1xyXG5cdHByaXZhdGUgc3RhdGljIGp1c3RTY3JvbGxlZDogYm9vbGVhbjtcclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuXHRwcml2YXRlIHN0YXRpYyByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblx0cHJpdmF0ZSBzdGF0aWMgdmlld3BvcnQ6IFZpZXdwb3J0O1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBrZXlNYXA6IE1hcDxBcnJheTxzdHJpbmc+PjtcclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMga2V5c0Rpc2FibGVkOiBib29sZWFuO1xyXG5cdHByaXZhdGUgc3RhdGljIG1vdXNlRGlzYWJsZWQ6IGJvb2xlYW47XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVzIHRoZSBJbnB1dCBvYmplY3RcclxuXHQgKiBAcGFyYW0gdmlld3BvcnQgQSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0IG9mIHRoZSBnYW1lXHJcblx0ICovXHJcblx0c3RhdGljIGluaXRpYWxpemUodmlld3BvcnQ6IFZpZXdwb3J0LCBrZXlNYXA6IEFycmF5PFJlY29yZDxzdHJpbmcsIGFueT4+KXtcclxuXHRcdElucHV0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcblx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSBmYWxzZTtcclxuXHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSBmYWxzZTtcclxuXHRcdElucHV0LnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZCA9IG5ldyBNYXA8Ym9vbGVhbj4oKTtcclxuXHRcdElucHV0LmtleVByZXNzZWQgPSBuZXcgTWFwPGJvb2xlYW4+KCk7XHJcblx0XHRJbnB1dC5tb3VzZVBvc2l0aW9uID0gbmV3IFZlYzIoMCwgMCk7XHJcblx0XHRJbnB1dC5tb3VzZVByZXNzUG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcclxuXHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IDA7XHJcblx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSBmYWxzZTtcclxuXHRcdElucHV0LmtleXNEaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0SW5wdXQubW91c2VEaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGtleW1hcFxyXG5cdFx0SW5wdXQua2V5TWFwID0gbmV3IE1hcCgpO1xyXG5cclxuXHRcdC8vIEFkZCBhbGwga2V5cyB0byB0aGUga2V5bWFwXHJcblx0XHRmb3IobGV0IGVudHJ5IGluIGtleU1hcCl7XHJcblx0XHRcdGxldCBuYW1lID0ga2V5TWFwW2VudHJ5XS5uYW1lO1xyXG5cdFx0XHRsZXQga2V5cyA9IGtleU1hcFtlbnRyeV0ua2V5cztcclxuXHRcdFx0SW5wdXQua2V5TWFwLmFkZChuYW1lLCBrZXlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRJbnB1dC5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xyXG5cdFx0Ly8gU3Vic2NyaWJlIHRvIGFsbCBpbnB1dCBldmVudHNcclxuXHRcdElucHV0LmV2ZW50UXVldWUuc3Vic2NyaWJlKElucHV0LnJlY2VpdmVyLCBbR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOLCBHYW1lRXZlbnRUeXBlLk1PVVNFX1VQLCBHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsXHJcblx0XHRcdCBHYW1lRXZlbnRUeXBlLktFWV9ET1dOLCBHYW1lRXZlbnRUeXBlLktFWV9VUCwgR2FtZUV2ZW50VHlwZS5DQU5WQVNfQkxVUiwgR2FtZUV2ZW50VHlwZS5XSEVFTF9VUCwgR2FtZUV2ZW50VHlwZS5XSEVFTF9ET1dOXSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBSZXNldCB0aGUganVzdFByZXNzZWQgdmFsdWVzIHRvIGZhbHNlXHJcblx0XHRJbnB1dC5tb3VzZUp1c3RQcmVzc2VkID0gZmFsc2U7XHJcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgZmFsc2UpKTtcclxuXHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IGZhbHNlO1xyXG5cdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gMDtcclxuXHJcblx0XHR3aGlsZShJbnB1dC5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XHRcdFx0XHJcblx0XHRcdGxldCBldmVudCA9IElucHV0LnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSGFuZGxlIGVhY2ggZXZlbnQgdHlwZVxyXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04pe1xyXG5cdFx0XHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NlZCA9IHRydWU7XHJcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKTtcdFxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLk1PVVNFX1VQKXtcclxuXHRcdFx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NT1VTRV9NT1ZFKXtcclxuXHRcdFx0XHRJbnB1dC5tb3VzZVBvc2l0aW9uID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5LRVlfRE9XTil7XHJcblx0XHRcdFx0bGV0IGtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xyXG5cdFx0XHRcdC8vIEhhbmRsZSBzcGFjZSBiYXJcclxuXHRcdFx0XHRpZihrZXkgPT09IFwiIFwiKXtcclxuXHRcdFx0XHRcdGtleSA9IFwic3BhY2VcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIUlucHV0LmtleVByZXNzZWQuZ2V0KGtleSkpe1xyXG5cdFx0XHRcdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuc2V0KGtleSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRJbnB1dC5rZXlQcmVzc2VkLnNldChrZXksIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5LRVlfVVApe1xyXG5cdFx0XHRcdGxldCBrZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcclxuXHRcdFx0XHQvLyBIYW5kbGUgc3BhY2UgYmFyXHJcblx0XHRcdFx0aWYoa2V5ID09PSBcIiBcIil7XHJcblx0XHRcdFx0XHRrZXkgPSBcInNwYWNlXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSKXtcclxuXHRcdFx0XHRJbnB1dC5jbGVhcktleVByZXNzZXMoKVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLldIRUVMX1VQKXtcclxuXHRcdFx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAtMTtcclxuXHRcdFx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSB0cnVlO1xyXG5cdFx0XHR9IGVsc2UgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5XSEVFTF9ET1dOKXtcclxuXHRcdFx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAxO1xyXG5cdFx0XHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGNsZWFyS2V5UHJlc3NlcygpOiB2b2lkIHtcclxuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xyXG5cdFx0SW5wdXQua2V5UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGtleSB3YXMgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cclxuXHQgKiBJZiB0aGUga2V5IGlzIHN0aWxsIHByZXNzZWQgZnJvbSBsYXN0IGZyYW1lIGFuZCB3YXNuJ3QgcmUtcHJlc3NlZCwgSW5wdXQgd2lsbCByZXR1cm4gZmFsc2UuXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5XHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBpc0tleUp1c3RQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRpZihJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRpZihJbnB1dC5rZXlKdXN0UHJlc3NlZC5oYXMoa2V5KSl7XHJcblx0XHRcdHJldHVybiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5nZXQoa2V5KVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgb2YgdGhlIGtleXMgdGhhdCBhcmUgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cclxuXHQgKiBJZiBhIGtleSBpcyBzdGlsbCBwcmVzc2VkIGZyb20gbGFzdCBmcmFtZSBhbmQgd2Fzbid0IHJlLXByZXNzZWQsIGl0IHdpbGwgbm90IGJlIGluIElucHV0IGxpc3QuXHJcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBuZXdseSBwcmVzc2VkIGtleXMuXHJcblx0ICovXHJcblx0c3RhdGljIGdldEtleXNKdXN0UHJlc3NlZCgpOiBBcnJheTxzdHJpbmc+IHtcclxuXHRcdGlmKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIFtdO1xyXG5cclxuXHRcdGxldCBrZXlzID0gQXJyYXk8c3RyaW5nPigpO1xyXG5cdFx0SW5wdXQua2V5SnVzdFByZXNzZWQuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRpZihJbnB1dC5rZXlKdXN0UHJlc3NlZC5nZXQoa2V5KSl7XHJcblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIGtleXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEga2V5IGlzIGJlaW5nIHByZXNzZWQuXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5XHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRpZihJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRpZihJbnB1dC5rZXlQcmVzc2VkLmhhcyhrZXkpKXtcclxuXHRcdFx0cmV0dXJuIElucHV0LmtleVByZXNzZWQuZ2V0KGtleSlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENoYW5nZXMgdGhlIGJpbmRpbmcgb2YgYW4gaW5wdXQgbmFtZSB0byBrZXlzXHJcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcclxuXHQgKiBAcGFyYW0ga2V5cyBUaGUgY29ycmVzcG9uZGluZyBrZXlzXHJcblx0ICovXHJcblx0c3RhdGljIGNoYW5nZUtleUJpbmRpbmcoaW5wdXROYW1lOiBzdHJpbmcsIGtleXM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuXHRcdElucHV0LmtleU1hcC5zZXQoaW5wdXROYW1lLCBrZXlzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFycyBhbGwga2V5IGJpbmRpbmdzXHJcblx0ICovXHJcblx0c3RhdGljIGNsZWFyQWxsS2V5QmluZGluZ3MoKTogdm9pZCB7XHJcblx0XHRJbnB1dC5rZXlNYXAuY2xlYXIoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gaW5wdXQgd2FzIGp1c3QgcHJlc3NlZCB0aGlzIGZyYW1lXHJcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnB1dCB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNKdXN0UHJlc3NlZChpbnB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0aWYoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYoSW5wdXQua2V5TWFwLmhhcyhpbnB1dE5hbWUpKXtcclxuXHRcdFx0Y29uc3Qga2V5cyA9IElucHV0LmtleU1hcC5nZXQoaW5wdXROYW1lKTtcclxuXHRcdFx0bGV0IGp1c3RQcmVzc2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IobGV0IGtleSBvZiBrZXlzKXtcclxuXHRcdFx0XHRqdXN0UHJlc3NlZCA9IGp1c3RQcmVzc2VkIHx8IElucHV0LmlzS2V5SnVzdFByZXNzZWQoa2V5KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGp1c3RQcmVzc2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVx0XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGlucHV0IGlzIGN1cnJlbnRseSBwcmVzc2VkXHJcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnB1dCBpcyBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNQcmVzc2VkKGlucHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRpZihJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRpZihJbnB1dC5rZXlNYXAuaGFzKGlucHV0TmFtZSkpe1xyXG5cdFx0XHRjb25zdCBrZXlzID0gSW5wdXQua2V5TWFwLmdldChpbnB1dE5hbWUpO1xyXG5cdFx0XHRsZXQgcHJlc3NlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yKGxldCBrZXkgb2Yga2V5cyl7XHJcblx0XHRcdFx0cHJlc3NlZCA9IHByZXNzZWQgfHwgSW5wdXQuaXNLZXlQcmVzc2VkKGtleSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBwcmVzc2VkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbW91c2Ugd2FzIG5ld2x5IHByZXNzZWQgSW5wdXQgZnJhbWVcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtb3VzZSB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNNb3VzZUp1c3RQcmVzc2VkKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlSnVzdFByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgcHJlc3NlZFxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNNb3VzZVByZXNzZWQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoZSB1c2VyIHNjcm9sbGVkIG9yIG5vdFxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIganVzdCBzY3JvbGxlZCBJbnB1dCBmcmFtZSwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICovXHJcblx0c3RhdGljIGRpZEp1c3RTY3JvbGwoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gSW5wdXQuanVzdFNjcm9sbGVkICYmICFJbnB1dC5tb3VzZURpc2FibGVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzY3JvbGxcclxuXHQgKiBAcmV0dXJucyAtMSBpZiB0aGUgdXNlciBzY3JvbGxlZCB1cCwgMSBpZiB0aGV5IHNjcm9sbGVkIGRvd25cclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0U2Nyb2xsRGlyZWN0aW9uKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gSW5wdXQuc2Nyb2xsRGlyZWN0aW9uO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXllcidzIG1vdXNlXHJcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0TW91c2VQb3NpdGlvbigpOiBWZWMyIHtcclxuXHRcdHJldHVybiBJbnB1dC5tb3VzZVBvc2l0aW9uLnNjYWxlZCgxL3RoaXMudmlld3BvcnQuZ2V0Wm9vbUxldmVsKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXllcidzIG1vdXNlIGluIHRoZSBnYW1lIHdvcmxkLFxyXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcclxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUG9zaXRpb24uY2xvbmUoKS5zY2FsZSgxL3RoaXMudmlld3BvcnQuZ2V0Wm9vbUxldmVsKCkpLmFkZChJbnB1dC52aWV3cG9ydC5nZXRPcmlnaW4oKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBtb3VzZSBwcmVzc1xyXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXHJcblx0ICovXHJcblx0c3RhdGljIGdldE1vdXNlUHJlc3NQb3NpdGlvbigpOiBWZWMyIHtcclxuXHRcdHJldHVybiBJbnB1dC5tb3VzZVByZXNzUG9zaXRpb247XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBtb3VzZSBwcmVzcyBpbiB0aGUgZ2FtZSB3b3JsZCxcclxuXHQgKiB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHZpZXdwb3J0XHJcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0R2xvYmFsTW91c2VQcmVzc1Bvc2l0aW9uKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbi5jbG9uZSgpLmFkZChJbnB1dC52aWV3cG9ydC5nZXRPcmlnaW4oKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNhYmxlcyBhbGwga2V5cHJlc3MgYW5kIG1vdXNlIGNsaWNrIGlucHV0c1xyXG5cdCAqL1xyXG5cdHN0YXRpYyBkaXNhYmxlSW5wdXQoKTogdm9pZCB7XHJcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0SW5wdXQubW91c2VEaXNhYmxlZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFbmFibGVzIGFsbCBrZXlwcmVzcyBhbmQgbW91c2UgY2xpY2sgaW5wdXRzXHJcblx0ICovXHJcblx0c3RhdGljIGVuYWJsZUlucHV0KCk6IHZvaWQge1xyXG5cdFx0SW5wdXQua2V5c0Rpc2FibGVkID0gZmFsc2U7XHJcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gZmFsc2U7XHJcblx0fVxyXG59IiwiaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIGNvbW11bmljYXRpb24gd2l0aCB0aGUgd2ViIGJyb3dzZXIgdG8gcmVjZWl2ZSBhc3luY2hyb25vdXMgZXZlbnRzIGFuZCBzZW5kIHRoZW0gdG8gdGhlIEByZWZlcmVuY2VbRXZlbnRRdWV1ZV1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0SGFuZGxlciB7XHJcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xyXG4gICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElucHV0SGFuZGxlclxyXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgZ2FtZSBjYW52YXNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCl7XHJcblx0XHR0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcblx0XHRcclxuICAgICAgICBjYW52YXMub25tb3VzZWRvd24gPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VEb3duKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgICAgIGNhbnZhcy5vbm1vdXNldXAgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VVcChldmVudCwgY2FudmFzKTtcclxuICAgICAgICBjYW52YXMub25jb250ZXh0bWVudSA9IHRoaXMuaGFuZGxlQ29udGV4dE1lbnU7XHJcbiAgICAgICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlTW92ZShldmVudCwgY2FudmFzKTtcclxuICAgICAgICBkb2N1bWVudC5vbmtleWRvd24gPSB0aGlzLmhhbmRsZUtleURvd247XHJcbiAgICAgICAgZG9jdW1lbnQub25rZXl1cCA9IHRoaXMuaGFuZGxlS2V5VXA7XHJcbiAgICAgICAgZG9jdW1lbnQub25ibHVyID0gdGhpcy5oYW5kbGVCbHVyO1xyXG4gICAgICAgIGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSB0aGlzLmhhbmRsZUJsdXI7XHJcbiAgICAgICAgZG9jdW1lbnQub253aGVlbCA9IHRoaXMuaGFuZGxlV2hlZWw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZURvd24gPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkID0+IHtcclxuXHRcdGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XHJcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5NT1VTRV9ET1dOLCB7cG9zaXRpb246IHBvc30pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VVcCA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XHJcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5NT1VTRV9VUCwge3Bvc2l0aW9uOiBwb3N9KTtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZU1vdXNlTW92ZSA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XHJcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5NT1VTRV9NT1ZFLCB7cG9zaXRpb246IHBvc30pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlS2V5RG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdldEtleShldmVudCk7XHJcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5LRVlfRE9XTiwge2tleToga2V5fSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlVcCA9IChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBrZXkgPSB0aGlzLmdldEtleShldmVudCk7XHJcbiAgICAgICAgbGV0IGdhbWVFdmVudCA9IG5ldyBHYW1lRXZlbnQoR2FtZUV2ZW50VHlwZS5LRVlfVVAsIHtrZXk6IGtleX0pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlQmx1ciA9IChldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSLCB7fSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVDb250ZXh0TWVudSA9IChldmVudDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlV2hlZWwgPSAoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBnYW1lRXZlbnQ6IEdhbWVFdmVudDtcclxuICAgICAgICBpZihldmVudC5kZWx0YVkgPCAwKXtcclxuICAgICAgICAgICAgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLldIRUVMX1VQLCB7fSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLldIRUVMX0RPV04sIHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRLZXkoa2V5RXZlbnQ6IEtleWJvYXJkRXZlbnQpe1xyXG4gICAgICAgIHJldHVybiBrZXlFdmVudC5rZXkudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldE1vdXNlUG9zaXRpb24obW91c2VFdmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IFZlYzIge1xyXG4gICAgICAgIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxldCB4ID0gbW91c2VFdmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xyXG4gICAgICAgIGxldCB5ID0gbW91c2VFdmVudC5jbGllbnRZIC0gcmVjdC50b3A7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHgsIHkpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHt9IGZyb20gXCIuLi8uLi9pbmRleFwiOyAgLy8gVGhpcyBpbXBvcnQgYWxsb3dzIHVzIHRvIG1vZGlmeSB0aGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHRvIGFkZCBleHRyYSBmdW5jdGlvbmFsaXR5XHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogU2V0cyB1cCB0aGUgZW52aXJvbm1lbnQgb2YgdGhlIGdhbWUgZW5naW5lXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnZpcm9ubWVudEluaXRpYWxpemVyIHtcclxuICAgIHN0YXRpYyBzZXR1cCgpe1xyXG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUucm91bmRlZFJlY3QgPSBmdW5jdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIsIHI6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgICAgICAvLyBDbGFtcCB0aGUgcmFkaXVzIGJldHdlZW4gMCBhbmQgdGhlIG1pbiBvZiB0aGUgd2lkdGggb3IgaGVpZ2h0XHJcbiAgICAgICAgICAgIGlmKHIgPCAwKSByID0gMDtcclxuICAgICAgICAgICAgaWYociA+IE1hdGgubWluKHcsIGgpKSByID0gTWF0aC5taW4odywgaCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIHJvdW5kZWQgcmVjdFxyXG4gICAgICAgICAgICB0aGlzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBUb3BcclxuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oeCArIHIsIHkpO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY1RvKHggKyB3LCB5LCB4ICsgdywgeSArIHIsIHIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBSaWdodFxyXG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcclxuICAgICAgICAgICAgdGhpcy5hcmNUbyh4ICsgdywgeSArIGgsIHggKyB3IC0gciwgeSArIGgsIHIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBCb3R0b21cclxuICAgICAgICAgICAgdGhpcy5saW5lVG8oeCArIHIsIHkgKyBoKTtcclxuICAgICAgICAgICAgdGhpcy5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSByLCByKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gTGVmdFxyXG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4LCB5ICsgcik7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCwgeSwgeCArIHIsIHksIHIpXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3Ryb2tlUm91bmRlZFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByKXtcclxuICAgICAgICAgICAgdGhpcy5yb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByKTtcclxuICAgICAgICAgICAgdGhpcy5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5maWxsUm91bmRlZFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByKXtcclxuICAgICAgICAgICAgdGhpcy5yb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByKTtcclxuICAgICAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgZ2FtZSBsb29wIHdpdGggYSBmaXhlZCB1cGRhdGUgdGltZSBhbmQgYSB2YXJpYWJsZSByZW5kZXIgdGltZS5cclxuICogRXZlcnkgZnJhbWUsIHRoZSBnYW1lIHVwZGF0ZXMgdW50aWwgYWxsIHRpbWUgc2luY2UgdGhlIGxhc3QgZnJhbWUgaGFzIGJlZW4gcHJvY2Vzc2VkLlxyXG4gKiBJZiB0b28gbXVjaCB0aW1lIGhhcyBwYXNzZWQsIHN1Y2ggYXMgaWYgdGhlIGxhc3QgdXBkYXRlIHdhcyB0b28gc2xvdywgXHJcbiAqIG9yIGlmIHRoZSBicm93c2VyIHdhcyBwdXQgaW50byB0aGUgYmFja2dyb3VuZCwgdGhlIGxvb3Agd2lsbCBwYW5pYyBhbmQgZGlzY2FyZCB0aW1lLlxyXG4gKiBBIHJlbmRlciBoYXBwZW5zIGF0IHRoZSBlbmQgb2YgZXZlcnkgZnJhbWUuIFRoaXMgaGFwcGVucyBhcyBmYXN0IGFzIHBvc3NpYmxlIHVubGVzcyBzcGVjaWZpZWQuXHJcbiAqIEEgbG9vcCBvZiB0aGlzIHR5cGUgYWxsb3dzIGZvciBkZXRlcm1pbmlzdGljIGJlaGF2aW9yIC0gTm8gbWF0dGVyIHdoYXQgdGhlIGZyYW1lIHJhdGUgaXMsIHRoZSB1cGRhdGUgc2hvdWxkIGJlaGF2ZSB0aGUgc2FtZSwgXHJcbiAqIGFzIGl0IGlzIG9jY3VyaW5nIGluIGEgZml4ZWQgaW50ZXJ2YWwuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXhlZFVwZGF0ZUdhbWVMb29wIGV4dGVuZHMgR2FtZUxvb3Age1xyXG5cclxuXHQvKiogVGhlIG1heCBhbGxvd2VkIHVwZGF0ZSBmcHMuKi9cclxuICAgIHByaXZhdGUgbWF4VXBkYXRlRlBTOiBudW1iZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgdGltZXN0ZXAgZm9yIGVhY2ggdXBkYXRlLiBUaGlzIGlzIHRoZSBkZWx0YVQgcGFzc2VkIHRvIHVwZGF0ZSBjYWxscy4gKi9cclxuXHRwcml2YXRlIHVwZGF0ZVRpbWVzdGVwOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBhcmUgeWV0IHRvIHNpbXVsYXRlLiAqL1xyXG4gICAgcHJpdmF0ZSBmcmFtZURlbHRhOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSB0aW1lIHdoZW4gdGhlIGxhc3QgZnJhbWUgd2FzIGRyYXduLiAqL1xyXG4gICAgcHJpdmF0ZSBsYXN0RnJhbWVUaW1lOiBudW1iZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgbWluaW11bSB0aW1lIHdlIHdhbnQgdG8gd2FpdCBiZXR3ZWVuIGdhbWUgZnJhbWVzLiAqL1xyXG4gICAgcHJpdmF0ZSBtaW5GcmFtZURlbGF5OiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgY3VycmVudCBmcmFtZSBvZiB0aGUgZ2FtZS4gKi9cclxuXHRwcml2YXRlIGZyYW1lOiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgYWN0dWFsIGZwcyBvZiB0aGUgZ2FtZS4gKi9cclxuICAgIHByaXZhdGUgZnBzOiBudW1iZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgdGltZSBiZXR3ZWVuIGZwcyBtZWFzdXJlbWVudCB1cGRhdGVzLiAqL1xyXG4gICAgcHJpdmF0ZSBmcHNVcGRhdGVJbnRlcnZhbDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgdGltZSBvZiB0aGUgbGFzdCBmcHMgdXBkYXRlLiAqL1xyXG4gICAgcHJpdmF0ZSBsYXN0RnBzVXBkYXRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZnJhbWVzIHNpbmNlIHRoZSBsYXN0IGZwcyB1cGRhdGUgd2FzIGRvbmUuICovXHJcbiAgICBwcml2YXRlIGZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaGFzIHN0YXJ0ZWQuICovXHJcbiAgICBwcml2YXRlIHN0YXJ0ZWQ6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBpcyBwYXVzZWQgKi9cclxuICAgIHByaXZhdGUgcGF1c2VkOiBib29sZWFuO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGlzIGN1cnJlbnRseSBydW5uaW5nLiAqL1xyXG4gICAgcHJpdmF0ZSBydW5uaW5nOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHVwZGF0ZSBzdGVwcyB0aGlzIGl0ZXJhdGlvbiBvZiB0aGUgZ2FtZSBsb29wLiAqL1xyXG4gICAgcHJpdmF0ZSBudW1VcGRhdGVTdGVwczogbnVtYmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5tYXhVcGRhdGVGUFMgPSA2MDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcclxuICAgICAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5taW5GcmFtZURlbGF5ID0gMDtcclxuICAgICAgICB0aGlzLmZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLmZwcyA9IHRoaXMubWF4VXBkYXRlRlBTOyAgIC8vIEluaXRpYWxpemUgdGhlIGZwcyB0byB0aGUgbWF4IGFsbG93ZWQgZnBzXHJcbiAgICAgICAgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCA9IDEwMDA7XHJcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gMDtcclxuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzID0gMDtcclxuXHR9XHJcblxyXG5cdGdldEZQUygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGZyYW1lIGNvdW50IGFuZCBzdW0gb2YgdGltZSBmb3IgdGhlIGZyYW1lcmF0ZSBvZiB0aGUgZ2FtZVxyXG4gICAgICogQHBhcmFtIHRpbWVzdGVwIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZUZQUyh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZnBzID0gMC45ICogdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUgKiAxMDAwIC8gKHRpbWVzdGFtcCAtIHRoaXMubGFzdEZwc1VwZGF0ZSkgKygxIC0gMC45KSAqIHRoaXMuZnBzO1xyXG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHRpbWVzdGFtcDtcclxuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XHJcblxyXG4gICAgICAgIERlYnVnLmxvZyhcImZwc1wiLCBcIkZQUzogXCIgKyB0aGlzLmZwcy50b0ZpeGVkKDEpKTtcclxuICAgICAgICBTdGF0cy51cGRhdGVGUFModGhpcy5mcHMpO1xyXG4gICAgfVxyXG5cclxuXHQgICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGh5c2ljcyBmcmFtZXJhdGUgb2YgdGhlIGdhbWVcclxuICAgICAqIEBwYXJhbSBpbml0TWF4IFRoZSBtYXggZnJhbWVyYXRlXHJcbiAgICAgKi9cclxuICAgIHNldE1heFVwZGF0ZUZQUyhpbml0TWF4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm1heFVwZGF0ZUZQUyA9IGluaXRNYXg7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lc3RlcCA9IE1hdGguZmxvb3IoMTAwMC90aGlzLm1heFVwZGF0ZUZQUyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXhpbXVtIHJlbmRlcmluZyBmcmFtZXJhdGVcclxuICAgICAqIEBwYXJhbSBtYXhGUFMgVGhlIG1heCBmcmFtZXJhdGVcclxuICAgICAqL1xyXG4gICAgc2V0TWF4RlBTKG1heEZQUzogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5taW5GcmFtZURlbGF5ID0gMTAwMC9tYXhGUFM7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGdhbWUgbG9vcCBwYW5pY3MsIGkuZS4gaXQgdHJpZXMgdG8gcHJvY2VzcyB0b28gbXVjaCB0aW1lIGluIGFuIGVudGlyZSBmcmFtZS5cclxuXHQgKiBUaGlzIHdpbGwgcmVzZXQgdGhlIGFtb3VudCBvZiB0aW1lIGJhY2sgdG8gemVyby5cclxuXHQgKiBAcmV0dXJucyBUaGUgYW1vdW50IG9mIHRpbWUgd2UgYXJlIGRpc2NhcmRpbmcgZnJvbSBwcm9jZXNzaW5nLlxyXG5cdCAqL1xyXG5cdHJlc2V0RnJhbWVEZWx0YSgpIDogbnVtYmVyIHtcclxuICAgICAgICBsZXQgb2xkRnJhbWVEZWx0YSA9IHRoaXMuZnJhbWVEZWx0YTtcclxuICAgICAgICB0aGlzLmZyYW1lRGVsdGEgPSAwO1xyXG4gICAgICAgIHJldHVybiBvbGRGcmFtZURlbHRhO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuICAgICAqIFN0YXJ0cyB1cCB0aGUgZ2FtZSBsb29wIGFuZCBjYWxscyB0aGUgZmlyc3QgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgKi9cclxuXHRzdGFydCgpOiB2b2lkIHtcclxuICAgICAgICBpZighdGhpcy5zdGFydGVkKXtcclxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHRpbWVzdGFtcCkgPT4gdGhpcy5kb0ZpcnN0RnJhbWUodGltZXN0YW1wKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHBhdXNlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bWUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBUaGUgZmlyc3QgZ2FtZSBmcmFtZSAtIGluaXRpYWxpemVzIHRoZSBmaXJzdCBmcmFtZSB0aW1lIGFuZCBiZWdpbnMgdGhlIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBkb0ZpcnN0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkICB7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fZG9SZW5kZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gdGltZXN0YW1wO1xyXG4gICAgICAgIHRoaXMubGFzdEZwc1VwZGF0ZSA9IHRpbWVzdGFtcDtcclxuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSA9IDA7XHJcblxyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKHQpID0+IHRoaXMuZG9GcmFtZSh0KSk7XHJcbiAgICB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEhhbmRsZXMgYW55IHByb2Nlc3NpbmcgdGhhdCBuZWVkcyB0byBiZSBkb25lIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhbWVcclxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lIG9mIHRoZSBmcmFtZSBpbiBtc1xyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBzdGFydEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHQvLyBVcGRhdGUgdGhlIGFtb3VudCBvZiB0aW1lIHdlIG5lZWQgb3VyIHVwZGF0ZSB0byBwcm9jZXNzXHJcblx0XHR0aGlzLmZyYW1lRGVsdGEgKz0gdGltZXN0YW1wIC0gdGhpcy5sYXN0RnJhbWVUaW1lO1xyXG5cclxuXHRcdC8vIFNldCB0aGUgbmV3IHRpbWUgb2YgdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aW1lc3RhbXA7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZXN0aW1hdGUgb2YgdGhlIGZyYW1lcmF0ZVxyXG4gICAgICAgIGlmKHRpbWVzdGFtcCA+IHRoaXMubGFzdEZwc1VwZGF0ZSArIHRoaXMuZnBzVXBkYXRlSW50ZXJ2YWwpe1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZQUyh0aW1lc3RhbXApO1xyXG4gICAgICAgIH1cclxuXHJcblx0XHQvLyBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBmcmFtZXNcclxuICAgICAgICB0aGlzLmZyYW1lKys7XHJcbiAgICAgICAgdGhpcy5mcmFtZXNTaW5jZUxhc3RGcHNVcGRhdGUrKztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICAgICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZS4gVXBkYXRlcyB1bnRpbCB0aGUgY3VycmVudCB0aW1lIGlzIHJlYWNoZWQuIFJlbmRlcnMgb25jZVxyXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgY3VycmVudCB0aW1lIGluIG1zXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBkb0ZyYW1lID0gKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgICAgICAgLy8gSWYgYSBwYXVzZSB3YXMgZXhlY3V0ZWQsIHN0b3AgZG9pbmcgdGhlIGxvb3AuXHJcbiAgICAgICAgaWYodGhpcy5wYXVzZWQpeyBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVxdWVzdCBhbmltYXRpb24gZnJhbWUgdG8gcHJlcGFyZSBmb3IgYW5vdGhlciB1cGRhdGUgb3IgcmVuZGVyXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodCkgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgd2UgYXJlIHRyeWluZyB0byByZW5kZXIgdG9vIHNvb24sIGRvIG5vdGhpbmcuXHJcbiAgICAgICAgaWYodGltZXN0YW1wIDwgdGhpcy5sYXN0RnJhbWVUaW1lICsgdGhpcy5taW5GcmFtZURlbGF5KXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBBIGZyYW1lIGlzIGFjdHVhbGx5IGhhcHBlbmluZ1xyXG5cdFx0dGhpcy5zdGFydEZyYW1lKHRpbWVzdGFtcCk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIHdoaWxlIHRoZXJlIGlzIHN0aWxsIHRpbWUgdG8gbWFrZSB1cC4gSWYgd2UgZG8gdG9vIG1hbnkgdXBkYXRlIHN0ZXBzLCBwYW5pYyBhbmQgZXhpdCB0aGUgbG9vcC5cclxuXHRcdHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xyXG5cdFx0bGV0IHBhbmljID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMuZnJhbWVEZWx0YSA+PSB0aGlzLnVwZGF0ZVRpbWVzdGVwKXtcclxuXHRcdFx0Ly8gRG8gYW4gdXBkYXRlXHJcblx0XHRcdHRoaXMuX2RvVXBkYXRlKHRoaXMudXBkYXRlVGltZXN0ZXAvMTAwMCk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBSZW1vdmUgdGhlIHVwZGF0ZSBzdGVwIHRpbWUgZnJvbSB0aGUgdGltZSB3ZSBoYXZlIHRvIHByb2Nlc3NcclxuICAgICAgICAgICAgdGhpcy5mcmFtZURlbHRhIC09IHRoaXMudXBkYXRlVGltZXN0ZXA7XHJcblxyXG5cdFx0XHQvLyBJbmNyZW1lbnQgc3RlcHMgYW5kIGNoZWNrIGlmIHdlJ3ZlIGRvbmUgdG9vIG1hbnlcclxuICAgICAgICAgICAgdGhpcy5udW1VcGRhdGVTdGVwcysrO1xyXG4gICAgICAgICAgICBpZih0aGlzLm51bVVwZGF0ZVN0ZXBzID4gMTAwKXtcclxuICAgICAgICAgICAgICAgIHBhbmljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGVzIGFyZSBkb25lLCByZW5kZXJcclxuICAgICAgICB0aGlzLl9kb1JlbmRlcigpO1xyXG5cclxuICAgICAgICAvLyBXcmFwIHVwIHRoZSBmcmFtZVxyXG4gICAgICAgIHRoaXMuZmluaXNoRnJhbWUocGFuaWMpO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuXHQgKiBXcmFwcyB1cCB0aGUgZnJhbWUgYW5kIGhhbmRsZXMgdGhlIHBhbmljIHN0YXRlIGlmIHRoZXJlIGlzIG9uZVxyXG5cdCAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgbG9vcCBwYW5pY2tlZFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBmaW5pc2hGcmFtZShwYW5pYzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0aWYocGFuaWMpIHtcclxuICAgICAgICAgICAgdmFyIGRpc2NhcmRlZFRpbWUgPSBNYXRoLnJvdW5kKHRoaXMucmVzZXRGcmFtZURlbHRhKCkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01haW4gbG9vcCBwYW5pY2tlZCwgcHJvYmFibHkgYmVjYXVzZSB0aGUgYnJvd3NlciB0YWIgd2FzIHB1dCBpbiB0aGUgYmFja2dyb3VuZC4gRGlzY2FyZGluZyAnICsgZGlzY2FyZGVkVGltZSArICdtcycpO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblxyXG59IiwiaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IElucHV0SGFuZGxlciBmcm9tIFwiLi4vSW5wdXQvSW5wdXRIYW5kbGVyXCI7XHJcbmltcG9ydCBSZWNvcmRlciBmcm9tIFwiLi4vUGxheWJhY2svUmVjb3JkZXJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuLi9TY2VuZS9TY2VuZU1hbmFnZXJcIjtcclxuaW1wb3J0IEF1ZGlvTWFuYWdlciBmcm9tIFwiLi4vU291bmQvQXVkaW9NYW5hZ2VyXCI7XHJcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcclxuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9SZW5kZXJpbmdNYW5hZ2VyXCI7XHJcbmltcG9ydCBDYW52YXNSZW5kZXJlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmVyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IEdhbWVPcHRpb25zIGZyb20gXCIuL0dhbWVPcHRpb25zXCI7XHJcbmltcG9ydCBHYW1lTG9vcCBmcm9tIFwiLi9HYW1lTG9vcFwiO1xyXG5pbXBvcnQgRml4ZWRVcGRhdGVHYW1lTG9vcCBmcm9tIFwiLi9GaXhlZFVwZGF0ZUdhbWVMb29wXCI7XHJcbmltcG9ydCBFbnZpcm9ubWVudEluaXRpYWxpemVyIGZyb20gXCIuL0Vudmlyb25tZW50SW5pdGlhbGl6ZXJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xyXG5pbXBvcnQgV2ViR0xSZW5kZXJlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtYWluIGxvb3Agb2YgdGhlIGdhbWUgZW5naW5lLlxyXG4gKiBIYW5kbGVzIHRoZSB1cGRhdGUgb3JkZXIsIGFuZCBpbml0aWFsaXplcyBhbGwgc3Vic3lzdGVtcy5cclxuICogVGhlIEdhbWUgbWFuYWdlcyB0aGUgdXBkYXRlIGN5Y2xlLCBhbmQgcmVxdWVzdHMgYW5pbWF0aW9uIGZyYW1lcyB0byByZW5kZXIgdG8gdGhlIGJyb3dzZXIuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lIHtcclxuICAgIGdhbWVPcHRpb25zOiBHYW1lT3B0aW9ucztcclxuICAgIHByaXZhdGUgc2hvd0RlYnVnOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBzaG93U3RhdHM6IGJvb2xlYW47XHJcblxyXG4gICAgLy8gVGhlIGdhbWUgbG9vcFxyXG4gICAgcHJpdmF0ZSBsb29wOiBHYW1lTG9vcDtcclxuXHJcbiAgICAvLyBHYW1lIGNhbnZhcyBhbmQgaXRzIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgIHJlYWRvbmx5IEdBTUVfQ0FOVkFTOiBIVE1MQ2FudmFzRWxlbWVudDtcclxuICAgIHJlYWRvbmx5IERFQlVHX0NBTlZBUzogSFRNTENhbnZhc0VsZW1lbnQ7XHJcblx0cmVhZG9ubHkgV0lEVEg6IG51bWJlcjtcclxuICAgIHJlYWRvbmx5IEhFSUdIVDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSB2aWV3cG9ydDogVmlld3BvcnQ7XHJcbiAgICBwcml2YXRlIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgcHJpdmF0ZSBjbGVhckNvbG9yOiBDb2xvcjtcclxuICAgIFxyXG4gICAgLy8gQWxsIG9mIHRoZSBuZWNlc3Nhcnkgc3Vic3lzdGVtcyB0aGF0IG5lZWQgdG8gcnVuIGhlcmVcclxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcblx0cHJpdmF0ZSBpbnB1dEhhbmRsZXI6IElucHV0SGFuZGxlcjtcclxuXHRwcml2YXRlIHJlY29yZGVyOiBSZWNvcmRlcjtcclxuICAgIHByaXZhdGUgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcbiAgICBwcml2YXRlIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyO1xyXG4gICAgcHJpdmF0ZSBhdWRpb01hbmFnZXI6IEF1ZGlvTWFuYWdlcjtcclxuICAgIHByaXZhdGUgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgR2FtZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIEdhbWUgaW5pdGlhbGl6YXRpb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pe1xyXG4gICAgICAgIC8vIEJlZm9yZSBhbnl0aGluZyBlbHNlLCBidWlsZCB0aGUgZW52aXJvbm1lbnRcclxuICAgICAgICBFbnZpcm9ubWVudEluaXRpYWxpemVyLnNldHVwKCk7XHJcblxyXG4gICAgICAgIC8vIFR5cGVjYXN0IHRoZSBjb25maWcgb2JqZWN0IHRvIGEgR2FtZUNvbmZpZyBvYmplY3RcclxuICAgICAgICB0aGlzLmdhbWVPcHRpb25zID0gR2FtZU9wdGlvbnMucGFyc2Uob3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMuc2hvd0RlYnVnID0gdGhpcy5nYW1lT3B0aW9ucy5zaG93RGVidWc7XHJcbiAgICAgICAgdGhpcy5zaG93U3RhdHMgPSB0aGlzLmdhbWVPcHRpb25zLnNob3dTdGF0cztcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIGEgZ2FtZSBsb29wXHJcbiAgICAgICAgdGhpcy5sb29wID0gbmV3IEZpeGVkVXBkYXRlR2FtZUxvb3AoKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBnYW1lIGNhbnZhcyBhbmQgZ2l2ZSBpdCBhIGJhY2tncm91bmQgY29sb3JcclxuICAgICAgICB0aGlzLkdBTUVfQ0FOVkFTID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FtZS1jYW52YXNcIik7XHJcbiAgICAgICAgdGhpcy5ERUJVR19DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkZWJ1Zy1jYW52YXNcIik7XHJcbiAgICBcclxuICAgICAgICAvLyBHaXZlIHRoZSBjYW52YXMgYSBzaXplIGFuZCBnZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgICAgdGhpcy5XSURUSCA9IHRoaXMuZ2FtZU9wdGlvbnMuY2FudmFzU2l6ZS54O1xyXG4gICAgICAgIHRoaXMuSEVJR0hUID0gdGhpcy5nYW1lT3B0aW9ucy5jYW52YXNTaXplLnk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgc3RlcCBNVVNUIGhhcHBlbiBiZWZvcmUgdGhlIHJlc291cmNlIG1hbmFnZXIgZG9lcyBhbnl0aGluZ1xyXG4gICAgICAgIGlmKHRoaXMuZ2FtZU9wdGlvbnMudXNlV2ViR0wpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IG5ldyBDYW52YXNSZW5kZXJlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXRpYWxpemVHYW1lV2luZG93KCk7XHJcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLnJlbmRlcmluZ01hbmFnZXIuaW5pdGlhbGl6ZUNhbnZhcyh0aGlzLkdBTUVfQ0FOVkFTLCB0aGlzLldJRFRILCB0aGlzLkhFSUdIVCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckNvbG9yID0gbmV3IENvbG9yKHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5yLCB0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuZywgdGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLmIpO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIGRlYnVnZ2luZyBhbmQgc3RhdHNcclxuICAgICAgICBEZWJ1Zy5pbml0aWFsaXplRGVidWdDYW52YXModGhpcy5ERUJVR19DQU5WQVMsIHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcclxuICAgICAgICBTdGF0cy5pbml0U3RhdHMoKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5nYW1lT3B0aW9ucy5zaG93U3RhdHMpIHtcclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgc3RhdHMgb3V0cHV0IGFuZCBtYWtlIGl0IG5vIGxvbmdlciBoaWRkZW5cclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0c1wiKS5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNpemUgdGhlIHZpZXdwb3J0IHRvIHRoZSBnYW1lIGNhbnZhc1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc1NpemUgPSBuZXcgVmVjMih0aGlzLldJRFRILCB0aGlzLkhFSUdIVCk7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChjYW52YXNTaXplLCB0aGlzLmdhbWVPcHRpb25zLnpvb21MZXZlbCk7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWxsIG5lY2Vzc2FyeSBnYW1lIHN1YnN5c3RlbXNcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIgPSBuZXcgSW5wdXRIYW5kbGVyKHRoaXMuR0FNRV9DQU5WQVMpO1xyXG4gICAgICAgIElucHV0LmluaXRpYWxpemUodGhpcy52aWV3cG9ydCwgdGhpcy5nYW1lT3B0aW9ucy5pbnB1dHMpO1xyXG4gICAgICAgIHRoaXMucmVjb3JkZXIgPSBuZXcgUmVjb3JkZXIoKTtcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyID0gbmV3IFNjZW5lTWFuYWdlcih0aGlzLnZpZXdwb3J0LCB0aGlzLnJlbmRlcmluZ01hbmFnZXIpO1xyXG4gICAgICAgIHRoaXMuYXVkaW9NYW5hZ2VyID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdXAgdGhlIGdhbWUgd2luZG93IHRoYXQgaG9sZHMgdGhlIGNhbnZhc2VzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaW5pdGlhbGl6ZUdhbWVXaW5kb3coKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgZ2FtZVdpbmRvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FtZS13aW5kb3dcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgd2luZG93XHJcbiAgICAgICAgZ2FtZVdpbmRvdy5zdHlsZS53aWR0aCA9IHRoaXMuV0lEVEggKyBcInB4XCI7XHJcbiAgICAgICAgZ2FtZVdpbmRvdy5zdHlsZS5oZWlnaHQgPSB0aGlzLkhFSUdIVCArIFwicHhcIjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJlaXZlcyB0aGUgU2NlbmVNYW5hZ2VyIGZyb20gdGhlIEdhbWVcclxuICAgICAqIEByZXR1cm5zIFRoZSBTY2VuZU1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgZ2V0U2NlbmVNYW5hZ2VyKCk6IFNjZW5lTWFuYWdlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVNYW5hZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBnYW1lXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KEluaXRpYWxTY2VuZTogbmV3ICguLi5hcmdzOiBhbnkpID0+IFNjZW5lLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgLy8gU2V0IHRoZSB1cGRhdGUgZnVuY3Rpb24gb2YgdGhlIGxvb3BcclxuICAgICAgICB0aGlzLmxvb3AuZG9VcGRhdGUgPSAoZGVsdGFUOiBudW1iZXIpID0+IHRoaXMudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIHRoZSBsb29wXHJcbiAgICAgICAgdGhpcy5sb29wLmRvUmVuZGVyID0gKCkgPT4gdGhpcy5yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlbG9hZCByZWdpc3RyeSBpdGVtc1xyXG4gICAgICAgIFJlZ2lzdHJ5TWFuYWdlci5wcmVsb2FkKCk7XHJcblxyXG4gICAgICAgIC8vIExvYWQgdGhlIGl0ZW1zIHdpdGggdGhlIHJlc291cmNlIG1hbmFnZXJcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSdyZSBkb25lIGxvYWRpbmcsIHN0YXJ0IHRoZSBsb29wXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoZWQgUHJlbG9hZCAtIGxvYWRpbmcgZmlyc3Qgc2NlbmVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoSW5pdGlhbFNjZW5lLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5sb29wLnN0YXJ0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGFsbCBuZWNlc3Nhcnkgc3Vic3lzdGVtcyBvZiB0aGUgZ2FtZS4gRGVmZXJzIHNjZW5lIHVwZGF0ZXMgdG8gdGhlIHNjZW5lTWFuYWdlclxyXG4gICAgICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZSBzaW5lIHRoZSBsYXN0IHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhbGwgZXZlbnRzIHRoYXQgaGFwcGVuZWQgc2luY2UgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IGxvb3BcclxuICAgICAgICAgICAgdGhpcy5ldmVudFF1ZXVlLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBkYXRhIHN0cnVjdHVyZXMgc28gZ2FtZSBvYmplY3RzIGNhbiBzZWUgdGhlIGlucHV0XHJcbiAgICAgICAgICAgIElucHV0LnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWNvcmRpbmcgb2YgdGhlIGdhbWVcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgc2NlbmVzXHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBzb3VuZHNcclxuICAgICAgICAgICAgdGhpcy5hdWRpb01hbmFnZXIudXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBMb2FkIG9yIHVubG9hZCBhbnkgcmVzb3VyY2VzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AucGF1c2UoKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgRXJyb3IgaW4gVXBkYXRlIC0gQ3Jhc2hpbmcgZ3JhY2VmdWxseVwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNhbnZhcyBhbmQgZGVmZXJzIHNjZW5lIHJlbmRlcmluZyB0byB0aGUgc2NlbmVNYW5hZ2VyLiBSZW5kZXJzIHRoZSBkZWJ1ZyBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhc2VzXHJcbiAgICAgICAgICAgIERlYnVnLmNsZWFyQ2FudmFzKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIuY2xlYXIodGhpcy5jbGVhckNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnJlbmRlcigpO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFja3kgZGVidWcgbW9kZVxyXG4gICAgICAgICAgICBpZihJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiZ1wiKSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dEZWJ1ZyA9ICF0aGlzLnNob3dEZWJ1ZztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVidWcgcmVuZGVyXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc2hvd0RlYnVnKXtcclxuICAgICAgICAgICAgICAgIERlYnVnLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnNob3dTdGF0cyl7XHJcbiAgICAgICAgICAgICAgICBTdGF0cy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcC5wYXVzZSgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmNhdWdodCBFcnJvciBpbiBSZW5kZXIgLSBDcmFzaGluZyBncmFjZWZ1bGx5XCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBOdWxsRnVuYyBmcm9tIFwiLi4vRGF0YVR5cGVzL0Z1bmN0aW9ucy9OdWxsRnVuY1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtYWluIGdhbWUgbG9vcCBvZiB0aGUgZ2FtZS4gS2VlcHMgdHJhY2sgb2YgZnBzIGFuZCBoYW5kbGVzIHNjaGVkdWxpbmcgb2YgdXBkYXRlcyBhbmQgcmVuZGVyaW5nLlxyXG4gKiBUaGlzIGNsYXNzIGlzIGxlZnQgYWJzdHJhY3QsIHNvIHRoYXQgYSBzdWJjbGFzcyBjYW4gaGFuZGxlIGV4YWN0bHkgaG93IHRoZSBsb29wIGlzIHNjaGVkdWxlZC5cclxuICogRm9yIGFuIGV4YW1wbGUgb2YgZGlmZmVyZW50IHR5cGVzIG9mIGdhbWUgbG9vcCBzY2hlZHVsaW5nLCBjaGVjayBvdXQgQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vZ2FtZS1sb29wLmh0bWwpXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTG9vcCB7XHJcblxyXG5cdC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIHVwZGF0ZSBvY2N1cnMgKi9cclxuXHRwcm90ZWN0ZWQgX2RvVXBkYXRlOiBGdW5jdGlvbiA9IE51bGxGdW5jO1xyXG5cclxuXHRzZXQgZG9VcGRhdGUodXBkYXRlOiBGdW5jdGlvbil7XHJcblx0XHR0aGlzLl9kb1VwZGF0ZSA9IHVwZGF0ZTtcclxuXHR9XHJcblxyXG5cdC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgcmVuZGVyIG9jY3VycyAqL1xyXG5cdHByb3RlY3RlZCBfZG9SZW5kZXI6IEZ1bmN0aW9uID0gTnVsbEZ1bmM7XHJcblxyXG5cclxuXHRzZXQgZG9SZW5kZXIocmVuZGVyOiBGdW5jdGlvbil7XHJcblx0XHR0aGlzLl9kb1JlbmRlciA9IHJlbmRlcjtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0cmlldmVzIHRoZSBjdXJyZW50IEZQUyBvZiB0aGUgZ2FtZVxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IGdldEZQUygpOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG4gICAgICogU3RhcnRzIHVwIHRoZSBnYW1lIGxvb3BcclxuICAgICAqL1xyXG5cdGFic3RyYWN0IHN0YXJ0KCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhdXNlcyB0aGUgZ2FtZSBsb29wLCB1c3VhbGx5IGZvciBhbiBlcnJvciBjb25kaXRpb24uXHJcblx0ICovXHJcblx0YWJzdHJhY3QgcGF1c2UoKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmVzdW1lcyB0aGUgZ2FtZSBsb29wLlxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IHJlc3VtZSgpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSdW5zIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgZ2FtZS4gTm8gdXBkYXRlIG9jY3VycyBoZXJlLCBvbmx5IGEgcmVuZGVyLlxyXG5cdCAqIFRoaXMgaXMgbmVlZGVkIHRvIGluaXRpYWxpemUgZGVsdGEgdGltZSB2YWx1ZXNcclxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GaXJzdEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUnVuIGJlZm9yZSBhbnkgdXBkYXRlcyBvciB0aGUgcmVuZGVyIG9mIGEgZnJhbWUuXHJcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IHN0YXJ0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgY29yZSBvZiB0aGUgZnJhbWUsIHdoZXJlIGFueSBuZWNlc3NhcnkgdXBkYXRlcyBvY2N1ciwgYW5kIHdoZXJlIGEgcmVuZGVyIGhhcHBlbnNcclxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZVxyXG5cdCAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgdXBkYXRlIGN5Y2xlIHBhbmlja2VkLiBUaGlzIGhhcHBlbnMgd2hlbiB0b28gbWFueSB1cGRhdGVzIHRyeSB0byBoYXBwZW4gaW4gYSBzaW5nbGUgZnJhbWVcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZmluaXNoRnJhbWUocGFuaWM6IGJvb2xlYW4pOiB2b2lkO1xyXG59IiwiLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKiBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBAcmVmZXJlbmNlW0dhbWVMb29wXSAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lT3B0aW9ucyB7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0ICovXHJcbiAgICBjYW52YXNTaXplOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9O1xyXG5cclxuICAgIC8qIFRoZSBkZWZhdWx0IGxldmVsIG9mIHpvb20gKi9cclxuICAgIHpvb21MZXZlbDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgY29sb3IgdG8gY2xlYXIgdGhlIGNhbnZhcyB0byBlYWNoIGZyYW1lICovXHJcbiAgICBjbGVhckNvbG9yOiB7cjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcn1cclxuXHJcbiAgICAvKiBBIGxpc3Qgb2YgaW5wdXQgYmluZGluZ3MgKi9cclxuICAgIGlucHV0czogQXJyYXk8e25hbWU6IHN0cmluZywga2V5czogQXJyYXk8c3RyaW5nPn0+O1xyXG5cclxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRoZSBkZWJ1ZyByZW5kZXJpbmcgc2hvdWxkIG9jY3VyICovXHJcbiAgICBzaG93RGVidWc6IGJvb2xlYW47XHJcblxyXG4gICAgLyogV2hldGhlciBvciBub3QgdGhlIHN0YXRzIHJlbmRlcmluZyBzaG91bGQgb2NjdXIgKi9cclxuICAgIHNob3dTdGF0czogYm9vbGVhbjtcclxuXHJcbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0byB1c2Ugd2ViR0wgKi9cclxuICAgIHVzZVdlYkdMOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHRoZSBkYXRhIGluIHRoZSByYXcgb3B0aW9ucyBvYmplY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBnYW1lIG9wdGlvbnMgYXMgYSBSZWNvcmRcclxuICAgICAqIEByZXR1cm5zIEEgdmVyc2lvbiBvZiB0aGUgb3B0aW9ucyBjb252ZXJ0ZWQgdG8gYSBHYW1lT3B0aW9ucyBvYmplY3RcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHBhcnNlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBHYW1lT3B0aW9ucyB7XHJcbiAgICAgICAgbGV0IGdPcHQgPSBuZXcgR2FtZU9wdGlvbnMoKTtcclxuXHJcbiAgICAgICAgZ09wdC5jYW52YXNTaXplID0gb3B0aW9ucy5jYW52YXNTaXplID8gb3B0aW9ucy5jYW52YXNTaXplIDoge3g6IDgwMCwgeTogNjAwfTtcclxuICAgICAgICBnT3B0Lnpvb21MZXZlbCA9IG9wdGlvbnMuem9vbUxldmVsID8gb3B0aW9ucy56b29tTGV2ZWwgOiAxO1xyXG4gICAgICAgIGdPcHQuY2xlYXJDb2xvciA9IG9wdGlvbnMuY2xlYXJDb2xvciA/IG9wdGlvbnMuY2xlYXJDb2xvciA6IHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1fTtcclxuICAgICAgICBnT3B0LmlucHV0cyA9IG9wdGlvbnMuaW5wdXRzID8gb3B0aW9ucy5pbnB1dHMgOiBbXTtcclxuICAgICAgICBnT3B0LnNob3dEZWJ1ZyA9ICEhb3B0aW9ucy5zaG93RGVidWc7XHJcbiAgICAgICAgZ09wdC5zaG93U3RhdHMgPSAhIW9wdGlvbnMuc2hvd1N0YXRzO1xyXG4gICAgICAgIGdPcHQudXNlV2ViR0wgPSAhIW9wdGlvbnMudXNlV2ViR0w7XHJcblxyXG4gICAgICAgIHJldHVybiBnT3B0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgUmVnaW9uIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb25cIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGluIHRoZSBnYW1lIHdvcmxkIHRoYXQgY2FuIGJlIGRyYXduIHRvIHRoZSBzY3JlZW5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIENhbnZhc05vZGUgZXh0ZW5kcyBHYW1lTm9kZSBpbXBsZW1lbnRzIFJlZ2lvbiB7XHJcblx0cHJpdmF0ZSBfc2l6ZTogVmVjMjtcclxuXHRwcml2YXRlIF9zY2FsZTogVmVjMjtcclxuXHRwcml2YXRlIF9ib3VuZGFyeTogQUFCQjtcclxuXHRwcml2YXRlIF9oYXNDdXN0b21TaGFkZXI6IGJvb2xlYW47XHJcblx0cHJpdmF0ZSBfY3VzdG9tU2hhZGVyS2V5OiBzdHJpbmc7XHJcblx0cHJpdmF0ZSBfYWxwaGE6IG51bWJlcjtcclxuXHJcblx0LyoqIEEgZmxhZyBmb3Igd2hldGhlciBvciBub3QgdGhlIENhbnZhc05vZGUgaXMgdmlzaWJsZSAqL1xyXG5cdHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5fc2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xyXG5cdFx0dGhpcy5fc2l6ZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNpemVDaGFuZ2VkKCkpO1xyXG5cdFx0dGhpcy5fc2NhbGUgPSBuZXcgVmVjMigxLCAxKTtcclxuXHRcdHRoaXMuX3NjYWxlLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2NhbGVDaGFuZ2VkKCkpO1xyXG5cdFx0dGhpcy5fYm91bmRhcnkgPSBuZXcgQUFCQigpO1xyXG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xyXG5cclxuXHRcdHRoaXMuX2hhc0N1c3RvbVNoYWRlciA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Z2V0IGFscGhhKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYWxwaGE7XHJcblx0fVxyXG5cclxuXHRzZXQgYWxwaGEoYTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9hbHBoYSA9IGE7XHJcblx0fVxyXG5cclxuXHRnZXQgc2l6ZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLl9zaXplO1xyXG5cdH1cclxuXHJcblx0c2V0IHNpemUoc2l6ZTogVmVjMil7XHJcblx0XHR0aGlzLl9zaXplID0gc2l6ZTtcclxuXHRcdC8vIEVudGVyIGFzIGEgbGFtYmRhIHRvIGJpbmQgXCJ0aGlzXCJcclxuXHRcdHRoaXMuX3NpemUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zaXplQ2hhbmdlZCgpKTtcclxuXHRcdHRoaXMuc2l6ZUNoYW5nZWQoKTtcclxuXHR9XHJcblxyXG5cdGdldCBzY2FsZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLl9zY2FsZTtcclxuXHR9XHJcblxyXG5cdHNldCBzY2FsZShzY2FsZTogVmVjMil7XHJcblx0XHR0aGlzLl9zY2FsZSA9IHNjYWxlO1xyXG5cdFx0Ly8gRW50ZXIgYXMgYSBsYW1iZGEgdG8gYmluZCBcInRoaXNcIlxyXG5cdFx0dGhpcy5fc2NhbGUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zY2FsZUNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnNjYWxlQ2hhbmdlZCgpO1xyXG5cdH1cclxuXHJcblx0c2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnNjYWxlLnggPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdHNldCBzY2FsZVkodmFsdWU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5zY2FsZS55ID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRnZXQgaGFzQ3VzdG9tU2hhZGVyKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2hhc0N1c3RvbVNoYWRlcjtcclxuXHR9XHJcblxyXG5cdGdldCBjdXN0b21TaGFkZXJLZXkoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl9jdXN0b21TaGFkZXJLZXk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgcG9zaXRpb25DaGFuZ2VkKCk6IHZvaWQge1xyXG5cdFx0c3VwZXIucG9zaXRpb25DaGFuZ2VkKCk7XHJcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XHJcblx0fVxyXG5cclxuXHQvKiogQ2FsbGVkIGlmIHRoZSBzaXplIHZlY3RvciBpcyBjaGFuZ2VkIG9yIHJlcGxhY2VkLiAqL1xyXG5cdHByb3RlY3RlZCBzaXplQ2hhbmdlZCgpOiB2b2lkIHtcclxuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcclxuXHR9XHJcblxyXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHNjYWxlIHZlY3RvciBpcyBjaGFuZ2VkIG9yIHJlcGxhY2VkICovXHJcblx0cHJvdGVjdGVkIHNjYWxlQ2hhbmdlZCgpOiB2b2lkIHtcclxuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcclxuXHR9XHJcblxyXG5cdC8vIEBkb2NJZ25vcmVcclxuXHQvKiogQ2FsbGVkIGlmIHRoZSBwb3NpdGlvbiwgc2l6ZSwgb3Igc2NhbGUgb2YgdGhlIENhbnZhc05vZGUgaXMgY2hhbmdlZC4gVXBkYXRlcyB0aGUgYm91bmRhcnkuICovXHJcblx0cHJpdmF0ZSB1cGRhdGVCb3VuZGFyeSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuX2JvdW5kYXJ5LmNlbnRlci5zZXQodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xyXG5cdFx0dGhpcy5fYm91bmRhcnkuaGFsZlNpemUuc2V0KHRoaXMuc2l6ZS54KnRoaXMuc2NhbGUueC8yLCB0aGlzLnNpemUueSp0aGlzLnNjYWxlLnkvMik7XHJcblx0fVxyXG5cclxuXHRnZXQgYm91bmRhcnkoKTogQUFCQiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRhcnk7XHJcblx0fVxyXG5cclxuXHRnZXQgc2l6ZVdpdGhab29tKCk6IFZlYzIge1xyXG5cdFx0bGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmJvdW5kYXJ5LmhhbGZTaXplLmNsb25lKCkuc2NhbGVkKHpvb20sIHpvb20pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIGN1c3RvbSBzaGFkZXIgdG8gdGhpcyBDYW52YXNOb2RlXHJcblx0ICogQHBhcmFtIGtleSBUaGUgcmVnaXN0cnkga2V5IG9mIHRoZSBTaGFkZXJUeXBlXHJcblx0ICovXHJcblx0dXNlQ3VzdG9tU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLl9oYXNDdXN0b21TaGFkZXIgPSB0cnVlO1xyXG5cdFx0dGhpcy5fY3VzdG9tU2hhZGVyS2V5ID0ga2V5O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCAoeCwgeSkgaXMgaW5zaWRlIG9mIHRoaXMgY2FudmFzIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB4IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG5cdCAqIEBwYXJhbSB5IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG5cdCAqIEByZXR1cm5zIEEgZmxhZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBub2RlIGNvbnRhaW5zIHRoZSBwb2ludC5cclxuXHQgKi9cclxuXHRjb250YWlucyh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kYXJ5LmNvbnRhaW5zUG9pbnQobmV3IFZlYzIoeCwgeSkpO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0ZGVidWdSZW5kZXIoKTogdm9pZCB7XHJcblx0XHREZWJ1Zy5kcmF3Qm94KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgdGhpcy5zaXplV2l0aFpvb20sIGZhbHNlLCBDb2xvci5CTFVFKTtcclxuXHRcdHN1cGVyLmRlYnVnUmVuZGVyKCk7XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJcIjtcclxuaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xyXG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XHJcbmltcG9ydCBQb3NpdGlvbmVkIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Qb3NpdGlvbmVkXCI7XHJcbmltcG9ydCB7IGlzUmVnaW9uIH0gZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1JlZ2lvblwiO1xyXG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IERlYnVnUmVuZGVyYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvRGVidWdSZW5kZXJhYmxlXCI7XHJcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5pbXBvcnQgVHdlZW5Db250cm9sbGVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2VlbkNvbnRyb2xsZXJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbiB0aGUgZ2FtZSB3b3JsZC5cclxuICogVG8gY29uc3RydWN0IEdhbWVOb2Rlcywgc2VlIHRoZSBAcmVmZXJlbmNlW1NjZW5lXSBkb2N1bWVudGF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgR2FtZU5vZGUgaW1wbGVtZW50cyBQb3NpdGlvbmVkLCBVbmlxdWUsIFVwZGF0ZWFibGUsIFBoeXNpY2FsLCBBY3RvciwgRGVidWdSZW5kZXJhYmxlIHtcclxuXHQvKi0tLS0tLS0tLS0gUE9TSVRJT05FRCAtLS0tLS0tLS0tKi9cclxuXHRwcml2YXRlIF9wb3NpdGlvbjogVmVjMjtcclxuXHJcblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cclxuXHRwcml2YXRlIF9pZDogbnVtYmVyO1xyXG5cclxuXHQvKi0tLS0tLS0tLS0gUEhZU0lDQUwgLS0tLS0tLS0tLSovXHJcblx0aGFzUGh5c2ljczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdG1vdmluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdGZyb3plbjogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdG9uR3JvdW5kOiBib29sZWFuID0gZmFsc2U7XHJcblx0b25XYWxsOiBib29sZWFuID0gZmFsc2U7XHJcblx0b25DZWlsaW5nOiBib29sZWFuID0gZmFsc2U7XHJcblx0YWN0aXZlOiBib29sZWFuID0gZmFsc2U7XHJcblx0Y29sbGlzaW9uU2hhcGU6IFNoYXBlO1xyXG5cdGNvbGxpZGVyT2Zmc2V0OiBWZWMyO1xyXG5cdGlzU3RhdGljOiBib29sZWFuO1xyXG5cdGlzQ29sbGlkYWJsZTogYm9vbGVhbjtcclxuXHRpc1RyaWdnZXI6IGJvb2xlYW47XHJcblx0dHJpZ2dlck1hc2s6IG51bWJlcjtcclxuXHR0cmlnZ2VyRW50ZXJzOiBBcnJheTxzdHJpbmc+O1xyXG5cdHRyaWdnZXJFeGl0czogQXJyYXk8c3RyaW5nPjtcclxuXHRfdmVsb2NpdHk6IFZlYzI7XHJcblx0c3dlcHRSZWN0OiBBQUJCO1xyXG5cdGNvbGxpZGVkV2l0aFRpbGVtYXA6IGJvb2xlYW47XHJcblx0Z3JvdXA6IG51bWJlcjtcclxuXHRpc1BsYXllcjogYm9vbGVhbjtcclxuXHRpc0NvbGxpZGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHQvKi0tLS0tLS0tLS0gQUNUT1IgLS0tLS0tLS0tLSovXHJcblx0X2FpOiBBSTtcclxuXHRhaUFjdGl2ZTogYm9vbGVhbjtcclxuXHRwYXRoOiBOYXZpZ2F0aW9uUGF0aDtcclxuXHRwYXRoZmluZGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHQvKi0tLS0tLS0tLS0gR0VORVJBTCAtLS0tLS0tLS0tKi9cclxuXHQvKiogQW4gZXZlbnQgcmVjZWl2ZXIuICovXHJcblx0cHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcclxuXHQvKiogQW4gZXZlbnQgZW1pdHRlci4gKi9cclxuXHRwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIHNjZW5lIHRoaXMgR2FtZU5vZGUgaXMgYSBwYXJ0IG9mLiAqL1xyXG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcblx0LyoqIFRoZSB2aXN1YWwgbGF5ZXIgdGhpcyBHYW1lTm9kZSByZXNpZGVzIGluLiAqL1xyXG5cdHByb3RlY3RlZCBsYXllcjogTGF5ZXI7XHJcblx0LyoqIEEgdXRpbGl0eSB0aGF0IGFsbG93cyB0aGUgdXNlIG9mIHR3ZWVucyBvbiB0aGlzIEdhbWVOb2RlICovXHJcblx0dHdlZW5zOiBUd2VlbkNvbnRyb2xsZXI7XHJcblx0LyoqIEEgdHdlZW5hYmxlIHByb3BlcnR5IGZvciByb3RhdGlvbi4gRG9lcyBub3QgYWZmZWN0IHRoZSBib3VuZGluZyBib3ggb2YgdGhpcyBHYW1lTm9kZSAtIE9ubHkgcmVuZGVyaW5nLiAqL1xyXG5cdHJvdGF0aW9uOiBudW1iZXI7XHJcblx0YXR0YWNrX2RpcmVjdGlvbjogbnVtYmVyOyBcclxuXHQvKiogVGhlIG9wYWNpdHkgdmFsdWUgb2YgdGhpcyBHYW1lTm9kZSAqL1xyXG5cdGFic3RyYWN0IHNldCBhbHBoYShhOiBudW1iZXIpO1xyXG5cclxuXHRhYnN0cmFjdCBnZXQgYWxwaGEoKTogbnVtYmVyO1xyXG5cclxuXHQvLyBDb25zdHJ1Y3RvciBkb2NzIGFyZSBpZ25vcmVkLCBhcyB0aGUgdXNlciBzaG91bGQgTk9UIGNyZWF0ZSBuZXcgR2FtZU5vZGVzIHdpdGggYSByYXcgY29uc3RydWN0b3JcclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5fcG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcclxuXHRcdHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xyXG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG5cdFx0dGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHRcdHRoaXMudHdlZW5zID0gbmV3IFR3ZWVuQ29udHJvbGxlcih0aGlzKTtcclxuXHRcdHRoaXMucm90YXRpb24gPSAwO1xyXG5cdH1cclxuXHJcblx0ZGVzdHJveSgpe1xyXG5cdFx0dGhpcy50d2VlbnMuZGVzdHJveSgpO1xyXG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XHJcblxyXG5cdFx0aWYodGhpcy5oYXNQaHlzaWNzKXtcclxuXHRcdFx0dGhpcy5yZW1vdmVQaHlzaWNzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5fYWkpe1xyXG5cdFx0XHR0aGlzLl9haS5kZXN0cm95KCk7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9haTtcclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZW1vdmVBY3Rvcih0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNjZW5lLnJlbW92ZSh0aGlzKTtcclxuXHJcblx0XHR0aGlzLmxheWVyLnJlbW92ZU5vZGUodGhpcyk7XHJcblx0fVxyXG5cclxuXHQvKi0tLS0tLS0tLS0gUE9TSVRJT05FRCAtLS0tLS0tLS0tKi9cclxuXHRnZXQgcG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fcG9zaXRpb247XHJcblx0fVxyXG5cclxuXHRzZXQgcG9zaXRpb24ocG9zOiBWZWMyKSB7XHJcblx0XHR0aGlzLl9wb3NpdGlvbiA9IHBvcztcclxuXHRcdHRoaXMuX3Bvc2l0aW9uLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2VkKCkpO1xyXG5cdFx0dGhpcy5wb3NpdGlvbkNoYW5nZWQoKTtcclxuXHR9XHJcblxyXG5cdGdldCByZWxhdGl2ZVBvc2l0aW9uKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydHMgYSBwb2ludCB0byBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgem9vbSBhbmQgb3JpZ2luIG9mIHRoaXMgbm9kZVxyXG5cdCAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY29udmVyXHJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiByZXByZXNlbnRpbmcgdGhlIHBvaW50IGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXHJcblx0ICovXHJcblx0aW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHBvaW50OiBWZWMyKTogVmVjMiB7XHJcblx0XHRsZXQgb3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24odGhpcyk7XHJcblx0XHRsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcblx0XHRyZXR1cm4gcG9pbnQuY2xvbmUoKS5zdWIob3JpZ2luKS5zY2FsZSh6b29tKTtcclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBVTklRVUUgLS0tLS0tLS0tLSovXHJcblx0Z2V0IGlkKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5faWQ7XHJcblx0fVxyXG5cclxuXHRzZXQgaWQoaWQ6IG51bWJlcikge1xyXG5cdFx0Ly8gaWQgY2FuIG9ubHkgYmUgc2V0IG9uY2VcclxuXHRcdGlmKHRoaXMuX2lkID09PSB1bmRlZmluZWQpe1xyXG5cdFx0XHR0aGlzLl9pZCA9IGlkO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhyb3cgXCJBdHRlbXB0ZWQgdG8gYXNzaWduIGlkIHRvIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIGlkLlwiXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKi0tLS0tLS0tLS0gUEhZU0lDQUwgLS0tLS0tLS0tLSovXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0LyoqXHJcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdG8gbW92ZSB0aGUgb2JqZWN0LlxyXG4gICAgICovXHJcblx0bW92ZSh2ZWxvY2l0eTogVmVjMik6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5mcm96ZW4pIHJldHVybjtcclxuXHRcdHRoaXMubW92aW5nID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gdmVsb2NpdHk7XHJcblx0fTtcclxuXHJcblx0bW92ZU9uUGF0aChzcGVlZDogbnVtYmVyLCBwYXRoOiBOYXZpZ2F0aW9uUGF0aCk6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5mcm96ZW4pIHJldHVybjtcclxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XHJcblx0XHRsZXQgZGlyID0gcGF0aC5nZXRNb3ZlRGlyZWN0aW9uKHRoaXMpO1xyXG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xyXG5cdFx0dGhpcy5wYXRoZmluZGluZyA9IHRydWU7XHJcblx0XHR0aGlzLl92ZWxvY2l0eSA9IGRpci5zY2FsZShzcGVlZCk7XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHZlbG9jaXR5IFRoZSB2ZWxvY2l0eSB3aXRoIHdoaWNoIHRoZSBvYmplY3Qgd2lsbCBtb3ZlLlxyXG4gICAgICovXHJcblx0ZmluaXNoTW92ZSgpOiB2b2lkIHtcclxuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLnBvc2l0aW9uLmFkZCh0aGlzLl92ZWxvY2l0eSk7XHJcblx0XHRpZih0aGlzLnBhdGhmaW5kaW5nKXtcclxuXHRcdFx0dGhpcy5wYXRoLmhhbmRsZVBhdGhQcm9ncmVzcyh0aGlzKTtcclxuXHRcdFx0dGhpcy5wYXRoID0gbnVsbDtcclxuXHRcdFx0dGhpcy5wYXRoZmluZGluZyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0LyoqXHJcblx0ICogQHBhcmFtIGNvbGxpc2lvblNoYXBlIFRoZSBjb2xsaWRlciBmb3IgdGhpcyBvYmplY3QuIElmIHRoaXMgaGFzIGEgcmVnaW9uIChpbXBsZW1lbnRzIFJlZ2lvbiksXHJcblx0ICogaXQgd2lsbCBiZSB1c2VkIHdoZW4gbm8gY29sbGlzaW9uIHNoYXBlIGlzIHNwZWNpZmllZCAob3IgaWYgY29sbGlzaW9uIHNoYXBlIGlzIG51bGwpLlxyXG5cdCAqIEBwYXJhbSBpc0NvbGxpZGFibGUgV2hldGhlciB0aGlzIGlzIGNvbGxpZGFibGUgb3Igbm90LiBUcnVlIGJ5IGRlZmF1bHQuXHJcblx0ICogQHBhcmFtIGlzU3RhdGljIFdoZXRoZXIgdGhpcyBpcyBzdGF0aWMgb3Igbm90LiBGYWxzZSBieSBkZWZhdWx0XHJcblx0ICovXHJcblx0YWRkUGh5c2ljcyhjb2xsaXNpb25TaGFwZT86IFNoYXBlLCBjb2xsaWRlck9mZnNldD86IFZlYzIsIGlzQ29sbGlkYWJsZTogYm9vbGVhbiA9IHRydWUsIGlzU3RhdGljOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHBoeXNpY3MgdmFyaWFibGVzXHJcblx0XHR0aGlzLmhhc1BoeXNpY3MgPSB0cnVlO1xyXG5cdFx0dGhpcy5tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMub25Hcm91bmQgPSBmYWxzZTtcclxuXHRcdHRoaXMub25XYWxsID0gZmFsc2U7XHJcblx0XHR0aGlzLm9uQ2VpbGluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cdFx0dGhpcy5pc0NvbGxpZGFibGUgPSBpc0NvbGxpZGFibGU7XHJcblx0XHR0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XHJcblx0XHR0aGlzLmlzVHJpZ2dlciA9IGZhbHNlO1xyXG5cdFx0dGhpcy50cmlnZ2VyTWFzayA9IDA7XHJcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnMgPSBuZXcgQXJyYXkoMzIpO1xyXG5cdFx0dGhpcy50cmlnZ2VyRXhpdHMgPSBuZXcgQXJyYXkoMzIpO1xyXG5cdFx0dGhpcy5fdmVsb2NpdHkgPSBWZWMyLlpFUk87XHJcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IG5ldyBBQUJCKCk7XHJcblx0XHR0aGlzLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcclxuXHRcdHRoaXMuZ3JvdXAgPSAtMTtcdFx0XHRcdFx0Ly8gVGhlIGRlZmF1bHQgZ3JvdXAsIGNvbGxpZGVzIHdpdGggZXZlcnl0aGluZ1xyXG5cclxuXHRcdC8vIFNldCB0aGUgY29sbGlzaW9uIHNoYXBlIGlmIHByb3ZpZGVkLCBvciBzaW1wbHkgdXNlIHRoZSB0aGUgcmVnaW9uIGlmIHRoZXJlIGlzIG9uZS5cclxuXHRcdGlmKGNvbGxpc2lvblNoYXBlKXtcclxuXHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9IGNvbGxpc2lvblNoYXBlO1xyXG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb247XHJcblx0XHR9IGVsc2UgaWYgKGlzUmVnaW9uKHRoaXMpKSB7XHJcblx0XHRcdC8vIElmIHRoZSBnYW1lbm9kZSBoYXMgYSByZWdpb24gYW5kIG5vIG90aGVyIGlzIHNwZWNpZmllZCwgdXNlIHRoYXRcclxuXHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9ICg8YW55PnRoaXMpLmJvdW5kYXJ5LmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBcIk5vIGNvbGxpc2lvbiBzaGFwZSBzcGVjaWZpZWQgZm9yIHBoeXNpY3Mgb2JqZWN0LlwiXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgd2Ugd2VyZSBwcm92aWRlZCB3aXRoIGEgY29sbGlkZXIgb2Zmc2V0LCBzZXQgaXQuIE90aGVyd2lzZSB0aGVyZSBpcyBubyBvZmZzZXQsIHNvIHVzZSB0aGUgemVybyB2ZWN0b3JcclxuXHRcdGlmKGNvbGxpZGVyT2Zmc2V0KXtcclxuXHRcdFx0dGhpcy5jb2xsaWRlck9mZnNldCA9IGNvbGxpZGVyT2Zmc2V0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5jb2xsaWRlck9mZnNldCA9IFZlYzIuWkVSTztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0aWFsaXplIHRoZSBzd2VwdCByZWN0XHJcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IHRoaXMuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblxyXG5cdFx0Ly8gUmVnaXN0ZXIgdGhlIG9iamVjdCB3aXRoIHBoeXNpY3NcclxuXHRcdHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5yZWdpc3Rlck9iamVjdCh0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZW1vdmVzIHRoaXMgb2JqZWN0IGZyb20gdGhlIHBoeXNpY3Mgc3lzdGVtICovXHJcbiAgICByZW1vdmVQaHlzaWNzKCk6IHZvaWQge1xyXG5cdFx0Ly8gUmVtb3ZlIHRoaXMgZnJvbSB0aGUgcGh5c2ljcyBtYW5hZ2VyXHJcblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuZGVyZWdpc3Rlck9iamVjdCh0aGlzKTtcclxuXHJcblx0XHQvLyBOdWxsaWZ5IGFsbCBwaHlzaWNzIGZpZWxkc1xyXG5cdFx0dGhpcy5oYXNQaHlzaWNzID0gZmFsc2U7XHJcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbldhbGwgPSBmYWxzZTtcclxuXHRcdHRoaXMub25DZWlsaW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc0NvbGxpZGFibGUgPSBmYWxzZTtcclxuXHRcdHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcclxuXHRcdHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XHJcblx0XHR0aGlzLnRyaWdnZXJNYXNrID0gMDtcclxuXHRcdHRoaXMudHJpZ2dlckVudGVycyA9IG51bGw7XHJcblx0XHR0aGlzLnRyaWdnZXJFeGl0cyA9IG51bGw7XHJcblx0XHR0aGlzLl92ZWxvY2l0eSA9IFZlYzIuWkVSTztcclxuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbnVsbDtcclxuXHRcdHRoaXMuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5ncm91cCA9IC0xO1xyXG5cdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9IG51bGw7XHJcblx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gVmVjMi5aRVJPO1xyXG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqIERpc2FibGVzIHBoeXNpY3MgbW92ZW1lbnQgZm9yIHRoaXMgbm9kZSAqL1xyXG5cdGZyZWV6ZSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuZnJvemVuID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZWVuYWJsZXMgcGh5c2ljcyBtb3ZlbWVudCBmb3IgdGhpcyBub2RlICovXHJcblx0dW5mcmVlemUoKTogdm9pZCB7XHJcblx0XHR0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG5cdH1cclxuXHJcbiAgICAvKiogUHJldmVudHMgdGhpcyBvYmplY3QgZnJvbSBwYXJ0aWNpcGF0aW5nIGluIGFsbCBjb2xsaXNpb25zIGFuZCB0cmlnZ2Vycy4gSXQgY2FuIHN0aWxsIG1vdmUuICovXHJcbiAgICBkaXNhYmxlUGh5c2ljcygpOiB2b2lkIHtcclxuXHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0fVxyXG5cclxuICAgIC8qKiBFbmFibGVzIHRoaXMgb2JqZWN0IHRvIHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIGRpc2FibGVQaHlzaWNzIHdhcyBjYWxsZWQgKi9cclxuICAgIGVuYWJsZVBoeXNpY3MoKTogdm9pZCB7XHJcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBjb2xsaWRlciBmb3IgdGhpcyBHYW1lTm9kZVxyXG5cdCAqIEBwYXJhbSBjb2xsaWRlciBUaGUgbmV3IGNvbGxpZGVyIHRvIHVzZVxyXG5cdCAqL1xyXG5cdHNldENvbGxpc2lvblNoYXBlKGNvbGxpZGVyOiBTaGFwZSk6IHZvaWQge1xyXG5cdFx0dGhpcy5jb2xsaXNpb25TaGFwZSA9IGNvbGxpZGVyO1xyXG5cdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIuY29weSh0aGlzLnBvc2l0aW9uKTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdC8qKlxyXG4gICAgICogU2V0cyB0aGlzIG9iamVjdCB0byBiZSBhIHRyaWdnZXIgZm9yIGEgc3BlY2lmaWMgZ3JvdXBcclxuICAgICAqIEBwYXJhbSBncm91cCBUaGUgbmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCBhY3RpdmF0ZXMgdGhlIHRyaWdnZXJcclxuICAgICAqIEBwYXJhbSBvbkVudGVyIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIHdoZW4gdGhpcyB0cmlnZ2VyIGlzIGFjdGl2YXRlZFxyXG4gICAgICogQHBhcmFtIG9uRXhpdCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgdHJpZ2dlciBzdG9wcyBiZWluZyBhY3RpdmF0ZWRcclxuICAgICAqL1xyXG4gICAgc2V0VHJpZ2dlcihncm91cDogc3RyaW5nLCBvbkVudGVyOiBzdHJpbmcsIG9uRXhpdDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHQvLyBNYWtlIHRoaXMgb2JqZWN0IGEgdHJpZ2dlclxyXG5cdFx0dGhpcy5pc1RyaWdnZXIgPSB0cnVlO1xyXG5cclxuXHRcdC8vIEdldCB0aGUgbnVtYmVyIG9mIHRoZSBwaHlzaWNzIGxheWVyXHJcblx0XHRsZXQgbGF5ZXJOdW1iZXIgPSB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuZ2V0R3JvdXBOdW1iZXIoZ3JvdXApO1xyXG5cclxuXHRcdGlmKGxheWVyTnVtYmVyID09PSAwKXtcclxuXHRcdFx0Y29uc29sZS53YXJuKGBUcmlnZ2VyIGZvciBHYW1lTm9kZSAke3RoaXMuaWR9IG5vdCBzZXQgLSBncm91cCBcIiR7Z3JvdXB9XCIgd2FzIG5vdCByZWNvZ25pemVkIGJ5IHRoZSBwaHlzaWNzIG1hbmFnZXIuYCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBZGQgdGhpcyB0byB0aGUgdHJpZ2dlciBtYXNrXHJcblx0XHR0aGlzLnRyaWdnZXJNYXNrIHw9IGxheWVyTnVtYmVyO1xyXG5cclxuXHRcdC8vIExheWVyIG51bWJlcnMgYXJlIGJpdHMsIHNvIGdldCB3aGljaCBiaXQgaXQgaXNcclxuXHRcdGxldCBpbmRleCA9IE1hdGgubG9nMihsYXllck51bWJlcik7XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBldmVudCBuYW1lc1xyXG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzW2luZGV4XSA9IG9uRW50ZXI7XHJcblx0XHR0aGlzLnRyaWdnZXJFeGl0c1tpbmRleF0gPSBvbkV4aXQ7XHJcblx0fTtcclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0LyoqXHJcblx0ICogQHBhcmFtIGdyb3VwIFRoZSBwaHlzaWNzIGdyb3VwIHRoaXMgbm9kZSBzaG91bGQgYmVsb25nIHRvXHJcblx0ICovXHJcblx0c2V0R3JvdXAoZ3JvdXA6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLnNldEdyb3VwKHRoaXMsIGdyb3VwKTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbmVkXHJcblx0Z2V0TGFzdFZlbG9jaXR5KCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3ZlbG9jaXR5O1xyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tIEFDVE9SIC0tLS0tLS0tLS0qL1xyXG5cdGdldCBhaSgpOiBBSSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYWk7XHJcblx0fVxyXG5cclxuXHRzZXQgYWkoYWk6IEFJKSB7XHJcblx0XHRpZighdGhpcy5fYWkpe1xyXG5cdFx0XHQvLyBJZiB3ZSBoYXZlbid0IGJlZW4gcHJldmlvdXNseSBoYWQgYW4gYWksIHJlZ2lzdGVyIHVzIHdpdGggdGhlIGFpIG1hbmFnZXJcclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRBSU1hbmFnZXIoKS5yZWdpc3RlckFjdG9yKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FpID0gYWk7XHJcblx0XHR0aGlzLmFpQWN0aXZlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGFkZEFJPFQgZXh0ZW5kcyBBST4oYWk6IHN0cmluZyB8IChuZXcgKCkgPT4gVCksIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRpZighdGhpcy5fYWkpe1xyXG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlZ2lzdGVyQWN0b3IodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodHlwZW9mIGFpID09PSBcInN0cmluZ1wiKXtcclxuXHRcdFx0dGhpcy5fYWkgPSB0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLmdlbmVyYXRlQUkoYWkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fYWkgPSBuZXcgYWkoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9haS5pbml0aWFsaXplQUkodGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5haUFjdGl2ZSA9IHRydWU7XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRzZXRBSUFjdGl2ZShhY3RpdmU6IGJvb2xlYW4sIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuXHRcdHRoaXMuYWlBY3RpdmUgPSBhY3RpdmU7XHJcblx0XHRpZih0aGlzLmFpQWN0aXZlKXtcclxuXHRcdFx0dGhpcy5haS5hY3RpdmF0ZShvcHRpb25zKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBUV0VFTkFCTEUgUFJPUEVSVElFUyAtLS0tLS0tLS0tKi9cclxuXHRzZXQgcG9zaXRpb25YKHZhbHVlOiBudW1iZXIpIHtcclxuXHRcdHRoaXMucG9zaXRpb24ueCA9IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0c2V0IHBvc2l0aW9uWSh2YWx1ZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnBvc2l0aW9uLnkgPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdGFic3RyYWN0IHNldCBzY2FsZVgodmFsdWU6IG51bWJlcik7XHJcblxyXG5cdGFic3RyYWN0IHNldCBzY2FsZVkodmFsdWU6IG51bWJlcik7XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBHQU1FIE5PREUgLS0tLS0tLS0tLSovXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgc2NlbmUgZm9yIHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdGhpcyBvYmplY3QgYmVsb25ncyB0by5cclxuXHQgKi9cclxuXHRzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHNjZW5lIHRoaXMgb2JqZWN0IGlzIGluLiBcclxuXHQgKiBAcmV0dXJucyBUaGUgc2NlbmUgdGhpcyBvYmplY3QgYmVsb25ncyB0b1xyXG5cdCovXHJcblx0Z2V0U2NlbmUoKTogU2NlbmUge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2NlbmU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBsYXllciBvZiB0aGlzIG9iamVjdC5cclxuXHQgKiBAcGFyYW0gbGF5ZXIgVGhlIGxheWVyIHRoaXMgb2JqZWN0IHdpbGwgYmUgb24uXHJcblx0ICovXHJcblx0c2V0TGF5ZXIobGF5ZXI6IExheWVyKTogdm9pZCB7XHJcblx0XHR0aGlzLmxheWVyID0gbGF5ZXI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBsYXllciB0aGlzIG9iamVjdCBpcyBvbi5cclxuXHQgKiBAcmV0dXJucyBUaGlzIGxheWVyIHRoaXMgb2JqZWN0IGlzIG9uLlxyXG5cdCovXHJcblx0Z2V0TGF5ZXIoKTogTGF5ZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXI7XHJcblx0fVxyXG5cclxuXHQvKiogQ2FsbGVkIGlmIHRoZSBwb3NpdGlvbiB2ZWN0b3IgaXMgbW9kaWZpZWQgb3IgcmVwbGFjZWQgKi9cclxuXHRwcm90ZWN0ZWQgcG9zaXRpb25DaGFuZ2VkKCk6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5jb2xsaXNpb25TaGFwZSl7XHJcblx0XHRcdGlmKHRoaXMuY29sbGlkZXJPZmZzZXQpe1xyXG5cdFx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLmNvbGxpZGVyT2Zmc2V0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb24uY2xvbmUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoaXMgR2FtZU5vZGVcclxuXHQgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lc3RlcCBvZiB0aGUgdXBkYXRlLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Ly8gRGVmZXIgZXZlbnQgaGFuZGxpbmcgdG8gQUkuXHJcblx0XHR3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcclxuXHRcdFx0dGhpcy5fYWkuaGFuZGxlRXZlbnQodGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRkZWJ1Z1JlbmRlcigpOiB2b2lkIHtcclxuXHRcdC8vIERyYXcgdGhlIHBvc2l0aW9uIG9mIHRoaXMgR2FtZU5vZGVcclxuXHRcdERlYnVnLmRyYXdQb2ludCh0aGlzLnJlbGF0aXZlUG9zaXRpb24sIENvbG9yLkJMVUUpO1xyXG5cclxuXHRcdC8vIElmIHZlbG9jaXR5IGlzIG5vdCB6ZXJvLCBkcmF3IGEgdmVjdG9yIGZvciBpdFxyXG5cdFx0aWYodGhpcy5fdmVsb2NpdHkgJiYgIXRoaXMuX3ZlbG9jaXR5LmlzWmVybygpKXtcclxuXHRcdFx0RGVidWcuZHJhd1JheSh0aGlzLnJlbGF0aXZlUG9zaXRpb24sIHRoaXMuX3ZlbG9jaXR5LmNsb25lKCkuc2NhbGVUbygyMCkuYWRkKHRoaXMucmVsYXRpdmVQb3NpdGlvbiksIENvbG9yLkJMVUUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHRoaXMgaGFzIGEgY29sbGlkZXIsIGRyYXcgaXRcclxuXHRcdGlmKHRoaXMuY29sbGlzaW9uU2hhcGUpe1xyXG5cdFx0XHRsZXQgY29sb3IgPSB0aGlzLmlzQ29sbGlkaW5nID8gQ29sb3IuUkVEIDogQ29sb3IuR1JFRU47XHJcblxyXG5cdFx0XHRpZih0aGlzLmlzVHJpZ2dlcil7XHJcblx0XHRcdFx0Y29sb3IgPSBDb2xvci5NQUdFTlRBO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRjb2xvci5hID0gMC4yO1xyXG5cclxuXHRcdFx0aWYodGhpcy5jb2xsaXNpb25TaGFwZSBpbnN0YW5jZW9mIEFBQkIpe1xyXG5cdFx0XHRcdERlYnVnLmRyYXdCb3godGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIpLCB0aGlzLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplLnNjYWxlZCh0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpKSwgdHJ1ZSwgY29sb3IpO1xyXG5cdFx0XHR9IGVsc2UgaWYodGhpcy5jb2xsaXNpb25TaGFwZSBpbnN0YW5jZW9mIENpcmNsZSl7XHJcblx0XHRcdFx0RGVidWcuZHJhd0NpcmNsZSh0aGlzLmluUmVsYXRpdmVDb29yZGluYXRlcyh0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciksIHRoaXMuY29sbGlzaW9uU2hhcGUuaHcqdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKSwgdHJ1ZSwgY29sb3IpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBUd2VlbmFibGVQcm9wZXJ0aWVze1xyXG5cdHBvc1ggPSBcInBvc2l0aW9uWFwiLFxyXG5cdHBvc1kgPSBcInBvc2l0aW9uWVwiLFxyXG5cdHNjYWxlWCA9IFwic2NhbGVYXCIsXHJcblx0c2NhbGVZID0gXCJzY2FsZVlcIixcclxuXHRyb3RhdGlvbiA9IFwicm90YXRpb25cIixcclxuXHRhbHBoYSA9IFwiYWxwaGFcIlxyXG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4vQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgZ2FtZSBvYmplY3QgdGhhdCBkb2Vzbid0IHJlbHkgb24gYW55IHJlc291cmNlcyB0byByZW5kZXIgLSBpdCBpcyBkcmF3biB0byB0aGUgc2NyZWVuIGJ5IHRoZSBjYW52YXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEdyYXBoaWMgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIEdyYXBoaWMgKi9cclxuICAgIGNvbG9yOiBDb2xvcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbG9yLlJFRDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYWxwaGEoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbG9yLmE7XHJcblx0fVxyXG5cclxuXHRzZXQgYWxwaGEoYTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLmNvbG9yLmEgPSBhO1xyXG5cdH1cclxuXHJcbiAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgR3JhcGhpYy4gREVQUkVDQVRFRFxyXG4gICAgICogQHBhcmFtIGNvbG9yIFRoZSBuZXcgY29sb3Igb2YgdGhlIEdyYXBoaWMuXHJcbiAgICAgKi9cclxuICAgIHNldENvbG9yKGNvbG9yOiBDb2xvcil7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgfVxyXG59IiwiZXhwb3J0IGVudW0gR3JhcGhpY1R5cGUge1xyXG5cdFBPSU5UID0gXCJQT0lOVFwiLFxyXG5cdFJFQ1QgPSBcIlJFQ1RcIixcclxuXHRMSU5FID0gXCJMSU5FXCIsXHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmUgZXh0ZW5kcyBHcmFwaGljIHtcclxuICAgIHByb3RlY3RlZCBfZW5kOiBWZWMyO1xyXG4gICAgdGhpY2tuZXNzOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc3RhcnQ6IFZlYzIsIGVuZDogVmVjMil7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSAyO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHRoaXMgcmVhbGx5IGhhdmUgYSBtZWFuaW5nIGZvciBsaW5lcz9cclxuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzdGFydChwb3M6IFZlYzIpe1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3M7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHN0YXJ0KCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBlbmQocG9zOiBWZWMyKXtcclxuICAgICAgICB0aGlzLl9lbmQgPSBwb3M7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGVuZCgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG4vKiogQSBiYXNpYyBwb2ludCB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludCBleHRlbmRzIEdyYXBoaWMge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uOiBWZWMyKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKiBBIGJhc2ljIHJlY3RhbmdsZSB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0IGV4dGVuZHMgR3JhcGhpYyB7XHJcblxyXG4gICAgLyoqIFRoZSBib3JkZXIgY29sb3Igb2YgdGhlIFJlY3QgKi9cclxuICAgIGJvcmRlckNvbG9yOiBDb2xvcjtcclxuXHJcbiAgICAvKiogVGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgKi9cclxuICAgIGJvcmRlcldpZHRoOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHNpemU6IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIGNvbG9yIG9mIHRoaXMgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgVGhlIGJvcmRlciBjb2xvclxyXG4gICAgICovXHJcbiAgICBzZXRCb3JkZXJDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgIGdldEJvcmRlckNvbG9yKCk6IENvbG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJvcmRlciB3aWR0aCBvZiB0aGlzIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBzZXRCb3JkZXJXaWR0aCh3aWR0aDogbnVtYmVyKXtcclxuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gd2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Qm9yZGVyV2lkdGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJXaWR0aDtcclxuICAgIH1cclxufSIsImltcG9ydCBTcHJpdGUgZnJvbSBcIi4vU3ByaXRlXCI7XHJcbmltcG9ydCBBbmltYXRpb25NYW5hZ2VyIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyXCI7XHJcbmltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuLyoqIEFuIHNwcml0ZSB3aXRoIHNwZWNpZmllZCBhbmltYXRpb24gZnJhbWVzLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZSB7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoaXMgc3ByaXRlIHNoZWV0ICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xyXG5cclxuICAgIGdldCBjb2xzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQ29scztcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIG51bWJlciBvZiByb3dzIGluIHRoaXMgc3ByaXRlIHNoZWV0ICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xyXG5cclxuICAgIGdldCByb3dzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUm93cztcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGFuaW1hdGlvbk1hbmFnZXIgZm9yIHRoaXMgc3ByaXRlICovXHJcbiAgICBhbmltYXRpb246IEFuaW1hdGlvbk1hbmFnZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc3ByaXRlc2hlZXQ6IFNwcml0ZXNoZWV0KXtcclxuICAgICAgICBzdXBlcihzcHJpdGVzaGVldC5uYW1lKTtcclxuICAgICAgICB0aGlzLm51bUNvbHMgPSBzcHJpdGVzaGVldC5jb2x1bW5zO1xyXG4gICAgICAgIHRoaXMubnVtUm93cyA9IHNwcml0ZXNoZWV0LnJvd3M7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgc3ByaXRlIHRvIHRoZSBzcHJpdGUgc2l6ZSBzcGVjaWZpZWQgYnkgdGhlIHNwcml0ZXNoZWV0XHJcbiAgICAgICAgdGhpcy5zaXplLnNldChzcHJpdGVzaGVldC5zcHJpdGVXaWR0aCwgc3ByaXRlc2hlZXQuc3ByaXRlSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uTWFuYWdlcih0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBhbmltYXRpb25zIHRvIHRoZSBhbmltYXRlZCBzcHJpdGVcclxuICAgICAgICBmb3IobGV0IGFuaW1hdGlvbiBvZiBzcHJpdGVzaGVldC5hbmltYXRpb25zKXtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkKGFuaW1hdGlvbi5uYW1lLCBhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGltYWdlIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgaW5kZXggb2YgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IHdlJ3JlIGF0IGluIHRoZSBhbmltYXRpb25cclxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBpbWFnZSBvZmZzZXRcclxuICAgICAqL1xyXG4gICAgZ2V0QW5pbWF0aW9uT2Zmc2V0KGluZGV4OiBudW1iZXIpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoKGluZGV4ICUgdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS54LCBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS55KTtcclxuICAgIH1cclxufSIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgc3ByaXRlIC0gYW4gaW4tZ2FtZSBpbWFnZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcbiAgICAvKiogVGhlIGlkIG9mIHRoZSBpbWFnZSBmcm9tIHRoZSByZXNvdXJjZU1hbmFnZXIgKi9cclxuICAgIGltYWdlSWQ6IHN0cmluZztcclxuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgaW4gYW4gYXRsYXMgaW1hZ2UgKi9cclxuICAgIGltYWdlT2Zmc2V0OiBWZWMyO1xyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB4LWF4aXMgc2hvdWxkIGJlIGludmVydGVkIG9uIHJlbmRlciAqL1xyXG4gICAgaW52ZXJ0WDogYm9vbGVhbjtcclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgeS1heGlzIHNob3VsZCBiZSBpbnZlcnRlZCBvbiByZW5kZXIgKi9cclxuICAgIGludmVydFk6IGJvb2xlYW47XHJcblxyXG4gICAgY29uc3RydWN0b3IoaW1hZ2VJZDogc3RyaW5nKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VJZCA9IGltYWdlSWQ7XHJcbiAgICAgICAgbGV0IGltYWdlID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0SW1hZ2UodGhpcy5pbWFnZUlkKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBuZXcgVmVjMihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmltYWdlT2Zmc2V0ID0gVmVjMi5aRVJPO1xyXG4gICAgICAgIHRoaXMuaW52ZXJ0WCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW52ZXJ0WSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgZnJvbSAoMCwgMCkgaW4gdGhlIGltYWdlJ3MgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBvZiB0aGUgc3ByaXRlIGZyb20gKDAsIDApIGluIGltYWdlIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHNldEltYWdlT2Zmc2V0KG9mZnNldDogVmVjMik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEsIFRpbGVkTGF5ZXJEYXRhIH0gZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIlxyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9QaHlzaWNzTWFuYWdlclwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHRpbGVtYXAgLSB0aGlzIGNhbiBjb25zaXN0IG9mIGEgY29tYmluYXRpb24gb2YgdGlsZXNldHMgaW4gb25lIGxheWVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBUaWxlbWFwIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcbiAgICAvKiogQW4gYXJyYXkgb2YgdGhlIHRpbGVzZXRzIHRoYXQgdGhpcyB0aWxlbWFwIHVzZXMgKi9cclxuICAgIHByb3RlY3RlZCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD47XHJcblxyXG4gICAgLyoqIFRoZSBzaXplIG9mIGEgdGlsZSBpbiB0aGlzIHRpbGVtYXAgKi9cclxuICAgIHByb3RlY3RlZCB0aWxlU2l6ZTogVmVjMjtcclxuXHJcbiAgICAvKiogQW4gYXJyYXkgb2YgdGlsZSBkYXRhICovXHJcbiAgICBwcm90ZWN0ZWQgZGF0YTogQXJyYXk8bnVtYmVyPjtcclxuXHJcbiAgICAvKiogQW4gYXJyYXkgb2YgdGlsZSBjb2xsaXNpb24gZGF0YSAqL1xyXG4gICAgcHJvdGVjdGVkIGNvbGxpc2lvbk1hcDogQXJyYXk8Ym9vbGVhbj47XHJcblxyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSB0aWxlbWFwICovXHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIG5vIGxvbmdlciBiZSBzcGVjaWZpYyB0byBUaWxlZFxyXG4gICAgY29uc3RydWN0b3IodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSwgdGlsZXNldHM6IEFycmF5PFRpbGVzZXQ+LCBzY2FsZTogVmVjMikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50aWxlc2V0cyA9IHRpbGVzZXRzO1xyXG4gICAgICAgIHRoaXMudGlsZVNpemUgPSBuZXcgVmVjMigwLCAwKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBsYXllci5uYW1lO1xyXG5cclxuICAgICAgICBsZXQgdGlsZWNvdW50ID0gMDtcclxuICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZXNldHMpe1xyXG4gICAgICAgICAgICB0aWxlY291bnQgKz0gdGlsZXNldC5nZXRUaWxlQ291bnQoKSArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcCA9IG5ldyBBcnJheSh0aWxlY291bnQpO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbGxpc2lvbk1hcC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWFwW2ldID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWZlciBwYXJzaW5nIG9mIHRoZSBkYXRhIHRvIGNoaWxkIGNsYXNzZXMgLSB0aGlzIGFsbG93cyBmb3IgaXNvbWV0cmljIHZzLiBvcnRob2dyYXBoaWMgdGlsZW1hcHMgYW5kIGhhbmRsaW5nIG9mIFRpbGVkIGRhdGEgb3Igb3RoZXIgZGF0YVxyXG4gICAgICAgIHRoaXMucGFyc2VUaWxlbWFwRGF0YSh0aWxlbWFwRGF0YSwgbGF5ZXIpO1xyXG4gICAgICAgIHRoaXMuc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGlsZW1hcFxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG9mIHRoZSB0aWxlc2V0cyBhc3NvY2FpdGVkIHdpdGggdGhpcyB0aWxlbWFwLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlc2V0cygpOiBUaWxlc2V0W10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVzZXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aWxlcyBpbiB0aGlzIHRpbGVtYXAgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGdhbWUgd29ybGQgYWZ0ZXIgc2NhbGluZ1xyXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgY29udGFpbmluZyB0aGUgc2l6ZSBvZiB0aWxlcyBpbiB0aGlzIHRpbGVtYXAgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGdhbWUgd29ybGQgYWZ0ZXIgc2NhbGluZy5cclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZVNpemUoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUuc2NhbGVkKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHRpbGUgc2l6ZSB0YWtpbmcgem9vbSBpbnRvIGFjY291bnRcclxuICAgICAqIEByZXR1cm5zIFRoZSB0aWxlIHNpemUgd2l0aCB6b29tXHJcbiAgICAqL1xyXG4gICAgZ2V0VGlsZVNpemVXaXRoWm9vbSgpOiBWZWMyIHtcclxuICAgICAgICBsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGUoem9vbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoaXMgdGlsZW1hcCB0byB0aGUgcGh5c2ljcyBzeXN0ZW1cclxuICAgICovXHJcbiAgICBhZGRQaHlzaWNzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaGFzUGh5c2ljcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSAtMTtcclxuICAgICAgICB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkucmVnaXN0ZXJUaWxlbWFwKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHdvcmxkQ29vcmRzIFRoZSBwb3NpdGlvbiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICogQHJldHVybnMgQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgd29ybGQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFRpbGVBdFdvcmxkUG9zaXRpb24od29ybGRDb29yZHM6IFZlYzIpOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXRUaWxlV29ybGRQb3NpdGlvbihpbmRleDogbnVtYmVyKTogVmVjMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFRpbGUoaW5kZXg6IG51bWJlcik6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIG5ldyBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldFRpbGUoaW5kZXg6IG51bWJlciwgdHlwZTogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCB1c2UgdGlsZWQgZGF0YSBzcGVjaWZpY2FsbHkgLSBpdCBzaG91bGQgYmUgbW9yZSBnZW5lcmFsXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIHRpbGVzZXQgdXNpbmcgdGhlIGRhdGEgbG9hZGVkIGZyb20gZmlsZVxyXG4gICAgICogQHBhcmFtIHRpbGVtYXBEYXRhIFRoZSB0aWxlbWFwIGRhdGEgZnJvbSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgVGhlIGxheWVyIGRhdGEgZnJvbSBmaWxlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBwYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhOiBUaWxlZFRpbGVtYXBEYXRhLCBsYXllcjogVGlsZWRMYXllckRhdGEpOiB2b2lkO1xyXG59IiwiaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL1RpbGVtYXBcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEsIFRpbGVkTGF5ZXJEYXRhIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9ydGhvZ29uYWwgdGlsZW1hcCAtIGkuZS4gYSB0b3AgZG93biBvciBwbGF0Zm9ybWVyIHRpbGVtYXBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ydGhvZ29uYWxUaWxlbWFwIGV4dGVuZHMgVGlsZW1hcCB7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0aWxlbWFwICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZW1hcCAqL1xyXG4gICAgcHJvdGVjdGVkIG51bVJvd3M6IG51bWJlcjtcclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCBwYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhOiBUaWxlZFRpbGVtYXBEYXRhLCBsYXllcjogVGlsZWRMYXllckRhdGEpOiB2b2lkIHtcclxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBpbiBsb2NhbCBzcGFjZVxyXG4gICAgICAgIHRoaXMubnVtQ29scyA9IHRpbGVtYXBEYXRhLndpZHRoO1xyXG4gICAgICAgIHRoaXMubnVtUm93cyA9IHRpbGVtYXBEYXRhLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGlsZXNcclxuICAgICAgICB0aGlzLnRpbGVTaXplLnNldCh0aWxlbWFwRGF0YS50aWxld2lkdGgsIHRpbGVtYXBEYXRhLnRpbGVoZWlnaHQpO1xyXG5cclxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBvbiB0aGUgY2FudmFzXHJcbiAgICAgICAgdGhpcy5zaXplLnNldCh0aGlzLm51bUNvbHMgKiB0aGlzLnRpbGVTaXplLngsIHRoaXMubnVtUm93cyAqIHRoaXMudGlsZVNpemUueSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbGF5ZXIuZGF0YTtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSBsYXllci52aXNpYmxlO1xyXG5cclxuICAgICAgICAvLyBXaGV0aGVyIHRoZSB0aWxlbWFwIGlzIGNvbGxpZGFibGUgb3Igbm90XHJcbiAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBmYWxzZTtcclxuICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgaWYoaXRlbS5uYW1lID09PSBcIkNvbGxpZGFibGVcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBpdGVtLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYWxsIHRpbGVzIGJlc2lkZXMgXCJlbXB0eTogMFwiIHRvIGJlIGNvbGxpZGFibGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGlsZW1hcFxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIG51bWJlciBvZiBjb2x1bW5zIGFuZCB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVtYXAuXHJcbiAgICAgKi9cclxuICAgIGdldERpbWVuc2lvbnMoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubnVtQ29scywgdGhpcy5udW1Sb3dzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCB3b3JsZCBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHdvcmxkQ29vcmRzIFRoZSBjb29yZGluYXRlcyBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZUF0V29ybGRQb3NpdGlvbih3b3JsZENvb3JkczogVmVjMik6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IGxvY2FsQ29vcmRzID0gdGhpcy5nZXRDb2xSb3dBdCh3b3JsZENvb3Jkcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUF0Um93Q29sKGxvY2FsQ29vcmRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uXHJcbiAgICAgKiBAcGFyYW0gcm93Q29sIFRoZSBjb29yZGluYXRlcyBpbiB0aWxlbWFwIHNwYWNlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlQXRSb3dDb2wocm93Q29sOiBWZWMyKTogbnVtYmVyIHtcclxuICAgICAgICBpZihyb3dDb2wueCA8IDAgfHwgcm93Q29sLnggPj0gdGhpcy5udW1Db2xzIHx8IHJvd0NvbC55IDwgMCB8fCByb3dDb2wueSA+PSB0aGlzLm51bVJvd3Mpe1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd0NvbC55ICogdGhpcy5udW1Db2xzICsgcm93Q29sLnhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0aWxlXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVXb3JsZFBvc2l0aW9uKGluZGV4OiBudW1iZXIpOiBWZWMyIHtcclxuICAgICAgICAvLyBHZXQgdGhlIGxvY2FsIHBvc2l0aW9uXHJcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xyXG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBwb3NpdGlvblxyXG4gICAgICAgIGxldCB4ID0gY29sICogdGhpcy50aWxlU2l6ZS54O1xyXG4gICAgICAgIGxldCB5ID0gcm93ICogdGhpcy50aWxlU2l6ZS55O1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcclxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGUoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBzZXRUaWxlKGluZGV4OiBudW1iZXIsIHR5cGU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGF0YVtpbmRleF0gPSB0eXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uXHJcbiAgICAgKiBAcGFyYW0gcm93Q29sIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aWxlbWFwIHNwYWNlXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgbmV3IGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgc2V0VGlsZUF0Um93Q29sKHJvd0NvbDogVmVjMiwgdHlwZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gcm93Q29sLnkgKiB0aGlzLm51bUNvbHMgKyByb3dDb2wueDtcclxuICAgICAgICB0aGlzLnNldFRpbGUoaW5kZXgsIHR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW4gb2YgdGhlIHRpbGVtYXAgaXMgY29sbGlkYWJsZVxyXG4gICAgICogQHBhcmFtIGluZGV4T3JDb2wgVGhlIGluZGV4IG9mIHRoZSB0aWxlIG9yIHRoZSBjb2x1bW4gaXQgaXMgaW5cclxuICAgICAqIEBwYXJhbSByb3cgVGhlIHJvdyB0aGUgdGlsZSBpcyBpblxyXG4gICAgICogQHJldHVybnMgQSBmbGFnIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdGlsZSBpcyBjb2xsaWRhYmxlLlxyXG4gICAgICovXHJcbiAgICBpc1RpbGVDb2xsaWRhYmxlKGluZGV4T3JDb2w6IG51bWJlciwgcm93PzogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gVGhlIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICAgICAgbGV0IHRpbGUgPSAwO1xyXG5cclxuICAgICAgICBpZihyb3cpe1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgY29sdW1uIGFuZCBhIHJvd1xyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy5nZXRUaWxlQXRSb3dDb2wobmV3IFZlYzIoaW5kZXhPckNvbCwgcm93KSk7XHJcblxyXG4gICAgICAgICAgICBpZih0aWxlIDwgMCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZihpbmRleE9yQ29sIDwgMCB8fCBpbmRleE9yQ29sID49IHRoaXMuZGF0YS5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgLy8gVGlsZXMgdGhhdCBkb24ndCBleGlzdCBhcmVuJ3QgY29sbGlkYWJsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gaW5kZXhcclxuICAgICAgICAgICAgdGlsZSA9IHRoaXMuZ2V0VGlsZShpbmRleE9yQ29sKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpc2lvbk1hcFt0aWxlXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGluIHdvcmxkIGNvb3JkaW5hdGVzIGFuZCByZXR1cm5zIHRoZSByb3cgYW5kIGNvbHVtbiBvZiB0aGUgdGlsZSBhdCB0aGF0IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3RlbnRpYWwgdGlsZSBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3RlbnRpYWwgdGlsZSBpbiB0aWxlbWFwIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldENvbFJvd0F0KHdvcmxkQ29vcmRzOiBWZWMyKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IGNvbCA9IE1hdGguZmxvb3Iod29ybGRDb29yZHMueCAvIHRoaXMudGlsZVNpemUueCAvIHRoaXMuc2NhbGUueCk7XHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3Iod29ybGRDb29yZHMueSAvIHRoaXMudGlsZVNpemUueSAvIHRoaXMuc2NhbGUueSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMihjb2wsIHJvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHt9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBkZWJ1Z1JlbmRlcigpe1xyXG4gICAgICAgIC8vIEhhbGYgb2YgdGhlIHRpbGUgc2l6ZVxyXG4gICAgICAgIGxldCB6b29tZWRIYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplV2l0aFpvb20oKS5zY2FsZWQoMC41KTtcclxuICAgICAgICBsZXQgaGFsZlRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLnNjYWxlZCgwLjUpO1xyXG5cclxuICAgICAgICAvLyBUaGUgY2VudGVyIG9mIHRoZSB0b3AgbGVmdCB0aWxlXHJcbiAgICAgICAgbGV0IHRvcExlZnQgPSB0aGlzLnBvc2l0aW9uLmNsb25lKCkuc3ViKHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQSB2ZWMgdG8gc3RvcmUgdGhlIGNlbnRlclxyXG4gICAgICAgIGxldCBjZW50ZXIgPSBWZWMyLlpFUk87XHJcblxyXG4gICAgICAgIGZvcihsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udW1Db2xzOyBjb2wrKyl7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgeC1wb3NpdGlvblxyXG4gICAgICAgICAgICBjZW50ZXIueCA9IHRvcExlZnQueCArIGNvbCoyKmhhbGZUaWxlU2l6ZS54ICsgaGFsZlRpbGVTaXplLng7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMubnVtUm93czsgcm93Kyspe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0NvbGxpZGFibGUgJiYgdGhpcy5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB5LXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyLnkgPSB0b3BMZWZ0LnkgKyByb3cqMipoYWxmVGlsZVNpemUueSArIGhhbGZUaWxlU2l6ZS55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IGEgYm94IGZvciB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5kcmF3Qm94KHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKGNlbnRlciksIHpvb21lZEhhbGZUaWxlU2l6ZSwgZmFsc2UsIENvbG9yLkJMVUUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4vQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgVUlFbGVtZW50IC0gdGhlIHBhcmVudCBjbGFzcyBvZiB0aGluZ3MgbGlrZSBidXR0b25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBVSUVsZW1lbnQgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuXHQvLyBTdHlsZSBhdHRyaWJ1dGVzIC0gVE9ETyAtIGFic3RyYWN0IHRoaXMgaW50byBhIHN0eWxlIG9iamVjdC9pbnRlcmZhY2VcclxuXHQvKiogVGhlIGJhY2tnb3VuZCBjb2xvciAqL1xyXG5cdGJhY2tncm91bmRDb2xvcjogQ29sb3I7XHJcblx0LyoqIFRoZSBib3JkZXIgY29sb3IgKi9cclxuXHRib3JkZXJDb2xvcjogQ29sb3I7XHJcblx0LyoqIFRoZSBib3JkZXIgcmFkaXVzICovXHJcblx0Ym9yZGVyUmFkaXVzOiBudW1iZXI7XHJcblx0LyoqIFRoZSBib3JkZXIgd2lkdGggKi9cclxuXHRib3JkZXJXaWR0aDogbnVtYmVyO1xyXG5cdC8qKiBUaGUgcGFkZGluZyAqL1xyXG5cdHBhZGRpbmc6IFZlYzI7XHJcblxyXG5cdC8vIEV2ZW50QXR0cmlidXRlc1xyXG5cdC8qKiBUaGUgcmVhY3Rpb24gb2YgdGhpcyBVSUVsZW1lbnQgb24gYSBjbGljayAqL1xyXG5cdG9uQ2xpY2s6IEZ1bmN0aW9uO1xyXG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiBjbGljayAqL1xyXG5cdG9uQ2xpY2tFdmVudElkOiBzdHJpbmc7XHJcblx0LyoqIFRoZSByZWFjdGlvbiB0byB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXHJcblx0b25SZWxlYXNlOiBGdW5jdGlvbjtcclxuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgb24gdGhlIHJlbGVhc2Ugb2YgYSBjbGljayAqL1xyXG5cdG9uUmVsZWFzZUV2ZW50SWQ6IHN0cmluZztcclxuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBlbnRlcnMgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHRvbkVudGVyOiBGdW5jdGlvbjtcclxuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdG9uRW50ZXJFdmVudElkOiBzdHJpbmc7XHJcblx0LyoqIFRoZSByZWFjdGlvbiB3aGVuIGEgbW91c2UgbGVhdmVzIHRoaXMgVUlFbGVtZW50ICovXHJcblx0b25MZWF2ZTogRnVuY3Rpb247XHJcblx0LyoqIFRoZSBldmVudCBwcm9wb2dhdGVkIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHRvbkxlYXZlRXZlbnRJZDogc3RyaW5nO1xyXG5cclxuXHQvKiogV2hldGhlciBvciBub3QgdGhpcyBVSUVsZW1lbnQgaXMgY3VycmVudGx5IGNsaWNrZWQgb24gKi9cclxuXHRwcm90ZWN0ZWQgaXNDbGlja2VkOiBib29sZWFuO1xyXG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFVJRWxlbWVudCBpcyBjdXJyZW50bHkgaG92ZXJlZCBvdmVyICovXHJcblx0cHJvdGVjdGVkIGlzRW50ZXJlZDogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHRcdFxyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XHJcblx0XHR0aGlzLmJvcmRlckNvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xyXG5cdFx0dGhpcy5ib3JkZXJSYWRpdXMgPSA1O1xyXG5cdFx0dGhpcy5ib3JkZXJXaWR0aCA9IDE7XHJcblx0XHR0aGlzLnBhZGRpbmcgPSBWZWMyLlpFUk87XHJcblxyXG5cdFx0dGhpcy5vbkNsaWNrID0gbnVsbDtcclxuXHRcdHRoaXMub25DbGlja0V2ZW50SWQgPSBudWxsO1xyXG5cdFx0dGhpcy5vblJlbGVhc2UgPSBudWxsO1xyXG5cdFx0dGhpcy5vblJlbGVhc2VFdmVudElkID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLm9uRW50ZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5vbkVudGVyRXZlbnRJZCA9IG51bGw7XHJcblx0XHR0aGlzLm9uTGVhdmUgPSBudWxsO1xyXG5cdFx0dGhpcy5vbkxlYXZlRXZlbnRJZCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBAZGVwcmVjYXRlZFxyXG5cdHNldEJhY2tncm91bmRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XHJcblx0fVxyXG5cclxuXHQvLyBAZGVwcmVjYXRlZFxyXG5cdHNldFBhZGRpbmcocGFkZGluZzogVmVjMik6IHZvaWQge1xyXG5cdFx0dGhpcy5wYWRkaW5nLmNvcHkocGFkZGluZyk7XHJcblx0fVxyXG5cclxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuXHRcdC8vIFNlZSBvZiB0aGlzIG9iamVjdCB3YXMganVzdCBjbGlja2VkXHJcblx0XHRpZihJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoKSl7XHJcblx0XHRcdGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpO1xyXG5cdFx0XHRpZih0aGlzLmNvbnRhaW5zKGNsaWNrUG9zLngsIGNsaWNrUG9zLnkpICYmIHRoaXMudmlzaWJsZSAmJiAhdGhpcy5sYXllci5pc0hpZGRlbigpKXtcclxuXHRcdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdGlmKHRoaXMub25DbGljayAhPT0gbnVsbCl7XHJcblx0XHRcdFx0XHR0aGlzLm9uQ2xpY2soKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodGhpcy5vbkNsaWNrRXZlbnRJZCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0XHRsZXQgZGF0YSA9IHt9O1xyXG5cdFx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uQ2xpY2tFdmVudElkLCBkYXRhKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB0aGUgbW91c2Ugd2Fzbid0IGp1c3QgcHJlc3NlZCwgdGhlbiB3ZSBkZWZpbml0ZWx5IHdlcmVuJ3QgY2xpY2tlZFxyXG5cdFx0aWYoIUlucHV0LmlzTW91c2VQcmVzc2VkKCkpe1xyXG5cdFx0XHRpZih0aGlzLmlzQ2xpY2tlZCl7XHJcblx0XHRcdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIGlmIHRoZSBtb3VzZSBpcyBob3ZlcmluZyBvdmVyIHRoaXMgZWxlbWVudFxyXG5cdFx0bGV0IG1vdXNlUG9zID0gSW5wdXQuZ2V0TW91c2VQb3NpdGlvbigpO1xyXG5cdFx0aWYobW91c2VQb3MgJiYgdGhpcy5jb250YWlucyhtb3VzZVBvcy54LCBtb3VzZVBvcy55KSl7XHJcblx0XHRcdHRoaXMuaXNFbnRlcmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmKHRoaXMub25FbnRlciAhPT0gbnVsbCl7XHJcblx0XHRcdFx0dGhpcy5vbkVudGVyKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5vbkVudGVyRXZlbnRJZCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcclxuXHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25FbnRlckV2ZW50SWQsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmKHRoaXMuaXNFbnRlcmVkKSB7XHJcblx0XHRcdHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZih0aGlzLm9uTGVhdmUgIT09IG51bGwpe1xyXG5cdFx0XHRcdHRoaXMub25MZWF2ZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMub25MZWF2ZUV2ZW50SWQgIT09IG51bGwpe1xyXG5cdFx0XHRcdGxldCBkYXRhID0ge307XHJcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uTGVhdmVFdmVudElkLCBkYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmKHRoaXMuaXNDbGlja2VkKSB7XHJcblx0XHRcdC8vIElmIG1vdXNlIGlzIGRyYWdnZWQgb2ZmIG9mIGVsZW1lbnQgd2hpbGUgZG93biwgaXQgaXMgbm90IGNsaWNrZWQgYW55bW9yZVxyXG5cdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBiYWNrZ3JvdW5kIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcclxuXHQgKiBAcmV0dXJucyBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgVUlFbGVtZW50XHJcblx0ICovXHJcblx0Y2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgYm9yZGVyIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcclxuXHQgKiBAcmV0dXJucyBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVCb3JkZXJDb2xvcigpOiBDb2xvciB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTGFiZWwgZnJvbSBcIi4vTGFiZWxcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKiBBIGNsaWNrYWJsZSBidXR0b24gVUlFbGVtZW50ICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvbiBleHRlbmRzIExhYmVsIHtcclxuXHJcblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwb3NpdGlvbiwgdGV4dCk7XHJcblx0XHRcclxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDE1MCwgNzUsIDIwMyk7XHJcblx0XHR0aGlzLmJvcmRlckNvbG9yID0gbmV3IENvbG9yKDQxLCA0NiwgMzApO1xyXG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRjYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKTogQ29sb3Ige1xyXG5cdFx0Ly8gQ2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlmIGNsaWNrZWQgb3IgaG92ZXJlZFxyXG5cdFx0aWYodGhpcy5pc0VudGVyZWQgJiYgIXRoaXMuaXNDbGlja2VkKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmxpZ2h0ZW4oKTtcclxuXHRcdH0gZWxzZSBpZih0aGlzLmlzQ2xpY2tlZCl7XHJcblx0XHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvci5kYXJrZW4oKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcclxuXHJcbi8qKiBBIGJhc2ljIHRleHQtY29udGFpbmluZyBsYWJlbCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbCBleHRlbmRzIFVJRWxlbWVudHtcclxuXHQvKiogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXHJcblx0dGV4dENvbG9yOiBDb2xvcjtcclxuXHQvKiogVGhlIHZhbHVlIG9mIHRoZSB0ZXh0IG9mIHRoaXMgVUlFbGVtZW50ICovXHJcblx0dGV4dDogc3RyaW5nO1xyXG5cdC8qKiBUaGUgbmFtZSBvZiB0aGUgZm9udCAqL1xyXG5cdGZvbnQ6IHN0cmluZztcclxuXHQvKiogVGhlIHNpemUgb2YgdGhlIGZvbnQgKi9cclxuXHRmb250U2l6ZTogbnVtYmVyO1xyXG5cdC8qKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlIHRleHQgd2l0aGluIHRoZSBsYWJlbCAqL1xyXG5cdHByb3RlY3RlZCBoQWxpZ246IHN0cmluZztcclxuXHQvKiogVGhlIHZlcnRpY2FsIGFsaWdubWVudCBvZiB0ZXh0IHdpdGhpbiB0aGUgbGFiZWwgKi9cclxuXHRwcm90ZWN0ZWQgdkFsaWduOiBzdHJpbmc7XHJcblxyXG5cdC8qKiBBIGZsYWcgZm9yIGlmIHRoZSB3aWR0aCBvZiB0aGUgdGV4dCBoYXMgYmVlbiBtZWFzdXJlZCBvbiB0aGUgY2FudmFzIGZvciBhdXRvIHdpZHRoIGFzc2lnbm1lbnQgKi9cclxuXHRwcm90ZWN0ZWQgc2l6ZUFzc2lnbmVkOiBib29sZWFuO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgdGV4dDogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHBvc2l0aW9uKTtcclxuXHRcdHRoaXMudGV4dCA9IHRleHQ7XHJcblx0XHR0aGlzLnRleHRDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcclxuXHRcdHRoaXMuZm9udCA9IFwiQXJpYWxcIjtcclxuXHRcdHRoaXMuZm9udFNpemUgPSAzMDtcclxuXHRcdHRoaXMuaEFsaWduID0gXCJjZW50ZXJcIjtcclxuXHRcdHRoaXMudkFsaWduID0gXCJjZW50ZXJcIjtcclxuXHJcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gQGRlcHJlY2F0ZWRcclxuXHRzZXRUZXh0KHRleHQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcclxuXHR9XHJcblxyXG5cdC8vIEBkZXByZWNhdGVkXHJcblx0c2V0VGV4dENvbG9yKGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBjb2xvcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgYSBzdHJpbmcgY29udGFpbmcgdGhlIGZvbnQgZGV0YWlscyBmb3IgcmVuZGVyaW5nXHJcblx0ICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgZm9udCBkZXRhaWxzXHJcblx0ICovXHJcblx0Z2V0Rm9udFN0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZm9udFNpemUgKyBcInB4IFwiICsgdGhpcy5mb250O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyB0ZXh0IGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcclxuXHQgKiBAcmV0dXJucyBhIHN0cmluZyBjb250YWluZyB0aGUgdGV4dCBjb2xvclxyXG5cdCAqL1xyXG5cdGNhbGN1bGF0ZVRleHRDb2xvcigpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMudGV4dENvbG9yLnRvU3RyaW5nUkdCQSgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXNlcyB0aGUgY2FudmFzIHRvIGNhbGN1bGF0ZSB0aGUgd2lkdGggb2YgdGhlIHRleHRcclxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqIEByZXR1cm5zIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgcmVuZGVyZWQgdGV4dCB3aWR0aFxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBjYWxjdWxhdGVUZXh0V2lkdGgoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBudW1iZXIge1xyXG5cdFx0Y3R4LmZvbnQgPSB0aGlzLmZvbnRTaXplICsgXCJweCBcIiArIHRoaXMuZm9udDtcclxuXHRcdHJldHVybiBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcclxuXHR9XHJcblxyXG5cdHNldEhBbGlnbihhbGlnbjogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLmhBbGlnbiA9IGFsaWduO1xyXG5cdH1cclxuXHJcblx0c2V0VkFsaWduKGFsaWduOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdHRoaXMudkFsaWduID0gYWxpZ247XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxjdWxhdGUgdGhlIG9mZnNldCBvZiB0aGUgdGV4dCAtIHRoaXMgaXMgdXNlZCBmb3IgcmVuZGVyaW5nIHRleHQgd2l0aCBkaWZmZXJlbnQgYWxpZ25tZW50c1xyXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICogQHJldHVybnMgVGhlIG9mZnNldCBvZiB0aGUgdGV4dCBpbiBhIFZlYzJcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVUZXh0T2Zmc2V0KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogVmVjMiB7XHJcblx0XHRsZXQgdGV4dFdpZHRoID0gdGhpcy5jYWxjdWxhdGVUZXh0V2lkdGgoY3R4KTtcclxuXHJcblx0XHRsZXQgb2Zmc2V0ID0gbmV3IFZlYzIoMCwgMCk7XHJcblxyXG5cdFx0bGV0IGhEaWZmID0gdGhpcy5zaXplLnggLSB0ZXh0V2lkdGg7XHJcblx0XHRpZih0aGlzLmhBbGlnbiA9PT0gSEFsaWduLkNFTlRFUil7XHJcblx0XHRcdG9mZnNldC54ID0gaERpZmYvMjtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5oQWxpZ24gPT09IEhBbGlnbi5SSUdIVCl7XHJcblx0XHRcdG9mZnNldC54ID0gaERpZmY7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy52QWxpZ24gPT09IFZBbGlnbi5UT1Ape1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcclxuXHRcdFx0b2Zmc2V0LnkgPSAwO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLnZBbGlnbiA9PT0gVkFsaWduLkJPVFRPTSl7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xyXG5cdFx0XHRvZmZzZXQueSA9IHRoaXMuc2l6ZS55O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XHJcblx0XHRcdG9mZnNldC55ID0gdGhpcy5zaXplLnkvMjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHNpemVDaGFuZ2VkKCk6IHZvaWQge1xyXG5cdFx0c3VwZXIuc2l6ZUNoYW5nZWQoKTtcclxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEF1dG9tYXRpY2FsbHkgc2l6ZXMgdGhlIGVsZW1lbnQgdG8gdGhlIHRleHQgd2l0aGluIGl0XHJcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYXV0b1NpemUoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkIHtcclxuXHRcdGxldCB3aWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XHJcblx0XHRsZXQgaGVpZ2h0ID0gdGhpcy5mb250U2l6ZTtcclxuXHRcdHRoaXMuc2l6ZS5zZXQod2lkdGggKyB0aGlzLnBhZGRpbmcueCoyLCBoZWlnaHQgKyB0aGlzLnBhZGRpbmcueSoyKTtcclxuXHRcdHRoaXMuc2l6ZUFzc2lnbmVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxseSBhc3NpZ25zIGEgc2l6ZSB0byB0aGUgVUlFbGVtZW50IGlmIG5vbmUgaXMgcHJvdmlkZWRcclxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqL1xyXG5cdGhhbmRsZUluaXRpYWxTaXppbmcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkIHtcclxuXHRcdGlmKCF0aGlzLnNpemVBc3NpZ25lZCl7XHJcblx0XHRcdHRoaXMuYXV0b1NpemUoY3R4KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKiBPbiB0aGUgbmV4dCByZW5kZXIsIHNpemUgdGhpcyBlbGVtZW50IHRvIGl0J3MgY3VycmVudCB0ZXh0IHVzaW5nIGl0cyBjdXJyZW50IGZvbnQgc2l6ZSAqL1xyXG5cdHNpemVUb1RleHQoKTogdm9pZCB7XHJcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IGZhbHNlO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gVkFsaWduIHtcclxuXHRUT1AgPSBcInRvcFwiLFxyXG5cdENFTlRFUiA9IFwiY2VudGVyXCIsXHJcblx0Qk9UVE9NID0gXCJib3R0b21cIlxyXG59XHJcblxyXG5leHBvcnQgZW51bSBIQWxpZ24ge1xyXG5cdExFRlQgPSBcImxlZnRcIixcclxuXHRDRU5URVIgPSBcImNlbnRlclwiLFxyXG5cdFJJR0hUID0gXCJyaWdodFwiXHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9VSUVsZW1lbnRcIjtcclxuXHJcbi8qKiBBIHNsaWRlciBVSUVsZW1lbnQgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2xpZGVyIGV4dGVuZHMgVUlFbGVtZW50IHtcclxuICAgIC8qKiBUaGUgdmFsdWUgb2YgdGhlIHNsaWRlciBmcm9tIFswLCAxXSAqL1xyXG4gICAgcHJvdGVjdGVkIHZhbHVlOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgbmliICovXHJcbiAgICBwdWJsaWMgbmliQ29sb3I6IENvbG9yO1xyXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBuaWIgKi9cclxuICAgIHB1YmxpYyBuaWJTaXplOiBWZWMyO1xyXG4gICAgLyoqIFRoZSBjb2xvciBvZiB0aGUgc2xpZGVyIHRyYWNrICovXHJcbiAgICBwdWJsaWMgc2xpZGVyQ29sb3I6IENvbG9yO1xyXG4gICAgLyoqIFRoZSByZWFjdGlvbiBvZiB0aGlzIFVJRWxlbWVudCB0byBhIHZhbHVlIGNoYW5nZSAqL1xyXG4gICAgcHVibGljIG9uVmFsdWVDaGFuZ2U6IEZ1bmN0aW9uO1xyXG4gICAgLyoqIFRoZSBldmVudCBwcm9wYWdhdGVkIGJ5IHRoaXMgVUlFbGVtZW50IHdoZW4gdmFsdWUgY2hhbmdlcyAqL1xyXG4gICAgcHVibGljIG9uVmFsdWVDaGFuZ2VFdmVudElkOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIGluaXRWYWx1ZTogbnVtYmVyKXtcclxuICAgICAgICBzdXBlcihwb3NpdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMudmFsdWUgPSBpbml0VmFsdWU7XHJcbiAgICAgICAgdGhpcy5uaWJDb2xvciA9IENvbG9yLlJFRDtcclxuICAgICAgICB0aGlzLnNsaWRlckNvbG9yID0gQ29sb3IuQkxBQ0s7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gQ29sb3IuVFJBTlNQQVJFTlQ7XHJcbiAgICAgICAgdGhpcy5uaWJTaXplID0gbmV3IFZlYzIoMTAsIDIwKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IGEgZGVmYXVsdCBzaXplXHJcbiAgICAgICAgdGhpcy5zaXplLnNldCgyMDAsIDIwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgdGhlIHNsaWRlclxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcclxuICAgICAqL1xyXG4gICAgZ2V0VmFsdWUoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQSBtZXRob2QgY2FsbGVkIGluIHJlc3BvbnNlIHRvIHRoZSB2YWx1ZSBjaGFuZ2luZyAqL1xyXG4gICAgcHJvdGVjdGVkIHZhbHVlQ2hhbmdlZCgpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLm9uVmFsdWVDaGFuZ2Upe1xyXG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLm9uVmFsdWVDaGFuZ2VFdmVudElkKXtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uVmFsdWVDaGFuZ2VFdmVudElkLCB7dGFyZ2V0OiB0aGlzLCB2YWx1ZTogdGhpcy52YWx1ZX0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5pc0NsaWNrZWQpe1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gTWF0aFV0aWxzLmludkxlcnAodGhpcy5wb3NpdGlvbi54IC0gdGhpcy5zaXplLngvMiwgdGhpcy5wb3NpdGlvbi54ICsgdGhpcy5zaXplLngvMiwgSW5wdXQuZ2V0TW91c2VQb3NpdGlvbigpLngpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gTWF0aFV0aWxzLmNsYW1wMDEodmFsKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4vTGFiZWxcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9JbnB1dC9JbnB1dFwiO1xyXG5cclxuLyoqIEEgdGV4dCBpbnB1dCBVSUVsZW1lbnQgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dElucHV0IGV4dGVuZHMgTGFiZWwge1xyXG4gICAgLyoqIEEgZmxhZyB0aGUgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSB1c2VyIGNhbiB0eXBlIGluIHRoaXMgVGV4dElucHV0ICovXHJcbiAgICBmb2N1c2VkOiBib29sZWFuO1xyXG4gICAgLyoqIFRoZSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIGluIHRoaXMgVGV4dElucHV0ICovXHJcbiAgICBjdXJzb3JDb3VudGVyOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKHBvc2l0aW9uLCBcIlwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jdXJzb3JDb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgLy8gR2l2ZSBhIGRlZmF1bHQgc2l6ZSB0byB0aGUgeCBvbmx5XHJcbiAgICAgICAgdGhpcy5zaXplLnNldCgyMDAsIHRoaXMuZm9udFNpemUpO1xyXG4gICAgICAgIHRoaXMuaEFsaWduID0gXCJsZWZ0XCI7XHJcblxyXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLldISVRFO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICBpZihJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoKSl7XHJcblx0XHRcdGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpO1xyXG5cdFx0XHRpZih0aGlzLmNvbnRhaW5zKGNsaWNrUG9zLngsIGNsaWNrUG9zLnkpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvckNvdW50ZXIgPSAzMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLmZvY3VzZWQpe1xyXG4gICAgICAgICAgICBsZXQga2V5cyA9IElucHV0LmdldEtleXNKdXN0UHJlc3NlZCgpO1xyXG4gICAgICAgICAgICBsZXQgbnVtcyA9IFwiMTIzNDU2Nzg5MFwiO1xyXG4gICAgICAgICAgICBsZXQgc3BlY2lhbENoYXJzID0gXCJgfiFAIyQlXiYqKCktXz0rW3tdfVxcXFx8OzonXFxcIiw8Lj4vP1wiO1xyXG4gICAgICAgICAgICBsZXQgbGV0dGVycyA9IFwicXdlcnR5dWlvcGFzZGZnaGprbHp4Y3Zibm1cIjtcclxuICAgICAgICAgICAgbGV0IG1hc2sgPSBudW1zICsgc3BlY2lhbENoYXJzICsgbGV0dGVycztcclxuICAgICAgICAgICAga2V5cyA9IGtleXMuZmlsdGVyKGtleSA9PiBtYXNrLmluY2x1ZGVzKGtleSkpO1xyXG4gICAgICAgICAgICBsZXQgc2hpZnRQcmVzc2VkID0gSW5wdXQuaXNLZXlQcmVzc2VkKFwic2hpZnRcIik7XHJcbiAgICAgICAgICAgIGxldCBiYWNrc3BhY2VQcmVzc2VkID0gSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcImJhY2tzcGFjZVwiKTtcclxuICAgICAgICAgICAgbGV0IHNwYWNlUHJlc3NlZCA9IElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJzcGFjZVwiKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGJhY2tzcGFjZVByZXNzZWQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnN1YnN0cmluZygwLCB0aGlzLnRleHQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihzcGFjZVByZXNzZWQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IFwiIFwiO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzaGlmdFByZXNzZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBrZXlzWzBdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSBrZXlzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiZXhwb3J0IGVudW0gVUlFbGVtZW50VHlwZSB7XHJcblx0QlVUVE9OID0gXCJCVVRUT05cIixcclxuXHRMQUJFTCA9IFwiTEFCRUxcIixcclxuXHRTTElERVIgPSBcIlNMSURFUlwiLFxyXG5cdFRFWFRfSU5QVVQgPSBcIlRFWFRJTlBVVFwiXHJcbn0iLCJpbXBvcnQgTmF2aWdhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9OYXZpZ2FibGVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuL05hdmlnYXRpb25QYXRoXCI7XHJcblxyXG4vKipcclxuICogVGhlIG1hbmFnZXIgY2xhc3MgZm9yIG5hdmlnYXRpb24uXHJcbiAqIEhhbmRsZXMgYWxsIG5hdmlnYWJsZSBlbnRpdGllcywgc3VjaCBhbmQgYWxsb3dzIHRoZW0gdG8gYmUgYWNjZXNzZWQgYnkgb3V0c2lkZSBzeXN0ZW1zIGJ5IHJlcXVlc3RpbmcgYSBwYXRoXHJcbiAqIGZyb20gb25lIHBvc2l0aW9uIHRvIGFub3RoZXIuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZpZ2F0aW9uTWFuYWdlciB7XHJcblx0LyoqIFRoZSBsaXN0IG9mIGFsbCBuYXZpZ2FibGUgZW50aXRpZXMgKi9cclxuXHRwcm90ZWN0ZWQgbmF2aWdhYmxlRW50aXRpZXM6IE1hcDxOYXZpZ2FibGU+O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5uYXZpZ2FibGVFbnRpdGllcyA9IG5ldyBNYXAoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBuYXZpZ2FibGUgZW50aXR5IHRvIHRoZSBOYXZpZ2F0aW9uTWFuYWdlclxyXG5cdCAqIEBwYXJhbSBuYXZOYW1lIFRoZSBuYW1lIG9mIHRoZSBuYXZpZ2FibGUgZW50aXRyeVxyXG5cdCAqIEBwYXJhbSBuYXYgVGhlIGFjdHVhbCBOYXZpZ2FibGUgaW5zdGFuY2VcclxuXHQgKi9cclxuXHRhZGROYXZpZ2FibGVFbnRpdHkobmF2TmFtZTogc3RyaW5nLCBuYXY6IE5hdmlnYWJsZSk6IHZvaWQge1xyXG5cdFx0dGhpcy5uYXZpZ2FibGVFbnRpdGllcy5hZGQobmF2TmFtZSwgbmF2KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgYSBwYXRoIGZyb21lIG9uZSBwb2ludCB0byBhbm90aGVyIHVzaW5nIGEgc3BlY2lmaWVkIE5hdmlnYWJsZSBvYmplY3RcclxuXHQgKiBAcGFyYW0gbmF2TmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBOYXZpZ2FibGUgb2JqZWN0XHJcblx0ICogQHBhcmFtIGZyb21Qb3NpdGlvbiBUaGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgbmF2aWdhdGlvblxyXG5cdCAqIEBwYXJhbSB0b1Bvc2l0aW9uIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgTmF2aWdhdGlvblxyXG5cdCAqIEByZXR1cm5zIEEgTmF2aWdhdGlvblBhdGggY29udGFpbmluZyB0aGUgcm91dGUgdG8gdGFrZSBvdmVyIHRoZSBOYXZpZ2FibGUgZW50aXR5IHRvIGdldCBiZXR3ZWVuIHRoZSBwcm92aWRlZCBwb3NpdGlvbnMuXHJcblx0ICovXHJcblx0Z2V0UGF0aChuYXZOYW1lOiBzdHJpbmcsIGZyb21Qb3NpdGlvbjogVmVjMiwgdG9Qb3NpdGlvbjogVmVjMik6IE5hdmlnYXRpb25QYXRoIHtcclxuXHRcdGxldCBuYXYgPSB0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmdldChuYXZOYW1lKTtcclxuXHRcdHJldHVybiBuYXYuZ2V0TmF2aWdhdGlvblBhdGgoZnJvbVBvc2l0aW9uLmNsb25lKCksIHRvUG9zaXRpb24uY2xvbmUoKSk7XHJcblx0fVxyXG59IiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHBhdGggdGhhdCBBSXMgY2FuIGZvbGxvdy4gVXNlcyBmaW5pc2hNb3ZlKCkgaW4gUGh5c2ljYWwgdG8gZGV0ZXJtaW5lIHByb2dyZXNzIG9uIHRoZSByb3V0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvblBhdGgge1xyXG5cdC8qKiBUaGUgbmF2aWdhdGlvbiBwYXRoLCBzdG9yZWQgYXMgYSBzdGFjayBvZiBuZXh0IHBvc2l0aW9ucyAqL1xyXG5cdHByb3RlY3RlZCBwYXRoOiBTdGFjazxWZWMyPjtcclxuXHQvKiogVGhlIGN1cnJlbnQgZGlyZWN0aW9uIG9mIG1vdmVtZW50ICovXHJcblx0cHJvdGVjdGVkIGN1cnJlbnRNb3ZlRGlyZWN0aW9uOiBWZWMyO1xyXG5cdC8qKiBUaGUgZGlzdGFuY2UgYSBub2RlIG11c3QgYmUgdG8gYSBwb2ludCB0byBjb25zaWRlciBpdCBhcyBoYXZpbmcgYXJyaXZlZCAqL1xyXG5cdHByb3RlY3RlZCBkaXN0YW5jZVRocmVzaG9sZDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IE5hdmlnYXRpb25QYXRoXHJcblx0ICogQHBhcmFtIHBhdGggVGhlIHBhdGggb2Ygbm9kZXMgdG8gdGFrZVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHBhdGg6IFN0YWNrPFZlYzI+KXtcclxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XHJcblx0XHR0aGlzLmN1cnJlbnRNb3ZlRGlyZWN0aW9uID0gVmVjMi5aRVJPO1xyXG5cdFx0dGhpcy5kaXN0YW5jZVRocmVzaG9sZCA9IDQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBzdGF0dXMgb2YgbmF2aWdhdGlvbiBhbG9uZyB0aGlzIE5hdmlnYXRpb25QYXRoXHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXRoLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRpc0RvbmUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5wYXRoLmlzRW1wdHkoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIG1vdmVtZW50IGRpcmVjdGlvbiBpbiB0aGUgY3VycmVudCBwb3NpdGlvbiBhbG9uZyB0aGUgcGF0aFxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIG1vdmUgYWxvbmcgdGhlIHBhdGhcclxuXHQgKiBAcmV0dXJucyBUaGUgbW92ZW1lbnQgZGlyZWN0aW9uIGFzIGEgVmVjMlxyXG5cdCAqL1xyXG5cdGdldE1vdmVEaXJlY3Rpb24obm9kZTogR2FtZU5vZGUpOiBWZWMyIHtcclxuXHRcdC8vIFJldHVybiBkaXJlY3Rpb24gdG8gbmV4dCBwb2ludCBpbiB0aGUgbmF2XHJcblx0XHRyZXR1cm4gbm9kZS5wb3NpdGlvbi5kaXJUbyh0aGlzLnBhdGgucGVlaygpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBOYXZpZ2F0aW9uUGF0aCB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgR2FtZU5vZGVcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSBtb3ZpbmcgYWxvbmcgdGhlIHBhdGhcclxuXHQgKi9cclxuXHRoYW5kbGVQYXRoUHJvZ3Jlc3Mobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuXHRcdGlmKG5vZGUucG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMucGF0aC5wZWVrKCkpIDwgdGhpcy5kaXN0YW5jZVRocmVzaG9sZCp0aGlzLmRpc3RhbmNlVGhyZXNob2xkKXtcclxuXHRcdFx0Ly8gV2UndmUgcmVhY2hlZCBvdXIgbm9kZSwgbW92ZSBvbiB0byB0aGUgbmV4dCBkZXN0aW5hdGlvblxyXG5cdFx0XHR0aGlzLnBhdGgucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpXHJcblx0fVxyXG59IiwiaW1wb3J0IFBvc2l0aW9uR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaFwiO1xyXG5pbXBvcnQgTmF2aWdhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9OYXZpZ2FibGVcIjtcclxuaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHcmFwaFV0aWxzIGZyb20gXCIuLi9VdGlscy9HcmFwaFV0aWxzXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgTmF2bWVzaC4gTmF2bWVzaGVzIGFyZSBncmFwaHMgaW4gdGhlIGdhbWUgd29ybGQgYWxvbmcgd2hpY2ggbm9kZXMgY2FuIG1vdmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZtZXNoIGltcGxlbWVudHMgTmF2aWdhYmxlIHtcclxuXHQvKiogVGhlIGdyYXBoIG9mIHBvaW50cyBpbiB0aGUgTmF2TWVzaCAqL1xyXG5cdHByb3RlY3RlZCBncmFwaDogUG9zaXRpb25HcmFwaDtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBOYXZtZXNoIGZyb20gdGhlIHBvaW50cyBpbiB0aGUgc3BlZWNpZmllZCBncmFwaFxyXG5cdCAqIEBwYXJhbSBncmFwaCBUaGUgZ3JhcGggdG8gY29uc3RydWN0IGEgbmF2bWVzaCBmcm9tXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZ3JhcGg6IFBvc2l0aW9uR3JhcGgpe1xyXG5cdFx0dGhpcy5ncmFwaCA9IGdyYXBoO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0Z2V0TmF2aWdhdGlvblBhdGgoZnJvbVBvc2l0aW9uOiBWZWMyLCB0b1Bvc2l0aW9uOiBWZWMyKTogTmF2aWdhdGlvblBhdGgge1xyXG5cdFx0bGV0IHN0YXJ0ID0gdGhpcy5nZXRDbG9zZXN0Tm9kZShmcm9tUG9zaXRpb24pO1xyXG5cdFx0bGV0IGVuZCA9IHRoaXMuZ2V0Q2xvc2VzdE5vZGUodG9Qb3NpdGlvbik7XHJcblxyXG5cdFx0bGV0IHBhcmVudCA9IEdyYXBoVXRpbHMuZGppa3N0cmEodGhpcy5ncmFwaCwgc3RhcnQpO1xyXG5cclxuXHRcdGxldCBwYXRoU3RhY2sgPSBuZXcgU3RhY2s8VmVjMj4odGhpcy5ncmFwaC5udW1WZXJ0aWNlcyk7XHJcblx0XHRcclxuXHRcdC8vIFB1c2ggdGhlIGZpbmFsIHBvc2l0aW9uIGFuZCB0aGUgZmluYWwgcG9zaXRpb24gaW4gdGhlIGdyYXBoXHJcblx0XHRwYXRoU3RhY2sucHVzaCh0b1Bvc2l0aW9uLmNsb25lKCkpO1xyXG5cdFx0cGF0aFN0YWNrLnB1c2godGhpcy5ncmFwaC5wb3NpdGlvbnNbZW5kXSk7XHJcblxyXG5cdFx0Ly8gQWRkIGFsbCBwYXJlbnRzIGFsb25nIHRoZSBwYXRoXHJcblx0XHRsZXQgaSA9IGVuZDtcclxuXHRcdHdoaWxlKHBhcmVudFtpXSAhPT0gLTEpe1xyXG5cdFx0XHRwYXRoU3RhY2sucHVzaCh0aGlzLmdyYXBoLnBvc2l0aW9uc1twYXJlbnRbaV1dKTtcclxuXHRcdFx0aSA9IHBhcmVudFtpXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IE5hdmlnYXRpb25QYXRoKHBhdGhTdGFjayk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBjbG9zZXN0IG5vZGUgaW4gdGhpcyBOYXZtZXNoIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIHF1ZXJ5XHJcblx0ICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG5vZGUgaW4gdGhlIE5hdm1lc2ggdG8gdGhlIHBvc2l0aW9uXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGdldENsb3Nlc3ROb2RlKHBvc2l0aW9uOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdGxldCBuID0gdGhpcy5ncmFwaC5udW1WZXJ0aWNlcztcclxuXHRcdGxldCBpID0gMTtcclxuXHRcdGxldCBpbmRleCA9IDA7XHJcblx0XHRsZXQgZGlzdCA9IHBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLmdyYXBoLnBvc2l0aW9uc1swXSk7XHJcblx0XHR3aGlsZShpIDwgbil7XHJcblx0XHRcdGxldCBkID0gcG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMuZ3JhcGgucG9zaXRpb25zW2ldKTtcclxuXHRcdFx0aWYoZCA8IGRpc3Qpe1xyXG5cdFx0XHRcdGRpc3QgPSBkO1xyXG5cdFx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpKys7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGluZGV4O1xyXG5cdH1cclxufSIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4vUGh5c2ljc01hbmFnZXJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgQXJlYUNvbGxpc2lvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL1BoeXNpY3MvQXJlYUNvbGxpc2lvblwiO1xyXG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcclxuXHJcbi8qKlxyXG4gKiBBTEdPUklUSE06XHJcbiAqIFx0SW4gYW4gZWZmb3J0IHRvIGtlZXAgdGhpbmdzIHNpbXBsZSBhbmQgd29ya2luZyBlZmZlY3RpdmVseSwgZWFjaCBkeW5hbWljIG5vZGUgd2lsbCByZXNvbHZlIGl0c1xyXG4gKiBcdGNvbGxpc2lvbnMgY29uc2lkZXJpbmcgdGhlIHJlc3Qgb2YgdGhlIHdvcmxkIGFzIHN0YXRpYy5cclxuICogXHJcbiAqIFx0Q29sbGlzaW9uIGRldGVjdGluZyB3aWxsIGhhcHBlbiBmaXJzdC4gVGhpcyBjYW4gYmUgY29uc2lkZXJlZCBhIGJyb2FkIHBoYXNlLCBidXQgaXQgaXMgbm90IGVzcGVjaWFsbHlcclxuICogXHRlZmZpY2llbnQsIGFzIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgZm9yIHRoaXMgZ2FtZSBlbmdpbmUuIEV2ZXJ5IGR5bmFtaWMgbm9kZSBpcyBjaGVja2VkIGFnYWluc3QgZXZlcnlcclxuICogXHRvdGhlciBub2RlIGZvciBjb2xsaXNpb24gYXJlYS4gSWYgY29sbGlzaW9uIGFyZWEgaXMgbm9uLXplcm8gKG1lYW5pbmcgdGhlIGN1cnJlbnQgbm9kZSBzd2VlcHMgaW50byBhbm90aGVyKSxcclxuICogXHRpdCBpcyBhZGRlZCB0byBhIGxpc3Qgb2YgaGl0cy5cclxuICogXHJcbiAqIFx0SU5JVElBTElaQVRJT046XHJcbiAqIFx0XHQtIFBoeXNpY3MgY29uc3RhbnRzIGFyZSByZXNldFxyXG4gKiBcdFx0LSBTd2VwdCBzaGFwZXMgYXJlIHJlY2FsY3VsYXRlZC4gSWYgYSBub2RlIGlzbid0IG1vdmluZywgaXQgaXMgc2tpcHBlZC5cclxuICogXHJcbiAqIFx0Q09MTElTSU9OIERFVEVDVElPTjpcclxuICogXHRcdC0gRm9yIGEgbm9kZSwgY29sbGlzaW9uIGFyZWEgd2lsbCBiZSBjYWxjdWxhdGVkIHVzaW5nIHRoZSBzd2VwdCBBQUJCIG9mIHRoZSBub2RlIGFnYWluc3QgZXZlcnkgb3RoZXIgQUFCQiBpbiBhIHN0YXRpYyBzdGF0ZVxyXG4gKiBcdFx0LSBUaGVzZSBjb2xsaXNpb25zIHdpbGwgYmUgc29ydGVkIGJ5IGFyZWEgaW4gZGVzY2VuZGluZyBvcmRlclxyXG4gKiBcdFxyXG4gKiBcdENPTExJU0lPTiBSRVNPTFVUSU9OOlxyXG4gKiBcdFx0LSBGb3IgZWFjaCBoaXQsIHRpbWUgb2YgY29sbGlzaW9uIGlzIGNhbGN1bGF0ZWQgdXNpbmcgYSBzd2VwdCBsaW5lIHRocm91Z2ggdGhlIEFBQkIgb2YgdGhlIHN0YXRpYyBub2RlIGV4cGFuZGVkXHJcbiAqIFx0XHRcdHdpdGggbWlua293c2tpIHN1bXMgKGRpc2NyZXRlbHksIGJ1dCB0aGUgY29uY2VwdCBpcyB0aGVyZSlcclxuICogXHRcdC0gVGhlIGNvbGxpc2lvbiBpcyByZXNvbHZlZCBiYXNlZCBvbiB0aGUgbmVhciB0aW1lIG9mIHRoZSBjb2xsaXNpb24gKGZyb20gbWV0aG9kIG9mIHNlcGFyYXRlZCBheGVzKVxyXG4gKiBcdFx0XHQtIFggaXMgcmVzb2x2ZWQgYnkgbmVhciB4LCBZIGJ5IG5lYXIgeS5cclxuICogXHRcdFx0LSBUaGVyZSBpcyBzb21lIGZ1ZGdpbmcgdG8gYWxsb3cgZm9yIHNsaWRpbmcgYWxvbmcgd2FsbHMgb2Ygc2VwYXJhdGUgY29sbGlkZXJzLiBTb3J0aW5nIGJ5IGFyZWEgYWxzbyBoZWxwcyB3aXRoIHRoaXMuXHJcbiAqIFx0XHRcdC0gQ29ybmVyIHRvIGNvcm5lciBjb2xsaXNpb25zIGFyZSByZXNvbHZlIHRvIGZhdm9yIHgtbW92ZW1lbnQuIFRoaXMgaXMgaW4gY29uc2lkZXJhdGlvbiBvZiBwbGF0Zm9ybWVycywgdG8gZ2l2ZVxyXG4gKiBcdFx0XHRcdHRoZSBwbGF5ZXIgc29tZSBoZWxwIHdpdGgganVtcHNcclxuICogXHJcbiAqIFx0UHJvczpcclxuICogXHRcdC0gRXZlcnl0aGluZyBoYXBwZW5zIHdpdGggYSBjb25zaXN0ZW50IHRpbWUuIFRoZXJlIGlzIGEgZGlzdGluY3QgYmVmb3JlIGFuZCBhZnRlciBmb3IgZWFjaCByZXNvbHV0aW9uLlxyXG4gKiBcdFx0LSBObyBiYWNrLXRyYWNraW5nIG5lZWRzIHRvIGJlIGRvbmUuIE9uY2Ugd2UgcmVzb2x2ZSBhIG5vZGUsIGl0IGlzIGRlZmluaXRpdmVseSByZXNvbHZlZC5cclxuICogXHRcclxuICogXHRDb25zOlxyXG4gKiBcdFx0LSBOb2RlcyB0aGF0IGFyZSBwcm9jZXNzZWQgZWFybHkgaGF2ZSBtb3ZlbWVudCBwcmlvcml0eSBvdmVyIG90aGVyIG5vZGVzLiBUaGlzIGNhbiBsZWFkIHRvIHNvbWUgdW5kZXNpcmFibGUgaW50ZXJhY3Rpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQaHlzaWNzTWFuYWdlciBleHRlbmRzIFBoeXNpY3NNYW5hZ2VyIHtcclxuXHJcblx0LyoqIFRoZSBhcnJheSBvZiBzdGF0aWMgbm9kZXMgKi9cclxuXHRwcm90ZWN0ZWQgc3RhdGljTm9kZXM6IEFycmF5PFBoeXNpY2FsPjtcclxuXHJcblx0LyoqIFRoZSBhcnJheSBvZiBkeW5hbWljIG5vZGVzICovXHJcblx0cHJvdGVjdGVkIGR5bmFtaWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xyXG5cclxuXHQvKiogVGhlIGFycmF5IG9mIHRpbGVtYXBzICovXHJcblx0cHJvdGVjdGVkIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcclxuXHJcblx0LyoqIEFuIGFycmF5IG9mIHRoZSBjb2xsaXNpb24gbWFza3MgZm9yIGVhY2ggZ3JvdXAgKi9cclxuXHRwcm90ZWN0ZWQgY29sbGlzaW9uTWFza3M6IEFycmF5PG51bWJlcj47XHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pe1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuc3RhdGljTm9kZXMgPSBuZXcgQXJyYXkoKTtcclxuXHRcdHRoaXMuZHluYW1pY05vZGVzID0gbmV3IEFycmF5KCk7XHJcblx0XHR0aGlzLnRpbGVtYXBzID0gbmV3IEFycmF5KCk7XHJcblx0XHR0aGlzLmNvbGxpc2lvbk1hc2tzID0gbmV3IEFycmF5KDMyKTtcclxuXHJcblx0XHQvLyBQYXJzZSBvcHRpb25zXHJcblx0XHR0aGlzLnBhcnNlT3B0aW9ucyhvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhcnNlcyB0aGUgb3B0aW9ucyBmb3IgY29uc3RydWN0aW5nIHRoZSBwaHlzaWNzIG1hbmFnZXJcclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBBIHJlY29yZCBvZiBvcHRpb25zXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHBhcnNlT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRpZihvcHRpb25zLmdyb3VwTmFtZXMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmNvbGxpc2lvbnMgIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmdyb3VwTmFtZXMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcdGxldCBncm91cCA9IG9wdGlvbnMuZ3JvdXBOYW1lc1tpXTtcclxuXHJcblx0XHRcdFx0Ly8gUmVnaXN0ZXIgdGhlIGdyb3VwIG5hbWUgYW5kIG51bWJlclxyXG5cdFx0XHRcdHRoaXMuZ3JvdXBOYW1lc1tpXSA9IGdyb3VwO1xyXG5cclxuXHRcdFx0XHR0aGlzLmdyb3VwTWFwLnNldChncm91cCwgMSA8PCBpKTtcclxuXHJcblx0XHRcdFx0bGV0IGNvbGxpc2lvbk1hc2sgPSAwO1xyXG5cclxuXHRcdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgb3B0aW9ucy5jb2xsaXNpb25zW2ldLmxlbmd0aDsgaisrKXtcclxuXHRcdFx0XHRcdGlmKG9wdGlvbnMuY29sbGlzaW9uc1tpXVtqXSl7XHJcblx0XHRcdFx0XHRcdGNvbGxpc2lvbk1hc2sgfD0gMSA8PCBqO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5jb2xsaXNpb25NYXNrc1tpXSA9IGNvbGxpc2lvbk1hc2s7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdHJlZ2lzdGVyT2JqZWN0KG5vZGU6IFBoeXNpY2FsKTogdm9pZCB7XHJcblx0XHRpZihub2RlLmlzU3RhdGljKXtcclxuXHRcdFx0Ly8gU3RhdGljIGFuZCBub3QgY29sbGlkYWJsZVxyXG5cdFx0XHR0aGlzLnN0YXRpY05vZGVzLnB1c2gobm9kZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBEeW5hbWljIGFuZCBub3QgY29sbGlkYWJsZVxyXG5cdFx0XHR0aGlzLmR5bmFtaWNOb2Rlcy5wdXNoKG5vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0ZGVyZWdpc3Rlck9iamVjdChub2RlOiBQaHlzaWNhbCk6IHZvaWQge1xyXG5cdFx0Y29uc29sZS5sb2coXCJEZXJlZ2lzdGVyaW5nIHBoeXNpY3Mgb2JqZWN0XCIpO1xyXG5cdFx0aWYobm9kZS5pc1N0YXRpYyl7XHJcblx0XHRcdC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBzdGF0aWMgbGlzdFxyXG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuc3RhdGljTm9kZXMuaW5kZXhPZihub2RlKTtcclxuXHRcdFx0dGhpcy5zdGF0aWNOb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGR5bmFtaWMgbGlzdFxyXG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuZHluYW1pY05vZGVzLmluZGV4T2Yobm9kZSk7XHJcblx0XHRcdHRoaXMuZHluYW1pY05vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xyXG5cdFx0dGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0ZGVyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnRpbGVtYXBzLmluZGV4T2YodGlsZW1hcCk7XHJcblx0XHR0aGlzLnRpbGVtYXBzLnNwbGljZShpbmRleCwgMSk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGZvcihsZXQgbm9kZSBvZiB0aGlzLmR5bmFtaWNOb2Rlcyl7XHJcblx0XHRcdC8qLS0tLS0tLS0tLSBJTklUSUFMSVpBVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cclxuXHRcdFx0Ly8gQ2xlYXIgZnJhbWUgZGVwZW5kZW50IGJvb2xlYW4gdmFsdWVzIGZvciBlYWNoIG5vZGVcclxuXHRcdFx0bm9kZS5vbkdyb3VuZCA9IGZhbHNlO1xyXG5cdFx0XHRub2RlLm9uQ2VpbGluZyA9IGZhbHNlO1xyXG5cdFx0XHRub2RlLm9uV2FsbCA9IGZhbHNlO1xyXG5cdFx0XHRub2RlLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcclxuXHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhpcyBub2RlIGlzIG5vdCBhY3RpdmUsIGRvbid0IHByb2Nlc3MgaXRcclxuXHRcdFx0aWYoIW5vZGUuYWN0aXZlKXtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHRoZSBzd2VwdCBzaGFwZXMgb2YgZWFjaCBub2RlXHJcblx0XHRcdGlmKG5vZGUubW92aW5nKXtcclxuXHRcdFx0XHQvLyBJZiBtb3ZpbmcsIHJlZmxlY3QgdGhhdCBpbiB0aGUgc3dlcHQgc2hhcGVcclxuXHRcdFx0XHRub2RlLnN3ZXB0UmVjdC5zd2VlcChub2RlLl92ZWxvY2l0eSwgbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXIsIG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIElmIG91ciBub2RlIGlzbid0IG1vdmluZywgZG9uJ3QgYm90aGVyIHRvIGNoZWNrIGl0IChvdGhlciBub2RlcyB3aWxsIGRldGVjdCBpZiB0aGV5IHJ1biBpbnRvIGl0KVxyXG5cdFx0XHRcdG5vZGUuX3ZlbG9jaXR5Lnplcm8oKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyotLS0tLS0tLS0tIERFVEVDVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cclxuXHRcdFx0Ly8gR2F0aGVyIGEgc2V0IG9mIG92ZXJsYXBzXHJcblx0XHRcdGxldCBvdmVybGFwcyA9IG5ldyBBcnJheTxBcmVhQ29sbGlzaW9uPigpO1xyXG5cclxuXHRcdFx0bGV0IGdyb3VwSW5kZXggPSBNYXRoLmxvZzIobm9kZS5ncm91cCk7XHJcblxyXG5cdFx0XHQvLyBGaXJzdCwgY2hlY2sgdGhpcyBub2RlIGFnYWluc3QgZXZlcnkgc3RhdGljIG5vZGUgKG9yZGVyIGRvZXNuJ3QgYWN0dWFsbHkgbWF0dGVyIGhlcmUsIHNpbmNlIHdlIHNvcnQgYW55d2F5cylcclxuXHRcdFx0Zm9yKGxldCBvdGhlciBvZiB0aGlzLnN0YXRpY05vZGVzKXtcclxuXHRcdFx0XHQvLyBJZ25vcmUgaW5hY3RpdmUgbm9kZXNcclxuXHRcdFx0XHRpZighb3RoZXIuYWN0aXZlKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0bGV0IGNvbGxpZGVyID0gb3RoZXIuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XHJcblx0XHRcdFx0aWYoYXJlYSA+IDApe1xyXG5cdFx0XHRcdFx0Ly8gV2UgaGFkIGEgY29sbGlzaW9uXHJcblx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCBvdGhlciwgXCJHYW1lTm9kZVwiLCBudWxsKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBUaGVuLCBjaGVjayBpdCBhZ2FpbnN0IGV2ZXJ5IGR5bmFtaWMgbm9kZVxyXG5cdFx0XHRmb3IobGV0IG90aGVyIG9mIHRoaXMuZHluYW1pY05vZGVzKXtcclxuXHRcdFx0XHQvLyBJZ25vcmUgb3Vyc2VsdmVzXHJcblx0XHRcdFx0aWYobm9kZSA9PT0gb3RoZXIpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHQvLyBJZ25vcmUgaW5hY3RpdmUgbm9kZXNcclxuXHRcdFx0XHRpZighb3RoZXIuYWN0aXZlKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0bGV0IGNvbGxpZGVyID0gb3RoZXIuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCk7XHJcblx0XHRcdFx0bGV0IGFyZWEgPSBub2RlLnN3ZXB0UmVjdC5vdmVybGFwQXJlYShjb2xsaWRlcik7XHJcblx0XHRcdFx0aWYoYXJlYSA+IDApe1xyXG5cdFx0XHRcdFx0Ly8gV2UgaGFkIGEgY29sbGlzaW9uXHJcblx0XHRcdFx0XHRvdmVybGFwcy5wdXNoKG5ldyBBcmVhQ29sbGlzaW9uKGFyZWEsIGNvbGxpZGVyLCBvdGhlciwgXCJHYW1lTm9kZVwiLCBudWxsKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBMYXN0bHksIGdhdGhlciBhIHNldCBvZiBBQUJCcyBmcm9tIHRoZSB0aWxlbWFwLlxyXG5cdFx0XHQvLyBUaGlzIHN0ZXAgaW52b2x2ZXMgdGhlIG1vc3QgZXh0cmEgd29yaywgc28gaXQgaXMgYWJzdHJhY3RlZCBpbnRvIGEgbWV0aG9kXHJcblx0XHRcdGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcclxuXHRcdFx0XHQvLyBJZ25vcmUgaW5hY3RpdmUgdGlsZW1hcHNcclxuXHRcdFx0XHRpZighdGlsZW1hcC5hY3RpdmUpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRpZih0aWxlbWFwIGluc3RhbmNlb2YgT3J0aG9nb25hbFRpbGVtYXApe1xyXG5cdFx0XHRcdFx0dGhpcy5jb2xsaWRlV2l0aE9ydGhvZ29uYWxUaWxlbWFwKG5vZGUsIHRpbGVtYXAsIG92ZXJsYXBzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNvcnQgdGhlIG92ZXJsYXBzIGJ5IGFyZWFcclxuXHRcdFx0b3ZlcmxhcHMgPSBvdmVybGFwcy5zb3J0KChhLCBiKSA9PiBiLmFyZWEgLSBhLmFyZWEpO1xyXG5cclxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBoaXRzIHRvIHVzZSBsYXRlclxyXG5cdFx0XHRsZXQgaGl0cyA9IFtdO1xyXG5cclxuXHRcdFx0LyotLS0tLS0tLS0tIFJFU09MVVRJT04gUEhBU0UgLS0tLS0tLS0tLSovXHJcblx0XHRcdC8vIEZvciBldmVyeSBvdmVybGFwLCBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBjb2xsaWRlIHdpdGggaXQgYW5kIHdoZW5cclxuXHRcdFx0Zm9yKGxldCBvdmVybGFwIG9mIG92ZXJsYXBzKXtcclxuXHRcdFx0XHQvLyBJZ25vcmUgbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxyXG5cdFx0XHRcdGlmKHRoaXMuY29sbGlzaW9uTWFza3NbZ3JvdXBJbmRleF0gIT09IHVuZGVmaW5lZCAmJiAodGhpcy5jb2xsaXNpb25NYXNrc1tncm91cEluZGV4XSAmIG92ZXJsYXAub3RoZXIuZ3JvdXApID09PSAwKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Ly8gRG8gYSBzd2VwdCBsaW5lIHRlc3Qgb24gdGhlIHN0YXRpYyBBQUJCIHdpdGggdGhpcyBBQUJCIHNpemUgYXMgcGFkZGluZyAodGhpcyBpcyBiYXNpY2FsbHkgdXNpbmcgYSBtaW5rb3dza2kgc3VtISlcclxuXHRcdFx0XHQvLyBTdGFydCB0aGUgc3dlZXAgYXQgdGhlIHBvc2l0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIGEgZGVsdGEgb2YgX3ZlbG9jaXR5XHJcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBub2RlLmNvbGxpc2lvblNoYXBlLmNlbnRlcjtcclxuXHRcdFx0XHRjb25zdCBkZWx0YSA9IG5vZGUuX3ZlbG9jaXR5O1xyXG5cdFx0XHRcdGNvbnN0IHBhZGRpbmcgPSBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplO1xyXG5cdFx0XHRcdGNvbnN0IG90aGVyQUFCQiA9IG92ZXJsYXAuY29sbGlkZXI7XHJcblxyXG5cclxuXHRcdFx0XHRjb25zdCBoaXQgPSBvdGhlckFBQkIuaW50ZXJzZWN0U2VnbWVudChub2RlLmNvbGxpc2lvblNoYXBlLmNlbnRlciwgbm9kZS5fdmVsb2NpdHksIG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUpO1xyXG5cclxuXHRcdFx0XHRvdmVybGFwLmhpdCA9IGhpdDtcclxuXHJcblx0XHRcdFx0aWYoaGl0ICE9PSBudWxsKXtcclxuXHRcdFx0XHRcdGhpdHMucHVzaChoaXQpO1xyXG5cclxuXHRcdFx0XHRcdC8vIFdlIGdvdCBhIGhpdCwgcmVzb2x2ZSB3aXRoIHRoZSB0aW1lIGluc2lkZSBvZiB0aGUgaGl0XHJcblx0XHRcdFx0XHRsZXQgdG5lYXJ4ID0gaGl0Lm5lYXJUaW1lcy54O1xyXG5cdFx0XHRcdFx0bGV0IHRuZWFyeSA9IGhpdC5uZWFyVGltZXMueTtcclxuXHJcblx0XHRcdFx0XHQvLyBBbGxvdyBlZGdlIGNsaXBwaW5nIChlZGdlIG92ZXJsYXBzIGRvbid0IGNvdW50LCBvbmx5IGFyZWEgb3ZlcmxhcHMpXHJcblx0XHRcdFx0XHQvLyBJbXBvcnRhbnRseSBkb24ndCBhbGxvdyBib3RoIGNhc2VzIHRvIGJlIHRydWUuIFRoZW4gd2UgY2xpcCB0aHJvdWdoIGNvcm5lcnMuIEZhdm9yIHggdG8gaGVscCBwbGF5ZXJzIGxhbmQganVtcHNcclxuXHRcdFx0XHRcdGlmKHRuZWFyeCA8IDEuMCAmJiAocG9pbnQueSA9PT0gb3RoZXJBQUJCLnRvcCAtIHBhZGRpbmcueSB8fCBwb2ludC55ID09PSBvdGhlckFBQkIuYm90dG9tICsgcGFkZGluZy55KSAmJiBkZWx0YS54ICE9PSAwKSB7XHJcblx0XHRcdFx0XHRcdHRuZWFyeCA9IDEuMDtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZih0bmVhcnkgPCAxLjAgJiYgKHBvaW50LnggPT09IG90aGVyQUFCQi5sZWZ0IC0gcGFkZGluZy54IHx8IHBvaW50LnggPT09IG90aGVyQUFCQi5yaWdodCArIHBhZGRpbmcueCkgJiYgZGVsdGEueSAhPT0gMCkge1xyXG5cdFx0XHRcdFx0XHR0bmVhcnkgPSAxLjA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmKGhpdC5uZWFyVGltZXMueCA+PSAwICYmIGhpdC5uZWFyVGltZXMueCA8IDEpe1xyXG5cdFx0XHRcdFx0XHQvLyBBbnkgdGlsZW1hcCBvYmplY3RzIHRoYXQgbWFkZSBpdCBoZXJlIGFyZSBjb2xsaWRhYmxlXHJcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpe1xyXG5cdFx0XHRcdFx0XHRcdG5vZGUuX3ZlbG9jaXR5LnggPSBub2RlLl92ZWxvY2l0eS54ICogdG5lYXJ4O1xyXG5cdFx0XHRcdFx0XHRcdG5vZGUuaXNDb2xsaWRpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYoaGl0Lm5lYXJUaW1lcy55ID49IDAgJiYgaGl0Lm5lYXJUaW1lcy55IDwgMSl7XHJcblx0XHRcdFx0XHRcdC8vIEFueSB0aWxlbWFwIG9iamVjdHMgdGhhdCBtYWRlIGl0IGhlcmUgYXJlIGNvbGxpZGFibGVcclxuXHRcdFx0XHRcdFx0aWYob3ZlcmxhcC50eXBlID09PSBcIlRpbGVtYXBcIiB8fCBvdmVybGFwLm90aGVyLmlzQ29sbGlkYWJsZSl7XHJcblx0XHRcdFx0XHRcdFx0bm9kZS5fdmVsb2NpdHkueSA9IG5vZGUuX3ZlbG9jaXR5LnkgKiB0bmVhcnk7XHJcblx0XHRcdFx0XHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8qLS0tLS0tLS0tLSBJTkZPUk1BVElPTi9UUklHR0VSIFBIQVNFIC0tLS0tLS0tLS0qL1xyXG5cdFx0XHQvLyBDaGVjayBpZiB3ZSBlbmRlZCB1cCBvbiB0aGUgZ3JvdW5kLCBjZWlsaW5nIG9yIHdhbGxcclxuXHRcdFx0Ly8gQWxzbyBjaGVjayBmb3IgdHJpZ2dlcnNcclxuXHRcdFx0Zm9yKGxldCBvdmVybGFwIG9mIG92ZXJsYXBzKXtcclxuXHRcdFx0XHQvLyBDaGVjayBmb3IgYSB0cmlnZ2VyLiBJZiB3ZSBjYXJlIGFib3V0IHRoZSB0cmlnZ2VyLCByZWFjdFxyXG5cdFx0XHRcdGlmKG92ZXJsYXAub3RoZXIuaXNUcmlnZ2VyICYmIChvdmVybGFwLm90aGVyLnRyaWdnZXJNYXNrICYgbm9kZS5ncm91cCkpe1xyXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBiaXQgdGhhdCB0aGlzIGdyb3VwIGlzIHJlcHJlc2VudGVkIGJ5XHJcblx0XHRcdFx0XHRsZXQgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgubG9nMihub2RlLmdyb3VwKSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCB0aGUgdHJpZ2dlckVudGVyIGV2ZW50IG5hbWVcclxuXHRcdFx0XHRcdHRoaXMuZW1pdHRlci5maXJlRXZlbnQob3ZlcmxhcC5vdGhlci50cmlnZ2VyRW50ZXJzW2luZGV4XSwge1xyXG5cdFx0XHRcdFx0XHRub2RlOiAoPEdhbWVOb2RlPm5vZGUpLmlkLFxyXG5cdFx0XHRcdFx0XHRvdGhlcjogKDxHYW1lTm9kZT5vdmVybGFwLm90aGVyKS5pZFxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBJZ25vcmUgY29sbGlzaW9uIHNpZGVzIGZvciBub2RlcyB3ZSBkb24ndCBpbnRlcmFjdCB3aXRoXHJcblx0XHRcdFx0aWYoKHRoaXMuY29sbGlzaW9uTWFza3NbZ3JvdXBJbmRleF0gJiBvdmVybGFwLm90aGVyLmdyb3VwKSA9PT0gMCkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdC8vIE9ubHkgY2hlY2sgZm9yIGRpcmVjdGlvbiBpZiB0aGUgb3ZlcmxhcCB3YXMgY29sbGlkYWJsZVxyXG5cdFx0XHRcdGlmKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpe1xyXG5cdFx0XHRcdFx0bGV0IGNvbGxpc2lvblNpZGUgPSBvdmVybGFwLmNvbGxpZGVyLnRvdWNoZXNBQUJCV2l0aG91dENvcm5lcnMobm9kZS5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKSk7XHJcblx0XHRcdFx0XHRpZihjb2xsaXNpb25TaWRlICE9PSBudWxsKXtcclxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UgdG91Y2gsIG5vdCBpbmNsdWRpbmcgY29ybmVyIGNhc2VzLCBjaGVjayB0aGUgY29sbGlzaW9uIG5vcm1hbFxyXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLmhpdCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UgaGl0IGEgdGlsZW1hcCwga2VlcCB0cmFjayBvZiBpdFxyXG5cdFx0XHRcdFx0XHRcdGlmKG92ZXJsYXAudHlwZSA9PSBcIlRpbGVtYXBcIil7XHJcblx0XHRcdFx0XHRcdFx0XHRub2RlLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZS55ID09PSAtMSl7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBOb2RlIGlzIG9uIHRvcCBvZiBvdmVybGFwLCBzbyBvbkdyb3VuZFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5vbkdyb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNvbGxpc2lvblNpZGUueSA9PT0gMSl7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBOb2RlIGlzIG9uIGJvdHRvbSBvZiBvdmVybGFwLCBzbyBvbkNlaWxpbmdcclxuXHRcdFx0XHRcdFx0XHRcdG5vZGUub25DZWlsaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSB3YXNuJ3QgdG91Y2hpbmcgb24geSwgc28gaXQgaXMgdG91Y2hpbmcgb24geFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5vbldhbGwgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgY29sbGlzaW9uIHdpdGggdGhlIG5vZGUsIGFuZCBtb3ZlIGl0XHJcblx0XHRcdG5vZGUuZmluaXNoTW92ZSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSGFuZGxlcyBhIGNvbGxpc2lvbiBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgYW4gb3J0aG9nb25hbCB0aWxlbWFwXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGVcclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0aGUgbm9kZSBtYXkgYmUgY29sbGlkaW5nIHdpdGhcclxuXHQgKiBAcGFyYW0gb3ZlcmxhcHMgVGhlIGxpc3Qgb2Ygb3ZlcmxhcHNcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgY29sbGlkZVdpdGhPcnRob2dvbmFsVGlsZW1hcChub2RlOiBQaHlzaWNhbCwgdGlsZW1hcDogT3J0aG9nb25hbFRpbGVtYXAsIG92ZXJsYXBzOiBBcnJheTxBcmVhQ29sbGlzaW9uPik6IHZvaWQge1xyXG5cdFx0Ly8gR2V0IHRoZSBtaW4gYW5kIG1heCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtb3Zpbmcgbm9kZVxyXG5cdFx0bGV0IG1pbiA9IG5ldyBWZWMyKG5vZGUuc3dlcHRSZWN0LmxlZnQsIG5vZGUuc3dlcHRSZWN0LnRvcCk7XHJcblx0XHRsZXQgbWF4ID0gbmV3IFZlYzIobm9kZS5zd2VwdFJlY3QucmlnaHQsIG5vZGUuc3dlcHRSZWN0LmJvdHRvbSk7XHJcblxyXG5cdFx0Ly8gQ29udmVydCB0aGUgbWluL21heCB4L3kgdG8gdGhlIG1pbiBhbmQgbWF4IHJvdy9jb2wgaW4gdGhlIHRpbGVtYXAgYXJyYXlcclxuXHRcdGxldCBtaW5JbmRleCA9IHRpbGVtYXAuZ2V0Q29sUm93QXQobWluKTtcclxuXHRcdGxldCBtYXhJbmRleCA9IHRpbGVtYXAuZ2V0Q29sUm93QXQobWF4KTtcclxuXHJcblx0XHRsZXQgdGlsZVNpemUgPSB0aWxlbWFwLmdldFRpbGVTaXplKCk7XHJcblxyXG5cdFx0Ly8gTG9vcCBvdmVyIGFsbCBwb3NzaWJsZSB0aWxlcyAod2hpY2ggaXNuJ3QgbWFueSBpbiB0aGUgc2NvcGUgb2YgdGhlIHZlbG9jaXR5IHBlciBmcmFtZSlcclxuXHRcdGZvcihsZXQgY29sID0gbWluSW5kZXgueDsgY29sIDw9IG1heEluZGV4Lng7IGNvbCsrKXtcclxuXHRcdFx0Zm9yKGxldCByb3cgPSBtaW5JbmRleC55OyByb3cgPD0gbWF4SW5kZXgueTsgcm93Kyspe1xyXG5cdFx0XHRcdGlmKHRpbGVtYXAuaXNUaWxlQ29sbGlkYWJsZShjb2wsIHJvdykpe1xyXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIHRpbGVcclxuXHRcdFx0XHRcdGxldCB0aWxlUG9zID0gbmV3IFZlYzIoY29sICogdGlsZVNpemUueCArIHRpbGVTaXplLngvMiwgcm93ICogdGlsZVNpemUueSArIHRpbGVTaXplLnkvMik7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGEgbmV3IGNvbGxpZGVyIGZvciB0aGlzIHRpbGVcclxuXHRcdFx0XHRcdGxldCBjb2xsaWRlciA9IG5ldyBBQUJCKHRpbGVQb3MsIHRpbGVTaXplLnNjYWxlZCgxLzIpKTtcclxuXHJcblx0XHRcdFx0XHQvLyBDYWxjdWxhdGUgY29sbGlzaW9uIGFyZWEgYmV0d2VlbiB0aGUgbm9kZSBhbmQgdGhlIHRpbGVcclxuXHRcdFx0XHRcdGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xyXG5cdFx0XHRcdFx0aWYoYXJlYSA+IDApe1xyXG5cdFx0XHRcdFx0XHQvLyBXZSBoYWQgYSBjb2xsaXNpb25cclxuXHRcdFx0XHRcdFx0b3ZlcmxhcHMucHVzaChuZXcgQXJlYUNvbGxpc2lvbihhcmVhLCBjb2xsaWRlciwgdGlsZW1hcCwgXCJUaWxlbWFwXCIsIG5ldyBWZWMyKGNvbCwgcm93KSkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBQaHlzaWNhbCBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvUGh5c2ljYWxcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBwaHlzaWNzIG1hbmFnZXIuXHJcbiAqIFRoaXMgY2xhc3MgZXhwb3NlcyBmdW5jdGlvbnMgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50IHRoYXQgc2hvdWxkIGFsbG93IGZvciBhIHdvcmtpbmcgcGh5c2ljcyBzeXN0ZW0gdG8gYmUgY3JlYXRlZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NNYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XHJcblx0LyoqIFRoZSBldmVudCByZWNlaXZlciBmb3IgdGhlIHBoeXNpY3Mgc3lzdGVtICovXHJcblx0cHJvdGVjdGVkIHJlY2VpdmVyOiBSZWNlaXZlcjtcclxuXHQvKiogVGhlIGV2ZW50IGVtaXR0ZXIgZm9yIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xyXG5cdHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuXHQvKiogTWFwcyBsYXllciBuYW1lcyB0byBudW1iZXJzICovXHJcblx0cHJvdGVjdGVkIGdyb3VwTWFwOiBNYXA8bnVtYmVyPjtcclxuXHJcblx0LyoqIE1hcHMgbGF5ZXIgbnVtYmVycyB0byBuYW1lcyAqL1xyXG5cdHByb3RlY3RlZCBncm91cE5hbWVzOiBBcnJheTxzdHJpbmc+O1xyXG5cclxuXHQvKiogVGhlIGRlZmF1bHQgZ3JvdXAgbmFtZSAqL1xyXG5cdHByb3RlY3RlZCBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9HUk9VUCA9IFwiRGVmYXVsdFwiO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG5cdFx0dGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcblx0XHQvLyBUaGUgY3JlYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIG9mIGxheWVycyBpcyBkZWZlcnJlZCB0byB0aGUgc3ViY2xhc3NcclxuXHRcdHRoaXMuZ3JvdXBNYXAgPSBuZXcgTWFwKCk7XHJcblx0XHR0aGlzLmdyb3VwTmFtZXMgPSBuZXcgQXJyYXkoKTtcclxuXHR9XHJcblxyXG5cdGRlc3Ryb3koKTogdm9pZCB7XHJcblx0XHR0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhIGdhbWVub2RlIHdpdGggdGhpcyBwaHlzaWNzIG1hbmFnZXJcclxuXHQgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcmVnaXN0ZXJcclxuXHQgKi9cclxuXHRhYnN0cmFjdCByZWdpc3Rlck9iamVjdChvYmplY3Q6IFBoeXNpY2FsKTogdm9pZDtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgcmVmZXJlbmNlcyB0byB0aGlzIG9iamVjdCBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJyXHJcblx0ICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBkZXJlZ2lzdGVyT2JqZWN0KG9iamVjdDogUGh5c2ljYWwpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgYSB0aWxlbWFwIHdpdGggdGhpcyBwaHlzaWNzIG1hbmFnZXJcclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZWdpc3RlclxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IHJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgdGlsZW1hcCBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJyXHJcblx0ICogQHBhcmFtIHRpbGVtYXAgVGhlIG9iamVjdCB0byBkZXJlZ2lzdGVyXHJcblx0ICovXHJcblx0YWJzdHJhY3QgZGVyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQ7XHJcblxyXG5cdGFic3RyYWN0IHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHBoeXNpY3MgbGF5ZXIgb2YgdGhlIEdhbWVOb2RlXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIEdhbWVOb2RlXHJcblx0ICogQHBhcmFtIGdyb3VwIFRoZSBncm91cCB0aGF0IHRoZSBHYW1lTm9kZSBzaG91bGQgYmUgb25cclxuXHQgKi9cclxuXHRzZXRHcm91cChub2RlOiBQaHlzaWNhbCwgZ3JvdXA6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0bm9kZS5ncm91cCA9IHRoaXMuZ3JvdXBNYXAuZ2V0KGdyb3VwKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHJpZXZlcyB0aGUgbGF5ZXIgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZVxyXG5cdCAqIEBwYXJhbSBsYXllciBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuXHQgKiBAcmV0dXJucyBUaGUgbGF5ZXIgbnVtYmVyLCBvciAwIGlmIHRoZXJlIGlzIG5vdCBhIGxheWVyIHdpdGggdGhhdCBuYW1lIHJlZ2lzdGVyZWRcclxuXHQgKi9cclxuXHRnZXRHcm91cE51bWJlcihncm91cDogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGlmKHRoaXMuZ3JvdXBNYXAuaGFzKGdyb3VwKSl7XHJcblx0XHRcdHJldHVybiB0aGlzLmdyb3VwTWFwLmdldChncm91cCk7XHJcblx0XHR9IGVsc2V7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBhbGwgZ3JvdXAgbmFtZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBudW1iZXIgcHJvdmlkZWRcclxuXHQgKiBAcGFyYW0gZ3JvdXBzIEEgbWFzayBvZiBncm91cHNcclxuXHQgKiBAcmV0dXJucyBBbGwgZ3JvdXBzIGNvbnRhaW5lZCBpbiB0aGUgbWFza1xyXG5cdCAqL1xyXG5cdGdldEdyb3VwTmFtZXMoZ3JvdXBzOiBudW1iZXIpOiBBcnJheTxzdHJpbmc+IHtcclxuXHRcdGlmKGdyb3VwcyA9PT0gLTEpe1xyXG5cdFx0XHRyZXR1cm4gW1BoeXNpY3NNYW5hZ2VyLkRFRkFVTFRfR1JPVVBdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGcgPSAxO1xyXG5cdFx0XHRsZXQgbmFtZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKXtcclxuXHRcdFx0XHRpZihnICYgZ3JvdXBzKXtcclxuXHRcdFx0XHRcdC8vIFRoaXMgZ3JvdXAgaXMgaW4gdGhlIGdyb3VwcyBudW1iZXJcclxuXHRcdFx0XHRcdG5hbWVzLnB1c2godGhpcy5ncm91cE5hbWVzW2ldKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFNoaWZ0IHRoZSBiaXQgb3ZlclxyXG5cdFx0XHRcdGcgPSBnIDw8IDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjb3JkZXIge1xyXG5cdHByaXZhdGUgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cdHByaXZhdGUgbG9nOiBRdWV1ZTxMb2dJdGVtPjtcclxuXHRwcml2YXRlIHJlY29yZGluZzogYm9vbGVhbjtcclxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcblx0cHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xyXG5cdHByaXZhdGUgcGxheWluZzogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuXHRcdHRoaXMubG9nID0gbmV3IFF1ZXVlKDEwMDApO1xyXG5cdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMucGxheWluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5mcmFtZSA9IDA7XHJcblxyXG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xyXG5cdFx0dGhpcy5ldmVudFF1ZXVlLnN1YnNjcmliZSh0aGlzLnJlY2VpdmVyLCBcImFsbFwiKTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5yZWNvcmRpbmcpe1xyXG5cdFx0XHR0aGlzLmZyYW1lICs9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5wbGF5aW5nKXtcclxuXHRcdFx0Ly8gSWYgcGxheWluZywgaWdub3JlIGV2ZW50cywganVzdCBmZWVkIHRoZSByZWNvcmQgdG8gdGhlIGV2ZW50IHF1ZXVlXHJcblx0XHRcdHRoaXMucmVjZWl2ZXIuaWdub3JlRXZlbnRzKCk7XHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHRcdFdoaWxlIHRoZXJlIGlzIGEgbmV4dCBpdGVtLCBhbmQgd2hpbGUgaXQgc2hvdWxkIG9jY3VyIGluIHRoaXMgZnJhbWUsXHJcblx0XHRcdFx0c2VuZCB0aGUgZXZlbnQuIGkuZS4sIHdoaWxlIGN1cnJlbnRfZnJhbWUgKiBjdXJyZW50X2RlbHRhX3QgaXMgZ3JlYXRlclxyXG5cdFx0XHRcdHRoYW4gcmVjb3JkZWRfZnJhbWUgKiByZWNvcmRlZF9kZWx0YV90XHJcblx0XHRcdCovXHJcblx0XHRcdHdoaWxlKHRoaXMubG9nLmhhc0l0ZW1zKClcclxuXHRcdFx0XHRcdCYmIHRoaXMubG9nLnBlZWtOZXh0KCkuZnJhbWUgKiB0aGlzLmxvZy5wZWVrTmV4dCgpLmRlbHRhIDwgdGhpcy5mcmFtZSAqIGRlbHRhVCl7XHJcblx0XHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5sb2cuZGVxdWV1ZSgpLmV2ZW50O1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKGV2ZW50KTtcclxuXHRcdFx0XHR0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZXZlbnQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZighdGhpcy5sb2cuaGFzSXRlbXMoKSl7XHJcblx0XHRcdFx0dGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZnJhbWUgKz0gMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIElmIG5vdCBwbGF5aW5nLCBoYW5kbGUgZXZlbnRzXHJcblx0XHRcdHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG5cdFx0XHRcdGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcblxyXG5cdFx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RPUF9SRUNPUkRJTkcpe1xyXG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKHRoaXMucmVjb3JkaW5nKXtcclxuXHRcdFx0XHRcdHRoaXMubG9nLmVucXVldWUobmV3IExvZ0l0ZW0odGhpcy5mcmFtZSwgZGVsdGFULCBldmVudCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5TVEFSVF9SRUNPUkRJTkcpe1xyXG5cdFx0XHRcdFx0dGhpcy5sb2cuY2xlYXIoKTtcclxuXHRcdFx0XHRcdHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHRoaXMuZnJhbWUgPSAwXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfUkVDT1JESU5HKXtcclxuXHRcdFx0XHRcdHRoaXMuZnJhbWUgPSAwO1xyXG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdHRoaXMucGxheWluZyA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBMb2dJdGVtIHtcclxuXHRmcmFtZTogbnVtYmVyO1xyXG5cdGRlbHRhOiBudW1iZXI7XHJcblx0ZXZlbnQ6IEdhbWVFdmVudDtcclxuXHJcblx0Y29uc3RydWN0b3IoZnJhbWU6IG51bWJlciwgZGVsdGFUOiBudW1iZXIsIGV2ZW50OiBHYW1lRXZlbnQpe1xyXG5cdFx0dGhpcy5mcmFtZSA9IGZyYW1lO1xyXG5cdFx0dGhpcy5kZWx0YSA9IGRlbHRhVDtcclxuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSZWdpc3RyeTxUPiBleHRlbmRzIE1hcDxUPntcclxuXHJcbiAgICAvKiogUHJlbG9hZHMgcmVnaXN0cnkgZGF0YSAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IHByZWxvYWQoKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBpdGVtIGFuZCBwcmVsb2FkcyBhbnkgbmVjZXNzYXJ5IGZpbGVzXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gcmVnaXN0ZXIgdGhpcyBpdGVtIHdpdGhcclxuICAgICAqIEBwYXJhbSBhcmdzIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBuZWVkZWQgZm9yIHJlZ2lzdHJhdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShrZXk6IHN0cmluZywgLi4uYXJnczogYW55KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbiBpdGVtIGFuZCBwcmVsb2FkcyBhbnkgbmVjZXNzYXJ5IGZpbGVzXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gcmVnaXN0ZXIgdGhpcyBpdGVtIHdpdGhcclxuICAgICAqIEBwYXJhbSBhcmdzIEFueSBhZGl0aW9uYWwgYXJndW1lbnRzIG5lZWRlZCBmb3IgcmVnaXN0cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCByZWdpc3Rlckl0ZW0oa2V5OiBzdHJpbmcsIC4uLmFyZ3M6IGFueSk6IHZvaWQ7XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgTGFiZWxTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvTGFiZWxTaGFkZXJUeXBlXCI7XHJcbmltcG9ydCBQb2ludFNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9Qb2ludFNoYWRlclR5cGVcIjtcclxuaW1wb3J0IFJlY3RTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUmVjdFNoYWRlclR5cGVcIjtcclxuaW1wb3J0IFNwcml0ZVNoYWRlclR5cGUgZnJvbSBcIi4uLy4uL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9TcHJpdGVTaGFkZXJUeXBlXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJ5XCI7XHJcblxyXG4vKipcclxuICogQSByZWdpc3RyeSB0aGF0IGhhbmRsZXMgc2hhZGVyc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhZGVyUmVnaXN0cnkgZXh0ZW5kcyBSZWdpc3RyeTxTaGFkZXJUeXBlPiB7XHJcblxyXG5cdC8vIFNoYWRlciBuYW1lc1xyXG5cdHB1YmxpYyBzdGF0aWMgUE9JTlRfU0hBREVSID0gXCJwb2ludFwiO1xyXG5cdHB1YmxpYyBzdGF0aWMgUkVDVF9TSEFERVIgPSBcInJlY3RcIjtcclxuXHRwdWJsaWMgc3RhdGljIFNQUklURV9TSEFERVIgPSBcInNwcml0ZVwiO1xyXG5cdHB1YmxpYyBzdGF0aWMgTEFCRUxfU0hBREVSID0gXCJsYWJlbFwiO1xyXG5cclxuXHRwcml2YXRlIHJlZ2lzdHJ5SXRlbXM6IEFycmF5PFNoYWRlclJlZ2lzdHJ5SXRlbT4gPSBuZXcgQXJyYXkoKTtcclxuXHJcblx0LyoqXHJcblx0ICogUHJlbG9hZHMgYWxsIGJ1aWx0LWluIHNoYWRlcnNcclxuXHQgKi9cclxuXHRwdWJsaWMgcHJlbG9hZCgpe1xyXG5cdFx0Ly8gR2V0IHRoZSByZXNvdXJjZU1hbmFnZXIgYW5kIHF1ZXVlIGFsbCBidWlsdC1pbiBzaGFkZXJzIGZvciBwcmVsb2FkaW5nXHJcblx0XHRjb25zdCBybSA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cclxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIHBvaW50IHNoYWRlclxyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlBPSU5UX1NIQURFUiwgUG9pbnRTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9wb2ludC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3BvaW50LmZzaGFkZXJcIik7XHJcblxyXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgcmVjdCBzaGFkZXJcclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5SRUNUX1NIQURFUiwgUmVjdFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3JlY3QudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9yZWN0LmZzaGFkZXJcIik7XHJcblxyXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgc3ByaXRlIHNoYWRlclxyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIsIFNwcml0ZVNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL3Nwcml0ZS52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL3Nwcml0ZS5mc2hhZGVyXCIpO1xyXG5cdFxyXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciB0aGUgbGFiZWwgc2hhZGVyXHJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuTEFCRUxfU0hBREVSLCBMYWJlbFNoYWRlclR5cGUsIFwiYnVpbHRpbi9zaGFkZXJzL2xhYmVsLnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvbGFiZWwuZnNoYWRlclwiKTtcclxuXHJcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIGFueSBwcmVsb2FkZWQgaXRlbXNcclxuXHRcdGZvcihsZXQgaXRlbSBvZiB0aGlzLnJlZ2lzdHJ5SXRlbXMpe1xyXG5cdFx0XHRjb25zdCBzaGFkZXIgPSBuZXcgaXRlbS5jb25zdHIoaXRlbS5rZXkpO1xyXG5cdFx0XHRzaGFkZXIuaW5pdEJ1ZmZlck9iamVjdCgpO1xyXG5cdFx0XHR0aGlzLmFkZChpdGVtLmtleSwgc2hhZGVyKTtcclxuXHJcblx0XHRcdC8vIExvYWQgaWYgZGVzaXJlZFxyXG5cdFx0XHRpZihpdGVtLnByZWxvYWQgIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdFx0cm0uc2hhZGVyKGl0ZW0ua2V5LCBpdGVtLnByZWxvYWQudnNoYWRlckxvY2F0aW9uLCBpdGVtLnByZWxvYWQuZnNoYWRlckxvY2F0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIGEgc2hhZGVyIGluIHRoZSByZWdpc3RyeSBhbmQgbG9hZHMgaXQgYmVmb3JlIHRoZSBnYW1lIGJlZ2luc1xyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB5b3Ugd2lzaCB0byBhc3NpZ24gdG8gdGhlIHNoYWRlclxyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBTaGFkZXJUeXBlXHJcblx0ICogQHBhcmFtIHZzaGFkZXJMb2NhdGlvbiBUaGUgbG9jYXRpb24gb2YgdGhlIHZlcnRleCBzaGFkZXJcclxuXHQgKiBAcGFyYW0gZnNoYWRlckxvY2F0aW9uIHRoZSBsb2NhdGlvbiBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyXHJcblx0ICovXHJcblx0cHVibGljIHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oa2V5OiBzdHJpbmcsIGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGUsIHZzaGFkZXJMb2NhdGlvbjogc3RyaW5nLCBmc2hhZGVyTG9jYXRpb246IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0bGV0IHNoYWRlclByZWxvYWQgPSBuZXcgU2hhZGVyUHJlbG9hZCgpO1xyXG5cdFx0c2hhZGVyUHJlbG9hZC52c2hhZGVyTG9jYXRpb24gPSB2c2hhZGVyTG9jYXRpb247XHJcblx0XHRzaGFkZXJQcmVsb2FkLmZzaGFkZXJMb2NhdGlvbiA9IGZzaGFkZXJMb2NhdGlvbjtcclxuXHJcblx0XHRsZXQgcmVnaXN0cnlJdGVtID0gbmV3IFNoYWRlclJlZ2lzdHJ5SXRlbSgpO1xyXG5cdFx0cmVnaXN0cnlJdGVtLmtleSA9IGtleTtcclxuXHRcdHJlZ2lzdHJ5SXRlbS5jb25zdHIgPSBjb25zdHI7XHJcblx0XHRyZWdpc3RyeUl0ZW0ucHJlbG9hZCA9IHNoYWRlclByZWxvYWQ7XHJcblxyXG5cdFx0dGhpcy5yZWdpc3RyeUl0ZW1zLnB1c2gocmVnaXN0cnlJdGVtKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhIHNoYWRlciBpbiB0aGUgcmVnaXN0cnkuIE5PVEU6IElmIHlvdSB1c2UgdGhpcywgeW91IE1VU1QgbG9hZCB0aGUgc2hhZGVyIGJlZm9yZSB1c2UuXHJcblx0ICogSWYgeW91IHdpc2ggdG8gcHJlbG9hZCB0aGUgc2hhZGVyLCB1c2UgcmVnaXN0ZXJBbmRQcmVsb2FkSXRlbSgpXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IHlvdSB3aXNoIHRvIGFzc2lnbiB0byB0aGUgc2hhZGVyXHJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIFNoYWRlclR5cGVcclxuXHQgKi9cclxuXHRwdWJsaWMgcmVnaXN0ZXJJdGVtKGtleTogc3RyaW5nLCBjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlKTogdm9pZCB7XHJcblx0XHRsZXQgcmVnaXN0cnlJdGVtID0gbmV3IFNoYWRlclJlZ2lzdHJ5SXRlbSgpO1xyXG5cdFx0cmVnaXN0cnlJdGVtLmtleSA9IGtleTtcclxuXHRcdHJlZ2lzdHJ5SXRlbS5jb25zdHIgPSBjb25zdHI7XHJcblxyXG5cdFx0dGhpcy5yZWdpc3RyeUl0ZW1zLnB1c2gocmVnaXN0cnlJdGVtKTtcclxuXHR9XHJcbn1cclxuXHJcbmNsYXNzIFNoYWRlclJlZ2lzdHJ5SXRlbSB7XHJcblx0a2V5OiBzdHJpbmc7XHJcblx0Y29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZTtcclxuXHRwcmVsb2FkOiBTaGFkZXJQcmVsb2FkO1xyXG59XHJcblxyXG5jbGFzcyBTaGFkZXJQcmVsb2FkIHtcclxuXHR2c2hhZGVyTG9jYXRpb246IHN0cmluZztcclxuXHRmc2hhZGVyTG9jYXRpb246IHN0cmluZztcclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJpZXMvUmVnaXN0cnlcIjtcclxuaW1wb3J0IFNoYWRlclJlZ2lzdHJ5IGZyb20gXCIuL1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnlcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUmVnaXN0cnkgaXMgdGhlIHN5c3RlbSdzIHdheSBvZiBjb252ZXJ0aW5nIGNsYXNzZXMgYW5kIHR5cGVzIGludG8gc3RyaW5nXHJcbiAqIHJlcHJlc2VudGF0aW9ucyBmb3IgdXNlIGVsc2V3aGVyZSBpbiB0aGUgYXBwbGljYXRpb24uXHJcbiAqIEl0IGFsbG93cyBjbGFzc2VzIHRvIGJlIGFjY2Vzc2VkIHdpdGhvdXQgZXhwbGljaXRseSB1c2luZyBjb25zdHJ1Y3RvcnMgaW4gY29kZSxcclxuICogYW5kIGZvciByZXNvdXJjZXMgdG8gYmUgbG9hZGVkIGF0IEdhbWUgY3JlYXRpb24gdGltZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZ2lzdHJ5TWFuYWdlciB7XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgc2hhZGVycyA9IG5ldyBTaGFkZXJSZWdpc3RyeSgpO1xyXG5cclxuXHQvKiogQWRkaXRpb25hbCBjdXN0b20gcmVnaXN0cmllcyB0byBhZGQgdG8gdGhlIHJlZ2lzdHJ5IG1hbmFnZXIgKi9cclxuXHRwcm90ZWN0ZWQgc3RhdGljIHJlZ2lzdHJpZXM6IE1hcDxSZWdpc3RyeTxhbnk+PiA9IG5ldyBNYXAoKTtcclxuXHJcblx0c3RhdGljIHByZWxvYWQoKXtcclxuXHRcdHRoaXMuc2hhZGVycy5wcmVsb2FkKCk7XHJcblxyXG5cdFx0dGhpcy5yZWdpc3RyaWVzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB0aGlzLnJlZ2lzdHJpZXMuZ2V0KGtleSkucHJlbG9hZCgpKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBhZGRDdXN0b21SZWdpc3RyeShuYW1lOiBzdHJpbmcsIHJlZ2lzdHJ5OiBSZWdpc3RyeTxhbnk+KXtcclxuXHRcdHRoaXMucmVnaXN0cmllcy5hZGQobmFtZSwgcmVnaXN0cnkpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldFJlZ2lzdHJ5KGtleTogc3RyaW5nKXtcclxuXHRcdHJldHVybiB0aGlzLnJlZ2lzdHJpZXMuZ2V0KGtleSk7XHJcblx0fVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IHsgQW5pbWF0aW9uRGF0YSwgQW5pbWF0aW9uU3RhdGUgfSBmcm9tIFwiLi9BbmltYXRpb25UeXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFuaW1hdGlvbiBtYW5hZ2VyIGNsYXNzIGZvciBhbiBhbmltYXRlZCBDYW52YXNOb2RlLlxyXG4gKiBUaGlzIGNsYXNzIGtlZXBzIHRyYWNrIG9mIHRoZSBwb3NzaWJsZSBhbmltYXRpb25zLCBhcyB3ZWxsIGFzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSxcclxuICogYW5kIGFic3RyYWN0cyBhbGwgaW50ZXJhY3Rpb25zIHdpdGggcGxheWluZywgcGF1c2luZywgYW5kIHN0b3BwaW5nIGFuaW1hdGlvbnMgYXMgd2VsbCBhcyBcclxuICogY3JlYXRpbmcgbmV3IGFuaW1hdGlvbnMgZnJvbSB0aGUgQ2FudmFzTm9kZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbk1hbmFnZXIge1xyXG4gICAgLyoqIFRoZSBvd25lciBvZiB0aGlzIGFuaW1hdGlvbiBtYW5hZ2VyICovXHJcbiAgICBwcm90ZWN0ZWQgb3duZXI6IENhbnZhc05vZGU7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgb2YgdGhpcyBzcHJpdGUgKi9cclxuICAgIHByb3RlY3RlZCBhbmltYXRpb25TdGF0ZTogQW5pbWF0aW9uU3RhdGU7XHJcblxyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBvZiB0aGlzIHNwcml0ZSAqL1xyXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRBbmltYXRpb246IHN0cmluZztcclxuXHJcbiAgICAvKiogVGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhpcyBhbmltYXRpb24gKi9cclxuICAgIHByb3RlY3RlZCBjdXJyZW50RnJhbWU6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIHByb2dyZXNzIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiB0aHJvdWdoIHRoZSBjdXJyZW50IGZyYW1lICovXHJcbiAgICBwcm90ZWN0ZWQgZnJhbWVQcm9ncmVzczogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpcyBsb29waW5nIG9yIG5vdCAqL1xyXG4gICAgcHJvdGVjdGVkIGxvb3A6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBtYXAgb2YgYW5pbWF0aW9ucyAqL1xyXG4gICAgcHJvdGVjdGVkIGFuaW1hdGlvbnM6IE1hcDxBbmltYXRpb25EYXRhPjtcclxuXHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChpZiBhbnkpIHRvIHNlbmQgd2hlbiB0aGUgY3VycmVudCBhbmltYXRpb24gc3RvcHMgcGxheWluZy4gKi9cclxuICAgIHByb3RlY3RlZCBvbkVuZEV2ZW50OiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIFRoZSBldmVudCBlbWl0dGVyIGZvciB0aGlzIGFuaW1hdGlvbiBtYW5hZ2VyICovXHJcbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuXHJcbiAgICAvKiogQSBxdWV1ZWQgYW5pbWF0aW9uICovXHJcbiAgICBwcm90ZWN0ZWQgcGVuZGluZ0FuaW1hdGlvbjogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBUaGUgbG9vcCBzdGF0dXMgb2YgYSBwZW5kaW5nIGFuaW1hdGlvbiAqL1xyXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdMb29wOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgb25FbmQgZXZlbnQgb2YgYSBwZW5kaW5nIGFuaW1hdGlvbiAqL1xyXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdPbkVuZDogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBbmltYXRpb25NYW5hZ2VyXHJcbiAgICAgKiBAcGFyYW0gb3duZXIgVGhlIG93bmVyIG9mIHRoZSBBbmltYXRpb25NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG93bmVyOiBDYW52YXNOb2RlKXtcclxuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gXCJcIjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcclxuICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGFuaW1hdGlvbiB0byB0aGlzIHNwcml0ZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGtleSBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24gZGF0YVxyXG4gICAgICovXHJcbiAgICBhZGQoa2V5OiBzdHJpbmcsIGFuaW1hdGlvbjogQW5pbWF0aW9uRGF0YSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucy5hZGQoa2V5LCBhbmltYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaW5kZXggc3BlY2lmaWVkIGJ5IHRoZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgY3VycmVudCBmcmFtZVxyXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IGluIHRoZSBjdXJyZW50IGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBnZXRJbmRleCgpOiBudW1iZXIge1xyXG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9ucy5oYXModGhpcy5jdXJyZW50QW5pbWF0aW9uKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZ2V0KHRoaXMuY3VycmVudEFuaW1hdGlvbikuZnJhbWVzW3RoaXMuY3VycmVudEZyYW1lXS5pbmRleDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBjdXJyZW50IGFuaW1hdGlvbiwgd2FybiB0aGUgdXNlclxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEFuaW1hdGlvbiBpbmRleCB3YXMgcmVxdWVzdGVkLCBidXQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uOiAke3RoaXMuY3VycmVudEFuaW1hdGlvbn0gd2FzIGludmFsaWRgKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIGlzIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGFuaW1hdGlvbiB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBpcyBwbGF5aW5nLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgaXNQbGF5aW5nKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9PT0ga2V5ICYmIHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGluZGV4IGFuZCBhZHZhbmNlcyB0aGUgYW5pbWF0aW9uIGZyYW1lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICovXHJcbiAgICBnZXRJbmRleEFuZEFkdmFuY2VBbmltYXRpb24oKTogbnVtYmVyIHtcclxuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgcGxheWluZywgd2Ugd29uJ3QgYmUgYWR2YW5jaW5nIHRoZSBhbmltYXRpb25cclxuICAgICAgICBpZighKHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkcpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9ucy5oYXModGhpcy5jdXJyZW50QW5pbWF0aW9uKSl7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50QW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zLmdldCh0aGlzLmN1cnJlbnRBbmltYXRpb24pO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uaW5kZXg7XHJcblxyXG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBhbmltYXRpb25cclxuICAgICAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzICs9IDE7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZnJhbWVQcm9ncmVzcyA+PSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uZHVyYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBiZWVuIG9uIHRoaXMgZnJhbWUgZm9yIGl0cyB3aG9sZSBkdXJhdGlvbiwgZ28gdG8gdGhlIG5leHQgb25lXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRGcmFtZSA+PSBjdXJyZW50QW5pbWF0aW9uLmZyYW1lcy5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoaXMgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5sb29wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ3VycmVudEFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjdXJyZW50IGluZGV4XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBjdXJyZW50IGFuaW1hdGlvbiwgY2FuJ3QgYWR2YW5jZS4gV2FybiB0aGUgdXNlclxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEFuaW1hdGlvbiBpbmRleCBhbmQgYWR2YW5jZSB3YXMgcmVxdWVzdGVkLCBidXQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uICgke3RoaXMuY3VycmVudEFuaW1hdGlvbn0pIGluIG5vZGUgd2l0aCBpZDogJHt0aGlzLm93bmVyLmlkfSB3YXMgaW52YWxpZGApO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEVuZHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCBmaXJlcyBhbnkgbmVjZXNzYXJ5IGV2ZW50cywgYXMgd2VsbCBhcyBzdGFydGluZyBhbnkgbmV3IGFuaW1hdGlvbnMgKi9cclxuICAgIHByb3RlY3RlZCBlbmRDdXJyZW50QW5pbWF0aW9uKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuXHJcbiAgICAgICAgaWYodGhpcy5vbkVuZEV2ZW50ICE9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uRW5kRXZlbnQsIHtvd25lcjogdGhpcy5vd25lci5pZCwgYW5pbWF0aW9uOiB0aGlzLmN1cnJlbnRBbmltYXRpb259KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcGVuZGluZyBhbmltYXRpb24sIHBsYXkgaXRcclxuICAgICAgICBpZih0aGlzLnBlbmRpbmdBbmltYXRpb24gIT09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLnBsYXkodGhpcy5wZW5kaW5nQW5pbWF0aW9uLCB0aGlzLnBlbmRpbmdMb29wLCB0aGlzLnBlbmRpbmdPbkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgdGhlIHNwZWNpZmllZCBhbmltYXRpb24uIERvZXMgbm90IHJlc3RhcnQgaXQgaWYgaXQgaXMgYWxyZWFkeSBwbGF5aW5nXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcGxheVxyXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgYW5pbWF0aW9uLiBGYWxzZSBieSBkZWZhdWx0XHJcbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIG5hbWUgb2YgYW4gZXZlbnQgdG8gc2VuZCB3aGVuIHRoaXMgYW5pbWF0aW9uIG5hdHVyYWxseSBzdG9wcyBwbGF5aW5nLiBUaGlzIG9ubHkgbWF0dGVycyBpZiBsb29wIGlzIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBwbGF5SWZOb3RBbHJlYWR5KGFuaW1hdGlvbjogc3RyaW5nLCBsb29wPzogYm9vbGVhbiwgb25FbmQ/OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLmN1cnJlbnRBbmltYXRpb24gIT09IGFuaW1hdGlvbil7XHJcbiAgICAgICAgICAgIHRoaXMucGxheShhbmltYXRpb24sIGxvb3AsIG9uRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXlcclxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIGFuaW1hdGlvbi4gRmFsc2UgYnkgZGVmYXVsdFxyXG4gICAgICogQHBhcmFtIG9uRW5kIFRoZSBuYW1lIG9mIGFuIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIGFuaW1hdGlvbiBuYXR1cmFsbHkgc3RvcHMgcGxheWluZy4gVGhpcyBvbmx5IG1hdHRlcnMgaWYgbG9vcCBpcyBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgcGxheShhbmltYXRpb246IHN0cmluZywgbG9vcD86IGJvb2xlYW4sIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0aW9uO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLmZyYW1lUHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xyXG5cclxuICAgICAgICAvLyBJZiBsb29wIGFyZyB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0XHJcbiAgICAgICAgaWYobG9vcCAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB3aGF0IHRoZSBqc29uIGZpbGUgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IHRoaXMuYW5pbWF0aW9ucy5nZXQoYW5pbWF0aW9uKS5yZXBlYXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihvbkVuZCAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gb25FbmQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vbkVuZEV2ZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHBlbmRpbmcgYW5pbWF0aW9uXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFF1ZXVlcyBhIHNpbmdsZSBhbmltYXRpb24gdG8gYmUgcGxheWVkIGFmdGVyIHRoZSBjdXJyZW50IG9uZS4gRG9lcyBOT1Qgc3RhY2suXHJcbiAgICAgKiBRdWV1ZWluZyBhZGRpdGlvbmFsIGFuaW1hdGlvbnMgcGFzdCAxIHdpbGwganVzdCByZXBsYWNlIHRoZSBxdWV1ZWQgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIFRoZSBhbmltYXRpb24gdG8gcXVldWVcclxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRoZSBsb29wIHRoZSBxdWV1ZWQgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gb25FbmQgVGhlIGV2ZW50IHRvIGZpcmUgd2hlbiB0aGUgcXVldWVkIGFuaW1hdGlvbiBlbmRzXHJcbiAgICAgKi9cclxuICAgIHF1ZXVlKGFuaW1hdGlvbjogc3RyaW5nLCBsb29wOiBib29sZWFuID0gZmFsc2UsIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gYW5pbWF0aW9uO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0xvb3AgPSBsb29wO1xyXG4gICAgICAgIGlmKG9uRW5kICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdPbkVuZCA9IG9uRW5kO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ09uRW5kID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFBhdXNlcyB0aGUgY3VycmVudCBhbmltYXRpb24gKi9cclxuICAgIHBhdXNlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QQVVTRUQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlc3VtZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlmIHBvc3NpYmxlICovXHJcbiAgICByZXN1bWUoKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUEFVU0VEKXtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlBMQVlJTkc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTdG9wcyB0aGUgY3VycmVudCBhbmltYXRpb24uIFRoZSBhbmltYXRpb24gY2Fubm90IGJlIHJlc3VtZWQgYWZ0ZXIgdGhpcy4gKi9cclxuICAgIHN0b3AoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBUd2VlbmFibGVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCB7IEVhc2VGdW5jdGlvblR5cGUgfSBmcm9tIFwiLi4vLi4vVXRpbHMvRWFzZUZ1bmN0aW9uc1wiO1xyXG5cclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbmV4cG9ydCBlbnVtIEFuaW1hdGlvblN0YXRlIHtcclxuICAgIFNUT1BQRUQgPSAwLFxyXG4gICAgUEFVU0VEID0gMSxcclxuICAgIFBMQVlJTkcgPSAyLFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uRGF0YSB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBmcmFtZXM6IEFycmF5PHtpbmRleDogbnVtYmVyLCBkdXJhdGlvbjogbnVtYmVyfT47XHJcbiAgICByZXBlYXQ6IGJvb2xlYW4gPSBmYWxzZTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFR3ZWVuRWZmZWN0IHtcclxuICAgIC8qKiBUaGUgcHJvcGVydHkgdG8gdHdlZW4gKi9cclxuICAgIHByb3BlcnR5OiBUd2VlbmFibGVQcm9wZXJ0aWVzO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgVHdlZW4gc2hvdWxkIHJlc2V0IHRoZSBwcm9wZXJ0eSB0byBpdHMgb3JpZ2luYWwgdmFsdWUgYWZ0ZXIgcGxheWluZyAqL1xyXG4gICAgcmVzZXRPbkNvbXBsZXRlOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgc3RhcnRpbmcgdmFsdWUgZm9yIHRoZSB0d2VlbiAqL1xyXG4gICAgc3RhcnQ6IGFueTtcclxuXHJcbiAgICAvKiogVGhlIGVuZGluZyB2YWx1ZSBmb3IgdGhlIHR3ZWVuICovXHJcbiAgICBlbmQ6IGFueTtcclxuXHJcbiAgICAvKiogVGhlIGVhc2UgZnVuY3Rpb24gdG8gdXNlICovXHJcbiAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlO1xyXG5cclxuICAgIC8qKiBETyBOT1QgTU9ESUZZIC0gVGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSAtIHNldCBhdXRvbWF0aWNhbGx5ICovXHJcbiAgICBpbml0aWFsVmFsdWU6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFR3ZWVuRGF0YSB7XHJcbiAgICAvLyBNZW1iZXJzIGZvciBpbml0aWFsaXphdGlvbiBieSB0aGUgdXNlclxyXG4gICAgLyoqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHR3ZWVuICovXHJcbiAgICBzdGFydERlbGF5OiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGR1cmF0aW9uIG9mIHRpbWUgb3ZlciB3aGljaCB0aGUgdmFsdWUgd2l0aCBjaGFuZ2UgZnJvbSBzdGFydCB0byBlbmQgKi9cclxuICAgIGR1cmF0aW9uOiBudW1iZXI7XHJcbiAgICAvKiogQW4gYXJyYXkgb2YgdGhlIGVmZmVjdHMgb24gdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCAqL1xyXG4gICAgZWZmZWN0czogQXJyYXk8VHdlZW5FZmZlY3Q+O1xyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gc2hvdWxkIHJldmVyc2UgZnJvbSBlbmQgdG8gc3RhcnQgZm9yIGVhY2ggcHJvcGVydHkgd2hlbiBpdCBmaW5pc2hlcyAqL1xyXG4gICAgcmV2ZXJzZU9uQ29tcGxldGU6IGJvb2xlYW47XHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBzaG91bGQgbG9vcCB3aGVuIGl0IGNvbXBsZXRlcyAqL1xyXG4gICAgbG9vcDogYm9vbGVhbjtcclxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc2VuZCAoaWYgYW55KSB3aGVuIHRoZSB0d2VlbiBmaW5pc2hlcyBwbGF5aW5nICovXHJcbiAgICBvbkVuZDogc3RyaW5nXHJcbiAgICBcclxuICAgIC8vIE1lbWJlcnMgZm9yIG1hbmFnZW1lbnQgYnkgdGhlIHR3ZWVuIG1hbmFnZXJcclxuICAgIC8qKiBUaGUgcHJvZ3Jlc3Mgb2YgdGhpcyB0d2VlbiB0aHJvdWdoIGl0cyBlZmZlY3RzICovXHJcbiAgICBwcm9ncmVzczogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdGhhdCBoYXMgcGFzc2VkIGZyb20gd2hlbiB0aGlzIHR3ZWVuIHN0YXJ0ZWQgcnVubmluZyAqL1xyXG4gICAgZWxhcHNlZFRpbWU6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIHN0YXRlIG9mIHRoaXMgdHdlZW4gKi9cclxuICAgIGFuaW1hdGlvblN0YXRlOiBBbmltYXRpb25TdGF0ZTtcclxuXHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhpcyB0d2VlbiBpcyBjdXJyZW50bHkgcmV2ZXJzaW5nICovXHJcbiAgICByZXZlcnNpbmc6IGJvb2xlYW47XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IHsgQW5pbWF0aW9uU3RhdGUsIFR3ZWVuRGF0YSB9IGZyb20gXCIuL0FuaW1hdGlvblR5cGVzXCI7XHJcbmltcG9ydCBFYXNlRnVuY3Rpb25zIGZyb20gXCIuLi8uLi9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgVHdlZW5NYW5hZ2VyIGZyb20gXCIuL1R3ZWVuTWFuYWdlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1hbmFnZXIgZm9yIHRoZSB0d2VlbnMgb2YgYSBHYW1lTm9kZS5cclxuICogVHdlZW5zIGFyZSBzaG9ydCBhbmltYXRpb25zIHBsYXllZCBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gdHdvIHByb3BlcnRpZXMgdXNpbmcgYW4gZWFzaW5nIGZ1bmN0aW9uLlxyXG4gKiBGb3IgYSBnb29kIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zLCBjaGVjayBvdXQgQGxpbmsoaHR0cHM6Ly9lYXNpbmdzLm5ldC8pKGh0dHBzOi8vZWFzaW5ncy5uZXQvKS5cclxuICogTXVsdGlwbGUgdHdlZW4gY2FuIGJlIHBsYXllZCBhdCB0aGUgc2FtZSB0aW1lLCBhcyBsb25nIGFzIHRoZXkgZG9uJ3QgY2hhbmdlIHRoZSBzYW1lIHByb3BlcnR5LlxyXG4gKiBUaGlzIGFsbG93cyBmb3Igc29tZSBpbnRlcmVzdGluZyBwb2xpc2hlcyBvciBhbmltYXRpb25zIHRoYXQgbWF5IGJlIHZlcnkgZGlmZmljdWx0IHRvIGRvIHdpdGggc3ByaXRlIHdvcmsgYWxvbmVcclxuICogLSBlc3BlY2lhbGx5IHBpeGVsIGFydCAoc3VjaCBhcyByb3RhdGlvbnMgb3Igc2NhbGluZykuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUd2VlbkNvbnRyb2xsZXIge1xyXG4gICAgLyoqIFRoZSBHYW1lTm9kZSB0aGlzIFR3ZWVuQ29udHJvbGxlciBhY3RzIHVwb24gKi9cclxuICAgIHByb3RlY3RlZCBvd25lcjogR2FtZU5vZGU7XHJcbiAgICAvKiogVGhlIGxpc3Qgb2YgY3JlYXRlZCB0d2VlbnMgKi9cclxuICAgIHByb3RlY3RlZCB0d2VlbnM6IE1hcDxUd2VlbkRhdGE+O1xyXG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cclxuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUd2VlbkNvbnRyb2xsZXJcclxuICAgICAqIEBwYXJhbSBvd25lciBUaGUgb3duZXIgb2YgdGhlIFR3ZWVuQ29udHJvbGxlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihvd25lcjogR2FtZU5vZGUpe1xyXG4gICAgICAgIHRoaXMub3duZXIgPSBvd25lcjtcclxuICAgICAgICB0aGlzLnR3ZWVucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cclxuICAgICAgICAvLyBHaXZlIG91cnNlbHZlcyB0byB0aGUgVHdlZW5NYW5hZ2VyXHJcbiAgICAgICAgVHdlZW5NYW5hZ2VyLmdldEluc3RhbmNlKCkucmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGlzIFR3ZWVuQ29udHJvbGxlclxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCl7XHJcbiAgICAgICAgLy8gT25seSB0aGUgZ2FtZW5vZGUgYW5kIHRoZSB0d2VlbiBtYW5hZ2VyIHNob3VsZCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoaXNcclxuICAgICAgICBkZWxldGUgdGhpcy5vd25lci50d2VlbnM7XHJcbiAgICAgICAgVHdlZW5NYW5hZ2VyLmdldEluc3RhbmNlKCkuZGVyZWdpc3RlclR3ZWVuQ29udHJvbGxlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHR3ZWVuIHRvIHRoaXMgZ2FtZSBub2RlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlblxyXG4gICAgICogQHBhcmFtIHR3ZWVuIFRoZSBkYXRhIG9mIHRoZSB0d2VlblxyXG4gICAgICovXHJcbiAgICBhZGQoa2V5OiBzdHJpbmcsIHR3ZWVuOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgVHdlZW5EYXRhKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHR5cGVkVHdlZW4gPSA8VHdlZW5EYXRhPnR3ZWVuO1xyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXplIG1lbWJlcnMgdGhhdCB3ZSBuZWVkIChhbmQgdGhlIHVzZXIgZGlkbid0IHByb3ZpZGUpXHJcbiAgICAgICAgdHlwZWRUd2Vlbi5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdHlwZWRUd2Vlbi5lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgdHlwZWRUd2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XHJcblxyXG4gICAgICAgIHRoaXMudHdlZW5zLmFkZChrZXksIHR5cGVkVHdlZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheSBhIHR3ZWVuIHdpdGggYSBjZXJ0YWluIG5hbWVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHBsYXlcclxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRoZSB0d2VlbiBzaG91bGQgbG9vcFxyXG4gICAgICovXHJcbiAgICBwbGF5KGtleTogc3RyaW5nLCBsb29wPzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcclxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgbG9vcCBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYobG9vcCAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIHR3ZWVuLmxvb3AgPSBsb29wO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIGZvcihsZXQgZWZmZWN0IG9mIHR3ZWVuLmVmZmVjdHMpe1xyXG4gICAgICAgICAgICAgICAgaWYoZWZmZWN0LnJlc2V0T25Db21wbGV0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0LmluaXRpYWxWYWx1ZSA9IHRoaXMub3duZXJbZWZmZWN0LnByb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHR3ZWVuIHJ1bm5pbmdcclxuICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xyXG4gICAgICAgICAgICB0d2Vlbi5lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHR3ZWVuLnByb2dyZXNzID0gMDtcclxuICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUcmllZCB0byBwbGF5IHR3ZWVuIFwiJHtrZXl9XCIgb24gbm9kZSB3aXRoIGlkICR7dGhpcy5vd25lci5pZH0sIGJ1dCBubyBzdWNoIHR3ZWVuIGV4aXN0c2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhdXNlcyBhIHBsYXlpbmcgdHdlZW4uIERvZXMgbm90IGFmZmVjdCB0d2VlbnMgdGhhdCBhcmUgc3RvcHBlZC5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHBhdXNlLlxyXG4gICAgICovXHJcbiAgICBwYXVzZShrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcclxuICAgICAgICAgICAgdGhpcy50d2VlbnMuZ2V0KGtleSkuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QQVVTRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzdW1lcyBhIHBhdXNlZCB0d2Vlbi5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5hbWUgb2YgdGhlIHR3ZWVuIHRvIHJlc3VtZVxyXG4gICAgICovXHJcbiAgICByZXN1bWUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XHJcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZih0d2Vlbi5hbmltYXRpb25TdGF0ZSA9PT0gQW5pbWF0aW9uU3RhdGUuUEFVU0VEKVxyXG4gICAgICAgICAgICAgICAgdHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIGEgY3VycmVudGx5IHBsYXlpbmcgdHdlZW5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdHdlZW5cclxuICAgICAqL1xyXG4gICAgc3RvcChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMudHdlZW5zLmhhcyhrZXkpKXtcclxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIHR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuU1RPUFBFRDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0byB0aGUgaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XHJcbiAgICAgICAgICAgICAgICBpZihlZmZlY3QucmVzZXRPbkNvbXBsZXRlKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV0gPSBlZmZlY3QuaW5pdGlhbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hdHVyYWwgc3RvcCBvZiBhIGN1cnJlbnRseSBwbGF5aW5nIHR3ZWVuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHR3ZWVuXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBlbmQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnN0b3Aoa2V5KTtcclxuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdHdlZW5cclxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBpdCBoYXMgYW4gb25FbmQsIHNlbmQgYW4gZXZlbnRcclxuICAgICAgICAgICAgaWYodHdlZW4ub25FbmQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0d2Vlbi5vbkVuZCwge2tleToga2V5LCBub2RlOiB0aGlzLm93bmVyLmlkfSk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYWxsIGN1cnJlbnRseSBwbGF5aW5nIHR3ZWVuc1xyXG4gICAgICovXHJcbiAgICBzdG9wQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudHdlZW5zLmZvckVhY2goa2V5ID0+IHRoaXMuc3RvcChrZXkpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy50d2VlbnMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYodHdlZW4uYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBMQVlJTkcpe1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyBvZiB0aGUgdHdlZW5cclxuICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lICs9IGRlbHRhVCoxMDAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHBhc3QgdGhlIHN0YXJ0RGVsYXksIGRvIHRoZSB0d2VlblxyXG4gICAgICAgICAgICAgICAgaWYodHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXR3ZWVuLnJldmVyc2luZyAmJiB0d2Vlbi5lbGFwc2VkVGltZSA+PSB0d2Vlbi5zdGFydERlbGF5ICsgdHdlZW4uZHVyYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVyIHRpbWUsIHN0b3AgdGhlIHR3ZWVuLCBsb29wLCBvciByZXZlcnNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2VPbkNvbXBsZXRlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG92ZXIgdGltZSBhbmQgY2FuIHJldmVyc2UsIGRvIHNvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5yZXZlcnNpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHdlZW4ubG9vcCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCByZXZlcnNlIGFuZCBjYW4gbG9vcCwgZG8gc29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLmVsYXBzZWRUaW1lIC09IHR3ZWVuLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlbid0IGxvb3BpbmcgYW5kIGNhbid0IHJldmVyc2UsIHNvIHN0b3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgZW5kIG9mIHJldmVyc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLnJldmVyc2luZyAmJiB0d2Vlbi5lbGFwc2VkVGltZSA+PSB0d2Vlbi5zdGFydERlbGF5ICsgMip0d2Vlbi5kdXJhdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR3ZWVuLmxvb3Ape1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGFwc2VkVGltZSAtPSAyKnR3ZWVuLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcywgbWFrZSBzdXJlIGl0IGlzIGJldHdlZW4gMCBhbmQgMS4gRXJyb3JzIGZyb20gdGhpcyBzaG91bGQgbmV2ZXIgYmUgbGFyZ2VcclxuICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNpbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5wcm9ncmVzcyA9IE1hdGhVdGlscy5jbGFtcDAxKCgyKnR3ZWVuLmR1cmF0aW9uIC0gKHR3ZWVuLmVsYXBzZWRUaW1lLSB0d2Vlbi5zdGFydERlbGF5KSkvdHdlZW4uZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnByb2dyZXNzID0gTWF0aFV0aWxzLmNsYW1wMDEoKHR3ZWVuLmVsYXBzZWRUaW1lIC0gdHdlZW4uc3RhcnREZWxheSkvdHdlZW4uZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBlZmZlY3Qgb2YgdHdlZW4uZWZmZWN0cyl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHZhbHVlIGZyb20gdGhlIGVhc2UgZnVuY3Rpb24gdGhhdCBjb3JyZXNwb25kcyB0byBvdXIgcHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVhc2UgPSBFYXNlRnVuY3Rpb25zW2VmZmVjdC5lYXNlXSh0d2Vlbi5wcm9ncmVzcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHZhbHVlIHRvIGxlcnAgdGhlIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IE1hdGhVdGlscy5sZXJwKGVmZmVjdC5zdGFydCwgZWZmZWN0LmVuZCwgZWFzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBUd2VlbkNvbnRyb2xsZXIgZnJvbSBcIi4vVHdlZW5Db250cm9sbGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUd2Vlbk1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogVHdlZW5NYW5hZ2VyID0gbnVsbDtcclxuICAgIFxyXG4gICAgcHJvdGVjdGVkIHR3ZWVuQ29udHJvbGxlcnM6IEFycmF5PFR3ZWVuQ29udHJvbGxlcj47XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBUd2Vlbk1hbmFnZXIge1xyXG4gICAgICAgIGlmKFR3ZWVuTWFuYWdlci5pbnN0YW5jZSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgIFR3ZWVuTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBUd2Vlbk1hbmFnZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBUd2Vlbk1hbmFnZXIuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIoY29udHJvbGxlcjogVHdlZW5Db250cm9sbGVyKXtcclxuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBkZXJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKGNvbnRyb2xsZXI6IFR3ZWVuQ29udHJvbGxlcil7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy50d2VlbkNvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcik7XHJcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJUd2VlbkNvbnRyb2xsZXJzKCl7XHJcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzID0gbmV3IEFycmF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgZm9yKGxldCB0d2VlbkNvbnRyb2xsZXIgb2YgdGhpcy50d2VlbkNvbnRyb2xsZXJzKXtcclxuICAgICAgICAgICAgdHdlZW5Db250cm9sbGVyLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNcIjtcclxuaW1wb3J0IFBvaW50IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudFwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgR3JhcGhpY1JlbmRlcmVyIGZyb20gXCIuL0NhbnZhc1JlbmRlcmluZy9HcmFwaGljUmVuZGVyZXJcIjtcclxuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4vUmVuZGVyaW5nTWFuYWdlclwiXHJcbmltcG9ydCBUaWxlbWFwUmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL1RpbGVtYXBSZW5kZXJlclwiO1xyXG5pbXBvcnQgVUlFbGVtZW50UmVuZGVyZXIgZnJvbSBcIi4vQ2FudmFzUmVuZGVyaW5nL1VJRWxlbWVudFJlbmRlcmVyXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xyXG5pbXBvcnQgU2xpZGVyIGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlclwiO1xyXG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IExpbmUgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBSZW5kZXJpbmdNYW5hZ2VyIGNsYXNzIHVzaW5nIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc1JlbmRlcmVyIGV4dGVuZHMgUmVuZGVyaW5nTWFuYWdlciB7XHJcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcbiAgICBwcm90ZWN0ZWQgZ3JhcGhpY1JlbmRlcmVyOiBHcmFwaGljUmVuZGVyZXI7XHJcbiAgICBwcm90ZWN0ZWQgdGlsZW1hcFJlbmRlcmVyOiBUaWxlbWFwUmVuZGVyZXI7XHJcbiAgICBwcm90ZWN0ZWQgdWlFbGVtZW50UmVuZGVyZXI6IFVJRWxlbWVudFJlbmRlcmVyO1xyXG5cclxuICAgIHByb3RlY3RlZCBvcmlnaW46IFZlYzI7XHJcbiAgICBwcm90ZWN0ZWQgem9vbTogbnVtYmVyO1xyXG5cclxuICAgIHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKXtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIuc2V0U2NlbmUoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcclxuICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIGluaXRpYWxpemVDYW52YXMoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHRoaXMud29ybGRTaXplID0gbmV3IFZlYzIod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIgPSBuZXcgR3JhcGhpY1JlbmRlcmVyKHRoaXMuY3R4KTtcclxuICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlciA9IG5ldyBUaWxlbWFwUmVuZGVyZXIodGhpcy5jdHgpO1xyXG4gICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIgPSBuZXcgVUlFbGVtZW50UmVuZGVyZXIodGhpcy5jdHgpXHJcblxyXG4gICAgICAgIC8vIEZvciBjcmlzcCBwaXhlbCBhcnRcclxuICAgICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3R4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcmVuZGVyKHZpc2libGVTZXQ6IENhbnZhc05vZGVbXSwgdGlsZW1hcHM6IFRpbGVtYXBbXSwgdWlMYXllcnM6IE1hcDxVSUxheWVyPik6IHZvaWQge1xyXG4gICAgICAgIC8vIFNvcnQgYnkgZGVwdGgsIHRoZW4gYnkgdmlzaWJsZSBzZXQgYnkgeS12YWx1ZVxyXG4gICAgICAgIHZpc2libGVTZXQuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBpZihhLmdldExheWVyKCkuZ2V0RGVwdGgoKSA9PT0gYi5nZXRMYXllcigpLmdldERlcHRoKCkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChhLmJvdW5kYXJ5LmJvdHRvbSkgLSAoYi5ib3VuZGFyeS5ib3R0b20pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpIC0gYi5nZXRMYXllcigpLmdldERlcHRoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHRpbGVtYXBJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IHRpbGVtYXBMZW5ndGggPSB0aWxlbWFwcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGxldCB2aXNpYmxlU2V0SW5kZXggPSAwO1xyXG4gICAgICAgIGxldCB2aXNpYmxlU2V0TGVuZ3RoID0gdmlzaWJsZVNldC5sZW5ndGg7XHJcblxyXG4gICAgICAgIHdoaWxlKHRpbGVtYXBJbmRleCA8IHRpbGVtYXBMZW5ndGggfHwgdmlzaWJsZVNldEluZGV4IDwgdmlzaWJsZVNldExlbmd0aCl7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGNvbmRpdGlvbnMgd2hlcmUgd2UndmUgYWxyZWFkeSByZWFjaGVkIHRoZSBlZGdlIG9mIG9uZSBsaXN0XHJcbiAgICAgICAgICAgIGlmKHRpbGVtYXBJbmRleCA+PSB0aWxlbWFwTGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVuZGVyIHRoZSByZW1haW5pbmcgdmlzaWJsZSBzZXRcclxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLnZpc2libGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih2aXNpYmxlU2V0SW5kZXggPj0gdmlzaWJsZVNldExlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbmRlciB0aWxlbWFwc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlbWFwKHRpbGVtYXBzW3RpbGVtYXBJbmRleCsrXSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVuZGVyIHdoaWNoZXZlciBpcyBmdXJ0aGVyIGRvd25cclxuICAgICAgICAgICAgaWYodGlsZW1hcHNbdGlsZW1hcEluZGV4XS5nZXRMYXllcigpLmdldERlcHRoKCkgPD0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXhdLmdldExheWVyKCkuZ2V0RGVwdGgoKSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGVtYXAodGlsZW1hcHNbdGlsZW1hcEluZGV4KytdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdmlzaWJsZVNldFt2aXNpYmxlU2V0SW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLnZpc2libGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVuZGVyIHRoZSB1aUxheWVycyBvbiB0b3Agb2YgZXZlcnl0aGluZyBlbHNlXHJcbiAgICAgICAgbGV0IHNvcnRlZFVJTGF5ZXJzID0gbmV3IEFycmF5PFVJTGF5ZXI+KCk7XHJcblxyXG4gICAgICAgIHVpTGF5ZXJzLmZvckVhY2goa2V5ID0+IHNvcnRlZFVJTGF5ZXJzLnB1c2godWlMYXllcnMuZ2V0KGtleSkpKTtcclxuXHJcbiAgICAgICAgc29ydGVkVUlMYXllcnMgPSBzb3J0ZWRVSUxheWVycy5zb3J0KCh1aTEsIHVpMikgPT4gdWkxLmdldERlcHRoKCkgLSB1aTIuZ2V0RGVwdGgoKSk7XHJcblxyXG4gICAgICAgIHNvcnRlZFVJTGF5ZXJzLmZvckVhY2godWlMYXllciA9PiB7XHJcblx0XHRcdGlmKCF1aUxheWVyLmlzSGlkZGVuKCkpXHJcblx0XHRcdFx0dWlMYXllci5nZXRJdGVtcygpLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoKDxDYW52YXNOb2RlPm5vZGUpLnZpc2libGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUoPENhbnZhc05vZGU+bm9kZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cdFx0fSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgc3BlY2lmaWVkIENhbnZhc05vZGVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBDYW52YXNOb2RlIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyTm9kZShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0IGFjY29yZGluZyB0byB0aGlzIHNwcml0ZVxyXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24obm9kZSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgem9vbSBsZXZlbCBvZiB0aGUgc2NlbmVcclxuICAgICAgICB0aGlzLnpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE1vdmUgdGhlIGNhbnZhcyB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgYW5kIHJvdGF0ZVxyXG4gICAgICAgIGxldCB4U2NhbGUgPSAxO1xyXG4gICAgICAgIGxldCB5U2NhbGUgPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xyXG4gICAgICAgICAgICB4U2NhbGUgPSBub2RlLmludmVydFggPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHlTY2FsZSA9IG5vZGUuaW52ZXJ0WSA/IC0xIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSh4U2NhbGUsIDAsIDAsIHlTY2FsZSwgKG5vZGUucG9zaXRpb24ueCAtIHRoaXMub3JpZ2luLngpKnRoaXMuem9vbSwgKG5vZGUucG9zaXRpb24ueSAtIHRoaXMub3JpZ2luLnkpKnRoaXMuem9vbSk7XHJcbiAgICAgICAgdGhpcy5jdHgucm90YXRlKC1ub2RlLnJvdGF0aW9uKTtcclxuICAgICAgICBsZXQgZ2xvYmFsQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcclxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgUmVjdCl7XHJcbiAgICAgICAgICAgIERlYnVnLmxvZyhcIm5vZGVcIiArIG5vZGUuaWQsIFwiTm9kZVwiICsgbm9kZS5pZCArIFwiIEFscGhhOiBcIiArIG5vZGUuYWxwaGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IG5vZGUuYWxwaGE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIEFuaW1hdGVkU3ByaXRlKXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJBbmltYXRlZFNwcml0ZSg8QW5pbWF0ZWRTcHJpdGU+bm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNwcml0ZSg8U3ByaXRlPm5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgR3JhcGhpYyl7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyR3JhcGhpYyg8R3JhcGhpYz5ub2RlKTtcclxuICAgICAgICB9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFVJRWxlbWVudCl7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVUlFbGVtZW50KDxVSUVsZW1lbnQ+bm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xyXG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW5kZXJTcHJpdGUoc3ByaXRlOiBTcHJpdGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBHZXQgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlIG1hbmFnZXJcclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRJbWFnZShzcHJpdGUuaW1hZ2VJZCk7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgaW1hZ2U6XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHN0YXJ0IC0+IHgsIHlcclxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc2l6ZSAgLT4gdywgaFxyXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIHdvcmxkXHJcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHN0YXJ0IC0+IHgsIHlcclxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc2l6ZSAgLT4gdywgaFxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxyXG4gICAgICAgICAgICBzcHJpdGUuaW1hZ2VPZmZzZXQueCwgc3ByaXRlLmltYWdlT2Zmc2V0LnksXHJcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLngsIHNwcml0ZS5zaXplLnksXHJcbiAgICAgICAgICAgICgtc3ByaXRlLnNpemUueCpzcHJpdGUuc2NhbGUueC8yKSp0aGlzLnpvb20sICgtc3ByaXRlLnNpemUueSpzcHJpdGUuc2NhbGUueS8yKSp0aGlzLnpvb20sXHJcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLnggKiBzcHJpdGUuc2NhbGUueCp0aGlzLnpvb20sIHNwcml0ZS5zaXplLnkgKiBzcHJpdGUuc2NhbGUueSp0aGlzLnpvb20pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcHJvdGVjdGVkIHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBHZXQgdGhlIGltYWdlIGZyb20gdGhlIHJlc291cmNlIG1hbmFnZXJcclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRJbWFnZShzcHJpdGUuaW1hZ2VJZCk7XHJcblxyXG4gICAgICAgIGxldCBhbmltYXRpb25JbmRleCA9IHNwcml0ZS5hbmltYXRpb24uZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk7XHJcblxyXG4gICAgICAgIGxldCBhbmltYXRpb25PZmZzZXQgPSBzcHJpdGUuZ2V0QW5pbWF0aW9uT2Zmc2V0KGFuaW1hdGlvbkluZGV4KTtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSBpbWFnZTpcclxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc3RhcnQgLT4geCwgeVxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzaXplICAtPiB3LCBoXHJcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgd29ybGQgKGdpdmVuIHdlIG1vdmVkKVxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzdGFydCAtPiAtdy8yLCAtaC8yXHJcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHNpemUgIC0+IHcsIGhcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcclxuICAgICAgICAgICAgc3ByaXRlLmltYWdlT2Zmc2V0LnggKyBhbmltYXRpb25PZmZzZXQueCwgc3ByaXRlLmltYWdlT2Zmc2V0LnkgKyBhbmltYXRpb25PZmZzZXQueSxcclxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCwgc3ByaXRlLnNpemUueSxcclxuICAgICAgICAgICAgKC1zcHJpdGUuc2l6ZS54KnNwcml0ZS5zY2FsZS54LzIpKnRoaXMuem9vbSwgKC1zcHJpdGUuc2l6ZS55KnNwcml0ZS5zY2FsZS55LzIpKnRoaXMuem9vbSxcclxuICAgICAgICAgICAgc3ByaXRlLnNpemUueCAqIHNwcml0ZS5zY2FsZS54KnRoaXMuem9vbSwgc3ByaXRlLnNpemUueSAqIHNwcml0ZS5zY2FsZS55KnRoaXMuem9vbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyR3JhcGhpYyhncmFwaGljOiBHcmFwaGljKTogdm9pZCB7XHJcbiAgICAgICAgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFBvaW50KXtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIucmVuZGVyUG9pbnQoPFBvaW50PmdyYXBoaWMsIHRoaXMuem9vbSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBMaW5lKXtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIucmVuZGVyTGluZSg8TGluZT5ncmFwaGljLCB0aGlzLm9yaWdpbiwgdGhpcy56b29tKTtcclxuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhpYyBpbnN0YW5jZW9mIFJlY3Qpe1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNSZW5kZXJlci5yZW5kZXJSZWN0KDxSZWN0PmdyYXBoaWMsIHRoaXMuem9vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcHJvdGVjdGVkIHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRpbGVtYXAgaW5zdGFuY2VvZiBPcnRob2dvbmFsVGlsZW1hcCl7XHJcbiAgICAgICAgICAgIHRoaXMudGlsZW1hcFJlbmRlcmVyLnJlbmRlck9ydGhvZ29uYWxUaWxlbWFwKDxPcnRob2dvbmFsVGlsZW1hcD50aWxlbWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZCB7XHJcbiAgICAgICAgaWYodWlFbGVtZW50IGluc3RhbmNlb2YgTGFiZWwpe1xyXG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlckxhYmVsKHVpRWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIEJ1dHRvbil7XHJcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyQnV0dG9uKHVpRWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIFNsaWRlcil7XHJcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyU2xpZGVyKHVpRWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIFRleHRJbnB1dCl7XHJcbiAgICAgICAgICAgIHRoaXMudWlFbGVtZW50UmVuZGVyZXIucmVuZGVyVGV4dElucHV0KHVpRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKGNsZWFyQ29sb3I6IENvbG9yKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xyXG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBoZWxwIHRoZSBAcmVmZXJlbmNlW0NhbnZhc1JlbmRlcmVyXSByZW5kZXIgQHJlZmVyZW5jZVtHcmFwaGljXXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYXBoaWNSZW5kZXJlciB7XHJcbiAgICAvKiogVGhlIHJlc291cmNlIG1hbmFnZXIgb2YgdGhlIGdhbWUgZW5naW5lICovXHJcbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcbiAgICAvKiogVGhlIGN1cnJlbnQgc2NlbmUgKi9cclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcbiAgICAvKiogVGhlIHJlbmRlcmluZyBjb250ZXh0ICovXHJcbiAgICBwcm90ZWN0ZWQgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpe1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBvZiB0aGlzIEdyYXBoaWNSZW5kZXJlclxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgKi9cclxuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBwb2ludFxyXG4gICAgICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byByZW5kZXJcclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclBvaW50KHBvaW50OiBQb2ludCwgem9vbTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBwb2ludC5jb2xvci50b1N0cmluZ1JHQkEoKTtcclxuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgoLXBvaW50LnNpemUueC8yKSp6b29tLCAoLXBvaW50LnNpemUueS8yKSp6b29tLFxyXG4gICAgICAgIHBvaW50LnNpemUueCp6b29tLCBwb2ludC5zaXplLnkqem9vbSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyTGluZShsaW5lOiBMaW5lLCBvcmlnaW46IFZlYzIsIHpvb206IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gbGluZS5jb2xvci50b1N0cmluZ1JHQkEoKTtcclxuICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSBsaW5lLnRoaWNrbmVzcztcclxuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKChsaW5lLmVuZC54IC0gbGluZS5zdGFydC54KSp6b29tLCAobGluZS5lbmQueSAtIGxpbmUuc3RhcnQueSkqem9vbSk7XHJcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgcmVjdFxyXG4gICAgICogQHBhcmFtIHJlY3QgVGhlIHJlY3QgdG8gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxyXG4gICAgICovXHJcbiAgICByZW5kZXJSZWN0KHJlY3Q6IFJlY3QsIHpvb206IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIC8vIERyYXcgdGhlIGludGVyaW9yIG9mIHRoZSByZWN0XHJcbiAgICAgICAgaWYocmVjdC5jb2xvci5hICE9PSAwKXtcclxuICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gcmVjdC5jb2xvci50b1N0cmluZ1JHQigpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgoLXJlY3Quc2l6ZS54LzIpKnpvb20sICgtcmVjdC5zaXplLnkvMikqem9vbSwgcmVjdC5zaXplLngqem9vbSwgcmVjdC5zaXplLnkqem9vbSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSBib3JkZXIgb2YgdGhlIHJlY3QgaWYgaXQgaXNuJ3QgdHJhbnNwYXJlbnRcclxuICAgICAgICBpZihyZWN0LmJvcmRlckNvbG9yLmEgIT09IDApe1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHJlY3QuZ2V0Qm9yZGVyQ29sb3IoKS50b1N0cmluZ1JHQigpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSByZWN0LmdldEJvcmRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVJlY3QoKC1yZWN0LnNpemUueC8yKSp6b29tLCAoLXJlY3Quc2l6ZS55LzIpKnpvb20sIHJlY3Quc2l6ZS54Knpvb20sIHJlY3Quc2l6ZS55Knpvb20pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgT3J0aG9nb25hbFRpbGVtYXAgZnJvbSBcIi4uLy4uL05vZGVzL1RpbGVtYXBzL09ydGhvZ29uYWxUaWxlbWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgVGlsZXNldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVzZXRcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3MgZm9yIHRoZSBAcmVmZXJlbmNlW0NhbnZhc1JlbmRlcmVyXSB0byByZW5kZXIgQHJlZmVyZW5jZVtUaWxlbWFwXXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVtYXBSZW5kZXJlciB7XHJcbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG4gICAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBUaWxlbWFwUmVuZGVyZXJcclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBzY2VuZVxyXG4gICAgICovXHJcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGFuIG9ydGhvZ29uYWwgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlck9ydGhvZ29uYWxUaWxlbWFwKHRpbGVtYXA6IE9ydGhvZ29uYWxUaWxlbWFwKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHByZXZpb3VzQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcclxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHRpbGVtYXAuZ2V0TGF5ZXIoKS5nZXRBbHBoYSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aWxlbWFwKTtcclxuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2NlbmUuZ2V0Vmlld3BvcnQoKS5nZXRIYWxmU2l6ZSgpO1xyXG4gICAgICAgIGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuICAgICAgICBsZXQgYm90dG9tUmlnaHQgPSBvcmlnaW4uY2xvbmUoKS5hZGQoc2l6ZS5zY2FsZWQoMip6b29tKSk7XHJcblxyXG4gICAgICAgIGlmKHRpbGVtYXAudmlzaWJsZSl7XHJcbiAgICAgICAgICAgIGxldCBtaW5Db2xSb3cgPSB0aWxlbWFwLmdldENvbFJvd0F0KG9yaWdpbik7XHJcbiAgICAgICAgICAgIGxldCBtYXhDb2xSb3cgPSB0aWxlbWFwLmdldENvbFJvd0F0KGJvdHRvbVJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgeCA9IG1pbkNvbFJvdy54OyB4IDw9IG1heENvbFJvdy54OyB4Kyspe1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCB5ID0gbWluQ29sUm93Lnk7IHkgPD0gbWF4Q29sUm93Lnk7IHkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0aWxlIGF0IHRoaXMgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlsZSA9IHRpbGVtYXAuZ2V0VGlsZUF0Um93Q29sKG5ldyBWZWMyKHgsIHkpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgcm90L2ZsaXAgcGFyYW1ldGVycyBpZiB0aGVyZSBhcmUgYW55XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFzayA9ICgweEUgPDwgMjgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdEZsaXAgPSAoKG1hc2sgJiB0aWxlKSA+PiAyOCkgJiAweEY7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZSA9IHRpbGUgJiB+bWFzaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgdGlsZXNldCB0aGF0IG93bnMgdGhpcyB0aWxlIGluZGV4IGFuZCByZW5kZXJcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZW1hcC5nZXRUaWxlc2V0cygpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGlsZXNldC5oYXNUaWxlKHRpbGUpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZSh0aWxlc2V0LCB0aWxlLCB4LCB5LCBvcmlnaW4sIHRpbGVtYXAuc2NhbGUsIHpvb20sIHJvdEZsaXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHByZXZpb3VzQWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgdGlsZVxyXG4gICAgICogQHBhcmFtIHRpbGVzZXQgVGhlIHRpbGVzZXQgdGhpcyB0aWxlIGJlbG9uZ3MgdG8gXHJcbiAgICAgKiBAcGFyYW0gdGlsZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAgICogQHBhcmFtIHRpbGVtYXBSb3cgVGhlIHJvdyBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIHRpbGVtYXBDb2wgVGhlIGNvbHVtbiBvZiB0aGUgdGlsZSBpbiB0aGUgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIG9yaWdpbiBUaGUgb3JpZ2luIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHNjYWxlIFRoZSBzY2FsZSBvZiB0aGUgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCByZW5kZXJUaWxlKHRpbGVzZXQ6IFRpbGVzZXQsIHRpbGVJbmRleDogbnVtYmVyLCB0aWxlbWFwUm93OiBudW1iZXIsIHRpbGVtYXBDb2w6IG51bWJlciwgb3JpZ2luOiBWZWMyLCBzY2FsZTogVmVjMiwgem9vbTogbnVtYmVyLCByb3RGbGlwOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRJbWFnZSh0aWxlc2V0LmdldEltYWdlS2V5KCkpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHRydWUgaW5kZXhcclxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aWxlc2V0LmdldFN0YXJ0SW5kZXgoKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSByb3cgYW5kIGNvbCBvZiB0aGUgdGlsZSBpbiBpbWFnZSBzcGFjZVxyXG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGlsZXNldC5nZXROdW1Db2xzKCkpO1xyXG4gICAgICAgIGxldCBjb2wgPSBpbmRleCAlIHRpbGVzZXQuZ2V0TnVtQ29scygpO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS54O1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSB0aWxlc2V0LmdldFRpbGVTaXplKCkueTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcclxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xyXG4gICAgICAgIGxldCB0b3AgPSByb3cgKiBoZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gaW4gdGhlIHdvcmxkIHRvIHJlbmRlciB0aGUgdGlsZVxyXG4gICAgICAgIGxldCB4ID0gTWF0aC5mbG9vcih0aWxlbWFwUm93ICogd2lkdGggKiBzY2FsZS54KTtcclxuICAgICAgICBsZXQgeSA9IE1hdGguZmxvb3IodGlsZW1hcENvbCAqIGhlaWdodCAqIHNjYWxlLnkpO1xyXG5cclxuICAgICAgICBsZXQgd29ybGRYID0gTWF0aC5mbG9vcigoeCAtIG9yaWdpbi54KSp6b29tKTtcclxuICAgICAgICBsZXQgd29ybGRZID0gTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSp6b29tKTtcclxuICAgICAgICBsZXQgd29ybGRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHNjYWxlLnggKiB6b29tKTtcclxuICAgICAgICBsZXQgd29ybGRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pO1xyXG5cclxuICAgICAgICBpZihyb3RGbGlwICE9PSAwKXtcclxuICAgICAgICAgICAgbGV0IHNjYWxlWCA9IDE7XHJcbiAgICAgICAgICAgIGxldCBzY2FsZVkgPSAxO1xyXG4gICAgICAgICAgICBsZXQgc2hlYXJYID0gMDtcclxuICAgICAgICAgICAgbGV0IHNoZWFyWSA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBGbGlwIG9uIHRoZSB4LWF4aXNcclxuICAgICAgICAgICAgaWYocm90RmxpcCAmIDgpe1xyXG4gICAgICAgICAgICAgICAgc2NhbGVYID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZsaXAgb24gdGhlIHktYXhpc1xyXG4gICAgICAgICAgICBpZihyb3RGbGlwICYgNCl7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmxpcCBvdmVyIHRoZSBsaW5lIHk9eFxyXG4gICAgICAgICAgICBpZihyb3RGbGlwICYgMil7XHJcbiAgICAgICAgICAgICAgICBzaGVhclggPSBzY2FsZVk7XHJcbiAgICAgICAgICAgICAgICBzaGVhclkgPSBzY2FsZVg7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVggPSAwO1xyXG4gICAgICAgICAgICAgICAgc2NhbGVZID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHNjYWxlWCwgc2hlYXJYLCBzaGVhclksIHNjYWxlWSwgd29ybGRYICsgd29ybGRXaWR0aC8yLCB3b3JsZFkgKyB3b3JsZEhlaWdodC8yKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcclxuICAgICAgICAgICAgICAgIGxlZnQsIHRvcCxcclxuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAtd29ybGRXaWR0aC8yLCAtd29ybGRIZWlnaHQvMixcclxuICAgICAgICAgICAgICAgIHdvcmxkV2lkdGgsIHdvcmxkSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gcm90YXRpb25zLCBkb24ndCBkbyB0aGUgY2FsY3VsYXRpb25zLCBqdXN0IHJlbmRlciB0aGUgdGlsZVxyXG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHRpbGVcclxuICAgICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGltYWdlLFxyXG4gICAgICAgICAgICAgICAgbGVmdCwgdG9wLFxyXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcclxuICAgICAgICAgICAgICAgIHdvcmxkWCwgd29ybGRZLFxyXG4gICAgICAgICAgICAgICAgd29ybGRXaWR0aCwgd29ybGRIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgU2xpZGVyIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlclwiO1xyXG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGhlbHAgdGhlIEByZWZlcmVuY2VbQ2FudmFzUmVuZGVyZXJdIHJlbmRlciBAcmVmZXJlbmNlW1VJRWxlbWVudF1zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVSUVsZW1lbnRSZW5kZXJlciB7XHJcbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG4gICAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBVSUVsZW1lbnRSZW5kZXJlclxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgKi9cclxuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBsYWJlbFxyXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyTGFiZWwobGFiZWw6IExhYmVsKTogdm9pZCB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHNpemUgaXMgdW5hc3NpZ25lZCAoYnkgdGhlIHVzZXIgb3IgYXV0b21hdGljYWxseSkgYXNzaWduIGl0XHJcbiAgICAgICAgbGFiZWwuaGFuZGxlSW5pdGlhbFNpemluZyh0aGlzLmN0eCk7XHJcblx0XHRcclxuXHRcdC8vIEdyYWIgdGhlIGdsb2JhbCBhbHBoYSBzbyB3ZSBjYW4gYWRqdXN0IGl0IGZvciB0aGlzIHJlbmRlclxyXG5cdFx0bGV0IHByZXZpb3VzQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBmb250IGFuZCB0ZXh0IHBvc2l0aW9uIGluIGxhYmVsXHJcblx0XHR0aGlzLmN0eC5mb250ID0gbGFiZWwuZ2V0Rm9udFN0cmluZygpO1xyXG5cdFx0bGV0IG9mZnNldCA9IGxhYmVsLmNhbGN1bGF0ZVRleHRPZmZzZXQodGhpcy5jdHgpO1xyXG5cclxuXHRcdC8vIFN0cm9rZSBhbmQgZmlsbCBhIHJvdW5kZWQgcmVjdCBhbmQgZ2l2ZSBpdCB0ZXh0XHJcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLmJhY2tncm91bmRDb2xvci5hO1xyXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gbGFiZWwuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCkudG9TdHJpbmdSR0JBKCk7XHJcblx0XHR0aGlzLmN0eC5maWxsUm91bmRlZFJlY3QoLWxhYmVsLnNpemUueC8yLCAtbGFiZWwuc2l6ZS55LzIsXHJcblx0XHRcdGxhYmVsLnNpemUueCwgbGFiZWwuc2l6ZS55LCBsYWJlbC5ib3JkZXJSYWRpdXMpO1xyXG5cdFx0XHJcblx0XHR0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZUJvcmRlckNvbG9yKCkudG9TdHJpbmdSR0JBKCk7XHJcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLmJvcmRlckNvbG9yLmE7XHJcblx0XHR0aGlzLmN0eC5saW5lV2lkdGggPSBsYWJlbC5ib3JkZXJXaWR0aDtcclxuXHRcdHRoaXMuY3R4LnN0cm9rZVJvdW5kZWRSZWN0KC1sYWJlbC5zaXplLngvMiwgLWxhYmVsLnNpemUueS8yLFxyXG5cdFx0XHRsYWJlbC5zaXplLngsIGxhYmVsLnNpemUueSwgbGFiZWwuYm9yZGVyUmFkaXVzKTtcclxuXHJcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBsYWJlbC5jYWxjdWxhdGVUZXh0Q29sb3IoKTtcclxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gbGFiZWwudGV4dENvbG9yLmE7XHJcblx0XHR0aGlzLmN0eC5maWxsVGV4dChsYWJlbC50ZXh0LCBvZmZzZXQueCAtIGxhYmVsLnNpemUueC8yLCBvZmZzZXQueSAtIGxhYmVsLnNpemUueS8yKTtcclxuXHRcclxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBidXR0b25cclxuICAgICAqIEBwYXJhbSBidXR0b24gVGhlIGJ1dHRvbiB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyQnV0dG9uKGJ1dHRvbjogQnV0dG9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJMYWJlbChidXR0b24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHNsaWRlclxyXG4gICAgICogQHBhcmFtIHNsaWRlciBUaGUgc2xpZGVyIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJTbGlkZXIoc2xpZGVyOiBTbGlkZXIpOiB2b2lkIHtcclxuXHRcdC8vIEdyYWIgdGhlIGdsb2JhbCBhbHBoYSBzbyB3ZSBjYW4gYWRqdXN0IGl0IGZvciB0aGlzIHJlbmRlclxyXG5cdFx0bGV0IHByZXZpb3VzQWxwaGEgPSB0aGlzLmN0eC5nbG9iYWxBbHBoYTtcclxuXHRcdHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gc2xpZGVyLmdldExheWVyKCkuZ2V0QWxwaGEoKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VhbGF0ZSB0aGUgc2xpZGVyIHNpemVcclxuICAgICAgICBsZXQgc2xpZGVyU2l6ZSA9IG5ldyBWZWMyKHNsaWRlci5zaXplLngsIDIpO1xyXG5cclxuICAgICAgICAvLyBEcmF3IHRoZSBzbGlkZXJcclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNsaWRlci5zbGlkZXJDb2xvci50b1N0cmluZygpO1xyXG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KC1zbGlkZXJTaXplLngvMiwgLXNsaWRlclNpemUueS8yLFxyXG4gICAgICAgICAgICBzbGlkZXJTaXplLngsIHNsaWRlclNpemUueSwgc2xpZGVyLmJvcmRlclJhZGl1cyk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmliIHNpemUgYW5kIHBvc2l0aW9uXHJcbiAgICAgICAgbGV0IHggPSBNYXRoVXRpbHMubGVycCgtc2xpZGVyLnNpemUueC8yLCBzbGlkZXIuc2l6ZS54LzIsIHNsaWRlci5nZXRWYWx1ZSgpKTtcclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aGUgbmliXHJcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBzbGlkZXIubmliQ29sb3IudG9TdHJpbmcoKTtcclxuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCh4LXNsaWRlci5uaWJTaXplLngvMiwgLXNsaWRlci5uaWJTaXplLnkvMixcclxuICAgICAgICAgICAgc2xpZGVyLm5pYlNpemUueCwgc2xpZGVyLm5pYlNpemUueSwgc2xpZGVyLmJvcmRlclJhZGl1cyk7XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHRoZSBhbHBoYVxyXG4gICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcHJldmlvdXNBbHBoYTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSB0ZXh0SW5wdXRcclxuICAgICAqIEBwYXJhbSB0ZXh0SW5wdXQgVGhlIHRleHRJbnB1dCB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyVGV4dElucHV0KHRleHRJbnB1dDogVGV4dElucHV0KTogdm9pZCB7XHJcbiAgICAgICAgLy8gU2hvdyBhIGN1cnNvciBzb21ldGltZXNcclxuICAgICAgICBpZih0ZXh0SW5wdXQuZm9jdXNlZCAmJiB0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciAlIDYwID4gMzApe1xyXG4gICAgICAgICAgICB0ZXh0SW5wdXQudGV4dCArPSBcInxcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWwodGV4dElucHV0KTtcclxuXHJcbiAgICAgICAgaWYodGV4dElucHV0LmZvY3VzZWQpe1xyXG4gICAgICAgICAgICBpZih0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciAlIDYwID4gMzApe1xyXG4gICAgICAgICAgICAgICAgdGV4dElucHV0LnRleHQgPSB0ZXh0SW5wdXQudGV4dC5zdWJzdHJpbmcoMCwgdGV4dElucHV0LnRleHQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyICs9IDE7XHJcbiAgICAgICAgICAgIGlmKHRleHRJbnB1dC5jdXJzb3JDb3VudGVyID49IDYwKXtcclxuICAgICAgICAgICAgICAgIHRleHRJbnB1dC5jdXJzb3JDb3VudGVyID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3QgZnJhbWV3b3JrIHRvIHB1dCBhbGwgcmVuZGVyaW5nIGluIG9uY2UgcGxhY2UgaW4gdGhlIGFwcGxpY2F0aW9uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSZW5kZXJpbmdNYW5hZ2VyIHtcclxuICAgIC8qKiBUaGUgUmVzb3VyY2VNYW5hZ2VyICovXHJcbiAgICBwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSBzY2VuZSBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWQgKi9cclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NlbmUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgU2NlbmVcclxuICAgICAqL1xyXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY2FudmFzIGZvciB0aGUgZ2FtZVxyXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVuZGVyaW5nIGNvbnRleHQgb2YgdGhlIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgdmlzaWJsZSBzZXQgb2YgQ2FudmFzTm9kZXMgYW5kIHZpc2libGUgcG9ydGlvbnMgb2YgdGlsZW1hcHMsIGFzIHdlbGwgYXMgYW55IFVJRWxlbWVudCBpbiBVSUxheWVyc1xyXG4gICAgICogQHBhcmFtIHZpc2libGVTZXQgVGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzXHJcbiAgICAgKiBAcGFyYW0gdGlsZW1hcHMgVGhlIHRpbGVtYXBzIHVzZWQgaW4gdGhlIGFwcGxpY2F0aW9uXHJcbiAgICAgKiBAcGFyYW0gdWlMYXllcnMgVGhlIHVzZXIgaW50ZXJmYWNlIGxheWVyc1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCByZW5kZXIodmlzaWJsZVNldDogQXJyYXk8Q2FudmFzTm9kZT4sIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPiwgdWlMYXllcnM6IE1hcDxVSUxheWVyPik6IHZvaWQ7XHJcblxyXG4gICAgLyoqIENsZWFycyB0aGUgY2FudmFzICovXHJcbiAgICBhYnN0cmFjdCBjbGVhcihjb2xvcjogQ29sb3IpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHNwcml0ZVxyXG4gICAgICogQHBhcmFtIHNwcml0ZSBUaGUgc3ByaXRlIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYW4gYW5pbWF0ZWQgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0gc3ByaXRlIFRoZSBhbmltYXRlZCBzcHJpdGUgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBncmFwaGljXHJcbiAgICAgKiBAcGFyYW0gZ3JhcGhpYyBUaGUgZ3JhcGhpYyB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBVSUVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB1aUVsZW1lbnQgVGhlIFVJRWxlbWVudCB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclVJRWxlbWVudCh1aUVsZW1lbnQ6IFVJRWxlbWVudCk6IHZvaWQ7XHJcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcclxuaW1wb3J0IFBvaW50IGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgU2hhZGVyUmVnaXN0cnkgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvU2hhZGVyUmVnaXN0cnlcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyXCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdVdGlscyBmcm9tIFwiLi4vVXRpbHMvUmVuZGVyaW5nVXRpbHNcIjtcclxuaW1wb3J0IFJlbmRlcmluZ01hbmFnZXIgZnJvbSBcIi4vUmVuZGVyaW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyaW5nTWFuYWdlciB7XHJcblxyXG5cdHByb3RlY3RlZCBvcmlnaW46IFZlYzI7XHJcblx0cHJvdGVjdGVkIHpvb206IG51bWJlcjtcclxuXHRwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xyXG5cclxuXHRwcm90ZWN0ZWQgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcclxuXHRwcm90ZWN0ZWQgdGV4dEN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuXHRpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogV2ViR0xSZW5kZXJpbmdDb250ZXh0IHtcclxuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0dGhpcy53b3JsZFNpemUgPSBWZWMyLlpFUk87XHJcblx0XHR0aGlzLndvcmxkU2l6ZS54ID0gd2lkdGg7XHJcblx0XHR0aGlzLndvcmxkU2l6ZS55ID0gaGVpZ2h0O1xyXG5cclxuXHRcdC8vIEdldCB0aGUgV2ViR0wgY29udGV4dFxyXG4gICAgICAgIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xyXG5cclxuXHRcdHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcblx0XHR0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5ERVBUSF9URVNUKTtcclxuICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcclxuICAgICAgICB0aGlzLmdsLmJsZW5kRnVuYyh0aGlzLmdsLlNSQ19BTFBIQSwgdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkNVTExfRkFDRSk7XHJcblxyXG5cdFx0Ly8gVGVsbCB0aGUgcmVzb3VyY2UgbWFuYWdlciB3ZSdyZSB1c2luZyBXZWJHTFxyXG5cdFx0UmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkudXNlV2ViR0wodHJ1ZSwgdGhpcy5nbCk7XHJcblxyXG5cdFx0Ly8gU2hvdyB0aGUgdGV4dCBjYW52YXMgYW5kIGdldCBpdHMgY29udGV4dFxyXG5cdFx0bGV0IHRleHRDYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXh0LWNhbnZhc1wiKTtcclxuXHRcdHRleHRDYW52YXMuaGlkZGVuID0gZmFsc2U7XHJcblx0XHR0aGlzLnRleHRDdHggPSB0ZXh0Q2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcblx0XHQvLyBTaXplIHRoZSB0ZXh0IGNhbnZhcyB0byBiZSB0aGUgc2FtZSBhcyB0aGUgZ2FtZSBjYW52YXNcclxuXHRcdHRleHRDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0dGV4dENhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nbDtcclxuXHR9XHJcblxyXG5cdHJlbmRlcih2aXNpYmxlU2V0OiBDYW52YXNOb2RlW10sIHRpbGVtYXBzOiBUaWxlbWFwW10sIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4pOiB2b2lkIHtcclxuXHRcdGZvcihsZXQgbm9kZSBvZiB2aXNpYmxlU2V0KXtcclxuXHRcdFx0dGhpcy5yZW5kZXJOb2RlKG5vZGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHVpTGF5ZXJzLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0aWYoIXVpTGF5ZXJzLmdldChrZXkpLmlzSGlkZGVuKCkpXHJcblx0XHRcdFx0dWlMYXllcnMuZ2V0KGtleSkuZ2V0SXRlbXMoKS5mb3JFYWNoKG5vZGUgPT4gdGhpcy5yZW5kZXJOb2RlKDxDYW52YXNOb2RlPm5vZGUpKVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRjbGVhcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuZ2wuY2xlYXJDb2xvcihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBjb2xvci5hKTtcclxuXHRcdHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUIHwgdGhpcy5nbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuXHJcblx0XHR0aGlzLnRleHRDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud29ybGRTaXplLngsIHRoaXMud29ybGRTaXplLnkpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlbmRlck5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xyXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0IGFjY29yZGluZyB0byB0aGlzIHNwcml0ZVxyXG4gICAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24obm9kZSk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgem9vbSBsZXZlbCBvZiB0aGUgc2NlbmVcclxuICAgICAgICB0aGlzLnpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xyXG5cdFx0XHJcblx0XHRpZihub2RlLmhhc0N1c3RvbVNoYWRlcil7XHJcblx0XHRcdC8vIElmIHRoZSBub2RlIGhhcyBhIGN1c3RvbSBzaGFkZXIsIHJlbmRlciB1c2luZyB0aGF0XHJcblx0XHRcdHRoaXMucmVuZGVyQ3VzdG9tKG5vZGUpO1xyXG5cdFx0fSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBHcmFwaGljKXtcclxuXHRcdFx0dGhpcy5yZW5kZXJHcmFwaGljKG5vZGUpO1xyXG5cdFx0fSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBTcHJpdGUpe1xyXG5cdFx0XHRpZihub2RlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xyXG5cdFx0XHRcdHRoaXMucmVuZGVyQW5pbWF0ZWRTcHJpdGUobm9kZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5yZW5kZXJTcHJpdGUobm9kZSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgVUlFbGVtZW50KXtcclxuXHRcdFx0dGhpcy5yZW5kZXJVSUVsZW1lbnQobm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZCB7XHJcblx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlNQUklURV9TSEFERVIpO1xyXG5cdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoc3ByaXRlKSwgc3ByaXRlKTtcclxuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQge1xyXG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSKTtcclxuXHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHNwcml0ZSksIHNwcml0ZSk7XHJcblx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQge1xyXG5cclxuXHRcdGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBQb2ludCl7XHJcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuUE9JTlRfU0hBREVSKTtcclxuXHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoZ3JhcGhpYyksIGdyYXBoaWMpO1xyXG5cdFx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBSZWN0KSB7XHJcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuUkVDVF9TSEFERVIpO1xyXG5cdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhncmFwaGljKSwgZ3JhcGhpYyk7XHJcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcblx0XHR9IFxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlbmRlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgcmVuZGVyVUlFbGVtZW50KHVpRWxlbWVudDogVUlFbGVtZW50KTogdm9pZCB7XHJcblx0XHRpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBMYWJlbCl7XHJcblx0XHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuTEFCRUxfU0hBREVSKTtcclxuXHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnModWlFbGVtZW50KSwgdWlFbGVtZW50KTtcclxuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHJcblx0XHRcdHRoaXMudGV4dEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgKHVpRWxlbWVudC5wb3NpdGlvbi54IC0gdGhpcy5vcmlnaW4ueCkqdGhpcy56b29tLCAodWlFbGVtZW50LnBvc2l0aW9uLnkgLSB0aGlzLm9yaWdpbi55KSp0aGlzLnpvb20pO1xyXG5cdFx0XHR0aGlzLnRleHRDdHgucm90YXRlKC11aUVsZW1lbnQucm90YXRpb24pO1xyXG5cdFx0XHRsZXQgZ2xvYmFsQWxwaGEgPSB0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGE7XHJcblx0XHRcdHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYSA9IHVpRWxlbWVudC5hbHBoYTtcclxuXHJcblx0XHRcdC8vIFJlbmRlciB0ZXh0XHJcblx0XHRcdHRoaXMudGV4dEN0eC5mb250ID0gdWlFbGVtZW50LmdldEZvbnRTdHJpbmcoKTtcclxuXHRcdFx0bGV0IG9mZnNldCA9IHVpRWxlbWVudC5jYWxjdWxhdGVUZXh0T2Zmc2V0KHRoaXMudGV4dEN0eCk7XHJcblx0XHRcdHRoaXMudGV4dEN0eC5maWxsU3R5bGUgPSB1aUVsZW1lbnQuY2FsY3VsYXRlVGV4dENvbG9yKCk7XHJcblx0XHRcdHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYSA9IHVpRWxlbWVudC50ZXh0Q29sb3IuYTtcclxuXHRcdFx0dGhpcy50ZXh0Q3R4LmZpbGxUZXh0KHVpRWxlbWVudC50ZXh0LCBvZmZzZXQueCAtIHVpRWxlbWVudC5zaXplLngvMiwgb2Zmc2V0LnkgLSB1aUVsZW1lbnQuc2l6ZS55LzIpO1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhID0gZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgXHR0aGlzLnRleHRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlbmRlckN1c3RvbShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XHJcblx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KG5vZGUuY3VzdG9tU2hhZGVyS2V5KTtcclxuXHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKG5vZGUpLCBub2RlKTtcclxuXHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgYWRkT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBub2RlOiBDYW52YXNOb2RlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcblx0XHQvLyBHaXZlIHRoZSBzaGFkZXIgYWNjZXNzIHRvIHRoZSB3b3JsZCBzaXplXHJcblx0XHRvcHRpb25zLndvcmxkU2l6ZSA9IHRoaXMud29ybGRTaXplO1xyXG5cclxuXHRcdC8vIEFkanVzdCB0aGUgb3JpZ2luIHBvc2l0aW9uIHRvIHRoZSBwYXJhbGxheFxyXG5cdFx0bGV0IGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xyXG5cdFx0bGV0IHBhcmFsbGF4ID0gbmV3IFZlYzIoMSwgMSk7XHJcblx0XHRpZihsYXllciBpbnN0YW5jZW9mIFBhcmFsbGF4TGF5ZXIpe1xyXG5cdFx0XHRwYXJhbGxheCA9ICg8UGFyYWxsYXhMYXllcj5sYXllcikucGFyYWxsYXg7XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucy5vcmlnaW4gPSB0aGlzLm9yaWdpbi5jbG9uZSgpLm11bHQocGFyYWxsYXgpO1xyXG5cclxuXHRcdHJldHVybiBvcHRpb25zO1xyXG5cdH1cclxuXHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHdyYXBwZXIgY2xhc3MgZm9yIFdlYkdMIHNoYWRlcnMuXHJcbiAqIFRoaXMgY2xhc3MgaXMgYSBzaW5nbGV0b24sIGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBmb3IgZWFjaCBzaGFkZXIgdHlwZS5cclxuICogQWxsIG9iamVjdHMgdGhhdCB1c2UgdGhpcyBzaGFkZXIgdHlwZSB3aWxsIHJlZmVyIHRvIGFuZCBtb2RpZnkgdGhpcyBzYW1lIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTaGFkZXJUeXBlIHtcclxuXHQvKiogVGhlIG5hbWUgb2YgdGhpcyBzaGFkZXIgKi9cclxuXHRwcm90ZWN0ZWQgbmFtZTogc3RyaW5nO1xyXG5cclxuXHQvKiogVGhlIGtleSB0byB0aGUgV2ViR0xQcm9ncmFtIGluIHRoZSBSZXNvdXJjZU1hbmFnZXIgKi9cclxuXHRwcm90ZWN0ZWQgcHJvZ3JhbUtleTogc3RyaW5nO1xyXG5cclxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIHJlc291cmNlIG1hbmFnZXIgKi9cclxuXHRwcm90ZWN0ZWQgcmVzb3VyY2VNYW5hZ2VyOiBSZXNvdXJjZU1hbmFnZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XHJcblx0XHR0aGlzLnByb2dyYW1LZXkgPSBwcm9ncmFtS2V5O1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVzIGFueSBidWZmZXIgb2JqZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzaGFkZXIgdHlwZS5cclxuXHQgKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICovXHJcblx0YWJzdHJhY3QgaW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBMb2FkcyBhbnkgdW5pZm9ybXNcclxuXHQgKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICogQHBhcmFtIG9wdGlvbnMgSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9iamVjdCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nXHJcblx0ICovXHJcblx0YWJzdHJhY3QgcmVuZGVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBFeHRyYWN0cyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBDYW52YXNOb2RlIGFuZCBnaXZlcyB0aGVtIHRvIHRoZSByZW5kZXIgZnVuY3Rpb25cclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBnZXQgb3B0aW9ucyBmcm9tXHJcblx0ICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wdGlvbnMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSByZW5kZXIgZnVuY3Rpb25cclxuXHQgKi9cclxuXHRnZXRPcHRpb25zKG5vZGU6IENhbnZhc05vZGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtyZXR1cm4ge307fVxyXG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsU2hhZGVyVHlwZSBleHRlbmRzIFF1YWRTaGFkZXJUeXBlIHtcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XHJcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwibGFiZWxcIjtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblx0fVxyXG5cclxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG5cdFx0Y29uc3QgYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IudG9XZWJHTCgpO1xyXG5cdFx0Y29uc3QgYm9yZGVyQ29sb3IgPSBvcHRpb25zLmJvcmRlckNvbG9yLnRvV2ViR0woKTtcclxuXHJcblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHJcblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xyXG5cclxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLmdldFZlcnRpY2VzKG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cclxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuXHRcdC8vIEF0dHJpYnV0ZXNcclxuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xyXG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XHJcblxyXG5cdFx0Ly8gVW5pZm9ybXNcclxuXHRcdGNvbnN0IHVfQmFja2dyb3VuZENvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9CYWNrZ3JvdW5kQ29sb3JcIik7XHJcblx0XHRnbC51bmlmb3JtNGZ2KHVfQmFja2dyb3VuZENvbG9yLCBiYWNrZ3JvdW5kQ29sb3IpO1xyXG5cclxuICAgICAgICBjb25zdCB1X0JvcmRlckNvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJDb2xvclwiKTtcclxuXHRcdGdsLnVuaWZvcm00ZnYodV9Cb3JkZXJDb2xvciwgYm9yZGVyQ29sb3IpO1xyXG5cclxuICAgICAgICBjb25zdCB1X01heFNpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X01heFNpemVcIik7XHJcbiAgICAgICAgZ2wudW5pZm9ybTJmKHVfTWF4U2l6ZSwgLXZlcnRleERhdGFbMF0sIHZlcnRleERhdGFbMV0pO1xyXG5cclxuXHRcdC8vIEdldCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuXHRcdC8vIFdlIHdhbnQgYSBzcXVhcmUgZm9yIG91ciByZW5kZXJpbmcgc3BhY2UsIHNvIGdldCB0aGUgbWF4aW11bSBkaW1lbnNpb24gb2Ygb3VyIHF1YWRcclxuXHRcdGxldCBtYXhEaW1lbnNpb24gPSBNYXRoLm1heChvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnkpO1xyXG5cclxuICAgICAgICBjb25zdCB1X0JvcmRlcldpZHRoID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJXaWR0aFwiKTtcclxuXHRcdGdsLnVuaWZvcm0xZih1X0JvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoL21heERpbWVuc2lvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyUmFkaXVzID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Cb3JkZXJSYWRpdXNcIik7XHJcblx0XHRnbC51bmlmb3JtMWYodV9Cb3JkZXJSYWRpdXMsIG9wdGlvbnMuYm9yZGVyUmFkaXVzL21heERpbWVuc2lvbik7XHJcblxyXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxyXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xyXG5cclxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xyXG5cclxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xyXG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcclxuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xyXG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XHJcblxyXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XHJcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcclxuXHJcblx0XHQvLyBEcmF3IHRoZSBxdWFkXHJcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSByZW5kZXJpbmcgc3BhY2UgYWx3YXlzIGhhcyB0byBiZSBhIHNxdWFyZSwgc28gbWFrZSBzdXJlIGl0cyBzcXVhcmUgdy5yLnQgdG8gdGhlIGxhcmdlc3QgZGltZW5zaW9uXHJcblx0ICogQHBhcmFtIHcgVGhlIHdpZHRoIG9mIHRoZSBxdWFkIGluIHBpeGVsc1xyXG5cdCAqIEBwYXJhbSBoIFRoZSBoZWlnaHQgb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIHZlcnRpY2VzIG9mIHRoZSBxdWFkXHJcblx0ICovXHJcblx0Z2V0VmVydGljZXModzogbnVtYmVyLCBoOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0bGV0IHgsIHk7XHJcblxyXG5cdFx0aWYoaCA+IHcpe1xyXG5cdFx0XHR5ID0gMC41O1xyXG5cdFx0XHR4ID0gdy8oMipoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHggPSAwLjU7XHJcblx0XHRcdHkgPSBoLygyKncpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcclxuXHRcdFx0LXgsICB5LFxyXG5cdFx0XHQteCwgLXksXHJcblx0XHRcdCB4LCAgeSxcclxuXHRcdFx0IHgsIC15XHJcblx0XHRdKTtcclxuXHR9XHJcblxyXG5cdGdldE9wdGlvbnMocmVjdDogTGFiZWwpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcclxuXHRcdGxldCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xyXG5cdFx0XHRwb3NpdGlvbjogcmVjdC5wb3NpdGlvbixcclxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiByZWN0LmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogcmVjdC5jYWxjdWxhdGVCb3JkZXJDb2xvcigpLFxyXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogcmVjdC5ib3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiByZWN0LmJvcmRlclJhZGl1cyxcclxuXHRcdFx0c2l6ZTogcmVjdC5zaXplLFxyXG5cdFx0XHRyb3RhdGlvbjogcmVjdC5yb3RhdGlvblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvcHRpb25zO1xyXG5cdH1cclxufSIsImltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IFBvaW50IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdVdGlscyBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvUmVuZGVyaW5nVXRpbHNcIjtcclxuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4uL1NoYWRlclR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50U2hhZGVyVHlwZSBleHRlbmRzIFNoYWRlclR5cGUge1xyXG5cclxuXHRwcm90ZWN0ZWQgYnVmZmVyT2JqZWN0S2V5OiBzdHJpbmc7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcclxuXHR9XHJcblxyXG5cdGluaXRCdWZmZXJPYmplY3QoKTogdm9pZCB7XHJcblx0XHR0aGlzLmJ1ZmZlck9iamVjdEtleSA9IFwicG9pbnRcIjtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblx0fVxyXG5cclxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG5cdFx0bGV0IHBvc2l0aW9uID0gUmVuZGVyaW5nVXRpbHMudG9XZWJHTENvb3JkcyhvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLm9yaWdpbiwgb3B0aW9ucy53b3JsZFNpemUpO1xyXG5cdFx0bGV0IGNvbG9yID0gUmVuZGVyaW5nVXRpbHMudG9XZWJHTENvbG9yKG9wdGlvbnMuY29sb3IpO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHBvc2l0aW9uO1xyXG5cclxuXHRcdGNvbnN0IEZTSVpFID0gdmVydGV4RGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcblx0XHQvLyBCaW5kIHRoZSBidWZmZXJcclxuXHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG5cdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRleERhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcblx0XHQvLyBBdHRyaWJ1dGVzXHJcblx0XHRjb25zdCBhX1Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1Bvc2l0aW9uXCIpO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1Bvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiBGU0laRSwgMCAqIEZTSVpFKTtcclxuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFfUG9zaXRpb24pO1xyXG5cclxuXHRcdC8vIFVuaWZvcm1zXHJcblx0XHRjb25zdCB1X0NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Db2xvclwiKTtcclxuXHRcdGdsLnVuaWZvcm00ZnYodV9Db2xvciwgY29sb3IpO1xyXG5cclxuXHRcdGNvbnN0IHVfUG9pbnRTaXplID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9Qb2ludFNpemVcIik7XHJcblx0XHRnbC51bmlmb3JtMWYodV9Qb2ludFNpemUsIG9wdGlvbnMucG9pbnRTaXplKTtcclxuXHJcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgMSk7XHJcblx0fVxyXG5cclxuXHRnZXRPcHRpb25zKHBvaW50OiBQb2ludCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcblx0XHRcdHBvc2l0aW9uOiBwb2ludC5wb3NpdGlvbixcclxuXHRcdFx0Y29sb3I6IHBvaW50LmNvbG9yLFxyXG5cdFx0XHRwb2ludFNpemU6IHBvaW50LnNpemUsXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xyXG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vU2hhZGVyVHlwZVwiO1xyXG5cclxuLyoqIFJlcHJlc2VudHMgYW55IFdlYkdMIG9iamVjdHMgdGhhdCBoYXZlIGEgcXVhZCBtZXNoIChpLmUuIGEgcmVjdGFuZ3VsYXIgZ2FtZSBvYmplY3QgY29tcG9zZWQgb2Ygb25seSB0d28gdHJpYW5nbGVzKSAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBRdWFkU2hhZGVyVHlwZSBleHRlbmRzIFNoYWRlclR5cGUge1xyXG5cdC8qKiBUaGUga2V5IHRvIHRoZSBidWZmZXIgb2JqZWN0IGZvciB0aGlzIHNoYWRlciAqL1xyXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcclxuXHJcblx0LyoqIFRoZSBzY2FsZSBtYXRyaWMgKi9cclxuXHRwcm90ZWN0ZWQgc2NhbGU6IE1hdDR4NDtcclxuXHJcblx0LyoqIFRoZSByb3RhdGlvbiBtYXRyaXggKi9cclxuXHRwcm90ZWN0ZWQgcm90YXRpb246IE1hdDR4NDtcclxuXHJcblx0LyoqIFRoZSB0cmFuc2xhdGlvbiBtYXRyaXggKi9cclxuXHRwcm90ZWN0ZWQgdHJhbnNsYXRpb246IE1hdDR4NDtcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cclxuXHRcdHRoaXMuc2NhbGUgPSBNYXQ0eDQuSURFTlRJVFk7XHJcblx0XHR0aGlzLnJvdGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xyXG5cdFx0dGhpcy50cmFuc2xhdGlvbiA9IE1hdDR4NC5JREVOVElUWTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBRdWFkU2hhZGVyVHlwZSBmcm9tIFwiLi9RdWFkU2hhZGVyVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdFNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblx0fVxyXG5cclxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInJlY3RcIjtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblx0fVxyXG5cclxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG5cdFx0Y29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yLnRvV2ViR0woKTtcclxuXHJcblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHJcblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xyXG5cclxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLmdldFZlcnRpY2VzKG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cclxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuXHRcdC8vIEF0dHJpYnV0ZXNcclxuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xyXG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XHJcblxyXG5cdFx0Ly8gVW5pZm9ybXNcclxuXHRcdGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTRmdih1X0NvbG9yLCBjb2xvcik7XHJcblxyXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxyXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxyXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xyXG5cclxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xyXG5cclxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xyXG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcclxuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xyXG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XHJcblxyXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XHJcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcclxuXHJcblx0XHQvLyBEcmF3IHRoZSBxdWFkXHJcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcclxuXHR9XHJcblxyXG5cclxuXHQvKlxyXG5cdFx0U28gYXMgaXQgdHVybnMgb3V0LCBXZWJHTCBoYXMgYW4gaXNzdWUgd2l0aCBub24tc3F1YXJlIHF1YWRzLlxyXG5cdFx0SXQgZG9lc24ndCBsaWtlIHdoZW4geW91IGRvbid0IGhhdmUgYSAxLTEgc2NhbGUsIGFuZCByb3RhdGlvbnMgYXJlIGVudGlyZWx5IG1lc3NlZCB1cCBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZS5cclxuXHRcdFRvIHNvbHZlIHRoaXMsIEkgdXNlZCB0aGUgc2NhbGUgb2YgdGhlIExBUkdFU1QgZGltZW5zaW9uIG9mIHRoZSBxdWFkIHRvIG1ha2UgYSBzcXVhcmUsIHRoZW4gYWRqdXN0ZWQgdGhlIHZlcnRleCBjb29yZGluYXRlcyBpbnNpZGUgb2YgdGhhdC5cclxuXHRcdEEgZGlhZ3JhbSBvZiB0aGUgc29sdXRpb24gZm9sbG93cy5cclxuXHJcblx0XHRUaGVyZSBpcyBhIGJvdW5kaW5nIHNxdWFyZSBmb3IgdGhlIHF1YWQgd2l0aCBkaW1lbnNpb25zIGh4aCAoaW4gdGhpcyBjYXNlLCBzaW5jZSBoZWlnaHQgaXMgdGhlIGxhcmdlc3QgZGltZW5zaW9uKS5cclxuXHRcdFRoZSBvZmZzZXQgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbiBpcyB0aGVyZWZvcmUgMC41LCBhcyBpdCBpcyBub3JtYWxseS5cclxuXHRcdEhvd2V2ZXIsIHRoZSBvZmZzZXQgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uIGlzIG5vdCBzbyBzdHJhaWdodGZvcndhcmQsIGJ1dCBpc24ndCBjb25jZXB0dWFsbHkgaGFyZC5cclxuXHRcdEFsbCB3ZSByZWFsbHkgaGF2ZSB0byBkbyBpcyBhIHJhbmdlIGNoYW5nZSBmcm9tIFswLCBoZWlnaHQvMl0gdG8gWzAsIDAuNV0sIHdoZXJlIG91ciB2YWx1ZSBpcyB0ID0gd2lkdGgvMiwgYW5kIDAgPD0gdCA8PSBoZWlnaHQvMi5cclxuXHJcblx0XHRTbyBub3cgd2UgaGF2ZSBvdXIgcmVjdCwgaW4gYSBzcGFjZSBzY2FsZWQgd2l0aCByZXNwZWN0IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvbi5cclxuXHRcdFJvdGF0aW9ucyB3b3JrIGFzIHlvdSB3b3VsZCBleHBlY3QsIGV2ZW4gZm9yIGxvbmcgcmVjdGFuZ2xlcy5cclxuXHJcblx0XHRcdFx0XHQwLjVcclxuXHRcdFx0X18gX18gX18gX18gX18gX18gX19cclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHRcdC0wLjV8XyBffDg4ODg4ODg4ODg4fF8gX3wwLjVcclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHQgIFx0XHR8X19ffDg4ODg4ODg4ODg4fF9fX3xcclxuXHRcdFx0ICBcdFx0LTAuNVxyXG5cclxuXHRcdFRoZSBnZXRWZXJ0aWNlcyBmdW5jdGlvbiBiZWxvdyBkb2VzIGFzIGRlc2NyaWJlZCwgYW5kIGNvbnZlcnRzIHRoZSByYW5nZVxyXG5cdCovXHJcblx0LyoqXHJcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcclxuXHQgKi9cclxuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRsZXQgeCwgeTtcclxuXHJcblx0XHRpZihoID4gdyl7XHJcblx0XHRcdHkgPSAwLjU7XHJcblx0XHRcdHggPSB3LygyKmgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9IDAuNTtcclxuXHRcdFx0eSA9IGgvKDIqdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHQteCwgIHksXHJcblx0XHRcdC14LCAteSxcclxuXHRcdFx0IHgsICB5LFxyXG5cdFx0XHQgeCwgLXlcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0Z2V0T3B0aW9ucyhyZWN0OiBSZWN0KTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuXHRcdFx0cG9zaXRpb246IHJlY3QucG9zaXRpb24sXHJcblx0XHRcdGNvbG9yOiByZWN0LmNvbG9yLFxyXG5cdFx0XHRzaXplOiByZWN0LnNpemUsXHJcblx0XHRcdHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcclxuXHJcbi8qKiBBIHNoYWRlciBmb3Igc3ByaXRlcyBhbmQgYW5pbWF0ZWQgc3ByaXRlcyAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xyXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblx0fVxyXG5cclxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInNwcml0ZVwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRUZXh0dXJlKG9wdGlvbnMuaW1hZ2VLZXkpO1xyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55LCBvcHRpb25zLnNjYWxlKTtcclxuXHJcblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG5cdFx0Ly8gQXR0cmlidXRlc1xyXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogRlNJWkUsIDAgKiBGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcclxuXHJcblx0XHRjb25zdCBhX1RleENvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1RleENvb3JkXCIpO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1RleENvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiBGU0laRSwgMipGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1RleENvb3JkKTtcclxuXHJcblx0XHQvLyBVbmlmb3Jtc1xyXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxyXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxyXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xyXG5cclxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xyXG5cclxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xyXG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcclxuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xyXG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XHJcblxyXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XHJcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcclxuXHJcblx0XHQvLyBTZXQgdXAgb3VyIHNhbXBsZXIgd2l0aCBvdXIgYXNzaWduZWQgdGV4dHVyZSB1bml0XHJcblx0XHRjb25zdCB1X1NhbXBsZXIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1NhbXBsZXJcIik7XHJcblx0XHRnbC51bmlmb3JtMWkodV9TYW1wbGVyLCB0ZXh0dXJlKTtcclxuXHJcblx0XHQvLyBQYXNzIGluIHRleFNoaWZ0XHJcblx0XHRjb25zdCB1X3RleFNoaWZ0ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXhTaGlmdFwiKTtcclxuXHRcdGdsLnVuaWZvcm0yZnYodV90ZXhTaGlmdCwgb3B0aW9ucy50ZXhTaGlmdCk7XHJcblxyXG5cdFx0Ly8gUGFzcyBpbiB0ZXhTY2FsZVxyXG5cdFx0Y29uc3QgdV90ZXhTY2FsZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4U2NhbGVcIik7XHJcblx0XHRnbC51bmlmb3JtMmZ2KHVfdGV4U2NhbGUsIG9wdGlvbnMudGV4U2NhbGUpO1xyXG5cclxuXHRcdC8vIERyYXcgdGhlIHF1YWRcclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcclxuXHQgKi9cclxuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlciwgc2NhbGU6IEZsb2F0MzJBcnJheSk6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRsZXQgeCwgeTtcclxuXHJcblx0XHRpZihoID4gdyl7XHJcblx0XHRcdHkgPSAwLjU7XHJcblx0XHRcdHggPSB3LygyKmgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9IDAuNTtcclxuXHRcdFx0eSA9IGgvKDIqdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2NhbGUgdGhlIHJlbmRlcmluZyBzcGFjZSBpZiBuZWVkZWRcclxuXHRcdHggKj0gc2NhbGVbMF07XHJcblx0XHR5ICo9IHNjYWxlWzFdO1xyXG5cclxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcclxuXHRcdFx0LXgsICB5LCAwLjAsIDAuMCxcclxuXHRcdFx0LXgsIC15LCAwLjAsIDEuMCxcclxuXHRcdFx0IHgsICB5LCAxLjAsIDAuMCxcclxuXHRcdFx0IHgsIC15LCAxLjAsIDEuMFxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRnZXRPcHRpb25zKHNwcml0ZTogU3ByaXRlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcblx0XHRsZXQgdGV4U2hpZnQ7XHJcblx0XHRsZXQgdGV4U2NhbGU7XHJcblxyXG5cdFx0aWYoc3ByaXRlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xyXG5cdFx0XHRsZXQgYW5pbWF0aW9uSW5kZXggPSBzcHJpdGUuYW5pbWF0aW9uLmdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpO1xyXG5cdFx0XHRsZXQgb2Zmc2V0ID0gc3ByaXRlLmdldEFuaW1hdGlvbk9mZnNldChhbmltYXRpb25JbmRleCk7XHJcblx0XHRcdHRleFNoaWZ0ID0gbmV3IEZsb2F0MzJBcnJheShbb2Zmc2V0LnggLyAoc3ByaXRlLmNvbHMgKiBzcHJpdGUuc2l6ZS54KSwgb2Zmc2V0LnkgLyAoc3ByaXRlLnJvd3MgKiBzcHJpdGUuc2l6ZS55KV0pO1xyXG5cdFx0XHR0ZXhTY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEvKHNwcml0ZS5jb2xzKSwgMS8oc3ByaXRlLnJvd3MpXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0ZXhTaGlmdCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKTtcclxuXHRcdFx0dGV4U2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAxXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcblx0XHRcdHBvc2l0aW9uOiBzcHJpdGUucG9zaXRpb24sXHJcblx0XHRcdHJvdGF0aW9uOiBzcHJpdGUucm90YXRpb24sXHJcblx0XHRcdHNpemU6IHNwcml0ZS5zaXplLFxyXG5cdFx0XHRzY2FsZTogc3ByaXRlLnNjYWxlLnRvQXJyYXkoKSxcclxuXHRcdFx0aW1hZ2VLZXk6IHNwcml0ZS5pbWFnZUlkLFxyXG5cdFx0XHR0ZXhTaGlmdCxcclxuXHRcdFx0dGV4U2NhbGVcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xyXG5pbXBvcnQgU3RyaW5nVXRpbHMgZnJvbSBcIi4uL1V0aWxzL1N0cmluZ1V0aWxzXCI7XHJcbmltcG9ydCBBdWRpb01hbmFnZXIgZnJvbSBcIi4uL1NvdW5kL0F1ZGlvTWFuYWdlclwiO1xyXG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xyXG5pbXBvcnQgV2ViR0xQcm9ncmFtVHlwZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1JlbmRlcmluZy9XZWJHTFByb2dyYW1UeXBlXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlc291cmNlIG1hbmFnZXIgZm9yIHRoZSBnYW1lIGVuZ2luZS5cclxuICogVGhlIHJlc291cmNlIG1hbmFnZXIgaW50ZXJmYWNlcyB3aXRoIHRoZSBsb2FkYWJsZSBhc3NldHMgb2YgYSBnYW1lIHN1Y2ggYXMgaW1hZ2VzLCBkYXRhIGZpbGVzLFxyXG4gKiBhbmQgc291bmRzLCB3aGljaCBhcmUgYWxsIGZvdW5kIGluIHRoZSBkaXN0IGZvbGRlci5cclxuICogVGhpcyBjbGFzcyBjb250cm9scyBsb2FkaW5nIGFuZCB1cGRhdGVzIHRoZSBAcmVmZXJlbmNlW1NjZW5lXSB3aXRoIHRoZSBsb2FkaW5nIHByb2dyZXNzLCBzbyB0aGF0IHRoZSBzY2VuZSBkb2VzIFxyXG4gKiBub3Qgc3RhcnQgYmVmb3JlIGFsbCBuZWNlc3NhcnkgYXNzZXRzIGFyZSBsb2FkZWQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNvdXJjZU1hbmFnZXIge1xyXG4gICAgLy8gSW5zdGFuY2UgZm9yIHRoZSBzaW5nbGV0b24gY2xhc3NcclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBSZXNvdXJjZU1hbmFnZXI7XHJcbiAgICBcclxuICAgIC8vIEJvb2xlYW5zIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBvciBub3QgdGhlIFJlc291cmNlTWFuYWdlciBpcyBjdXJyZW50bHkgbG9hZGluZyBzb21ldGhpbmdcclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCBhbnkgcmVzb3VyY2VzIGFyZSBsb2FkaW5nICovXHJcbiAgICBwcml2YXRlIGxvYWRpbmc6IGJvb2xlYW47XHJcbiAgICAvKiogQSBib29sZWFuIHRvIGluZGljYXRlIHRoYXQgdGhlIGFzc2V0cyBqdXN0IGZpbmlzaGVkIGxvYWRpbmcgKi9cclxuICAgIHByaXZhdGUganVzdExvYWRlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBGdW5jdGlvbnMgdG8gZG8gc29tZXRoaW5nIHdoZW4gbG9hZGluZyBwcm9ncmVzc2VzIG9yIGlzIGNvbXBsZXRlZCBzdWNoIGFzIHJlbmRlciBhIGxvYWRpbmcgc2NyZWVuXHJcbiAgICAvKiogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGxvYWRpbmcgcHJvZ3Jlc3NlcyAqL1xyXG4gICAgcHVibGljIG9uTG9hZFByb2dyZXNzOiBGdW5jdGlvbjtcclxuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBjb21wbGV0ZXMgKi9cclxuICAgIHB1YmxpYyBvbkxvYWRDb21wbGV0ZTogRnVuY3Rpb247XHJcblxyXG5cclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBpbWFnZXMgbmVlZCB0byBiZSBsb2FkZWQqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZXNMb2FkZWQ6IG51bWJlcjtcclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBpbWFnZXMgYXJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZXNUb0xvYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgcXVldWUgb2YgaW1hZ2VzIHdlIG11c3QgbG9hZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xyXG4gICAgLyoqIEEgbWFwIG9mIHRoZSBpbWFnZXMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUuIFRoZSByZWZlcmVuY2UgdG8gdGhlc2UgaW1hZ2VzIG9ubHkgZXhpc3QgaGVyZSBmb3IgZWFzeSBjbGVhbnVwLiAqL1xyXG4gICAgcHJpdmF0ZSBpbWFnZXM6IE1hcDxIVE1MSW1hZ2VFbGVtZW50PjtcclxuXHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkOiBudW1iZXI7XHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgcXVldWUgb2YgdGlsZW1hcHMgd2UgbXVzdCBsb2FkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICAvKiogQSBtYXAgb2YgdGhlIHRpbGVtYXBzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xyXG4gICAgcHJpdmF0ZSBzcHJpdGVzaGVldHM6IE1hcDxTcHJpdGVzaGVldD47XHJcblxyXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIG5lZWQgdG8gYmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkOiBudW1iZXI7XHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwc1RvTG9hZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBxdWV1ZSBvZiB0aWxlbWFwcyB3ZSBtdXN0IGxvYWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xyXG4gICAgLyoqIEEgbWFwIG9mIHRoZSB0aWxlbWFwcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cclxuICAgIHByaXZhdGUgdGlsZW1hcHM6IE1hcDxUaWxlZFRpbGVtYXBEYXRhPjtcclxuXHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgc291bmRzIG5lZWQgdG8gYmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvTG9hZGVkOiBudW1iZXI7XHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgc291bmRzIGFyZSBsb2FkZWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Ub0xvYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgcXVldWUgb2Ygc291bmRzIHdlIG11c3QgbG9hZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xyXG4gICAgLyoqIEEgbWFwIG9mIHRoZSBzb3VuZHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXHJcbiAgICBwcml2YXRlIGF1ZGlvQnVmZmVyczogTWFwPEF1ZGlvQnVmZmVyPjtcclxuXHJcbiAgICAvKiogVGhlIHRvdGFsIG51bWJlciBvZiBcInR5cGVzXCIgb2YgdGhpbmdzIHRoYXQgbmVlZCB0byBiZSBsb2FkZWQgKGkuZS4gaW1hZ2VzIGFuZCB0aWxlbWFwcykgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfdHlwZXNUb0xvYWQ6IG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkZWQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgbG9hZG9ubHlfanNvblRvTG9hZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICBwcml2YXRlIGpzb25PYmplY3RzOiBNYXA8UmVjb3JkPHN0cmluZywgYW55Pj47XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBJTkZPUk1BVElPTiBTUEVDSUFMIFRPIFdFQkdMICMjIyMjIyMjIyMgKi9cclxuICAgIHByaXZhdGUgZ2xfV2ViR0xBY3RpdmU6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhfU2hhZGVyPjtcclxuXHJcbiAgICBwcml2YXRlIGdsX1NoYWRlclByb2dyYW1zOiBNYXA8V2ViR0xQcm9ncmFtVHlwZT47XHJcblxyXG4gICAgcHJpdmF0ZSBnbF9UZXh0dXJlczogTWFwPG51bWJlcj47XHJcbiAgICBwcml2YXRlIGdsX05leHRUZXh0dXJlSUQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgZ2xfQnVmZmVyczogTWFwPFdlYkdMQnVmZmVyPjsgXHJcblxyXG4gICAgcHJpdmF0ZSBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG5cclxuICAgIC8qICMjIyMjIyMjIyMgVU5MT0FESU5HIEFORCBFWENMVVNJT04gTElTVCAjIyMjIyMjIyMjICovXHJcbiAgICAvKiogQSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IHdpbGwgYmUgdW5sb2FkZWQgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzY2VuZSAqL1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZXNUb1VubG9hZDogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xyXG5cclxuICAgIC8qKiBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGtlZXAgdW50aWwgZnVydGhlciBub3RpY2UgKi9cclxuICAgIHByaXZhdGUgcmVzb3VyY2VzVG9LZWVwOiBBcnJheTxSZXNvdXJjZVJlZmVyZW5jZT47XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICB0aGlzLmltYWdlcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkID0gMDtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuanNvbk9iamVjdHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5nbF9OZXh0VGV4dHVyZUlEID0gMDtcclxuICAgICAgICB0aGlzLmdsX0J1ZmZlcnMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnJlc291cmNlc1RvS2VlcCA9IG5ldyBBcnJheSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFNJTkdMRVRPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgZXhpc3RcclxuICAgICAqIEByZXR1cm5zIFRoZSByZXNvdXJjZSBtYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBSZXNvdXJjZU1hbmFnZXIge1xyXG4gICAgICAgIGlmKCF0aGlzLmluc3RhbmNlKXtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSZXNvdXJjZU1hbmFnZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgUFVCTElDIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgb3IgZGVhY3RpdmF0ZXMgdGhlIHVzZSBvZiBXZWJHTFxyXG4gICAgICogQHBhcmFtIGZsYWcgVHJ1ZSBpZiBXZWJHTCBzaG91bGQgYmUgdXNlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGluc3RhbmNlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LCBpZiBhcHBsaWNhYmxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VXZWJHTChmbGFnOiBib29sZWFuLCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5nbF9XZWJHTEFjdGl2ZSA9IGZsYWc7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xyXG4gICAgICAgICAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYW4gaW1hZ2UgZnJvbSBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHRoZSBsb2FkZWQgaW1hZ2Ugd2l0aFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGltYWdlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGltYWdlKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGtlZXBJbWFnZShrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBpbWFnZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgaW1hZ2VcclxuICAgICAqIEByZXR1cm5zIFRoZSBpbWFnZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SW1hZ2Uoa2V5OiBzdHJpbmcpOiBIVE1MSW1hZ2VFbGVtZW50IHtcclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmltYWdlcy5nZXQoa2V5KTtcclxuICAgICAgICBpZihpbWFnZSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5pbWFnZXMpO1xyXG4gICAgICAgICAgICB0aHJvdyBgVGhlcmUgaXMgbm8gaW1hZ2UgYXNzb2NpYXRlZCB3aXRoIGtleSBcIiR7a2V5fVwiYFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNwcml0ZXNoZWV0IGZyb20gZmlsZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB0aGUgbG9hZGVkIHNwcml0ZXNoZWV0IHdpdGhcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzcHJpdGVzaGVldChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBrZWVwU3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgc3ByaXRlc2hlZXRcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxyXG4gICAgICogQHJldHVybnMgVGhlIGxvYWRlZCBTcHJpdGVzaGVldFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0U3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcpOiBTcHJpdGVzaGVldCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc2hlZXRzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYW4gYXVkaW8gZmlsZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgYXVkaW8gZmlsZVxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYXVkaW8oa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICAgcHVibGljIGtlZXBBdWRpbyhrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvQnVmZmVyIGNyZWF0ZWQgZnJvbSB0aGUgbG9hZGVkIGF1ZGlvIGZsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXVkaW8oa2V5OiBzdHJpbmcpOiBBdWRpb0J1ZmZlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9CdWZmZXJzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhIHRpbGVtYXAgZnJvbSBhIGpzb24gZmlsZS4gQXV0b21hdGljYWxseSBsb2FkcyByZWxhdGVkIGltYWdlc1xyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdGlsZW1hcChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgIHB1YmxpYyBrZWVwVGlsZW1hcChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLlRJTEVNQVApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmVpdmVzIGEgbG9hZGVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIHRpbGVtYXBcclxuICAgICAqIEByZXR1cm5zIFRoZSB0aWxlbWFwIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRpbGVtYXAoa2V5OiBzdHJpbmcpOiBUaWxlZFRpbGVtYXBEYXRhIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aWxlbWFwcy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFuIG9iamVjdCBmcm9tIGEganNvbiBmaWxlLlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBsb2FkZWQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUganNvbiBmaWxlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9iamVjdChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nKXtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICAgcHVibGljIGtlZXBPYmplY3Qoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5KU09OKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJlaXZlcyBhIGxvYWRlZCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIG9iamVjdFxyXG4gICAgICogQHJldHVybnMgVGhlIG9iamVjdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRPYmplY3Qoa2V5OiBzdHJpbmcpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmpzb25PYmplY3RzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgTE9BRCBGVU5DVElPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIHJlc291cmNlcyBjdXJyZW50bHkgaW4gdGhlIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbCB3aGVuIHRoZSByZXNvdXJjZXMgYXJlIGZpbmlzaGVkIGxvYWRpbmdcclxuICAgICAqL1xyXG4gICAgbG9hZFJlc291cmNlc0Zyb21RdWV1ZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3R5cGVzVG9Mb2FkID0gNTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gTG9hZCBldmVyeXRoaW5nIGluIHRoZSBxdWV1ZXMuIFRpbGVtYXBzIGhhdmUgdG8gY29tZSBiZWZvcmUgaW1hZ2VzIGJlY2F1c2UgdGhleSB3aWxsIGFkZCBuZXcgaW1hZ2VzIHRvIHRoZSBxdWV1ZVxyXG4gICAgICAgIHRoaXMubG9hZFRpbGVtYXBzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgVGlsZW1hcHNcIik7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFNwcml0ZXNoZWV0c0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBTcHJpdGVzaGVldHNcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRJbWFnZXNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIEltYWdlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRBdWRpb0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIEF1ZGlvXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRPYmplY3RzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIE9iamVjdHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xfTG9hZFNoYWRlcnNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBTaGFkZXJzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmcoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICAvLyBEb25lIGxvYWRpbmdcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmp1c3RMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBVTkxPQUQgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXHJcbiAgICBcclxuICAgIHByaXZhdGUga2VlcFJlc291cmNlKGtleTogc3RyaW5nLCB0eXBlOiBSZXNvdXJjZVR5cGUpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIktlZXAgcmVzb3VyY2UuLi5cIik7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucmVzb3VyY2VzVG9VbmxvYWQubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1RvVW5sb2FkW2ldO1xyXG4gICAgICAgICAgICBpZihyZXNvdXJjZS5rZXkgPT09IGtleSAmJiByZXNvdXJjZS5yZXNvdXJjZVR5cGUgPT09IHR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCByZXNvdXJjZSBcIiArIGtleSArIFwiIG9mIHR5cGUgXCIgKyB0eXBlICsgXCIuIEtlZXBpbmcuXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlVG9Nb3ZlID0gdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvS2VlcC5wdXNoKC4uLnJlc291cmNlVG9Nb3ZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHJlZmVyZW5jZXMgdG8gYWxsIHJlc291cmNlcyBpbiB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgICovXHJcbiAgICB1bmxvYWRBbGxSZXNvdXJjZXMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvcihsZXQgcmVzb3VyY2Ugb2YgdGhpcy5yZXNvdXJjZXNUb1VubG9hZCl7XHJcbiAgICAgICAgICAgIC8vIFVubG9hZCB0aGUgcmVzb3VyY2VcclxuICAgICAgICAgICAgdGhpcy51bmxvYWRSZXNvdXJjZShyZXNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdW5sb2FkUmVzb3VyY2UocmVzb3VyY2U6IFJlc291cmNlUmVmZXJlbmNlKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRGVsZXRlIHRoZSByZXNvdXJjZSBpdHNlbGZcclxuICAgICAgICBzd2l0Y2gocmVzb3VyY2UucmVzb3VyY2VUeXBlKXtcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuSU1BR0U6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuVElMRU1BUDpcclxuICAgICAgICAgICAgICAgIHRoaXMudGlsZW1hcHMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNoZWV0cy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5BVURJTzpcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLkpTT046XHJcbiAgICAgICAgICAgICAgICB0aGlzLmpzb25PYmplY3RzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLlNIQURFUjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KHJlc291cmNlLmtleSkuZGVsZXRlKHRoaXMuZ2wpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVsZXRlIGFueSBkZXBlbmRlbmNpZXNcclxuICAgICAgICBmb3IobGV0IGRlcGVuZGVuY3kgb2YgcmVzb3VyY2UuZGVwZW5kZW5jaWVzKXtcclxuICAgICAgICAgICAgdGhpcy51bmxvYWRSZXNvdXJjZShkZXBlbmRlbmN5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBXT1JLIEZVTkNUSU9OUyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIHRpbGVtYXBzIGN1cnJlbnRseSBpbiB0aGUgdGlsZW1hcCBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gbG9hZGluZyBpcyBjb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvYWRUaWxlbWFwc0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIGxldCB0aWxlbWFwID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkVGlsZW1hcCh0aWxlbWFwLmtleSwgdGlsZW1hcC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgdGlsZW1hcCBcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgdGlsZW1hcFxyXG4gICAgICogQHBhcmFtIHBhdGhUb1RpbGVtYXBKU09OIFRoZSBwYXRoIHRvIHRoZSB0aWxlbWFwIEpTT04gZmlsZVxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZFRpbGVtYXAoa2V5OiBzdHJpbmcsIHBhdGhUb1RpbGVtYXBKU09OOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHBhdGhUb1RpbGVtYXBKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdGlsZW1hcE9iamVjdCA9IDxUaWxlZFRpbGVtYXBEYXRhPkpTT04ucGFyc2UoZmlsZVRleHQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gV2UgY2FuIHBhcnNlIHRoZSBvYmplY3QgbGF0ZXIgLSBpdCdzIG11Y2ggZmFzdGVyIHRoYW4gbG9hZGluZ1xyXG4gICAgICAgICAgICB0aGlzLnRpbGVtYXBzLmFkZChrZXksIHRpbGVtYXBPYmplY3QpO1xyXG4gICAgICAgICAgICBsZXQgcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuVElMRU1BUCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSB0aWxlc2V0IGltYWdlcyB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBpbWFnZWxvYWRpbmcgcXVldWVcclxuICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXBPYmplY3QudGlsZXNldHMpe1xyXG4gICAgICAgICAgICAgICAgaWYodGlsZXNldC5pbWFnZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IHRpbGVzZXQuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1RpbGVtYXBKU09OKSArIGtleTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgaW1hZ2UgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0aWxlbWFwXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aWxlc2V0LnRpbGVzKXtcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGUgb2YgdGlsZXNldC50aWxlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aWxlLmltYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvVGlsZW1hcEpTT04pICsga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRoLCBpc0RlcGVuZGVuY3k6IHRydWV9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGltYWdlIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgdGlsZW1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZXNvdXJjZSByZWZlcmVuY2UgdG8gdGhlIGxpc3Qgb2YgcmVzb3VyY2UgdG8gdW5sb2FkXHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChyZXNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZ1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdUaWxlbWFwKGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGEgdGlsZW1hcC4gQ2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCBiZWluZyBsb2FkZWRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHRpbGVtYXAgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdUaWxlbWFwKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV90aWxlbWFwc1RvTG9hZCl7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyB0aWxlbWFwc1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFsbCBzcHJpdGVzaGVldHMgY3VycmVudGx5IGluIHRoZSBzcHJpdGVzaGVldCBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHNwcml0ZXNoZWV0cyBhcmUgZG9uZSBsb2FkaW5nXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZFNwcml0ZXNoZWV0c0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQgPT09IDApe1xyXG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgbGV0IHNwcml0ZXNoZWV0ID0gdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldExvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFNwcml0ZXNoZWV0KHNwcml0ZXNoZWV0LmtleSwgc3ByaXRlc2hlZXQucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIHNwcml0ZXNoZWV0IFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzcHJpdGVzaGVldCB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gcGF0aFRvU3ByaXRlc2hlZXRKU09OIFRoZSBwYXRoIHRvIHRoZSBzcHJpdGVzaGVldCBKU09OIGZpbGVcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZFNwcml0ZXNoZWV0KGtleTogc3RyaW5nLCBwYXRoVG9TcHJpdGVzaGVldEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aFRvU3ByaXRlc2hlZXRKU09OLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3ByaXRlc2hlZXQgPSA8U3ByaXRlc2hlZXQ+SlNPTi5wYXJzZShmaWxlVGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBXZSBjYW4gcGFyc2UgdGhlIG9iamVjdCBsYXRlciAtIGl0J3MgbXVjaCBmYXN0ZXIgdGhhbiBsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc2hlZXRzLmFkZChrZXksIHNwcml0ZXNoZWV0KTtcclxuXHJcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5TUFJJVEVTSEVFVCk7XHJcblxyXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSBpbWFnZSB3ZSBuZWVkIHRvIGxvYWQgYW5kIGFkZCBpdCB0byB0aGUgaW1hZ2Vsb2FkaW5nIHF1ZXVlXHJcbiAgICAgICAgICAgIGxldCBwYXRoID0gU3RyaW5nVXRpbHMuZ2V0UGF0aEZyb21GaWxlUGF0aChwYXRoVG9TcHJpdGVzaGVldEpTT04pICsgc3ByaXRlc2hlZXQuc3ByaXRlU2hlZXRJbWFnZTtcclxuICAgICAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IHNwcml0ZXNoZWV0Lm5hbWUsIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xyXG5cclxuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRGVwZW5kZW5jeShuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoc3ByaXRlc2hlZXQubmFtZSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChyZXNvdXJjZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZ1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdTcHJpdGVzaGVldChjYWxsYmFja0lmTGFzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhIHNwcml0ZXNoZWV0LiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaWYgdGhpcyBpcyB0aGUgbGFzdCBzcHJpdGVzaGVldCBiZWluZyBsb2FkZWRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0IHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nU3ByaXRlc2hlZXQoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHNwcml0ZXNoZWV0c1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFsbCBpbWFnZXMgY3VycmVudGx5IGluIHRoZSBpbWFnZSBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgaW1hZ2VzIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkSW1hZ2VzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2UoaW1hZ2Uua2V5LCBpbWFnZS5wYXRoLCBpbWFnZS5pc0RlcGVuZGVuY3ksIG9uRmluaXNoTG9hZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciBpbWFnZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgaW1hZ2UgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRJbWFnZShrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBpc0RlcGVuZGVuY3k6IGJvb2xlYW4sIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0byBsb2FkZWQgaW1hZ2VzXHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLmFkZChrZXksIGltYWdlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vdCBhIGRlcGVuZGVuY3ksIHB1c2ggaXQgdG8gdGhlIHVubG9hZCBsaXN0LiBPdGhlcndpc2UgaXQncyBtYW5hZ2VkIGJ5IHNvbWV0aGluZyBlbHNlXHJcbiAgICAgICAgICAgIGlmKCFpc0RlcGVuZGVuY3kpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBXZWJHTCBpcyBhY3RpdmUsIGNyZWF0ZSBhIHRleHR1cmVcclxuICAgICAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVdlYkdMVGV4dHVyZShrZXksIGltYWdlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmluaXNoIGltYWdlIGxvYWRcclxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW1hZ2Uuc3JjID0gcGF0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIGltYWdlLiBJZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlLCBpdCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGltYWdlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ0ltYWdlKGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZCApe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgaW1hZ2VzXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIGF1ZGlvIGN1cnJlbnRseSBpbiB0aGUgdGlsZW1hcCBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGlsZW1hcHMgYXJlIGRvbmUgbG9hZGluZ1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvYWRBdWRpb0Zyb21RdWV1ZShvbkZpbmlzaExvYWRpbmc6IEZ1bmN0aW9uKXtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICBsZXQgYXVkaW8gPSB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQXVkaW8oYXVkaW8ua2V5LCBhdWRpby5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBzaW5ndWxhciBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZEF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIGxldCBhdWRpb0N0eCA9IEF1ZGlvTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEF1ZGlvQ29udGV4dCgpO1xyXG5cclxuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG5cclxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgYXVkaW9DdHguZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIChidWZmZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsaXN0IG9mIGF1ZGlvIGJ1ZmZlcnNcclxuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkFVRElPKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmcgc291bmRcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ0F1ZGlvKGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICAgICAgfSwgKGVycm9yKSA9PntcclxuICAgICAgICAgICAgICAgIHRocm93IFwiRXJyb3IgbG9hZGluZyBzb3VuZFwiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBhdWRpbyBmaWxlLiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3RvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIHNhbXBsZSBiZWluZyBsb2FkZWQuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBmaWxlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIGF1ZGlvXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIG9iamVjdHMgY3VycmVudGx5IGluIHRoZSBvYmplY3QgbG9hZGluZyBxdWV1ZVxyXG4gICAgICogQHBhcmFtIG9uRmluaXNoTG9hZGluZyBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIG9iamVjdHMgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvYWRPYmplY3RzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPSB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkID09PSAwKXtcclxuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZE9iamVjdChvYmoua2V5LCBvYmoucGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIG9iamVjdFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIG9iamVjdCB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgcHVibGljIGxvYWRPYmplY3Qoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aCwgKGZpbGVUZXh0OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UoZmlsZVRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLmpzb25PYmplY3RzLmFkZChrZXksIG9iaik7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLkpTT04pKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ09iamVjdChjYWxsYmFja0lmTGFzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2ggbG9hZGluZyBhbiBvYmplY3QuIElmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0LCBpdCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdPYmplY3QoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfanNvbkxvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9qc29uVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIG9iamVjdHNcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBXRUJHTCBTUEVDSUZJQyBGVU5DVElPTlMgIyMjIyMjIyMjIyAqL1xyXG5cclxuICAgIHB1YmxpYyBnZXRUZXh0dXJlKGtleTogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbF9UZXh0dXJlcy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0U2hhZGVyUHJvZ3JhbShrZXk6IHN0cmluZyk6IFdlYkdMUHJvZ3JhbSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KGtleSkucHJvZ3JhbTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QnVmZmVyKGtleTogc3RyaW5nKTogV2ViR0xCdWZmZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdsX0J1ZmZlcnMuZ2V0KGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVXZWJHTFRleHR1cmUoaW1hZ2VLZXk6IHN0cmluZywgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQpOiB2b2lkIHtcclxuICAgICAgICAvLyBHZXQgdGhlIHRleHR1cmUgSURcclxuICAgICAgICBjb25zdCB0ZXh0dXJlSUQgPSB0aGlzLmdldFRleHR1cmVJRCh0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHR1cmVcclxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCB0aGUgdGV4dHVyZVxyXG4gICAgICAgIC8vIEVuYWJsZSB0ZXh0dXJlMFxyXG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlSUQpO1xyXG5cclxuICAgICAgICAvLyBCaW5kIG91ciB0ZXh0dXJlIHRvIHRleHR1cmUgMFxyXG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnNcclxuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xyXG4gICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB0ZXh0dXJlIGltYWdlXHJcbiAgICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIHRleHR1cmUgdG8gb3VyIG1hcCB3aXRoIHRoZSBzYW1lIGtleSBhcyB0aGUgaW1hZ2VcclxuICAgICAgICB0aGlzLmdsX1RleHR1cmVzLmFkZChpbWFnZUtleSwgdGhpcy5nbF9OZXh0VGV4dHVyZUlEKTtcclxuXHJcbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBrZXlcclxuICAgICAgICB0aGlzLmdsX05leHRUZXh0dXJlSUQgKz0gMTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFRleHR1cmVJRChpZDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICAvLyBTdGFydCB3aXRoIDkgY2FzZXMgLSB0aGlzIGNhbiBiZSBleHBhbmRlZCBpZiBuZWVkZWQsIGJ1dCBmb3IgdGhlIGJlc3QgcGVyZm9ybWFuY2UsXHJcbiAgICAgICAgLy8gVGV4dHVyZXMgc2hvdWxkIGJlIHN0aXRjaGVkIGludG8gYW4gYXRsYXNcclxuICAgICAgICBzd2l0Y2goaWQpe1xyXG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUwO1xyXG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUxO1xyXG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUyO1xyXG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiB0aGlzLmdsLlRFWFRVUkUzO1xyXG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU0O1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU1O1xyXG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU2O1xyXG4gICAgICAgICAgICBjYXNlIDc6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU3O1xyXG4gICAgICAgICAgICBjYXNlIDg6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU4O1xyXG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdGhpcy5nbC5URVhUVVJFOTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUJ1ZmZlcihrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xyXG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZ2xfQnVmZmVycy5hZGQoa2V5LCBidWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVucXVldWVzIGxvYWRpbmcgb2YgYSBuZXcgc2hhZGVyIHByb2dyYW1cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc2hhZGVyIHByb2dyYW1cclxuICAgICAqIEBwYXJhbSB2U2hhZGVyRmlsZXBhdGggXHJcbiAgICAgKiBAcGFyYW0gZlNoYWRlckZpbGVwYXRoIFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2hhZGVyKGtleTogc3RyaW5nLCB2U2hhZGVyRmlsZXBhdGg6IHN0cmluZywgZlNoYWRlckZpbGVwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBsZXQgc3BsaXRQYXRoID0gdlNoYWRlckZpbGVwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICBsZXQgZW5kID0gc3BsaXRQYXRoW3NwbGl0UGF0aC5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgaWYoZW5kICE9PSBcInZzaGFkZXJcIil7XHJcbiAgICAgICAgICAgIHRocm93IGAke3ZTaGFkZXJGaWxlcGF0aH0gaXMgbm90IGEgdmFsaWQgdmVydGV4IHNoYWRlciAtIG11c3QgZW5kIGluIFwiLnZzaGFkZXJgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3BsaXRQYXRoID0gZlNoYWRlckZpbGVwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICBpZihlbmQgIT09IFwiZnNoYWRlclwiKXtcclxuICAgICAgICAgICAgdGhyb3cgYCR7ZlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIuZnNoYWRlcmA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcGF0aHMgPSBuZXcgS2V5UGF0aF9TaGFkZXIoKTtcclxuICAgICAgICBwYXRocy5rZXkgPSBrZXk7XHJcbiAgICAgICAgcGF0aHMudnBhdGggPSB2U2hhZGVyRmlsZXBhdGg7XHJcbiAgICAgICAgcGF0aHMuZnBhdGggPSBmU2hhZGVyRmlsZXBhdGg7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmVucXVldWUocGF0aHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgKi9cclxuICAgICBwdWJsaWMga2VlcFNoYWRlcihrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdsX0xvYWRTaGFkZXJzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZWJHTCBpc24nYWN0aXZlIG9yIHRoZXJlIGFyZSBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxyXG4gICAgICAgIGlmKCF0aGlzLmdsX1dlYkdMQWN0aXZlIHx8IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPT09IDApe1xyXG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIGxldCBzaGFkZXIgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xfTG9hZFNoYWRlcihzaGFkZXIua2V5LCBzaGFkZXIudnBhdGgsIHNoYWRlci5mcGF0aCwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnbF9Mb2FkU2hhZGVyKGtleTogc3RyaW5nLCB2cGF0aDogc3RyaW5nLCBmcGF0aDogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZSh2cGF0aCwgKHZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZTaGFkZXIgPSB2RmlsZVRleHQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShmcGF0aCwgKGZGaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmU2hhZGVyID0gZkZpbGVUZXh0XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgcHJvZ3JhbSBhbmQgc2hhZGVyc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3NoYWRlclByb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdID0gdGhpcy5jcmVhdGVTaGFkZXJQcm9ncmFtKHZTaGFkZXIsIGZTaGFkZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgdHlwZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3JhbVdyYXBwZXIgPSBuZXcgV2ViR0xQcm9ncmFtVHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZ3JhbVdyYXBwZXIucHJvZ3JhbSA9IHNoYWRlclByb2dyYW07XHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci52ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXI7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBvdXIgbWFwXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsX1NoYWRlclByb2dyYW1zLmFkZChrZXksIHByb2dyYW1XcmFwcGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNIQURFUikpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdsX0ZpbmlzaExvYWRpbmdTaGFkZXIoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHNoYWRlcnNcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjcmVhdGVTaGFkZXJQcm9ncmFtKHZTaGFkZXJTb3VyY2U6IHN0cmluZywgZlNoYWRlclNvdXJjZTogc3RyaW5nKXtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmxvYWRWZXJ0ZXhTaGFkZXIodlNoYWRlclNvdXJjZSk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmxvYWRGcmFnbWVudFNoYWRlcihmU2hhZGVyU291cmNlKTtcclxuICAgIFxyXG4gICAgICAgIGlmKHZlcnRleFNoYWRlciA9PT0gbnVsbCB8fCBmcmFnbWVudFNoYWRlciA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhIHByb2JsZW0gaW50aWFsaXppbmcgLSBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBDcmVhdGUgYSBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICBpZighcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICAvLyBFcnJvciBjcmVhdGluZ1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW1cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIEF0dGFjaCBvdXIgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuICAgIFxyXG4gICAgICAgIC8vIExpbmtcclxuICAgICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGlmKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUykpe1xyXG4gICAgICAgICAgICAvLyBFcnJvciBsaW5raW5nXHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGxpbmsgcHJvZ3JhbTogXCIgKyBlcnJvcik7XHJcbiAgICBcclxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcclxuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIFdlIHN1Y2Nlc3NmdWxseSBjcmVhdGUgYSBwcm9ncmFtXHJcbiAgICAgICAgcmV0dXJuIFtwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBsb2FkVmVydGV4U2hhZGVyKHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHZlcnRleCBzaGFkZXJcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUiwgc2hhZGVyU291cmNlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBsb2FkRnJhZ21lbnRTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUiwgc2hhZGVyU291cmNlKTtcdFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIGxvYWRTaGFkZXIodHlwZTogbnVtYmVyLCBzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xyXG4gICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgY3JlYXRlIHRoZSBzaGFkZXIsIGVycm9yXHJcbiAgICAgICAgaWYoc2hhZGVyID09PSBudWxsKXtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5hYmxlIHRvIGNyZWF0ZSBzaGFkZXJcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIEFkZCB0aGUgc291cmNlIHRvIHRoZSBzaGFkZXIgYW5kIGNvbXBpbGVcclxuICAgICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XHJcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICBcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgd2VyZSBubyBlcnJvcnMgZHVyaW5nIHRoaXMgcHJvY2Vzc1xyXG4gICAgICAgIGlmKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKXtcclxuICAgICAgICAgICAgLy8gTm90IGNvbXBpbGVkIC0gZXJyb3JcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNvbXBpbGUgc2hhZGVyOiBcIiArIGVycm9yKTtcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBTdWNlc3MsIHNvIHJldHVybiB0aGUgc2hhZGVyXHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIEdFTkVSQUwgTE9BRElORyBGVU5DVElPTlMgIyMjIyMjIyMjIyAqL1xyXG5cclxuICAgIHByaXZhdGUgbG9hZFRleHRGaWxlKHRleHRGaWxlUGF0aDogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICBsZXQgeG9iajogWE1MSHR0cFJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB4b2JqLm92ZXJyaWRlTWltZVR5cGUoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xyXG4gICAgICAgIHhvYmoub3BlbignR0VUJywgdGV4dEZpbGVQYXRoLCB0cnVlKTtcclxuICAgICAgICB4b2JqLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCh4b2JqLnJlYWR5U3RhdGUgPT0gNCkgJiYgKHhvYmouc3RhdHVzID09IDIwMCkpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhvYmoucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgeG9iai5zZW5kKG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMgTE9BRElORyBCQVIgSU5GTyAjIyMjIyMjIyMjICovXHJcblxyXG4gICAgcHJpdmF0ZSBnZXRMb2FkUGVyY2VudCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZC90aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkXHJcbiAgICAgICAgICAgICsgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQvdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWRcclxuICAgICAgICAgICAgKyB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZC90aGlzLmxvYWRvbmx5X2ltYWdlc1RvTG9hZFxyXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQvdGhpcy5sb2Fkb25seV9hdWRpb1RvTG9hZClcclxuICAgICAgICAgICAgLyB0aGlzLmxvYWRvbmx5X3R5cGVzVG9Mb2FkO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMubG9hZGluZyl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkUHJvZ3Jlc3Mpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRQcm9ncmVzcyh0aGlzLmdldExvYWRQZXJjZW50KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuanVzdExvYWRlZCl7XHJcbiAgICAgICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZih0aGlzLm9uTG9hZENvbXBsZXRlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgcmVmZXJlbmNlIHRvIGEgcmVzb3VyY2UuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgdGhlIGV4ZW1wdGlvbiBsaXN0IHRvIGFzc3VyZSBhc3NldHMgYW5kIHRoZWlyIGRlcGVuZGVuY2llcyBkb24ndCBnZXRcclxuICogZGVzdHJveWVkIGlmIHRoZXkgYXJlIHN0aWxsIG5lZWRlZC5cclxuICovXHJcbmNsYXNzIFJlc291cmNlUmVmZXJlbmNlIHtcclxuICAgIGtleTogc3RyaW5nO1xyXG4gICAgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGU7XHJcbiAgICBkZXBlbmRlbmNpZXM6IEFycmF5PFJlc291cmNlUmVmZXJlbmNlPjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihrZXk6IHN0cmluZywgcmVzb3VyY2VUeXBlOiBSZXNvdXJjZVR5cGUpe1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VUeXBlID0gcmVzb3VyY2VUeXBlO1xyXG4gICAgICAgIHRoaXMuIGRlcGVuZGVuY2llcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZERlcGVuZGVuY3kocmVzb3VyY2U6IFJlc291cmNlUmVmZXJlbmNlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMucHVzaChyZXNvdXJjZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5lbnVtIFJlc291cmNlVHlwZSB7XHJcbiAgICBJTUFHRSA9IFwiSU1BR0VcIixcclxuICAgIFRJTEVNQVAgPSBcIlRJTEVNQVBcIixcclxuICAgIFNQUklURVNIRUVUID0gXCJTUFJJVEVTSEVFVFwiLFxyXG4gICAgQVVESU8gPSBcIkFVRElPXCIsXHJcbiAgICBKU09OID0gXCJKU09OXCIsXHJcbiAgICBTSEFERVIgPSBcIlNIQURFUlwiXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHBhaXIgcmVwcmVzZW50aW5nIGEga2V5IGFuZCB0aGUgcGF0aCBvZiB0aGUgcmVzb3VyY2UgdG8gbG9hZFxyXG4gKi9cclxuY2xhc3MgS2V5UGF0aFBhaXIge1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICBwYXRoOiBzdHJpbmc7XHJcbiAgICBpc0RlcGVuZGVuY3k/OiBib29sZWFuID0gZmFsc2U7XHJcbn1cclxuXHJcbmNsYXNzIEtleVBhdGhfU2hhZGVyIHtcclxuICAgIGtleTogc3RyaW5nO1xyXG4gICAgdnBhdGg6IHN0cmluZztcclxuICAgIGZwYXRoOiBzdHJpbmc7XHJcbn0iLCJpbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4vVmlld3BvcnRcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3QgaW50ZXJmYWNlIG9mIGEgU2NlbmVHcmFwaC5cclxuICogRXhwb3NlcyBtZXRob2RzIGZvciB1c2UgYnkgb3RoZXIgY29kZSwgYnV0IGxlYXZlcyB0aGUgaW1wbGVtZW50YXRpb24gdXAgdG8gdGhlIHN1YmNsYXNzZXMuXHJcbiAqIFRoZSBTY2VuZUdyYXBoIG1hbmFnZXMgdGhlIHBvc2l0aW9ucyBvZiBhbGwgR2FtZU5vZGVzLCBhbmQgY2FuIGVhc2lseSBwcnVuZSBhIHZpc2libGUgc2V0IGZvciByZW5kZXJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTY2VuZUdyYXBoIHtcclxuXHQvKipcdEEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCAqL1xyXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblx0LyoqXHRBIG1hcCBvZiBDYW52YXNOb2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cclxuXHRwcm90ZWN0ZWQgbm9kZU1hcDogQXJyYXk8Q2FudmFzTm9kZT47XHJcblx0LyoqIEEgY291bnRlciBvZiBJRHMgZm9yIG5vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xyXG5cdHByb3RlY3RlZCBpZENvdW50ZXI6IG51bWJlcjtcclxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIFNjZW5lIHRoaXMgU2NlbmVHcmFwaCBiZWxvbmdzIHRvICovXHJcblx0cHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoXHJcblx0ICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydFxyXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cclxuXHQgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmU6IFNjZW5lKXtcclxuXHRcdHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHRcdHRoaXMubm9kZU1hcCA9IG5ldyBBcnJheSgpO1xyXG5cdFx0dGhpcy5pZENvdW50ZXIgPSAwO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBub2RlIHRvIHRoZSBTY2VuZUdyYXBoXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIENhbnZhc05vZGUgdG8gYWRkIHRvIHRoZSBTY2VuZUdyYXBoXHJcblx0ICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGggSUQgb2YgdGhpcyBuZXdseSBhZGRlZCBDYW52YXNOb2RlXHJcblx0ICovXHJcbiAgICBhZGROb2RlKG5vZGU6IENhbnZhc05vZGUpOiBudW1iZXIge1xyXG5cdFx0dGhpcy5ub2RlTWFwW25vZGUuaWRdID0gbm9kZTtcclxuXHRcdHRoaXMuYWRkTm9kZVNwZWNpZmljKG5vZGUsIHRoaXMuaWRDb3VudGVyKTtcclxuXHRcdHRoaXMuaWRDb3VudGVyICs9IDE7XHJcblx0XHRyZXR1cm4gdGhpcy5pZENvdW50ZXIgLSAxO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIG92ZXJyaWRhYmxlIG1ldGhvZCB0byBhZGQgYSBDYW52YXNOb2RlIHRvIHRoZSBzcGVjaWZpYyBkYXRhIHN0cnVjdHVyZSBvZiB0aGUgU2NlbmVHcmFwaFxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGUgZGF0YSBzdHJ1Y3R1cmVcclxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBDYW52YXNOb2RlXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IGFkZE5vZGVTcGVjaWZpYyhub2RlOiBDYW52YXNOb2RlLCBpZDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgU2NlbmVHcmFwaFxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG5cdCAqL1xyXG4gICAgcmVtb3ZlTm9kZShub2RlOiBDYW52YXNOb2RlKTogdm9pZCB7XHJcblx0XHQvLyBGaW5kIGFuZCByZW1vdmUgbm9kZSBpbiBPKG4pXHJcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnJlbW92ZU5vZGVTcGVjaWZpYyhub2RlLCBub2RlLmlkKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gb2YgcmVtb3ZpbmcgYSBub2RlXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXHJcblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgbm9kZSB0byByZW1vdmVcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYSBzcGVjaWZpYyBub2RlIHVzaW5nIGl0cyBpZFxyXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIENhbnZhc05vZGUgdG8gcmV0cmlldmVcclxuXHQgKiBAcmV0dXJucyBUaGUgbm9kZSB3aXRoIHRoaXMgSURcclxuXHQgKi9cclxuXHRnZXROb2RlKGlkOiBudW1iZXIpOiBDYW52YXNOb2RlIHtcclxuXHRcdHJldHVybiB0aGlzLm5vZGVNYXBbaWRdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgYXQgc3BlY2lmaWMgY29vcmRpbmF0ZXNcclxuXHQgKiBAcGFyYW0gdmVjT3JYIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHBvc2l0aW9uLCBvciB0aGUgY29vcmRpbmF0ZXMgaW4gYSBWZWMyXHJcblx0ICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb25cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBhdCB0aGUgcG9zaXRpb24gcHJvdmlkZWRcclxuXHQgKi9cclxuICAgIGdldE5vZGVzQXQodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLngsIHZlY09yWC55KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldE5vZGVzQXRDb29yZHModmVjT3JYLCB5KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG5vZGVzIHRoYXQgb3ZlcmxhcCBhIHNwZWNpZmljIGJvdW5kYXJ5XHJcblx0ICogQHBhcmFtIGJvdW5kYXJ5IFRoZSByZWdpb24gdG8gY2hlY2tcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyBmb3VuZCBvdmVybGFwcGluZyB0aGUgcHJvdmlkZWQgYm91bmRhcnlcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBnZXROb2Rlc0luUmVnaW9uKGJvdW5kYXJ5OiBBQUJCKTogQXJyYXk8Q2FudmFzTm9kZT47XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbGwgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcclxuXHQgKiBAcmV0dXJucyBBbiBBcnJheSBjb250YWluaW5nIGFsbCBub2RlcyBpbiB0aGUgU2NlbmVHcmFwaFxyXG5cdCAqL1xyXG5cdGdldEFsbE5vZGVzKCk6IEFycmF5PENhbnZhc05vZGU+IHtcclxuXHRcdGxldCBhcnIgPSBuZXcgQXJyYXk8Q2FudmFzTm9kZT4oKTtcclxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm5vZGVNYXAubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRpZih0aGlzLm5vZGVNYXBbaV0gIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdFx0YXJyLnB1c2godGhpcy5ub2RlTWFwW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiBnZXR0aW5nIGEgbm9kZSBhdCBjZXJ0YWluIGNvb3JkaW5hdGVzXHJcblx0ICogQHBhcmFtIHggVGhlIHgtY29vcmRpbmF0ZXMgb2YgdGhlIG5vZGVcclxuXHQgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlcyBvZiB0aGUgbm9kZVxyXG5cdCAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHJcblx0YWJzdHJhY3QgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZDtcclxuXHRcclxuXHRhYnN0cmFjdCByZW5kZXIoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2RlcyBiYXNlZCBvbiB0aGUgQHJlZmVyZW5jZVtWaWV3cG9ydF1cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCB2aXNpYmxlIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXHJcblx0ICovXHJcbiAgICBhYnN0cmFjdCBnZXRWaXNpYmxlU2V0KCk6IEFycmF5PENhbnZhc05vZGU+O1xyXG59IiwiaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4vU2NlbmVHcmFwaFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgVmlld3BvcnQgZnJvbSBcIi4vVmlld3BvcnRcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBTdGF0cyBmcm9tIFwiLi4vRGVidWcvU3RhdHNcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIFNjZW5lR3JhcGggdGhhdCBzaW1wbHkgc3RvcmVkIENhbnZhc05vZGVzIGluIGFuIGFycmF5LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVHcmFwaEFycmF5IGV4dGVuZHMgU2NlbmVHcmFwaCB7XHJcbiAgICAvKiogVGhlIGxpc3Qgb2YgQ2FudmFzTm9kZXMgaW4gdGhpcyBTY2VuZUdyYXBoICovXHJcbiAgICBwcml2YXRlIG5vZGVMaXN0OiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2NlbmVHcmFwaEFycmF5XHJcbiAgICAgKiBAcGFyYW0gdmlld3BvcnQgVGhlIFZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIFNjZW5lIHRoaXMgU2NlbmVHcmFwaCBiZWxvbmdzIHRvXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmU6IFNjZW5lKXtcclxuICAgICAgICBzdXBlcih2aWV3cG9ydCwgc2NlbmUpO1xyXG5cclxuICAgICAgICB0aGlzLm5vZGVMaXN0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgYWRkTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm5vZGVMaXN0LnB1c2gobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm5vZGVMaXN0LmluZGV4T2Yobm9kZSk7XHJcbiAgICAgICAgaWYoaW5kZXggPiAtMSl7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZUxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBnZXROb2Rlc0F0Q29vcmRzKHg6IG51bWJlciwgeTogbnVtYmVyKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XHJcblxyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcclxuICAgICAgICAgICAgaWYobm9kZS5jb250YWlucyh4LCB5KSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgZ2V0Tm9kZXNJblJlZ2lvbihib3VuZGFyeTogQUFCQik6IEFycmF5PENhbnZhc05vZGU+IHtcclxuICAgICAgICBsZXQgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5ub2RlTGlzdCl7XHJcbiAgICAgICAgICAgIGlmKGJvdW5kYXJ5Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBTdGF0cy5sb2coXCJzZ3F1ZXJ5XCIsICh0MS10MCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5ub2RlTGlzdCl7XHJcbiAgICAgICAgICAgIGlmKCFub2RlLmdldExheWVyKCkuaXNQYXVzZWQoKSl7XHJcbiAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0MSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIFN0YXRzLmxvZyhcInNndXBkYXRlXCIsICh0MS10MCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQge31cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG4gICAgICAgIGxldCB2aXNpYmxlU2V0ID0gbmV3IEFycmF5PENhbnZhc05vZGU+KCk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcclxuICAgICAgICAgICAgaWYoIW5vZGUuZ2V0TGF5ZXIoKS5pc0hpZGRlbigpICYmIG5vZGUudmlzaWJsZSAmJiB0aGlzLnZpZXdwb3J0LmluY2x1ZGVzKG5vZGUpKXtcclxuICAgICAgICAgICAgICAgIHZpc2libGVTZXQucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZpc2libGVTZXQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWUuIENvcnJlc3BvbmRzIHRvIHRoZSB2aXNpYmxlIHdpbmRvdyBkaXNwbGF5ZWQgaW4gdGhlIGJyb3dzZXIuXHJcbiAqIFRoZSB2aWV3cG9ydCBrZWVwcyB0cmFjayBvZiBpdHMgcG9zaXRpb24gaW4gdGhlIGdhbWUgd29ybGQsIGFuZCBjYW4gYWN0IGFzIGEgY2FtZXJhIHRvIGZvbGxvdyBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xyXG4gICAgLyoqIFRoZSBBQUJCIHRoYXQgY29udGFpbnMgdGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSB2aWV3cG9ydCB2aWV3ICovXHJcbiAgICBwcml2YXRlIHZpZXc6IEFBQkI7XHJcbiAgICAvKiogVGhlIGJvdW5kYXJ5IGZvciB0aGUgdmlld3BvcnQuIFRoaXMgcmVwcmVzZW50cyB0aGUgbGltaXRzIHRvIHdoZXJlIHRoZSB2aWV3cG9ydCBjYW4gZ28gKi9cclxuICAgIHByaXZhdGUgYm91bmRhcnk6IEFBQkI7XHJcbiAgICAvKiogVGhlIEdhbWVOb2RlIHRoZSBWaWV3cG9ydCBpcyBmb2xsb3dpbmcgKi9cclxuICAgIHByaXZhdGUgZm9sbG93aW5nOiBHYW1lTm9kZTtcclxuICAgIC8qKiBUaGUgcG9zaXRpb24gdGhlIEdhbWVOb2RlIGlzIGZvY3VzaW5nIG9uLiBUaGlzIGlzIG92ZXJyaWRkZW4gaWYgXCJmb2xsb3dpbmdcIiBpcyBzZXQuICovXHJcbiAgICBwcml2YXRlIGZvY3VzOiBWZWMyO1xyXG5cclxuICAgIC8qKiBBIHF1ZXVlIG9mIHByZXZpb3VzIHBvc2l0aW9ucyBvZiB3aGF0IHRoaXMgdmlld3BvcnQgaXMgZm9sbG93aW5nLiBVc2VkIGZvciBzbW9vdGhpbmcgdmlld3BvcnQgbW92ZW1lbnQgKi9cclxuICAgIHByaXZhdGUgbGFzdFBvc2l0aW9uczogUXVldWU8VmVjMj47XHJcblxyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgcG9zaXRpb25zIHRoaXMgdmlld3BvcnQgdHJhY2tzICovXHJcbiAgICBwcml2YXRlIHNtb290aGluZ0ZhY3RvcjogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBBIGJvb2xlYW4gdGhhIHJlcHJlc2VudHMgd2hldGhlciB0aGUgcGxheWVyIGNhbiB6b29tIGJ5IHNjcm9sbGluZyB3aXRoIHRoZSBtb3VzZSB3aGVlbCAqL1xyXG4gICAgcHJpdmF0ZSBzY3JvbGxab29tRW5hYmxlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIGFtb3VudCB0aGF0IGlzIHpvb21lZCBpbiBvciBvdXQuICovXHJcbiAgICBwcml2YXRlIFpPT01fRkFDVE9SOiBudW1iZXIgPSAxLjI7XHJcblxyXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSBjYW52YXMgKi9cclxuICAgIHByaXZhdGUgY2FudmFzU2l6ZTogVmVjMjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXNTaXplOiBWZWMyLCB6b29tTGV2ZWw6IG51bWJlcil7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gbmV3IEFBQkIoVmVjMi5aRVJPLCBWZWMyLlpFUk8pO1xyXG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XHJcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5zbW9vdGhpbmdGYWN0b3IgPSAxMDtcclxuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYW52YXNTaXplID0gVmVjMi5aRVJPO1xyXG4gICAgICAgIHRoaXMuZm9jdXMgPSBWZWMyLlpFUk87XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzXHJcbiAgICAgICAgdGhpcy5zZXRDYW52YXNTaXplKGNhbnZhc1NpemUpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgICAgdGhpcy5zZXRTaXplKGNhbnZhc1NpemUpO1xyXG4gICAgICAgIHRoaXMuc2V0Wm9vbUxldmVsKHpvb21MZXZlbCk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgY2VudGVyIChhbmQgbWFrZSB0aGUgdmlld3BvcnQgc3RheSB0aGVyZSlcclxuICAgICAgICB0aGlzLnNldENlbnRlcih0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5zZXRGb2N1cyh0aGlzLnZpZXcuaGFsZlNpemUuY2xvbmUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEVuYWJsZXMgdGhlIHZpZXdwb3J0IHRvIHpvb20gaW4gYW5kIG91dCAqL1xyXG4gICAgZW5hYmxlWm9vbSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFpvb21FbmFibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHJldHVybnMgVGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgYXMgYSBWZWMyXHJcbiAgICAgKi9cclxuICAgIGdldENlbnRlcigpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmNlbnRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgVmVjMiB3aXRoIHRoZSBvcmlnaW4gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG9wIGxlZnQgY29ybmRlciBvZiB0aGUgVmllcG9ydCBhcyBhIFZlYzJcclxuICAgICAqL1xyXG4gICAgZ2V0T3JpZ2luKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnZpZXcubGVmdCwgdGhpcy52aWV3LnRvcCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGlzIHZpZXdwb3J0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQUFCQiBjb250YWluaW5nIHRoZSByZWdpb24gdmlzaWJsZSB0byB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgZ2V0VmlldygpOiBBQUJCIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIG5ldyBwb3NpdGlvbiBvciB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBuZXcgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBzZXRDZW50ZXIodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHBvczogVmVjMjtcclxuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xyXG4gICAgICAgICAgICBwb3MgPSB2ZWNPclg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zID0gbmV3IFZlYzIodmVjT3JYLCB5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIgPSBwb3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcclxuICAgICAqIEByZXR1cm5zIFRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxyXG4gICAgICovXHJcbiAgICBnZXRIYWxmU2l6ZSgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEhhbGZTaXplKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB2ZWNPclggVGhlIG5ldyB3aWR0aCBvZiB0aGUgdmlld3BvcnQgb3IgdGhlIG5ldyBzaXplIGFzIGEgVmVjMlxyXG4gICAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHNldFNpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKHZlY09yWC5zY2FsZWQoMS8yKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYLzIsIHkvMikpO1xyXG5cdFx0fVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgaGFsZi1zaXplIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IGhhbGYtd2lkdGggb2YgdGhlIHZpZXdwb3J0IG9yIHRoZSBuZXcgaGFsZi1zaXplIGFzIGEgVmVjMlxyXG4gICAgICogQHBhcmFtIHkgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHNldEhhbGZTaXplKHZlY09yWDogVmVjMiB8IG51bWJlciwgeTogbnVtYmVyID0gbnVsbCk6IHZvaWQge1xyXG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XHJcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZSh2ZWNPclguY2xvbmUoKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUobmV3IFZlYzIodmVjT3JYLCB5KSk7XHJcblx0XHR9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB2aWV3cG9ydCB3aXRoIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IENhbnZhc1xyXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcywgb3IgdGhlIGNhbnZhcyBzaXplIGFzIGEgVmVjMlxyXG4gICAgICogQHBhcmFtIHkgVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIHNldENhbnZhc1NpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0dGhpcy5jYW52YXNTaXplID0gdmVjT3JYLmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNhbnZhc1NpemUgPSBuZXcgVmVjMih2ZWNPclgsIHkpO1xyXG5cdFx0fVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsXHJcbiAgICAgKi9cclxuICAgIHNldFpvb21MZXZlbCh6b29tOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnZpZXcuaGFsZlNpemUuY29weSh0aGlzLmNhbnZhc1NpemUuc2NhbGVkKDEvem9vbS8yKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHJldHVybnMgVGhlIHpvb20gbGV2ZWxcclxuICAgICAqL1xyXG4gICAgZ2V0Wm9vbUxldmVsKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzU2l6ZS54L3RoaXMudmlldy5ody8yXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnQgbW92ZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gc21vb3RoaW5nRmFjdG9yIFRoZSBzbW9vdGhpbmcgZmFjdG9yIGZvciB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgc2V0U21vb3RoaW5nRmFjdG9yKHNtb290aGluZ0ZhY3RvcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYoc21vb3RoaW5nRmFjdG9yIDwgMSkgc21vb3RoaW5nRmFjdG9yID0gMTtcclxuICAgICAgICB0aGlzLnNtb290aGluZ0ZhY3RvciA9IHNtb290aGluZ0ZhY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSB2aWV3cG9ydCB0byBmb2N1cyBvbiBhIHBvaW50LiBPdmVyaWRkZW4gYnkgXCJmb2xsb3dpbmdcIi5cclxuICAgICAqIEBwYXJhbSBmb2N1cyBUaGUgcG9pbnQgdGhlICB2aWV3cG9ydCBzaG91bGQgZm9jdXMgb25cclxuICAgICAqL1xyXG4gICAgc2V0Rm9jdXMoZm9jdXM6IFZlYzIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZvY3VzLmNvcHkoZm9jdXMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgQ2FudmFzTm9kZSBpcyBpbnNpZGUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQsIGZhbHNlIGlmIG5vdFxyXG4gICAgICovXHJcbiAgICBpbmNsdWRlcyhub2RlOiBDYW52YXNOb2RlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IHBhcmFsbGF4ID0gbm9kZS5nZXRMYXllcigpIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBVSUxheWVyID8gKDxQYXJhbGxheExheWVyPm5vZGUuZ2V0TGF5ZXIoKSkucGFyYWxsYXggOiBuZXcgVmVjMigxLCAxKTtcclxuICAgICAgICBsZXQgY2VudGVyID0gdGhpcy52aWV3LmNlbnRlci5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIubXVsdChwYXJhbGxheCk7XHJcbiAgICAgICAgbGV0IG92ZXJsYXBzID0gdGhpcy52aWV3Lm92ZXJsYXBzKG5vZGUuYm91bmRhcnkpO1xyXG4gICAgICAgIHRoaXMudmlldy5jZW50ZXIgPSBjZW50ZXJcclxuICAgICAgICByZXR1cm4gb3ZlcmxhcHM7XHJcbiAgICB9XHJcblxyXG5cdC8vIFRPRE86IFB1dCBzb21lIGVycm9yIGhhbmRsaW5nIG9uIHRoaXMgZm9yIHRyeWluZyB0byBtYWtlIHRoZSBib3VuZHMgdG9vIHNtYWxsIGZvciB0aGUgdmlld3BvcnRcclxuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGRvbmUgYXV0b21hdGljYWxseSwgb3Igc2hvdWxkIGNvbnNpZGVyIHRoZSBhc3BlY3QgcmF0aW8gb3Igc29tZXRoaW5nXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJvdW5kcyBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBsb3dlclggVGhlIGxlZnQgZWRnZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBsb3dlclkgVGhlIHRvcCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHVwcGVyWCBUaGUgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB1cHBlclkgVGhlIGJvdHRvbSBlZGdlIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBzZXRCb3VuZHMobG93ZXJYOiBudW1iZXIsIGxvd2VyWTogbnVtYmVyLCB1cHBlclg6IG51bWJlciwgdXBwZXJZOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaHdpZHRoID0gKHVwcGVyWCAtIGxvd2VyWCkvMjtcclxuICAgICAgICBsZXQgaGhlaWdodCA9ICh1cHBlclkgLSBsb3dlclkpLzI7XHJcbiAgICAgICAgbGV0IHggPSBsb3dlclggKyBod2lkdGg7XHJcbiAgICAgICAgbGV0IHkgPSBsb3dlclkgKyBoaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuYm91bmRhcnkuY2VudGVyLnNldCh4LCB5KTtcclxuICAgICAgICB0aGlzLmJvdW5kYXJ5LmhhbGZTaXplLnNldChod2lkdGgsIGhoZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZSB0aGUgdmlld3BvcnQgZm9sbG93IHRoZSBzcGVjaWZpZWQgR2FtZU5vZGVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBHYW1lTm9kZSB0byBmb2xsb3dcclxuICAgICAqL1xyXG4gICAgZm9sbG93KG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mb2xsb3dpbmcgPSBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVZpZXcoKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5sYXN0UG9zaXRpb25zLmdldFNpemUoKSA+IHRoaXMuc21vb3RoaW5nRmFjdG9yKXtcclxuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmRlcXVldWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2V0IHRoZSBhdmVyYWdlIG9mIHRoZSBsYXN0IDEwIHBvc2l0aW9uc1xyXG4gICAgICAgIGxldCBwb3MgPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4gcG9zLmFkZChwb3NpdGlvbikpO1xyXG4gICAgICAgIHBvcy5zY2FsZSgxL3RoaXMubGFzdFBvc2l0aW9ucy5nZXRTaXplKCkpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhpcyBwb3NpdGlvbiBlaXRoZXIgdG8gdGhlIG9iamVjdCBvciB0byBpdHMgYm91bmRzXHJcbiAgICAgICAgcG9zLnggPSBNYXRoVXRpbHMuY2xhbXAocG9zLngsIHRoaXMuYm91bmRhcnkubGVmdCArIHRoaXMudmlldy5odywgdGhpcy5ib3VuZGFyeS5yaWdodCAtIHRoaXMudmlldy5odyk7XHJcbiAgICAgICAgcG9zLnkgPSBNYXRoVXRpbHMuY2xhbXAocG9zLnksIHRoaXMuYm91bmRhcnkudG9wICsgdGhpcy52aWV3LmhoLCB0aGlzLmJvdW5kYXJ5LmJvdHRvbSAtIHRoaXMudmlldy5oaCk7XHJcblxyXG4gICAgICAgIC8vIEFzc3VyZSB0aGVyZSBhcmUgbm8gbGluZXMgaW4gdGhlIHRpbGVtYXBcclxuICAgICAgICBwb3MueCA9IE1hdGguZmxvb3IocG9zLngpO1xyXG4gICAgICAgIHBvcy55ID0gTWF0aC5mbG9vcihwb3MueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlci5jb3B5KHBvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gSWYgem9vbSBpcyBlbmFibGVkXHJcbiAgICAgICAgaWYodGhpcy5zY3JvbGxab29tRW5hYmxlZCl7XHJcbiAgICAgICAgICAgIGlmKElucHV0LmRpZEp1c3RTY3JvbGwoKSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFNpemUgPSB0aGlzLnZpZXcuZ2V0SGFsZlNpemUoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYoSW5wdXQuZ2V0U2Nyb2xsRGlyZWN0aW9uKCkgPCAwKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBab29tIGluXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUuc2NhbGUoMS90aGlzLlpPT01fRkFDVE9SKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWm9vbSBvdXRcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSh0aGlzLlpPT01fRkFDVE9SKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50U2l6ZS54ID4gdGhpcy5ib3VuZGFyeS5odyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaHcvY3VycmVudFNpemUueDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS54ID0gdGhpcy5ib3VuZGFyeS5odztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS55ICo9IGZhY3RvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50U2l6ZS55ID4gdGhpcy5ib3VuZGFyeS5oaCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhY3RvciA9IHRoaXMuYm91bmRhcnkuaGgvY3VycmVudFNpemUueTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS55ID0gdGhpcy5ib3VuZGFyeS5oaDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS54ICo9IGZhY3RvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuc2V0SGFsZlNpemUoY3VycmVudFNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB2aWV3cG9ydCBpcyBmb2xsb3dpbmcgYW4gb2JqZWN0XHJcbiAgICAgICAgaWYodGhpcy5mb2xsb3dpbmcpe1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgb3VyIGxpc3Qgb2YgcHJldmlvdXMgcG9zaXRpb25zXHJcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9sbG93aW5nLnBvc2l0aW9uLmNsb25lKCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFBvc2l0aW9ucy5lbnF1ZXVlKHRoaXMuZm9jdXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudFwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XHJcbmltcG9ydCB7IFVJRWxlbWVudFR5cGUgfSBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlc1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcclxuaW1wb3J0IFRleHRJbnB1dCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXRcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgTGluZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvTGluZVwiO1xyXG5cclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBBIGZhY3RvcnkgdGhhdCBhYnN0cmFjdHMgYWRkaW5nIEByZWZlcmVuY2VbQ2FudmFzTm9kZV1zIHRvIHRoZSBAcmVmZXJlbmNlW1NjZW5lXS5cclxuICogQWNjZXNzIG1ldGhvZHMgaW4gdGhpcyBmYWN0b3J5IHRocm91Z2ggU2NlbmUuYWRkLlttZXRob2ROYW1lXSgpLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzTm9kZUZhY3Rvcnkge1xyXG5cdHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuXHRpbml0KHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXHJcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XHJcblx0ICovXHJcblx0YWRkVUlFbGVtZW50ID0gKHR5cGU6IHN0cmluZyB8IFVJRWxlbWVudFR5cGUsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFVJRWxlbWVudCA9PiB7XHJcblx0XHQvLyBHZXQgdGhlIGxheWVyXHJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblxyXG5cdFx0bGV0IGluc3RhbmNlOiBVSUVsZW1lbnQ7XHJcblxyXG5cdFx0c3dpdGNoKHR5cGUpe1xyXG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuQlVUVE9OOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZEJ1dHRvbihvcHRpb25zKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5MQUJFTDpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRMYWJlbChvcHRpb25zKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5TTElERVI6XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkU2xpZGVyKG9wdGlvbnMpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLlRFWFRfSU5QVVQ6XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkVGV4dElucHV0KG9wdGlvbnMpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBgVUlFbGVtZW50VHlwZSAnJHt0eXBlfScgZG9lcyBub3QgZXhpc3QsIG9yIGlzIHJlZ2lzdGVyZWQgaW5jb3JyZWN0bHkuYFxyXG5cdFx0fVxyXG5cclxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcclxuXHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSlcclxuXHJcblx0XHRyZXR1cm4gaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcclxuXHQgKi9cclxuXHRhZGRTcHJpdGUgPSAoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlID0+IHtcclxuXHRcdGxldCBsYXllciA9IHRoaXMuc2NlbmUuZ2V0TGF5ZXIobGF5ZXJOYW1lKTtcclxuXHJcblx0XHRsZXQgaW5zdGFuY2UgPSBuZXcgU3ByaXRlKGtleSk7XHJcblxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIHNjZW5lXHJcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcclxuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcblxyXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhbiBBbmltYXRlZFNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXHJcblx0ICogQHJldHVybnMgQSBuZXcgQW5pbWF0ZWRTcHJpdGVcclxuXHQgKi9cclxuXHRhZGRBbmltYXRlZFNwcml0ZSA9IChrZXk6IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcpOiBBbmltYXRlZFNwcml0ZSA9PiB7XHJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblx0XHRsZXQgc3ByaXRlc2hlZXQgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTcHJpdGVzaGVldChrZXkpO1xyXG5cdFx0bGV0IGluc3RhbmNlID0gbmV3IEFuaW1hdGVkU3ByaXRlKHNwcml0ZXNoZWV0KTtcclxuXHJcblx0XHQvLyBBZGQgaW5zdGFuY2UgZm8gc2NlbmVcclxuXHRcdGluc3RhbmNlLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG5cdFx0aW5zdGFuY2UuaWQgPSB0aGlzLnNjZW5lLmdlbmVyYXRlSWQoKTtcclxuXHRcdFxyXG5cdFx0aWYoISh0aGlzLnNjZW5lLmlzUGFyYWxsYXhMYXllcihsYXllck5hbWUpIHx8IHRoaXMuc2NlbmUuaXNVSUxheWVyKGxheWVyTmFtZSkpKXtcclxuXHRcdFx0dGhpcy5zY2VuZS5nZXRTY2VuZUdyYXBoKCkuYWRkTm9kZShpbnN0YW5jZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIHRvIGxheWVyXHJcblx0XHRsYXllci5hZGROb2RlKGluc3RhbmNlKTtcclxuXHJcblx0XHRyZXR1cm4gaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxyXG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGdyYXBoaWMgdG8gYWRkXHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljXHJcblx0ICovXHJcblx0YWRkR3JhcGhpYyA9ICh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyA9PiB7XHJcblx0XHQvLyBHZXQgdGhlIGxheWVyXHJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblxyXG5cdFx0bGV0IGluc3RhbmNlOiBHcmFwaGljO1xyXG5cclxuXHRcdHN3aXRjaCh0eXBlKXtcclxuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5QT0lOVDpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRQb2ludChvcHRpb25zKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5MSU5FOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZExpbmUob3B0aW9ucyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuUkVDVDpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRSZWN0KG9wdGlvbnMpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93IGBHcmFwaGljVHlwZSAnJHt0eXBlfScgZG9lcyBub3QgZXhpc3QsIG9yIGlzIHJlZ2lzdGVyZWQgaW5jb3JyZWN0bHkuYFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBzY2VuZVxyXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG5cclxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XHJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xyXG5cdH1cclxuXHJcblx0LyogLS0tLS0tLS0tLSBCVUlMREVSUyAtLS0tLS0tLS0tICovXHJcblxyXG5cdGJ1aWxkQnV0dG9uKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogQnV0dG9uIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiQnV0dG9uXCIsIG9wdGlvbnMsIFwidGV4dFwiLCBcInN0cmluZ1wiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJ1dHRvbihvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpO1xyXG5cdH1cclxuXHJcblx0YnVpbGRMYWJlbChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IExhYmVsIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInRleHRcIiwgXCJzdHJpbmdcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYWJlbChvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpXHJcblx0fVxyXG5cclxuXHRidWlsZFNsaWRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogU2xpZGVyIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJTbGlkZXJcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0bGV0IGluaXRWYWx1ZSA9IDA7XHJcblx0XHRpZihvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpe1xyXG5cdFx0XHRpbml0VmFsdWUgPSBvcHRpb25zLnZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgU2xpZGVyKG9wdGlvbnMucG9zaXRpb24sIGluaXRWYWx1ZSk7XHJcblx0fVxyXG5cclxuXHRidWlsZFRleHRJbnB1dChvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVGV4dElucHV0IHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJUZXh0SW5wdXRcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUZXh0SW5wdXQob3B0aW9ucy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHRidWlsZFBvaW50KG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBvaW50XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQob3B0aW9ucy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHRidWlsZExpbmUob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQb2ludCB7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGluZVwiLCBvcHRpb25zLCBcInN0YXJ0XCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMaW5lXCIsIG9wdGlvbnMsIFwiZW5kXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExpbmUob3B0aW9ucy5zdGFydCwgb3B0aW9ucy5lbmQpO1xyXG5cdH1cclxuXHJcblx0YnVpbGRSZWN0KG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjdCB7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUmVjdFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBSZWN0KG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMuc2l6ZSk7XHJcblx0fVxyXG5cclxuXHQvKiAtLS0tLS0tLS0tIEVSUk9SIEhBTkRMSU5HIC0tLS0tLS0tLS0gKi9cclxuXHJcblx0Y2hlY2tJZlByb3BFeGlzdHM8VD4ob2JqZWN0TmFtZTogc3RyaW5nLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcm9wOiBzdHJpbmcsIHR5cGU6IChuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCkgfCBzdHJpbmcsIHR5cGVOYW1lPzogc3RyaW5nKXtcclxuXHRcdGlmKCFvcHRpb25zIHx8IG9wdGlvbnNbcHJvcF0gPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHlcclxuXHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGVOYW1lfSwgYnV0IG5vbmUgd2FzIHByb3ZpZGVkLmA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBwcm9wZXJ0eSBoYXMgdGhlIGNvcnJlY3QgdHlwZVxyXG5cdFx0XHRpZigodHlwZW9mIHR5cGUpID09PSBcInN0cmluZ1wiKXtcclxuXHRcdFx0XHRpZighKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSB0eXBlKSl7XHJcblx0XHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGV9LmA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcclxuXHRcdFx0XHQvLyBJZiB0eXBlIGlzIGEgY29uc3RydWN0b3IsIGNoZWNrIGFnYWluc3QgdGhhdFxyXG5cdFx0XHRcdGlmKCEob3B0aW9uc1twcm9wXSBpbnN0YW5jZW9mIHR5cGUpKXtcclxuXHRcdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlTmFtZX0uYDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcclxuaW1wb3J0IENhbnZhc05vZGVGYWN0b3J5IGZyb20gXCIuL0NhbnZhc05vZGVGYWN0b3J5XCI7XHJcbmltcG9ydCBUaWxlbWFwRmFjdG9yeSBmcm9tIFwiLi9UaWxlbWFwRmFjdG9yeVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFuYWdlciBvZiBhbGwgZmFjdG9yaWVzIHVzZWQgZm9yIGFkZGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjdG9yeU1hbmFnZXIge1xyXG5cclxuICAgIC8vIENvbnN0cnVjdG9ycyBhcmUgY2FsbGVkIGhlcmUgdG8gYWxsb3cgYXNzaWdubWVudCBvZiB0aGVpciBmdW5jdGlvbnMgdG8gZnVuY3Rpb25zIGluIHRoaXMgY2xhc3NcclxuICAgIHByaXZhdGUgY2FudmFzTm9kZUZhY3Rvcnk6IENhbnZhc05vZGVGYWN0b3J5ID0gbmV3IENhbnZhc05vZGVGYWN0b3J5KCk7XHJcbiAgICBwcml2YXRlIHRpbGVtYXBGYWN0b3J5OiBUaWxlbWFwRmFjdG9yeSA9IG5ldyBUaWxlbWFwRmFjdG9yeSgpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+KXtcclxuICAgICAgICB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmluaXQoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcEZhY3RvcnkuaW5pdChzY2VuZSwgdGlsZW1hcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4cG9zZSBhbGwgb2YgdGhlIGZhY3RvcmllcyB0aHJvdWdoIHRoZSBmYWN0b3J5IG1hbmFnZXJcclxuICAgIC8qKlxyXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXHJcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XHJcblx0ICovXHJcbiAgICB1aUVsZW1lbnQodHlwZTogc3RyaW5nIHwgVUlFbGVtZW50VHlwZSwgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVUlFbGVtZW50IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRVSUVsZW1lbnQodHlwZSwgbGF5ZXJOYW1lLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcclxuXHQgKi9cclxuXHRzcHJpdGUoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIEFkZHMgYW4gQW5pbWF0ZWRTcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGVkU3ByaXRlXHJcblx0ICovXHJcblx0YW5pbWF0ZWRTcHJpdGUoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogQW5pbWF0ZWRTcHJpdGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZEFuaW1hdGVkU3ByaXRlKGtleSwgbGF5ZXJOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxyXG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGdyYXBoaWMgdG8gYWRkXHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljXHJcblx0ICovXHJcblx0Z3JhcGhpYyh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkR3JhcGhpYyh0eXBlLCBsYXllck5hbWUsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkZXNpcmVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG5cdHRpbGVtYXAoa2V5OiBzdHJpbmcsIHNjYWxlPzogVmVjMik6IEFycmF5PExheWVyPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZW1hcEZhY3RvcnkuYWRkKGtleSwgc2NhbGUpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xyXG5pbXBvcnQgVGlsZXNldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVzZXRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IFRpbGVkQ29sbGVjdGlvblRpbGUgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XHJcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuLi8uLi9QYXRoZmluZGluZy9OYXZtZXNoXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuLyoqXHJcbiAqIEEgZmFjdG9yeSB0aGF0IGFic3RyYWN0cyBhZGRpbmcgQHJlZmVyZW5jZVtUaWxlbWFwXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxyXG4gKiBBY2Nlc3MgbWV0aG9kcyBpbiB0aGlzIGZhY3RvcnkgdGhyb3VnaCBTY2VuZS5hZGQuW21ldGhvZE5hbWVdKCkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwRmFjdG9yeSB7XHJcbiAgICBwcml2YXRlIHNjZW5lOiBTY2VuZTtcclxuICAgIHByaXZhdGUgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIFxyXG4gICAgaW5pdChzY2VuZTogU2NlbmUsIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgICAgICB0aGlzLnRpbGVtYXBzID0gdGlsZW1hcHM7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIC0gVGhpcyBpcyBzcGVjaWZpY2FsbHkgY2F0ZXJlZCB0byBUaWxlZCB0aWxlbWFwcyByaWdodCBub3cuIEluIHRoZSBmdXR1cmUsXHJcbiAgICAvLyBpdCB3b3VsZCBiZSBnb29kIHRvIGhhdmUgYSBcInBhcnNlVGlsZW1hcFwiIGZ1bmN0aW9uIHRoYXQgd291bGQgY29udmVydCB0aGUgdGlsZW1hcFxyXG4gICAgLy8gZGF0YSBpbnRvIGEgc3RhbmRhcmQgZm9ybWF0LiBUaGlzIGNvdWxkIGFsbG93IGZvciBzdXBwb3J0IGZyb20gb3RoZXIgcHJvZ3JhbXNcclxuICAgIC8vIG9yIHRoZSBkZXZlbG9wbWVudCBvZiBhbiBpbnRlcm5hbCBsZXZlbCBidWlsZGVyIHRvb2xcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkZXNpcmVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG5cdGFkZCA9IChrZXk6IHN0cmluZywgc2NhbGU6IFZlYzIgPSBuZXcgVmVjMigxLCAxKSk6IEFycmF5PExheWVyPiA9PiB7XHJcbiAgICAgICAgLy8gR2V0IFRpbGVtYXAgRGF0YVxyXG4gICAgICAgIGxldCB0aWxlbWFwRGF0YSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRpbGVtYXAoa2V5KTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyB0aWxlbWFwIHRvIGVpdGhlciBiZSBvcnRob2dyYXBoaWMgb3IgaXNvbWV0cmljXHJcbiAgICAgICAgbGV0IGNvbnN0cjogbmV3KC4uLmFyZ3M6IGFueSkgPT4gVGlsZW1hcDtcclxuICAgICAgICBpZih0aWxlbWFwRGF0YS5vcmllbnRhdGlvbiA9PT0gXCJvcnRob2dyYXBoaWNcIil7XHJcbiAgICAgICAgICAgIGNvbnN0ciA9IE9ydGhvZ29uYWxUaWxlbWFwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGlzb21ldHJpYyB0aWxlbWFwIHN1cHBvcnQgcmlnaHQgbm93LCBzbyBPcnRob2dyYXBoaWMgdGlsZW1hcFxyXG4gICAgICAgICAgICBjb25zdHIgPSBPcnRob2dvbmFsVGlsZW1hcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJldHVybiB2YWx1ZSBhcnJheVxyXG4gICAgICAgIGxldCBzY2VuZUxheWVycyA9IG5ldyBBcnJheTxMYXllcj4oKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBvZiB0aGUgdGlsZXNldHMgZm9yIHRoaXMgdGlsZW1hcFxyXG4gICAgICAgIGxldCB0aWxlc2V0cyA9IG5ldyBBcnJheTxUaWxlc2V0PigpO1xyXG5cclxuICAgICAgICBsZXQgY29sbGVjdGlvblRpbGVzID0gbmV3IEFycmF5PFRpbGVkQ29sbGVjdGlvblRpbGU+KCk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwRGF0YS50aWxlc2V0cyl7XHJcbiAgICAgICAgICAgIGlmKHRpbGVzZXQuaW1hZ2Upe1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0YW5kYXJkIHRpbGVzZXQgYW5kIG5vdCBhIGNvbGxlY3Rpb24sIGNyZWF0ZSBhIHRpbGVzZXQgZm9yIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIFdlIGFyZSBpZ25vcmluZyBjb2xsZWN0aW9uIHRpbGVzZXRzIGZvciBub3cuIFRoaXMgaXMgbGlrZWx5IG5vdCBhIGdyZWF0IGlkZWEgaW4gcHJhY3RpY2UsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGVvcmV0aWNhbGx5IHNvbWVvbmUgY291bGQgd2FudCB0byB1c2Ugb25lIGZvciBhIHN0YW5kYXJkIHRpbGVtYXAuIFdlIGFyZSBhc3N1bWluZyBmb3Igbm93XHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIG9ubHkgd2FudCB0byB1c2UgdGhlbSBmb3Igb2JqZWN0IGxheWVyc1xyXG4gICAgICAgICAgICAgICAgdGlsZXNldHMucHVzaChuZXcgVGlsZXNldCh0aWxlc2V0KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlc2V0LnRpbGVzLmZvckVhY2godGlsZSA9PiB0aWxlLmlkICs9IHRpbGVzZXQuZmlyc3RnaWQpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblRpbGVzLnB1c2goLi4udGlsZXNldC50aWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSB0aWxlbWFwIGFuZCBjcmVhdGUgdGlsZWRsYXllcnMgb3Igb2JqZWN0IGxheWVyc1xyXG4gICAgICAgIGZvcihsZXQgbGF5ZXIgb2YgdGlsZW1hcERhdGEubGF5ZXJzKXtcclxuXHJcbiAgICAgICAgICAgIGxldCBzY2VuZUxheWVyO1xyXG4gICAgICAgICAgICBsZXQgaXNQYXJhbGxheExheWVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiUGFyYWxsYXhcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFyYWxsYXhMYXllciA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJEZXB0aFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGlzUGFyYWxsYXhMYXllcil7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRQYXJhbGxheExheWVyKGxheWVyLm5hbWUsIG5ldyBWZWMyKDEsIDEpLCBkZXB0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRMYXllcihsYXllci5uYW1lLCBkZXB0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGxheWVyLnR5cGUgPT09IFwidGlsZWxheWVyXCIpe1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHRpbGVtYXAgb2JqZWN0IGZvciB0aGUgbGF5ZXJcclxuICAgICAgICAgICAgICAgIGxldCB0aWxlbWFwID0gbmV3IGNvbnN0cih0aWxlbWFwRGF0YSwgbGF5ZXIsIHRpbGVzZXRzLCBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGlsZW1hcCB0byBzY2VuZVxyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyLmFkZE5vZGUodGlsZW1hcCk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRpbGVtYXAgd2l0aCBwaHlzaWNzIGlmIGl0J3MgY29sbGlkYWJsZVxyXG4gICAgICAgICAgICAgICAgaWYodGlsZW1hcC5pc0NvbGxpZGFibGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuYWRkUGh5c2ljcygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5uYW1lID09PSBcIkdyb3VwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuc2V0R3JvdXAoaXRlbS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGlzTmF2bWVzaFBvaW50cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5hdm1lc2hOYW1lO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVkZ2VzO1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXIucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiTmF2bWVzaFBvaW50c1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmF2bWVzaFBvaW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwibmFtZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdm1lc2hOYW1lID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJlZGdlc1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gcHJvcC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihpc05hdm1lc2hQb2ludHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBnID0gbmV3IFBvc2l0aW9uR3JhcGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBvYmogb2YgbGF5ZXIub2JqZWN0cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcuYWRkUG9zaXRpb25lZE5vZGUobmV3IFZlYzIob2JqLngsIG9iai55KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVkZ2Ugb2YgZWRnZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnLmFkZEVkZ2UoZWRnZS5mcm9tLCBlZGdlLnRvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5hZGROYXZpZ2FibGVFbnRpdHkobmF2bWVzaE5hbWUsIG5ldyBOYXZtZXNoKGcpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGF5ZXIgaXMgYW4gb2JqZWN0IGxheWVyLCBzbyBhZGQgZWFjaCBvYmplY3QgYXMgYSBzcHJpdGUgdG8gYSBuZXcgbGF5ZXJcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9iaiBpcyBjb2xsaWRhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1BoeXNpY3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNDb2xsaWRhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvbkVudGVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb25FeGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJpZ2dlckdyb3VwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihvYmoucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBvYmoucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiSGFzUGh5c2ljc1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQaHlzaWNzID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbGxpZGFibGUgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJHcm91cFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cCA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIklzVHJpZ2dlclwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RyaWdnZXIgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJUcmlnZ2VyR3JvdXBcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckdyb3VwID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiVHJpZ2dlck9uRW50ZXJcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbnRlciA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkV4aXRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FeGl0ID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwcml0ZTogU3ByaXRlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvYmogaXMgYSB0aWxlIGZyb20gYSB0aWxlc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVzZXRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGlsZXNldC5oYXNUaWxlKG9iai5naWQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgaXMgYSB0aWxlIGZyb20gdGhpcyBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aWxlc2V0LmdldEltYWdlT2Zmc2V0Rm9yVGlsZShvYmouZ2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHRoaXMuc2NlbmUuYWRkLnNwcml0ZShpbWFnZUtleSwgbGF5ZXIubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCgob2JqLnggKyBzaXplLngvMikqc2NhbGUueCwgKG9iai55IC0gc2l6ZS55LzIpKnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEltYWdlT2Zmc2V0KG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2l6ZS5jb3B5KHNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGluIGEgdGlsZXNldCwgbXVzdCBjb3JyZXNwb25kIHRvIGEgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzcHJpdGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGUgb2YgY29sbGVjdGlvblRpbGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9iai5naWQgPT09IHRpbGUuaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGUuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUucG9zaXRpb24uc2V0KChvYmoueCArIHRpbGUuaW1hZ2V3aWR0aC8yKSpzY2FsZS54LCAob2JqLnkgLSB0aWxlLmltYWdlaGVpZ2h0LzIpKnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHNwcml0ZS4gQXNzb2NpYXRlIGl0IHdpdGggb3VyIHBoeXNpY3Mgb2JqZWN0IGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1BoeXNpY3Mpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBzcHJpdGUgYSBzdGF0aWMgcGh5c2ljcyBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmFkZFBoeXNpY3Moc3ByaXRlLmJvdW5kYXJ5LmNsb25lKCksIFZlYzIuWkVSTywgaXNDb2xsaWRhYmxlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEdyb3VwKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNUcmlnZ2VyICYmIHRyaWdnZXJHcm91cCAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0VHJpZ2dlcih0cmlnZ2VyR3JvdXAsIG9uRW50ZXIsIG9uRXhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgIHNjZW5lTGF5ZXJzLnB1c2goc2NlbmVMYXllcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NlbmVMYXllcnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuL1NjZW5lXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgbGF5ZXIgaW4gdGhlIHNjZW5lLiBMYXllcnMgYXJlIHVzZWQgZm9yIHNvcnRpbmcgQHJlZmVyZW5jZVtHYW1lTm9kZV1zIGJ5IGRlcHRoLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xyXG4gICAgLyoqIFRoZSBzY2VuZSB0aGlzIGxheWVyIGJlbG9uZ3MgdG8gKi9cclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcblxyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBsYXllciBpcyBwYXVzZWQgb3Igbm90ICovXHJcbiAgICBwcm90ZWN0ZWQgcGF1c2VkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgaGlkZGVuIGZyb20gYmVpbmcgcmVuZGVyZWQgb3Igbm90ICovXHJcbiAgICBwcm90ZWN0ZWQgaGlkZGVuOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgZ2xvYmFsIGFscGhhIGxldmVsIG9mIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgR2FtZU5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBpdGVtczogQXJyYXk8R2FtZU5vZGU+O1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGxheWVyIHNob3VsZCBiZSB5c29ydGVkICovXHJcbiAgICBwcm90ZWN0ZWQgeVNvcnQ6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBkZXB0aCBvZiB0aGlzIGxheWVyIGNvbXBhcmVkIHRvIG90aGVyIGxheWVycyAqL1xyXG4gICAgcHJvdGVjdGVkIGRlcHRoOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxheWVyLiBUbyBkbyB0aGlzIGluIGEgZ2FtZSwgdXNlIHRoZSBhZGRMYXllcigpIG1ldGhvZCBpbiBAcmVmcmVuY2VbU2NlbmVdXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGFkZCB0aGUgbGF5ZXIgdG9cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZyl7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnlTb3J0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyZWl2ZXMgdGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqL1xyXG4gICAgZ2V0TmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZXMvVW5wYXVzZXMgdGhlIGxheWVyLiBBZmZlY3RzIGFsbCBlbGVtZW50cyBpbiB0aGlzIGxheWVyXHJcbiAgICAgKiBAcGFyYW0gcGF1c2VWYWx1ZSBUcnVlIGlmIHRoZSBsYXllciBzaG91bGQgYmUgcGF1c2VkLCBmYWxzZSBpZiBub3RcclxuICAgICAqL1xyXG4gICAgc2V0UGF1c2VkKHBhdXNlVmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHBhdXNlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgcGF1c2VkXHJcbiAgICAgKi9cclxuICAgIGlzUGF1c2VkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcGFyYW0gYWxwaGEgVGhlIG5ldyBvcGFjaXR5IHZhbHVlIGluIHRoZSByYW5nZSBbMCwgMV1cclxuICAgICAqL1xyXG4gICAgc2V0QWxwaGEoYWxwaGE6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSBNYXRoVXRpbHMuY2xhbXAoYWxwaGEsIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBvcGFjaXR5XHJcbiAgICAgKi9cclxuICAgIGdldEFscGhhKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBsYXllcidzIGhpZGRlbiB2YWx1ZS4gSWYgaGlkZGVuLCBhIGxheWVyIHdpbGwgbm90IGJlIHJlbmRlcmVkLCBidXQgd2lsbCBzdGlsbCB1cGRhdGVcclxuICAgICAqIEBwYXJhbSBoaWRkZW4gVGhlIGhpZGRlbiB2YWx1ZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqL1xyXG4gICAgc2V0SGlkZGVuKGhpZGRlbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gaGlkZGVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaGlkZWVuIHZhbHVlIG9mIHRoZSBseWFlclxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2NlbmUgaXMgaGlkZGVuLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgaXNIaWRkZW4oKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkZGVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBQYXVzZXMgdGhpcyBzY2VuZSBhbmQgaGlkZXMgaXQgKi9cclxuICAgIGRpc2FibGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVW5wYXVzZXMgdGhpcyBsYXllciBhbmQgbWFrZXMgaXQgdmlzaWJsZSAqL1xyXG4gICAgZW5hYmxlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHNjZW5lIHdpbGwgeVNvcnQgYXV0b21hdGljYWxseS5cclxuICAgICAqIHlTb3J0aW5nIG1lYW5zIHRoYXQgQ2FudmFzTm9kZXMgb24gdGhpcyBsYXllciB3aWxsIGhhdmUgdGhlaXIgZGVwdGggc29ydGVkIGRlcGVuZGluZyBvbiB0aGVpciB5LXZhbHVlLlxyXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGlmIGFuIG9iamVjdCBpcyBcImhpZ2hlclwiIGluIHRoZSBzY2VuZSwgaXQgd2lsbCBzb3J0IGJlaGluZCBvYmplY3RzIHRoYXQgYXJlIFwibG93ZXJcIi5cclxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciAzLzQgdmlldyBnYW1lcywgb3Igc2ltaWxhciBzaXR1YXRpb25zLCB3aGVyZSB5b3Ugc29tZXRpbWVzIHdhbnQgdG8gYmUgaW4gZnJvbnQgb2Ygb2JqZWN0cyxcclxuICAgICAqIGFuZCBvdGhlciB0aW1lcyB3YW50IHRvIGJlIGJlaGluZCB0aGUgc2FtZSBvYmplY3RzLlxyXG4gICAgICogQHBhcmFtIHlTb3J0IFRydWUgaWYgeVNvcnRpbmcgc2hvdWxkIGJlIGFjdGl2ZSwgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIHNldFlTb3J0KHlTb3J0OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy55U29ydCA9IHlTb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgeVNvcnQgc3RhdHVzIG9mIHRoZSBzY2VuZVxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB5U29ydGluZyBpcyBvY2N1cnJpbmcsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBnZXRZU29ydCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55U29ydDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGRlcHRoIG9mIHRoZSBsYXllciBjb21wYXJlZCB0byBvdGhlciBsYXllcnMuIEEgbGFyZ2VyIG51bWJlciBtZWFucyB0aGUgbGF5ZXIgd2lsbCBiZSBjbG9zZXIgdG8gdGhlIHNjcmVlbi5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBzZXREZXB0aChkZXB0aDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVwdGhcclxuICAgICAqL1xyXG4gICAgZ2V0RGVwdGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBub2RlIHRvIHRoaXMgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGlzIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBhZGROb2RlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgIG5vZGUuc2V0TGF5ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoaXMgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSB3YXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBGaW5kIGFuZCByZW1vdmUgdGhlIG5vZGVcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2Yobm9kZSk7XHJcblxyXG4gICAgICAgIGlmKGluZGV4ICE9PSAtMSl7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgbm9kZS5zZXRMYXllcih1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJlaXZlcyBhbGwgR2FtZU5vZGVzIGZyb20gdGhpcyBsYXllclxyXG4gICAgICogQHJldHVybnMgYW4gQXJyYXkgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIEdhbWVOb2RlcyBpbiB0aGlzIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBnZXRJdGVtcygpOiBBcnJheTxHYW1lTm9kZT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGV4dGVuc2lvbiBvZiBhIExheWVyIHRoYXQgaGFzIGEgcGFyYWxsYXggdmFsdWUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJhbGxheExheWVyIGV4dGVuZHMgTGF5ZXIge1xyXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhlIHBhcmFsbGF4IG9mIHRoZSBMYXllciAqL1xyXG5cdHBhcmFsbGF4OiBWZWMyO1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgUGFyYWxsYXhMYXllci5cclxuXHQgKiBVc2UgYWRkUGFyYWxsYXhMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXHJcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0byBhZGQgdGhpcyBQYXJhbGxheExheWVyIHRvXHJcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFBhcmFsbGF4TGF5ZXJcclxuXHQgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyKXtcclxuXHRcdHN1cGVyKHNjZW5lLCBuYW1lKTtcclxuXHRcdHRoaXMucGFyYWxsYXggPSBwYXJhbGxheDtcclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi9QYXJhbGxheExheWVyXCI7XHJcblxyXG4vKipcclxuICogQSBMYXllciBzdHJpY3RseSB0byBiZSB1c2VkIGZvciBtYW5hZ2luZyBVSUVsZW1lbnRzLlxyXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGEgTGF5ZXIgdGhhdCBhbHdheXMgc3RheXMgaW4gdGhlIHNhbWUgcGxhY2UsXHJcbiAqIGFuZCB0aHVzIHJlbmRlcnMgdGhpbmdzIGxpa2UgYSBIVUQgb3IgYW4gaW52ZW50b3J5IHdpdGhvdXQgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgXFxyZWZlcmVuY2VbVmlld3BvcnRdIHNjcm9sbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJTGF5ZXIgZXh0ZW5kcyBQYXJhbGxheExheWVyIHtcclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IFVJTGF5ZXIuXHJcblx0ICogVXNlIGFkZFVJTGF5ZXIoKSBpbiBAcmVmZXJlbmNlW1NjZW5lXSB0byBhZGQgYSBsYXllciBvZiB0aGlzIHR5cGUgdG8geW91ciBnYW1lLlxyXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdG8gYWRkIHRoaXMgVUlMYXllciB0b1xyXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBVSUxheWVyXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIoc2NlbmUsIG5hbWUsIFZlYzIuWkVSTyk7XHJcblx0fVxyXG59IiwiaW1wb3J0IExheWVyIGZyb20gXCIuL0xheWVyXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4uL1NjZW5lR3JhcGgvU2NlbmVHcmFwaFwiO1xyXG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvUGh5c2ljc01hbmFnZXJcIjtcclxuaW1wb3J0IEJhc2ljUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvQmFzaWNQaHlzaWNzTWFuYWdlclwiO1xyXG5pbXBvcnQgU2NlbmVHcmFwaEFycmF5IGZyb20gXCIuLi9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheVwiO1xyXG5pbXBvcnQgRmFjdG9yeU1hbmFnZXIgZnJvbSBcIi4vRmFjdG9yaWVzL0ZhY3RvcnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IEdhbWUgZnJvbSBcIi4uL0xvb3AvR2FtZVwiO1xyXG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25NYW5hZ2VyIGZyb20gXCIuLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgQUlNYW5hZ2VyIGZyb20gXCIuLi9BSS9BSU1hbmFnZXJcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBTY2VuZU9wdGlvbnMgZnJvbSBcIi4vU2NlbmVPcHRpb25zXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBUaW1lck1hbmFnZXIgZnJvbSBcIi4uL1RpbWluZy9UaW1lck1hbmFnZXJcIjtcclxuaW1wb3J0IFR3ZWVuTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5NYW5hZ2VyXCI7XHJcblxyXG4vKipcclxuICogU2NlbmVzIGFyZSB0aGUgbWFpbiBjb250YWluZXIgaW4gdGhlIGdhbWUgZW5naW5lLlxyXG4gKiBZb3VyIG1haW4gc2NlbmUgaXMgdGhlIGN1cnJlbnQgbGV2ZWwgb3IgbWVudSBvZiB0aGUgZ2FtZSwgYW5kIHdpbGwgY29udGFpbiBhbGwgb2YgdGhlIEdhbWVOb2RlcyBuZWVkZWQuXHJcbiAqIFNjZW5lcyBwcm92aWRlIGFuIGVhc3kgd2F5IHRvIGxvYWQgYXNzZXRzLCBhZGQgYXNzZXRzIHRvIHRoZSBnYW1lIHdvcmxkLCBhbmQgdW5sb2FkIGFzc2V0cyxcclxuICogYW5kIGhhdmUgbGlmZWN5Y2xlIG1ldGhvZHMgZXhwb3NlZCBmb3IgdGhlc2UgZnVuY3Rpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmUgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgZ2FtZSB3b3JsZC4gKi9cclxuICAgIHByb3RlY3RlZCB3b3JsZFNpemU6IFZlYzI7XHJcblxyXG4gICAgLyoqIFRoZSB2aWV3cG9ydC4gKi9cclxuICAgIHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblxyXG4gICAgLyoqIEEgZmxhZyB0aGF0IHJlcHJlc2VudHMgd2hldGhlciB0aGlzIHNjZW5lIGlzIHJ1bm5pbmcgb3Igbm90LiAqL1xyXG4gICAgcHJvdGVjdGVkIHJ1bm5pbmc6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBtYW5hZ2VyIG9mIHRoaXMgc2NlbmUuICovXHJcbiAgICBwcm90ZWN0ZWQgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSByZWNlaXZlciBmb3IgdGhpcyBzY2VuZS4gKi9cclxuICAgIHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblxyXG4gICAgLyoqIFRoZSBlbWl0dGVyIGZvciB0aGlzIHNjZW5lLiAqL1xyXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gICAgLyoqIFRoaXMgbGlzdCBvZiB0aWxlbWFwcyBpbiB0aGlzIHNjZW5lLiAqL1xyXG4gICAgcHJvdGVjdGVkIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcclxuXHJcbiAgICAvKiogQSBtYXAgZnJvbSBsYXllciBuYW1lcyB0byB0aGUgbGF5ZXJzIHRoZW1zZWx2ZXMgKi9cclxuICAgIHByb3RlY3RlZCBsYXllcnM6IE1hcDxMYXllcj47XHJcblxyXG4gICAgLyoqIEEgbWFwIGZyb20gcGFyYWxsYXggbGF5ZXIgbmFtZXMgdG8gdGhlIHBhcmFsbGF4IGxheWVycyB0aGVtc2VsdmVzICovXHJcbiAgICBwcm90ZWN0ZWQgcGFyYWxsYXhMYXllcnM6IE1hcDxQYXJhbGxheExheWVyPjtcclxuXHJcbiAgICAvKiogQSBtYXAgZnJvbSB1aUxheWVyIG5hbWVzIHRvIHRoZSB1aUxheWVycyB0aGVtc2VsdmVzICovXHJcbiAgICBwcm90ZWN0ZWQgdWlMYXllcnM6IE1hcDxVSUxheWVyPjtcclxuXHJcbiAgICAvKiogVGhlIHNjZW5lIGdyYXBoIG9mIHRoZSBTY2VuZSovXHJcbiAgICBwcm90ZWN0ZWQgc2NlbmVHcmFwaDogU2NlbmVHcmFwaDtcclxuXHJcbiAgICAvKiogVGhlIHBoeXNpY3MgbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cclxuICAgIHByb3RlY3RlZCBwaHlzaWNzTWFuYWdlcjogUGh5c2ljc01hbmFnZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgbmF2aWdhdGlvbiBtYW5hZ2VyIG9mIHRoZSBTY2VuZSAqL1xyXG4gICAgcHJvdGVjdGVkIG5hdk1hbmFnZXI6IE5hdmlnYXRpb25NYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgQUkgbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cclxuICAgIHByb3RlY3RlZCBhaU1hbmFnZXI6IEFJTWFuYWdlcjtcclxuXHJcbiAgICAvKiogVGhlIHJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIHNjZW5lICovXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcclxuXHJcbiAgICAvKiogQW4gaW50ZXJmYWNlIHRoYXQgYWxsb3dzIHRoZSBhZGRpbmcgb2YgZGlmZmVyZW50IG5vZGVzIHRvIHRoZSBzY2VuZSAqL1xyXG4gICAgcHVibGljIGFkZDogRmFjdG9yeU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBvZiBkaWZmZXJlbnQgZmlsZXMgZm9yIHVzZSBpbiB0aGUgc2NlbmUuIEFuIGFsaWFzIGZvciByZXNvdXJjZU1hbmFnZXIgKi9cclxuICAgIHB1YmxpYyBsb2FkOiBSZXNvdXJjZU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgbG9hZGluZyBhbmQgdW5sb2FkaW5nIG9mIGRpZmZlcmVudCBmaWxlcyBmb3IgdXNlIGluIHRoZSBzY2VuZSAqL1xyXG4gICAgcHVibGljIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGlzIHNjZW5lICovXHJcbiAgICBwdWJsaWMgc2NlbmVPcHRpb25zOiBTY2VuZU9wdGlvbnM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNjZW5lLiBUbyBhZGQgYSBuZXcgU2NlbmUgaW4geW91ciBnYW1lLCB1c2UgY2hhbmdlVG9TY2VuZSgpIGluIEByZWZlcmVuY2VbU2NlbmVNYW5hZ2VyXVxyXG4gICAgICogQHBhcmFtIHZpZXdwb3J0IFRoZSB2aWV3cG9ydCBvZiB0aGUgZ2FtZVxyXG4gICAgICogQHBhcmFtIHNjZW5lTWFuYWdlciBUaGUgU2NlbmVNYW5hZ2VyIHRoYXQgb3ducyB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcGFyYW0gcmVuZGVyaW5nTWFuYWdlciBUaGUgUmVuZGVyaW5nTWFuYWdlciB0aGF0IHdpbGwgaGFuZGxlIHRoaXMgU2NlbmUncyByZW5kZXJpbmdcclxuICAgICAqIEBwYXJhbSBnYW1lIFRoZSBpbnN0YW5jZSBvZiB0aGUgR2FtZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIFNjZW5lIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZpZXdwb3J0OiBWaWV3cG9ydCwgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXIsIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXIsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pe1xyXG4gICAgICAgIHRoaXMuc2NlbmVPcHRpb25zID0gU2NlbmVPcHRpb25zLnBhcnNlKG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMud29ybGRTaXplID0gbmV3IFZlYzIoNTAwLCA1MDApO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCAyNTYwLCAxMjgwKTtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjZW5lTWFuYWdlciA9IHNjZW5lTWFuYWdlcjtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy50aWxlbWFwcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuc2NlbmVHcmFwaCA9IG5ldyBTY2VuZUdyYXBoQXJyYXkodGhpcy52aWV3cG9ydCwgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMubGF5ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMudWlMYXllcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5wYXJhbGxheExheWVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5waHlzaWNzTWFuYWdlciA9IG5ldyBCYXNpY1BoeXNpY3NNYW5hZ2VyKHRoaXMuc2NlbmVPcHRpb25zLnBoeXNpY3MpO1xyXG4gICAgICAgIHRoaXMubmF2TWFuYWdlciA9IG5ldyBOYXZpZ2F0aW9uTWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMuYWlNYW5hZ2VyID0gbmV3IEFJTWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IHJlbmRlcmluZ01hbmFnZXI7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkID0gbmV3IEZhY3RvcnlNYW5hZ2VyKHRoaXMsIHRoaXMudGlsZW1hcHMpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWQgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKVxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gdGhpcy5sb2FkO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHRpbWVyIG1hbmFnZXIgYW5kIGNsZWFyIGFueSBleGlzdGluZyB0aW1lcnNcclxuICAgICAgICBUaW1lck1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5jbGVhclRpbWVycygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBhIG5ldyBzY2VuZSBpcyBjcmVhdGVkLCBiZWZvcmUgYW55dGhpbmcgZWxzZS4gKi9cclxuICAgIGluaXRTY2VuZShpbml0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG5cclxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIGEgbmV3IHNjZW5lIGlzIGNyZWF0ZWQuIExvYWQgYWxsIGZpbGVzIHlvdSB3aXNoIHRvIGFjY2VzcyBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cclxuICAgIGxvYWRTY2VuZSgpOiB2b2lkIHt9XHJcblxyXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgc3RyaWN0bHkgYWZ0ZXIgbG9hZFNjZW5lKCkuIENyZWF0ZSBhbnkgZ2FtZSBvYmplY3RzIHlvdSB3aXNoIHRvIHVzZSBpbiB0aGUgc2NlbmUgaGVyZS4gKi9cclxuICAgIHN0YXJ0U2NlbmUoKTogdm9pZCB7fVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIGNhbGxlZCBldmVyeSBmcmFtZSBvZiB0aGUgZ2FtZS4gVGhpcyBpcyB3aGVyZSB5b3UgY2FuIGR5bmFtaWNhbGx5IGRvIHRoaW5ncyBsaWtlIGFkZCBpbiBuZXcgZW5lbWllc1xyXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSB0aW1lIHRoaXMgZnJhbWUgcmVwcmVzZW50c1xyXG4gICAgICovXHJcbiAgICB1cGRhdGVTY2VuZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge31cclxuXHJcbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgb24gc2NlbmUgZGVzdHJ1Y3Rpb24uIFNwZWNpZnkgd2hpY2ggZmlsZXMgeW91IG5vIGxvbmdlciBuZWVkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uICovXHJcbiAgICB1bmxvYWRTY2VuZSgpOiB2b2lkIHt9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTY2VuZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBEbyB0aW1lIHVwZGF0ZXNcclxuICAgICAgICBUaW1lck1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gRG8gYWxsIEFJIHVwZGF0ZXNcclxuICAgICAgICB0aGlzLmFpTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGFsbCBwaHlzaWNzIG9iamVjdHNcclxuICAgICAgICB0aGlzLnBoeXNpY3NNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgYWxsIGNhbnZhcyBvYmplY3RzXHJcbiAgICAgICAgdGhpcy5zY2VuZUdyYXBoLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgYWxsIHRpbGVtYXBzXHJcbiAgICAgICAgdGhpcy50aWxlbWFwcy5mb3JFYWNoKHRpbGVtYXAgPT4ge1xyXG4gICAgICAgICAgICBpZighdGlsZW1hcC5nZXRMYXllcigpLmlzUGF1c2VkKCkpe1xyXG4gICAgICAgICAgICAgICAgdGlsZW1hcC51cGRhdGUoZGVsdGFUKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgYWxsIHR3ZWVuc1xyXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdmlld3BvcnRcclxuICAgICAgICB0aGlzLnZpZXdwb3J0LnVwZGF0ZShkZWx0YVQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGVjdHMgcmVuZGVyYWJsZSBzZXRzIGFuZCBjb29yZGluYXRlcyB3aXRoIHRoZSBSZW5kZXJpbmdNYW5hZ2VyIHRvIGRyYXcgdGhlIFNjZW5lXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcigpOiB2b2lkIHtcclxuICAgICAgICAvLyBHZXQgdGhlIHZpc2libGUgc2V0IG9mIG5vZGVzXHJcbiAgICAgICAgbGV0IHZpc2libGVTZXQgPSB0aGlzLnNjZW5lR3JhcGguZ2V0VmlzaWJsZVNldCgpO1xyXG5cclxuICAgICAgICAvLyBBZGQgcGFyYWxsYXggbGF5ZXIgaXRlbXMgdG8gdGhlIHZpc2libGUgc2V0ICh3ZSdyZSByZW5kZXJpbmcgdGhlbSBhbGwgZm9yIG5vdylcclxuICAgICAgICB0aGlzLnBhcmFsbGF4TGF5ZXJzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgbGV0IHBMYXllciA9IHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGZvcihsZXQgbm9kZSBvZiBwTGF5ZXIuZ2V0SXRlbXMoKSl7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQ2FudmFzTm9kZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgdGhlIHZpc2libGUgc2V0LCB0aWxlbWFwcywgYW5kIHVpTGF5ZXJzIHRvIHRoZSByZW5kZXJlclxyXG4gICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlci5yZW5kZXIodmlzaWJsZVNldCwgdGhpcy50aWxlbWFwcywgdGhpcy51aUxheWVycyk7XHJcblxyXG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuc2NlbmVHcmFwaC5nZXRBbGxOb2RlcygpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcHMuZm9yRWFjaCh0aWxlbWFwID0+IHRpbGVtYXAudmlzaWJsZSA/IG5vZGVzLnB1c2godGlsZW1hcCkgOiAwKTtcclxuICAgICAgICBEZWJ1Zy5zZXROb2Rlcyhub2Rlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzY2VuZSBhcyBydW5uaW5nIG9yIG5vdFxyXG4gICAgICogQHBhcmFtIHJ1bm5pbmcgVHJ1ZSBpZiB0aGUgU2NlbmUgc2hvdWxkIGJlIHJ1bm5pbmcsIGZhbHNlIGlmIG5vdFxyXG4gICAgICovXHJcbiAgICBzZXRSdW5uaW5nKHJ1bm5pbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBydW5uaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgU2NlbmUgaXMgcnVubmluZ1xyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2NlbmUgaXMgcnVubmluZywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGlzUnVubmluZygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIHNjZW5lIGdyYXBoXHJcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIENhbnZhc05vZGUpe1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lR3JhcGgucmVtb3ZlTm9kZShub2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEZXN0cm95cyB0aGlzIHNjZW5lIGFuZCBhbGwgbm9kZXMgaW4gaXQgKi9cclxuICAgIGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMuc2NlbmVHcmFwaC5nZXRBbGxOb2RlcygpKXtcclxuICAgICAgICAgICAgbm9kZS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IobGV0IHRpbGVtYXAgb2YgdGhpcy50aWxlbWFwcyl7XHJcbiAgICAgICAgICAgIHRpbGVtYXAuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XHJcblxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lR3JhcGg7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucGh5c2ljc01hbmFnZXI7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMubmF2TWFuYWdlcjtcclxuICAgICAgICBkZWxldGUgdGhpcy5haU1hbmFnZXI7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMucmVjZWl2ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGxheWVyIHRvIHRoZSBzY2VuZSBhbmQgcmV0dXJucyBpdFxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBsYXllclxyXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIExheWVyXHJcbiAgICAgKi9cclxuICAgIGFkZExheWVyKG5hbWU6IHN0cmluZywgZGVwdGg/OiBudW1iZXIpOiBMYXllciB7XHJcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcclxuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBMYXllcih0aGlzLCBuYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy5sYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcclxuXHJcbiAgICAgICAgaWYoZGVwdGgpe1xyXG4gICAgICAgICAgICBsYXllci5zZXREZXB0aChkZXB0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IHBhcmFsbGF4IGxheWVyIHRvIHRoaXMgc2NlbmUgYW5kIHJldHVybnMgaXRcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJhbGxheCBsYXllclxyXG4gICAgICogQHBhcmFtIHBhcmFsbGF4IFRoZSBwYXJhbGxheCBsZXZlbFxyXG4gICAgICogQHBhcmFtIGRlcHRoIFRoZSBkZXB0aCBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIFBhcmFsbGF4TGF5ZXJcclxuICAgICAqL1xyXG4gICAgYWRkUGFyYWxsYXhMYXllcihuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyLCBkZXB0aD86IG51bWJlcik6IFBhcmFsbGF4TGF5ZXIge1xyXG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGF5ZXIgPSBuZXcgUGFyYWxsYXhMYXllcih0aGlzLCBuYW1lLCBwYXJhbGxheCk7XHJcblxyXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcclxuXHJcbiAgICAgICAgaWYoZGVwdGgpe1xyXG4gICAgICAgICAgICBsYXllci5zZXREZXB0aChkZXB0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IFVJTGF5ZXIgdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IFVJbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIFVJTGF5ZXJcclxuICAgICAqL1xyXG4gICAgYWRkVUlMYXllcihuYW1lOiBzdHJpbmcpOiBVSUxheWVyIHtcclxuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xyXG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxheWVyID0gbmV3IFVJTGF5ZXIodGhpcywgbmFtZSk7XHJcblxyXG4gICAgICAgIHRoaXMudWlMYXllcnMuYWRkKG5hbWUsIGxheWVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxheWVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGxheWVyIGZyb20gdGhlIHNjZW5lIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxyXG4gICAgICogVGhpcyBjYW4gYmUgYSBMYXllciBvciBhbnkgb2YgaXRzIHN1YmNsYXNzZXNcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIExheWVyIGZvdW5kIHdpdGggdGhhdCBuYW1lXHJcbiAgICAgKi9cclxuICAgIGdldExheWVyKG5hbWU6IHN0cmluZyk6IExheWVyIHtcclxuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllcnMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFsbGF4TGF5ZXJzLmdldChuYW1lKTtcclxuICAgICAgICB9IGVsc2UgaWYodGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51aUxheWVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgYFJlcXVlc3RlZCBsYXllciAke25hbWV9IGRvZXMgbm90IGV4aXN0LmA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGF5ZXIgaXMgYSBQYXJhbGxheExheWVyXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBhIFBhcmFsbGF4TGF5ZXJcclxuICAgICAqL1xyXG4gICAgaXNQYXJhbGxheExheWVyKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgVUlMYXllclxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgbGF5ZXIgaXMgUGFyYWxsYXhMYXllclxyXG4gICAgICovXHJcbiAgICBpc1VJTGF5ZXIobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudWlMYXllcnMuaGFzKG5hbWUpO1xyXG4gICAgfSAgICBcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIG9mIHRoaXMgbm9kZSB3aXRoIHJlc3BlY3QgdG8gY2FtZXJhIHNwYWNlIChkdWUgdG8gdGhlIHZpZXdwb3J0IG1vdmluZykuXHJcbiAgICAgKiBUaGlzIHZhbHVlIGlzIGFmZmVjdGVkIGJ5IHRoZSBwYXJhbGxheCBsZXZlbCBvZiB0aGUgQHJlZmVyZW5jZVtMYXllcl0gdGhlIG5vZGUgaXMgb24uXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBjaGVjayB0aGUgdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgdHJhbnNsYXRpb24gb2Ygdmlld3BvcnQgd2l0aCByZXNwZWN0IHRvIHRoaXMgbm9kZS5cclxuICAgICAqL1xyXG4gICAgZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGU6IEdhbWVOb2RlKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IGxheWVyID0gbm9kZS5nZXRMYXllcigpO1xyXG5cclxuICAgICAgICBpZihsYXllciBpbnN0YW5jZW9mIFBhcmFsbGF4TGF5ZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBVSUxheWVyKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luKCkubXVsdChsYXllci5wYXJhbGxheCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luKCk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNjYWxlIGxldmVsIG9mIHRoZSB2aWV3XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlld3BvcnRcclxuICAgICovXHJcblx0Z2V0Vmlld1NjYWxlKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKTtcclxuXHR9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBWaWV3cG9ydCBhc3NvY2lhdGVkIHdpdGggdGhpcyBzY2VuZVxyXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgVmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgZ2V0Vmlld3BvcnQoKTogVmlld3BvcnQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgd29ybGQgc2l6ZSBvZiB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgd29ybGQgc2l6ZSBpbiBhIFZlYzJcclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRTaXplKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkU2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIFNjZW5lR3JhcGggYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSBTY2VuZUdyYXBoXHJcbiAgICAgKi9cclxuICAgIGdldFNjZW5lR3JhcGgoKTogU2NlbmVHcmFwaCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVHcmFwaDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIFBoeXNpY3NNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgUGh5c2ljc01hbmFnZXJcclxuICAgICAqL1xyXG4gICAgZ2V0UGh5c2ljc01hbmFnZXIoKTogUGh5c2ljc01hbmFnZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBoeXNpY3NNYW5hZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgTmF2aWdhdGlvbk1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSBOYXZpZ2F0aW9uTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXROYXZpZ2F0aW9uTWFuYWdlcigpOiBOYXZpZ2F0aW9uTWFuYWdlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2TWFuYWdlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEFJTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxyXG4gICAgICogQHJldHVybnMgVGhlIEFJTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXRBSU1hbmFnZXIoKTogQUlNYW5hZ2VyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5haU1hbmFnZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYW4gSUQgZm9yIGEgR2FtZU5vZGVcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgSURcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVJZCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjZW5lTWFuYWdlci5nZW5lcmF0ZUlkKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBUaWxlbWFwIGluIHRoaXMgU2NlbmVcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBUaWxlbWFwXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVGlsZW1hcCwgaWYgb25lIHRoaXMgbmFtZSBleGlzdHMsIG90aGVyd2lzZSBudWxsXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVtYXAobmFtZTogc3RyaW5nKTogVGlsZW1hcCB7XHJcbiAgICAgICAgZm9yKGxldCB0aWxlbWFwIG9mIHRoaXMgLnRpbGVtYXBzKXtcclxuICAgICAgICAgICAgaWYodGlsZW1hcC5uYW1lID09PSBuYW1lKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aWxlbWFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi9TY2VuZVwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcclxuaW1wb3J0IE1lbW9yeVV0aWxzIGZyb20gXCIuLi9VdGlscy9NZW1vcnlVdGlsc1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBTY2VuZU1hbmFnZXIgYWN0cyBhcyBhbiBpbnRlcmZhY2UgdG8gY3JlYXRlIFNjZW5lcywgYW5kIGhhbmRsZXMgdGhlIGxpZmVjeWNsZSBtZXRob2RzIG9mIFNjZW5lcy5cclxuICogSXQgZ2l2ZXMgU2NlbmVzIGFjY2VzcyB0byBpbmZvcm1hdGlvbiB0aGV5IG5lZWQgZnJvbSB0aGUgQHJlZmVyZW5jZVtHYW1lXSBjbGFzcyB3aGlsZSBrZWVwaW5nIGEgbGF5ZXIgb2Ygc2VwYXJhdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lTWFuYWdlciB7XHJcblx0LyoqIFRoZSBjdXJyZW50IFNjZW5lIG9mIHRoZSBnYW1lICovXHJcblx0cHJvdGVjdGVkIGN1cnJlbnRTY2VuZTogU2NlbmU7XHJcblxyXG5cdC8qKiBUaGUgVmlld3BvcnQgb2YgdGhlIGdhbWUgKi9cclxuXHRwcm90ZWN0ZWQgdmlld3BvcnQ6IFZpZXdwb3J0O1xyXG5cclxuXHQvKiogQSByZWZlcmVuY2UgdG8gdGhlIFJlc291cmNlTWFuYWdlciAqL1xyXG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcblx0LyoqIEEgY291bnRlciB0byBrZWVwIHRyYWNrIG9mIGdhbWUgaWRzICovXHJcblx0cHJvdGVjdGVkIGlkQ291bnRlcjogbnVtYmVyO1xyXG5cclxuXHQvKiogVGhlIFJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIGdhbWUgKi9cclxuXHRwcm90ZWN0ZWQgcmVuZGVyaW5nTWFuYWdlcjogUmVuZGVyaW5nTWFuYWdlcjtcclxuXHJcblx0LyoqIEZvciBjb25zaXN0ZW5jeSwgb25seSBjaGFuZ2Ugc2NlbmVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHVwZGF0ZSBjeWNsZSAqL1xyXG5cdHByb3RlY3RlZCBwZW5kaW5nU2NlbmU6IFNjZW5lO1xyXG5cdHByb3RlY3RlZCBwZW5kaW5nU2NlbmVJbml0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IFNjZW5lTWFuYWdlclxyXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgVmlld3BvcnQgb2YgdGhlIGdhbWVcclxuXHQgKiBAcGFyYW0gZ2FtZSBUaGUgR2FtZSBpbnN0YW5jZVxyXG5cdCAqIEBwYXJhbSByZW5kZXJpbmdNYW5hZ2VyIFRoZSBSZW5kZXJpbmdNYW5hZ2VyIG9mIHRoZSBnYW1lXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyKXtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblx0XHR0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcblx0XHR0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSByZW5kZXJpbmdNYW5hZ2VyO1xyXG5cdFx0dGhpcy5pZENvdW50ZXIgPSAwO1xyXG5cdFx0dGhpcy5wZW5kaW5nU2NlbmUgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGEgc2NlbmUgYXMgdGhlIG1haW4gc2NlbmUuXHJcblx0ICogVXNlIHRoaXMgbWV0aG9kIGlmIHlvdSd2ZSBjcmVhdGVkIGEgc3ViY2xhc3Mgb2YgU2NlbmUsIGFuZCB5b3Ugd2FudCB0byBhZGQgaXQgYXMgdGhlIG1haW4gU2NlbmUuXHJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHNjZW5lIHRvIGFkZFxyXG5cdCAqIEBwYXJhbSBpbml0IEFuIG9iamVjdCB0byBwYXNzIHRvIHRoZSBpbml0IGZ1bmN0aW9uIG9mIHRoZSBuZXcgc2NlbmVcclxuXHQgKi9cclxuXHRwdWJsaWMgY2hhbmdlVG9TY2VuZTxUIGV4dGVuZHMgU2NlbmU+KGNvbnN0cjogbmV3ICguLi5hcmdzOiBhbnkpID0+IFQsIGluaXQ/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG5cdFx0Y29uc29sZS5sb2coXCJDcmVhdGluZyB0aGUgbmV3IHNjZW5lIC0gY2hhbmdlIGlzIHBlbmRpbmcgdW50aWwgbmV4dCB1cGRhdGVcIik7XHJcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG5ldyBjb25zdHIodGhpcy52aWV3cG9ydCwgdGhpcywgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zKTtcclxuXHRcdHRoaXMucGVuZGluZ1NjZW5lSW5pdCA9IGluaXQ7XHJcblx0fVxyXG5cclxuXHRwcm90ZWN0ZWQgZG9TY2VuZUNoYW5nZSgpe1xyXG5cdFx0Y29uc29sZS5sb2coXCJQZXJmb3JtaW5nIHNjZW5lIGNoYW5nZVwiKTtcclxuXHRcdHRoaXMudmlld3BvcnQuc2V0Q2VudGVyKHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS54LCB0aGlzLnZpZXdwb3J0LmdldEhhbGZTaXplKCkueSk7XHJcblx0XHRcclxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lKXtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHNjZW5lXCIpXHJcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnVubG9hZFNjZW5lKCk7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyhcIkRlc3Ryb3lpbmcgb2xkIHNjZW5lXCIpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5kZXN0cm95KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc29sZS5sb2coXCJVbmxvYWRpbmcgb2xkIHJlc291cmNlcy4uLlwiKTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLnVubG9hZEFsbFJlc291cmNlcygpO1xyXG5cclxuXHRcdC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgdGhlIGN1cnJlbnQgb25lXHJcblx0XHR0aGlzLmN1cnJlbnRTY2VuZSA9IHRoaXMucGVuZGluZ1NjZW5lO1xyXG5cclxuXHRcdC8vIE1ha2UgdGhlIHBlbmRpbmcgc2NlbmUgbnVsbFxyXG5cdFx0dGhpcy5wZW5kaW5nU2NlbmUgPSBudWxsO1xyXG5cclxuXHRcdC8vIEluaXQgdGhlIHNjZW5lXHJcblx0XHR0aGlzLmN1cnJlbnRTY2VuZS5pbml0U2NlbmUodGhpcy5wZW5kaW5nU2NlbmVJbml0KTtcclxuXHJcblx0XHQvLyBFbnF1ZXVlIGFsbCBzY2VuZSBhc3NldCBsb2Fkc1xyXG5cdFx0dGhpcy5jdXJyZW50U2NlbmUubG9hZFNjZW5lKCk7XHJcblxyXG5cdFx0Ly8gTG9hZCBhbGwgYXNzZXRzXHJcblx0XHRjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIFNjZW5lIExvYWRcIik7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlci5sb2FkUmVzb3VyY2VzRnJvbVF1ZXVlKCgpID0+IHtcclxuXHRcdFx0Y29uc29sZS5sb2coXCJTdGFydGluZyBTY2VuZVwiKTtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUuc3RhcnRTY2VuZSgpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zZXRSdW5uaW5nKHRydWUpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJpbmdNYW5hZ2VyLnNldFNjZW5lKHRoaXMuY3VycmVudFNjZW5lKTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGVzIGEgdW5pcXVlIElEXHJcblx0ICogQHJldHVybnMgQSBuZXcgSURcclxuXHQgKi9cclxuXHRwdWJsaWMgZ2VuZXJhdGVJZCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuaWRDb3VudGVyKys7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBjdXJyZW50IFNjZW5lXHJcblx0ICovXHJcblx0cHVibGljIHJlbmRlcigpOiB2b2lkIHtcclxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lKXtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUucmVuZGVyKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSBjdXJyZW50IFNjZW5lXHJcblx0ICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZXN0ZXAgb2YgdGhlIFNjZW5lXHJcblx0ICovXHJcblx0cHVibGljIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XHJcblx0XHRpZih0aGlzLnBlbmRpbmdTY2VuZSAhPT0gbnVsbCl7XHJcblx0XHRcdHRoaXMuZG9TY2VuZUNoYW5nZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMuY3VycmVudFNjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmlzUnVubmluZygpKXtcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUudXBkYXRlKGRlbHRhVCk7XHJcblx0XHR9XHJcblx0fVxyXG59IiwiaW1wb3J0IEFycmF5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL0FycmF5VXRpbHNcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogVGhlIG9wdGlvbnMgdG8gZ2l2ZSBhIEByZWZlcmVuY2VbU2NlbmVdIGZvciBpbml0aWFsaXphdGlvblxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVPcHRpb25zIHtcclxuICAgIHBoeXNpY3M6IHtcclxuICAgICAgICBncm91cHM6IEFycmF5PHN0cmluZz4sXHJcbiAgICAgICAgY29sbGlzaW9uczogQXJyYXk8QXJyYXk8bnVtYmVyPj47XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBTY2VuZU9wdGlvbnN7XHJcbiAgICAgICAgbGV0IHNPcHQgPSBuZXcgU2NlbmVPcHRpb25zKCk7XHJcblxyXG4gICAgICAgIGlmKG9wdGlvbnMucGh5c2ljcyA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgc09wdC5waHlzaWNzID0ge2dyb3VwczogdW5kZWZpbmVkLCBjb2xsaXNpb25zOiB1bmRlZmluZWR9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNPcHQucGh5c2ljcyA9IG9wdGlvbnMucGh5c2ljcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzT3B0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBNYW5hZ2VzIGFueSBzb3VuZHMgb3IgbXVzaWMgbmVlZGVkIGZvciB0aGUgZ2FtZS5cclxuICogVGhyb3VnaCB0aGUgRXZlbnRRdWV1ZSwgZXhwb3NlcyBpbnRlcmZhY2UgdG8gcGxheSBzb3VuZHMgc28gR2FtZU5vZGVzIGNhbiBhY3RpdmF0ZSBzb3VuZHMgd2l0aG91dFxyXG4gKiBuZWVkaW5nIGRpcmVjdCByZWZlcmVuY2VzIHRvIHRoZSBhdWRpbyBzeXN0ZW1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvTWFuYWdlciB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogQXVkaW9NYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgZXZlbnQgcmVjZWl2ZXIgb2YgdGhpcyBBdWRpb01hbmFnZXIgKi9cclxuICAgIHByaXZhdGUgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cclxuICAgIC8qKiBBIE1hcCBvZiB0aGUgbmFtZXMgb2YgY3VycmVudGx5IHBsYXlpbmcgKG9yIHBhdXNlZCkgc291bmRzIHRvIHRoZWlyIEF1ZGlvQnVmZmVycyAqL1xyXG4gICAgcHJpdmF0ZSBjdXJyZW50U291bmRzOiBNYXA8QXVkaW9CdWZmZXJTb3VyY2VOb2RlPjtcclxuXHJcbiAgICBwcml2YXRlIGF1ZGlvQ3R4OiBBdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgcHJpdmF0ZSBnYWluTm9kZXM6IEFycmF5PEdhaW5Ob2RlPjtcclxuXHJcbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5pbml0QXVkaW8oKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoW1xyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQsXHJcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCxcclxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5QTEFZX01VU0lDLFxyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYLFxyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLk1VVEVfQ0hBTk5FTCxcclxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5VTk1VVEVfQ0hBTk5FTFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNvdW5kcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5nYWluTm9kZXMgPSBuZXcgQXJyYXk8R2Fpbk5vZGU+KE1BWF9BVURJT19DSEFOTkVMUyk7XHJcbiAgICAgICAgdGhpcy5pbml0R2Fpbk5vZGVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGluc3RhbmNlIG9mIHRoZSBBdWRpb01hbmFnZXIgY2xhc3Mgb3IgY3JlYXRlIGEgbmV3IG9uZSBpZiBub25lIGV4aXN0c1xyXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IEF1ZGlvTWFuYWdlciB7XHJcbiAgICAgICAgaWYoIXRoaXMuaW5zdGFuY2Upe1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IEF1ZGlvTWFuYWdlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSB3ZWJBdWRpbyBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaW5pdEF1ZGlvKCk6IHZvaWQge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0Oy8vIHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7IFxyXG4gICAgICAgICAgICB0aGlzLmF1ZGlvQ3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpOyBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dlYiBBdWRpbyBBUEkgc3VjY2Vzc2Z1bGx5IGxvYWRlZCcpO1xyXG4gICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dlYiBBdWRpbyBBUEkgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTsgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaW5pdEdhaW5Ob2RlcygpOiB2b2lkIHtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgTUFYX0FVRElPX0NIQU5ORUxTOyBpKyspe1xyXG4gICAgICAgICAgICB0aGlzLmdhaW5Ob2Rlc1tpXSA9IHRoaXMuYXVkaW9DdHguY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYXVkaW8gY29udGV4dFxyXG4gICAgICogQHJldHVybnMgVGhlIEF1ZGlvQ29udGV4dFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QXVkaW9Db250ZXh0KCk6IEF1ZGlvQ29udGV4dCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9DdHg7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAgICBBY2NvcmRpbmcgdG8gdGhlIE1ETiwgY3JlYXRlIGEgbmV3IHNvdW5kIGZvciBldmVyeSBjYWxsOlxyXG5cclxuICAgICAgICBBbiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgY2FuIG9ubHkgYmUgcGxheWVkIG9uY2U7IGFmdGVyIGVhY2ggY2FsbCB0byBzdGFydCgpLCB5b3UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgbm9kZVxyXG4gICAgICAgIGlmIHlvdSB3YW50IHRvIHBsYXkgdGhlIHNhbWUgc291bmQgYWdhaW4uIEZvcnR1bmF0ZWx5LCB0aGVzZSBub2RlcyBhcmUgdmVyeSBpbmV4cGVuc2l2ZSB0byBjcmVhdGUsIGFuZCB0aGVcclxuICAgICAgICBhY3R1YWwgQXVkaW9CdWZmZXJzIGNhbiBiZSByZXVzZWQgZm9yIG11bHRpcGxlIHBsYXlzIG9mIHRoZSBzb3VuZC4gSW5kZWVkLCB5b3UgY2FuIHVzZSB0aGVzZSBub2RlcyBpbiBhXHJcbiAgICAgICAgXCJmaXJlIGFuZCBmb3JnZXRcIiBtYW5uZXI6IGNyZWF0ZSB0aGUgbm9kZSwgY2FsbCBzdGFydCgpIHRvIGJlZ2luIHBsYXlpbmcgdGhlIHNvdW5kLCBhbmQgZG9uJ3QgZXZlbiBib3RoZXIgdG9cclxuICAgICAgICBob2xkIGEgcmVmZXJlbmNlIHRvIGl0LiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgYXQgYW4gYXBwcm9wcmlhdGUgdGltZSwgd2hpY2ggd29uJ3QgYmVcclxuICAgICAgICB1bnRpbCBzb21ldGltZSBhZnRlciB0aGUgc291bmQgaGFzIGZpbmlzaGVkIHBsYXlpbmcuXHJcbiAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNvdW5kIGZyb20gdGhlIGtleSBvZiBhIGxvYWRlZCBhdWRpbyBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBhdWRpbyBmaWxlIHRvIGNyZWF0ZSBhIG5ldyBzb3VuZCBmb3JcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXdseSBjcmVhdGVkIEF1ZGlvQnVmZmVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBjcmVhdGVTb3VuZChrZXk6IHN0cmluZywgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgb3B0aW9uczogTWFwPGFueT4pOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGUge1xyXG4gICAgICAgIC8vIEdldCBhdWRpbyBidWZmZXJcclxuICAgICAgICBsZXQgYnVmZmVyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0QXVkaW8oa2V5KTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgc291bmQgc291cmNlXHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuYXVkaW9DdHguY3JlYXRlQnVmZmVyU291cmNlKCk7IFxyXG4gICAgICBcclxuICAgICAgICAvLyBUZWxsIHRoZSBzb3VyY2Ugd2hpY2ggc291bmQgdG8gcGxheVxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSBidWZmZXI7ICAgICAgICAgICAgICAgXHJcbiAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBhbnkgYWRkaXRpb25hbCBub2Rlc1xyXG4gICAgICAgIGNvbnN0IG5vZGVzOiBBcnJheTxBdWRpb05vZGU+ID0gW3NvdXJjZV07XHJcblxyXG4gICAgICAgIC8vIERvIGFueSBhZGRpdGlvbmFsIG5vZGVzIGhlcmU/XHJcbiAgICAgICAgLy8gT2YgY291cnNlLCB0aGVyZSBhcmVuJ3QgYW55IHN1cHBvcnRlZCB5ZXQuLi5cclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBnYWluIG5vZGUgZm9yIHRoaXMgY2hhbm5lbFxyXG4gICAgICAgIG5vZGVzLnB1c2godGhpcy5nYWluTm9kZXNbY2hhbm5lbF0pO1xyXG5cclxuICAgICAgICAvLyBDb25uZWN0IGFueSBub2RlcyBhbG9uZyB0aGUgcGF0aFxyXG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIG5vZGVzW2ktMV0uY29ubmVjdChub2Rlc1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25uZWN0IHRoZSBzb3VyY2UgdG8gdGhlIGNvbnRleHQncyBkZXN0aW5hdGlvblxyXG4gICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5hdWRpb0N0eC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYXkgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNvdW5kIHRvIHBsYXlcclxuICAgICAqIEBwYXJhbSBsb29wIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdG8gbG9vcCB0aGUgc291bmRcclxuICAgICAqIEBwYXJhbSBob2xkUmVmZXJlbmNlIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3Qgd2Ugd2FudCB0byBob2xkIG9uIHRvIGEgcmVmZXJlbmNlIG9mIHRoZSBhdWRpbyBub2RlLiBUaGlzIGlzIGdvb2QgZm9yIHBsYXlpbmcgbXVzaWMgb24gYSBsb29wIHRoYXQgd2lsbCBldmVudHVhbGx5IG5lZWQgdG8gYmUgc3RvcHBlZC5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHBsYXlTb3VuZChrZXk6IHN0cmluZywgbG9vcDogYm9vbGVhbiwgaG9sZFJlZmVyZW5jZTogYm9vbGVhbiwgY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgb3B0aW9uczogTWFwPGFueT4pOiB2b2lkIHtcclxuICAgICAgICBsZXQgc291bmQgPSB0aGlzLmNyZWF0ZVNvdW5kKGtleSwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIGlmKGxvb3Ape1xyXG4gICAgICAgICAgICBzb3VuZC5sb29wID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBhIHJlZmVyZW5jZSBvZiB0aGUgbmV3IHNvdW5kIHRvIGEgbWFwLiBUaGlzIHdpbGwgYWxsb3cgdXMgdG8gc3RvcCBhIGxvb3Bpbmcgb3IgbG9uZyBzb3VuZCBhdCBhIGxhdGVyIHRpbWVcclxuICAgICAgICBpZihob2xkUmVmZXJlbmNlKXtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U291bmRzLmFkZChrZXksIHNvdW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc291bmQuc3RhcnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgdGhlIHNvdW5kIHNwZWNpZmllZCBieSB0aGUga2V5XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdG9wU291bmQoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBsZXQgc291bmQgPSB0aGlzLmN1cnJlbnRTb3VuZHMuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYoc291bmQpe1xyXG4gICAgICAgICAgICBzb3VuZC5zdG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNvdW5kcy5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIG11dGVDaGFubmVsKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUpe1xyXG4gICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGhpcy5hdWRpb0N0eC5jdXJyZW50VGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHVubXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XHJcbiAgICAgICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgxLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZvbHVtZSBvZiBhIGNoYW5uZWwgdXNpbmcgdGhlIEdhaW5Ob2RlIGZvciB0aGF0IGNoYW5uZWwuIEZvciBtb3JlXHJcbiAgICAgKiBpbmZvcm1hdGlvbiBvbiBHYWluTm9kZXMsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2Fpbk5vZGVcclxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBhdWRpbyBjaGFubmVsIHRvIHNldCB0aGUgdm9sdW1lIGZvclxyXG4gICAgICogQHBhcmFtIHZvbHVtZSBUaGUgdm9sdW1lIG9mIHRoZSBjaGFubmVsLiAwIGlzIG11dGVkLiBWYWx1ZXMgYmVsb3cgemVybyB3aWxsIGJlIHNldCB0byB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2V0Vm9sdW1lKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUsIHZvbHVtZTogbnVtYmVyKXtcclxuICAgICAgICBpZih2b2x1bWUgPCAwKXtcclxuICAgICAgICAgICAgdm9sdW1lID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFtID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgYW0uZ2Fpbk5vZGVzW2NoYW5uZWxdLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sdW1lLCBhbS5hdWRpb0N0eC5jdXJyZW50VGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBHYWluTm9kZSBmb3IgdGhpcyBjaGFubmVsLlxyXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCBHYWluTm9kZXMgaGVyZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2Fpbk5vZGVcclxuICAgICAqIERPTidUIFVTRSBUSElTIFVOTEVTUyBZT1UgS05PVyBXSEFUIFlPVSdSRSBET0lOR1xyXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWxcclxuICAgICAqIEByZXR1cm5zIFRoZSBHYWluTm9kZSBmb3IgdGhlIHNwZWNpZmllZCBjaGFubmVsXHJcbiAgICAgKi9cclxuICAgIGdldENoYW5uZWxHYWluTm9kZShjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5nYWluTm9kZXNbY2hhbm5lbF07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIC8vIFBsYXkgZWFjaCBhdWRpbyBjbGlwIHJlcXVlc3RlZFxyXG4gICAgICAgIC8vIFRPRE8gLSBBZGQgbG9naWMgdG8gbWVyZ2Ugc291bmRzIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBvZiB0aGUgc2FtZSBrZXlcclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX1NPVU5EIHx8IGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyB8fCBldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU0ZYKXtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VuZEtleSA9IGV2ZW50LmRhdGEuZ2V0KFwia2V5XCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvb3AgPSBldmVudC5kYXRhLmdldChcImxvb3BcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgaG9sZFJlZmVyZW5jZSA9IGV2ZW50LmRhdGEuZ2V0KFwiaG9sZFJlZmVyZW5jZVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuREVGQVVMVDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLk1VU0lDO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKEdhbWVFdmVudFR5cGUuUExBWV9TRlgpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBBdWRpb0NoYW5uZWxUeXBlLlNGWDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihldmVudC5kYXRhLmhhcyhcImNoYW5uZWxcIikpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBldmVudC5kYXRhLmdldChcImNoYW5uZWxcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5U291bmQoc291bmRLZXksIGxvb3AsIGhvbGRSZWZlcmVuY2UsIGNoYW5uZWwsIGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlNUT1BfU09VTkQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdW5kS2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BTb3VuZChzb3VuZEtleSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTVVURV9DSEFOTkVMKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5VTk1VVEVfQ0hBTk5FTCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVubXV0ZUNoYW5uZWwoZXZlbnQuZGF0YS5nZXQoXCJjaGFubmVsXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gQXVkaW9DaGFubmVsVHlwZSB7XHJcbiAgICBERUZBVUxUID0gMCxcclxuICAgIFNGWCA9IDEsXHJcbiAgICBNVVNJQyA9IDIsXHJcbiAgICBDVVNUT01fMSA9IDMsXHJcbiAgICBDVVNUT01fMiA9IDQsXHJcbiAgICBDVVNUT01fMyA9IDUsXHJcbiAgICBDVVNUT01fNCA9IDYsXHJcbiAgICBDVVNUT01fNSA9IDcsXHJcbiAgICBDVVNUT01fNiA9IDgsXHJcbiAgICBDVVNUT01fNyA9IDksXHJcbiAgICBDVVNUT01fOCA9IDEwLFxyXG4gICAgQ1VTVE9NXzkgPSAxMSxcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9BVURJT19DSEFOTkVMUyA9IDEyOyIsImltcG9ydCBVcGRhdGVhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VcGRhdGVhYmxlXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgVGltZXJNYW5hZ2VyIGZyb20gXCIuL1RpbWVyTWFuYWdlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHJcbiAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyB0aW1lciAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXRlOiBUaW1lclN0YXRlO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIHRpbWVyIGVuZHMgKi9cclxuICAgIHByb3RlY3RlZCBvbkVuZDogRnVuY3Rpb247XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdGltZXIgc2hvdWxkIGxvb3AgKi9cclxuICAgIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgdG90YWwgYW1vdW50IG9mIHRpbWUgdGhpcyB0aW1lciBydW5zIGZvciAqL1xyXG4gICAgcHJvdGVjdGVkIHRvdGFsVGltZTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgbGVmdCBvbiB0aGUgY3VycmVudCBydW4gKi9cclxuICAgIHByb3RlY3RlZCB0aW1lTGVmdDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoaXMgdGltZXIgaGFzIGJlZW4gcnVuICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtUnVuczogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRpbWU6IG51bWJlciwgb25FbmQ/OiBGdW5jdGlvbiwgbG9vcDogYm9vbGVhbiA9IGZhbHNlKXtcclxuICAgICAgICAvLyBSZWdpc3RlciB0aGlzIHRpbWVyXHJcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuYWRkVGltZXIodGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHRoaXMudGltZUxlZnQgPSAwO1xyXG4gICAgICAgIHRoaXMub25FbmQgPSBvbkVuZDtcclxuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XHJcbiAgICAgICAgdGhpcy5udW1SdW5zID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc1N0b3BwZWQoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5TVE9QUEVEO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUGF1c2VkKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFRpbWVyU3RhdGUuUEFVU0VEO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIHRpbWVyIGhhcyBiZWVuIHJ1biBiZWZvcmVcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgaXQgaGFzIGJlZW4gcnVuIGF0IGxlYXN0IG9uY2UgKGFmdGVyIHRoZSBsYXRlc3QgcmVzZXQpLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGhhc1J1bigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1SdW5zID4gMDtcclxuICAgIH1cclxuXHJcbiAgICBzdGFydCh0aW1lPzogbnVtYmVyKXtcclxuICAgICAgICBpZih0aW1lICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsVGltZSA9IHRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLkFDVElWRTtcclxuICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlc2V0cyB0aGlzIHRpbWVyLiBTZXRzIHRoZSBwcm9ncmVzcyBiYWNrIHRvIHplcm8sIGFuZCBzZXRzIHRoZSBudW1iZXIgb2YgcnVucyBiYWNrIHRvIHplcm8gKi9cclxuICAgIHJlc2V0KCl7XHJcbiAgICAgICAgdGhpcy50aW1lTGVmdCA9IHRoaXMudG90YWxUaW1lO1xyXG4gICAgICAgIHRoaXMubnVtUnVucyA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcGF1c2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuUEFVU0VEO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcil7XHJcbiAgICAgICAgaWYodGhpcy5zdGF0ZSA9PT0gVGltZXJTdGF0ZS5BQ1RJVkUpe1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVMZWZ0IC09IGRlbHRhVCoxMDAwO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy50aW1lTGVmdCA8PSAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZUxlZnQgPSBNYXRoVXRpbHMuY2xhbXBMb3cwKHRoaXMudGltZUxlZnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZW5kKCl7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBUaW1lclN0YXRlLlNUT1BQRUQ7XHJcbiAgICAgICAgdGhpcy5udW1SdW5zICs9IDE7XHJcblxyXG4gICAgICAgIC8vIENhbGwgdGhlIGVuZCBmdW5jdGlvbiBpZiB0aGVyZSBpcyBvbmVcclxuICAgICAgICBpZih0aGlzLm9uRW5kKXtcclxuICAgICAgICAgICAgdGhpcy5vbkVuZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTG9vcCBpZiB3ZSB3YW50IHRvXHJcbiAgICAgICAgaWYodGhpcy5sb29wKXtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbWVyU3RhdGUuQUNUSVZFO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gdGhpcy50b3RhbFRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ3tcclxuICAgICAgICByZXR1cm4gXCJUaW1lcjogXCIgKyB0aGlzLnN0YXRlICsgXCIgLSBUaW1lIExlZnQ6IFwiICsgdGhpcy50aW1lTGVmdCArIFwibXMgb2YgXCIgKyB0aGlzLnRvdGFsVGltZSArIFwibXNcIjtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gVGltZXJTdGF0ZSB7XHJcbiAgICBBQ1RJVkUgPSBcIkFDVElWRVwiLFxyXG4gICAgUEFVU0VEID0gXCJQQVVTRURcIixcclxuICAgIFNUT1BQRUQgPSBcIlNUT1BQRURcIlxyXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL1RpbWVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lck1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgdGltZXJzOiBBcnJheTxUaW1lcj47XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5zdGFuY2U6IFRpbWVyTWFuYWdlcjtcclxuXHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVGltZXJNYW5hZ2VyIHtcclxuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgVGltZXJNYW5hZ2VyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRUaW1lcih0aW1lcjogVGltZXIpe1xyXG4gICAgICAgIHRoaXMudGltZXJzLnB1c2godGltZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyVGltZXJzKCl7XHJcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnRpbWVycy5mb3JFYWNoKHRpbWVyID0+IHRpbWVyLnVwZGF0ZShkZWx0YVQpKTtcclxuICAgIH1cclxufSIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4vTWF0aFV0aWxzXCI7XHJcblxyXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgZGF0YXR5cGVzIGZvbGRlclxyXG4vKipcclxuICogQSBDb2xvciB1dGlsIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgY29sb3JzIGxpa2UgYSB2ZWN0b3IsIGJ1dCBjYW4gYmUgY29udmVydGVkIGludG8gYSBzdHJpbmcgZm9ybWF0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvciB7XHJcblx0LyoqIFRoZSByZWQgdmFsdWUgKi9cclxuXHRwdWJsaWMgcjogbnVtYmVyO1xyXG5cdC8qKiBUaGUgZ3JlZW4gdmFsdWUgKi9cclxuXHRwdWJsaWMgZzogbnVtYmVyO1xyXG5cdC8qKiBUaGUgYmx1ZSB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBiOiBudW1iZXI7XHJcblx0LyoqIFRoZSBhbHBoYSB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBhOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgY29sb3JcclxuXHQgKiBAcGFyYW0gciBSZWRcclxuXHQgKiBAcGFyYW0gZyBHcmVlblxyXG5cdCAqIEBwYXJhbSBiIEJsdWVcclxuXHQgKiBAcGFyYW0gYSBBbHBoYVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHI6IG51bWJlciA9IDAsIGc6IG51bWJlciA9IDAsIGI6IG51bWJlciA9IDAsIGE6IG51bWJlciA9IDEpe1xyXG4gICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgdGhpcy5nID0gZztcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYSA9IGE7XHJcblx0fVxyXG5cclxuXHQvKipcdFxyXG5cdCAqIFRyYW5zcGFyZW50IGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiYSgwLCAwLCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgVFJBTlNQQVJFTlQoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHRcclxuXHQgKiBSZWQgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgUkVEKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogR3JlZW4gY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgR1JFRU4oKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDAsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBCbHVlIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDAsIDAsIDI1NSlcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IEJMVUUoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAyNTUsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBZZWxsb3cgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDApXHJcblx0ICovXHJcblx0c3RhdGljIGdldCBZRUxMT1coKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDI1NSwgMCwgMSk7XHJcblx0fVxyXG5cclxuXHQvKipcdFxyXG5cdCAqIE1hZ2VudGEgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAyNTUpXHJcblx0ICovXHJcblx0c3RhdGljIGdldCBNQUdFTlRBKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAyNTUsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBDeWFuIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDAsIDI1NSwgMjU1KVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgQ1lBTigpOiBDb2xvciB7XHJcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDI1NSwgMjU1LCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogV2hpdGUgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDI1NSlcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IFdISVRFKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSwgMSk7XHJcblx0fSBcclxuXHJcblx0LyoqXHRcclxuXHQgKiBCbGFjayBjb2xvclxyXG5cdCAqIEByZXR1cm5zIHJnYigwLCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgQkxBQ0soKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogT3JhbmdlIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMTAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgT1JBTkdFKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAxMDAsIDAsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgY29sb3IgdG8gdGhlIHZhbHVlcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSByIFJlZFxyXG5cdCAqIEBwYXJhbSBnIEdyZWVuXHJcblx0ICogQHBhcmFtIGIgQmx1ZVxyXG5cdCAqIEBwYXJhbSBhIEFscGhhXHJcblx0ICovXHJcblx0c2V0KHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuXHRcdHRoaXMuciA9IHI7XHJcblx0XHR0aGlzLmcgPSBnO1xyXG5cdFx0dGhpcy5iID0gYjtcclxuXHRcdHRoaXMuYSA9IGE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGxpZ2h0ZXIgdGhhbiB0aGUgY3VycmVudCBjb2xvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IGxpZ2h0ZXIgQ29sb3JcclxuXHQgKi9cclxuXHRsaWdodGVuKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoTWF0aFV0aWxzLmNsYW1wKHRoaXMuciArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5nICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmIgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYSArIDEwLCAwLCAyNTUpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igc2xpZ2h0bHkgZGFya2VyIHRoYW4gdGhlIGN1cnJlbnQgY29sb3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBkYXJrZXIgQ29sb3JcclxuXHQgKi9cclxuXHRkYXJrZW4oKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcihNYXRoVXRpbHMuY2xhbXAodGhpcy5yIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmcgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYiAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5hICsgMTAsIDAsIDI1NSkpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoaXMgY29sb3IgYXMgYW4gYXJyYXlcclxuXHQgKiBAcmV0dXJucyBbciwgZywgYiwgYV1cclxuXHQgKi9cclxuXHR0b0FycmF5KCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gI1JSR0dCQlxyXG5cdCAqIEByZXR1cm5zICNSUkdHQkJcclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiI1wiICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuciwgMikgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5nLCAyKSArIE1hdGhVdGlscy50b0hleCh0aGlzLmIsIDIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiKHIsIGcsIGIpXHJcblx0ICogQHJldHVybnMgcmdiKHIsIGcsIGIpXHJcblx0ICovXHJcblx0dG9TdHJpbmdSR0IoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcInJnYihcIiArIHRoaXMuci50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5nLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmIudG9TdHJpbmcoKSArIFwiKVwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiYShyLCBnLCBiLCBhKVxyXG5cdCAqIEByZXR1cm5zIHJnYmEociwgZywgYiwgYSlcclxuXHQgKi9cclxuXHR0b1N0cmluZ1JHQkEoKTogc3RyaW5nIHtcclxuXHRcdGlmKHRoaXMuYSA9PT0gMCl7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nUkdCKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCJyZ2JhKFwiICsgdGhpcy5yLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmcudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYi50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5hLnRvU3RyaW5nKCkgK1wiKVwiXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUdXJucyB0aGlzIGNvbG9yIGludG8gYSBmbG9hdDMyQXJyYXkgYW5kIGNoYW5nZXMgY29sb3IgcmFuZ2UgdG8gWzAuMCwgMS4wXVxyXG5cdCAqIEByZXR1cm5zIGEgRmxvYXQzMkFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbG9yXHJcblx0ICovXHJcblx0dG9XZWJHTCgpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHR0aGlzLnIvMjU1LFxyXG5cdFx0XHR0aGlzLmcvMjU1LFxyXG5cdFx0XHR0aGlzLmIvMjU1LFxyXG5cdFx0XHR0aGlzLmFcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21TdHJpbmdIZXgoc3RyOiBzdHJpbmcpOiBDb2xvciB7XHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRpZihzdHIuY2hhckF0KDApID09IFwiI1wiKSBpKz0gMTtcclxuXHRcdGxldCByID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpLCBpKzIpKTtcclxuXHRcdGxldCBnID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpKzIsIGkrNCkpO1xyXG5cdFx0bGV0IGIgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGkrNCwgaSs2KSk7XHJcblx0XHRyZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIpO1xyXG5cdH1cclxufSIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYXNlRnVuY3Rpb25zIHtcclxuXHJcbiAgICBzdGF0aWMgZWFzZUluT3V0U2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZWFzZU91dEluU2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gLU1hdGguY29zKE1hdGguUEkqKHggKyAwLjUpKS8yIDogLU1hdGguY29zKE1hdGguUEkqKHggLSAwLjUpKS8yICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZWFzZU91dFNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zaW4oKHggKiBNYXRoLlBJKSAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5TaW5lKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoeCAqIE1hdGguUEkpIC8gMik7IFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWludCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gMTYgKiB4ICogeCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCA1KSAvIDI7ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgMikgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlT3V0SW5RdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyB0aGlzLmVhc2VPdXRJbl9PdXRQb3coeCwgMikgOiB0aGlzLmVhc2VPdXRJbl9JblBvdyh4LCAyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fT3V0UG93KHg6IG51bWJlciwgcG93OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAwLjUgLSBNYXRoLnBvdygtMiAqIHggKyAxLCBwb3cpIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fSW5Qb3coeDogbnVtYmVyLCBwb3c6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSArIE1hdGgucG93KDIgKiB4IC0gMSwgcG93KSAvIDI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEVhc2VGdW5jdGlvblR5cGUge1xyXG4gICAgLy8gU0lORVxyXG4gICAgSU5fT1VUX1NJTkUgPSBcImVhc2VJbk91dFNpbmVcIixcclxuICAgIE9VVF9JTl9TSU5FID0gXCJlYXNlT3V0SW5TaW5lXCIsXHJcbiAgICBJTl9TSU5FID0gXCJlYXNlSW5TaW5lXCIsXHJcbiAgICBPVVRfU0lORSA9IFwiZWFzZU91dFNpbmVcIixcclxuXHJcbiAgICAvLyBRVUFEXHJcbiAgICBJTl9PVVRfUVVBRCA9IFwiZWFzZUluT3V0UXVhZFwiLFxyXG4gICAgT1VUX0lOX1FVQUQgPSBcImVhc2VPdXRJblF1YWRcIixcclxuXHJcbiAgICAvLyBRVUlOVFxyXG4gICAgSU5fT1VUX1FVSU5UID0gXCJlYXNlSW5PdXRRdWludFwiXHJcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcclxuaW1wb3J0IEVkZ2VOb2RlIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0VkZ2VOb2RlXCI7XHJcblxyXG4vKiogQSBjbGFzcyB0byBwcm92aWRlcyBzb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBncmFwaHMgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhVdGlscyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERqaWtzdHJhJ3Mgc2hvcnRlc3QgcGF0aCBhbGdvcml0aG0gYmFzZWQgb24gdGhlIG9uZSBkZXNjcmliZWQgaW4gVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxyXG5cdCAqIEBwYXJhbSBnIFRoZSBncmFwaFxyXG5cdCAqIEBwYXJhbSBzdGFydCBUaGUgbnVtYmVyIHRvIHN0YXJ0IHRoZSBzaG9ydGVzdCBwYXRoIGZyb21cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwYXJlbnQgb2YgZWFjaCBub2RlIG9mIHRoZSBHcmFwaCBpbiB0aGUgc2hvcnRlc3QgcGF0aC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZGppa3N0cmEoZzogR3JhcGgsIHN0YXJ0OiBudW1iZXIpOiBBcnJheTxudW1iZXI+IHtcclxuXHRcdGxldCBpOiBudW1iZXI7XHRcdC8vIENvdW50ZXJcclxuXHRcdGxldCBwOiBFZGdlTm9kZTtcdC8vIFBvaW50ZXIgdG8gZWRnZW5vZGVcclxuXHRcdGxldCBpblRyZWU6IEFycmF5PGJvb2xlYW4+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG5cdFx0bGV0IGRpc3RhbmNlOiBBcnJheTxudW1iZXI+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG5cdFx0bGV0IHBhcmVudDogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcclxuXHRcdGxldCB2OiBudW1iZXI7XHRcdC8vIEN1cnJlbnQgdmVydGV4IHRvIHByb2Nlc3NcclxuXHRcdGxldCB3OiBudW1iZXI7IFx0XHQvLyBDYW5kaWRhdGUgZm9yIG5leHQgdmVydGV4XHJcblx0XHRsZXQgd2VpZ2h0OiBudW1iZXI7XHQvLyBFZGdlIHdlaWdodFxyXG5cdFx0bGV0IGRpc3Q7XHRcdFx0Ly8gQmVzdCBjdXJyZW50IGRpc3RhbmNlIGZyb20gc3RhcnRcclxuXHJcblx0XHRmb3IoaSA9IDA7IGkgPCBnLm51bVZlcnRpY2VzOyBpKyspe1xyXG5cdFx0XHRpblRyZWVbaV0gPSBmYWxzZTtcclxuXHRcdFx0ZGlzdGFuY2VbaV0gPSBJbmZpbml0eTtcclxuXHRcdFx0cGFyZW50W2ldID0gLTE7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGlzdGFuY2Vbc3RhcnRdID0gMDtcclxuXHRcdHYgPSBzdGFydDtcclxuXHJcblx0XHR3aGlsZSghaW5UcmVlW3ZdKXtcclxuXHRcdFx0aW5UcmVlW3ZdID0gdHJ1ZTtcclxuXHRcdFx0cCA9IGcuZWRnZXNbdl07XHJcblxyXG5cdFx0XHR3aGlsZShwICE9PSBudWxsKXtcclxuXHRcdFx0XHR3ID0gcC55O1xyXG5cdFx0XHRcdHdlaWdodCA9IHAud2VpZ2h0O1xyXG5cclxuXHRcdFx0XHRpZihkaXN0YW5jZVt3XSA+IGRpc3RhbmNlW3ZdICsgd2VpZ2h0KXtcclxuXHRcdFx0XHRcdGRpc3RhbmNlW3ddID0gZGlzdGFuY2Vbdl0gKyB3ZWlnaHQ7XHJcblx0XHRcdFx0XHRwYXJlbnRbd10gPSB2O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cCA9IHAubmV4dDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0diA9IDA7XHJcblxyXG5cdFx0XHRkaXN0ID0gSW5maW5pdHk7XHJcblxyXG5cdFx0XHRmb3IoaSA9IDA7IGkgPD0gZy5udW1WZXJ0aWNlczsgaSsrKXtcclxuXHRcdFx0XHRpZighaW5UcmVlW2ldICYmIGRpc3QgPiBkaXN0YW5jZVtpXSl7XHJcblx0XHRcdFx0XHRkaXN0ID0gZGlzdGFuY2U7XHJcblx0XHRcdFx0XHR2ID0gaTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFyZW50O1xyXG5cclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKiBBIGNsYXNzIGNvbnRhaW5pbmcgc29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgbWF0aCBvcGVyYXRpb25zICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGhVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgdGhlIHZhbHVlIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gZXh0cmFjdCB0aGUgc2lnbiBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyAtMSBpZiB0aGUgbnVtYmVyIGlzIGxlc3MgdGhhbiAwLCAxIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2lnbih4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMCA/IC0xIDogMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgeCBpcyBiZXR3ZWVuIGEgYW5kIGJcclxuICAgICAqIEBwYXJhbSBhIFRoZSBtaW4gYm91bmRcclxuICAgICAqIEBwYXJhbSBiIFRoZSBtYXggYm91bmRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIGV4Y2x1c2l2ZSBXaGV0aGVyIG9yIG5vdCBhIGFuZCBiIGFyZSBleGNsdXNpdmUgYm91bmRzXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHggaXMgYmV0d2VlbiBhIGFuZCBiLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJldHdlZW4oYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciwgZXhjbHVzaXZlPzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmKGV4Y2x1c2l2ZSl7XHJcbiAgICAgICAgICAgIHJldHVybiAoYSA8IHgpICYmICh4IDwgYik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhIDw9IHgpICYmICh4IDw9IGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgW21pbiwgbWF4XSwgcm91bmRpbmcgdXAgb3IgZG93biBpZiBuZWVkZWRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW4gb2YgdGhlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbWF4IFRoZSBtYXggb2YgdGhlIHJhbmdlXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCBvciBtaW4vbWF4IGlmIGl0IGV4Y2VlZHMgdGhlaXIgYm91bmRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbGFtcCh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgaWYoeCA8IG1pbikgcmV0dXJuIG1pbjtcclxuICAgICAgICBpZih4ID4gbWF4KSByZXR1cm4gbWF4O1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhbXBzIHRoZSB2YWx1ZSB4IHRvIHRoZSByYW5nZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEsIG9yIDAvMSBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2xhbXAwMSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXAoeCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFtcHMgdGhlIGxvd2VyIGVuZCBvZiB0aGUgdmFsdWUgb2YgeCB0byB0aGUgcmFuZ2UgdG8gbWluXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxyXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIG9mIHhcclxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiBtaW4sIG90aGVyd2lzZSBtaW5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsYW1wTG93KHg6IG51bWJlciwgbWluOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgbG93ZXIgZW5kIG9mIHRoZSB2YWx1ZSBvZiB4IHRvIHplcm9cclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMCwgb3RoZXJ3aXNlIDBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsYW1wTG93MCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXBMb3coeCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNsYW1wTWFnbml0dWRlKHY6IFZlYzIsIG06IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIGlmKHYubWFnU3EoKSA+IG0qbSl7XHJcbiAgICAgICAgICAgIHJldHVybiB2LnNjYWxlVG8obSk7XHJcbiAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNoYW5nZVJhbmdlKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBuZXdNaW46IG51bWJlciwgbmV3TWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlcnAobmV3TWluLCBuZXdNYXgsIHRoaXMuaW52TGVycChtaW4sIG1heCwgeCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIExpbmVhciBJbnRlcnBvbGF0aW9uXHJcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXHJcblx0ICogQHBhcmFtIHQgVGhlIHRpbWUgd2UgYXJlIGludGVycG9sYXRpbmcgdG9cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIgYXQgdGltZSB0XHJcblx0ICovXHJcblx0c3RhdGljIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIGEgKyB0ICogKGIgLSBhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludmVyc2UgTGluZWFyIEludGVycG9sYXRpb24uIEZpbmRzIHRoZSB0aW1lIGF0IHdoaWNoIGEgdmFsdWUgYmV0d2VlbiBhIGFuZCBiIHdvdWxkIG9jY3VyXHJcbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXHJcbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdGltZSBhdCB3aGljaCB0aGUgY3VycmVudCB2YWx1ZSBvY2N1cnMgYmV0d2VlbiBhIGFuZCBiXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnZMZXJwKGE6IG51bWJlciwgYjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKXtcclxuICAgICAgICByZXR1cm4gKHZhbHVlIC0gYSkvKGIgLSBhKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXRzIG9mZiBkZWNpbWFsIHBvaW50cyBvZiBhIG51bWJlciBhZnRlciBhIHNwZWNpZmllZCBwbGFjZVxyXG4gICAgICogQHBhcmFtIG51bSBUaGUgbnVtYmVyIHRvIGZsb29yXHJcbiAgICAgKiBAcGFyYW0gcGxhY2UgVGhlIGxhc3QgZGVjaW1hbCBwbGFjZSBvZiB0aGUgbmV3IG51bWJlclxyXG4gICAgICogQHJldHVybnMgVGhlIGZsb29yZWQgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmbG9vclRvUGxhY2UobnVtOiBudW1iZXIsIHBsYWNlOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGlmKHBsYWNlID09PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmYWN0b3IgPSAxMDtcclxuICAgICAgICB3aGlsZShwbGFjZSA+IDEpe1xyXG4gICAgICAgICAgICBmYWN0b3IgIT0gMTA7XHJcbiAgICAgICAgICAgIHBsYWNlLS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW0qZmFjdG9yKS9mYWN0b3I7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG51bWJlciBmcm9tIGEgaGV4IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGhleCBudW1iZXJcclxuICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgaW4gZGVjaW1hbCByZXByZXNlbnRlZCBieSB0aGUgaGV4IHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUhleChzdHI6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIGFzIGEgaGV4YWRlY2ltYWxcclxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGhleFxyXG4gICAgICogQHBhcmFtIG1pbkxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBoZXggc3RyaW5nIChhZGRzIHplcm8gcGFkZGluZyBpZiBuZWVkZWQpXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRvSGV4KG51bTogbnVtYmVyLCBtaW5MZW5ndGg6IG51bWJlciA9IG51bGwpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBmYWN0b3IgPSAxO1xyXG4gICAgICAgIHdoaWxlKGZhY3RvcioxNiA8IG51bSl7XHJcbiAgICAgICAgICAgIGZhY3RvciAqPSAxNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhleFN0ciA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUoZmFjdG9yID49IDEpe1xyXG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBNYXRoLmZsb29yKG51bS9mYWN0b3IpO1xyXG4gICAgICAgICAgICBoZXhTdHIgKz0gTWF0aFV0aWxzLnRvSGV4RGlnaXQoZGlnaXQpO1xyXG4gICAgICAgICAgICBudW0gLT0gZGlnaXQgKiBmYWN0b3I7XHJcbiAgICAgICAgICAgIGZhY3RvciAvPSAxNjtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYobWluTGVuZ3RoICE9PSBudWxsKXtcclxuXHRcdFx0d2hpbGUoaGV4U3RyLmxlbmd0aCA8IG1pbkxlbmd0aCl7XHJcblx0XHRcdFx0aGV4U3RyID0gXCIwXCIgKyBoZXhTdHI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGhleFN0cjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgZGlnaXQgdG8gaGV4YWRlY2ltYWwuIEluIHRoaXMgY2FzZSwgYSBkaWdpdCBpcyBiZXR3ZWVuIDAgYW5kIDE1IGluY2x1c2l2ZVxyXG4gICAgICogQHBhcmFtIG51bSBUaGUgZGlnaXQgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbFxyXG4gICAgICogQHJldHVybnMgVGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGlnaXQgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRvSGV4RGlnaXQobnVtOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmKG51bSA8IDEwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBudW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBudW0gLSAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi9Db2xvclwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuL01hdGhVdGlsc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyaW5nVXRpbHMge1xyXG5cdHN0YXRpYyB0b1dlYkdMQ29vcmRzKHBvaW50OiBWZWMyLCBvcmlnaW46IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShwb2ludC54LCBvcmlnaW4ueCwgb3JpZ2luLnggKyB3b3JsZFNpemUueCwgLTEsIDEpLFxyXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueSwgb3JpZ2luLnksIG9yaWdpbi55ICsgd29ybGRTaXplLnksIDEsIC0xKVxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgdG9XZWJHTFNjYWxlKHNpemU6IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdDIqc2l6ZS54L3dvcmxkU2l6ZS54LFxyXG5cdFx0XHQyKnNpemUueS93b3JsZFNpemUueSxcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIHRvV2ViR0xDb2xvcihjb2xvcjogQ29sb3IpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuciwgMCwgMjU1LCAwLCAxKSxcclxuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLmcsIDAsIDI1NSwgMCwgMSksXHJcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5iLCAwLCAyNTUsIDAsIDEpLFxyXG5cdFx0XHRjb2xvci5hXHJcblx0XHRdKTtcclxuXHR9XHJcbn0iLCIvKiogU29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIHN0cmluZ3MgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nVXRpbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyB0aGUgcGF0aCBmcm9tIGEgZmlsZXBhdGggdGhhdCBpbmNsdWRlcyB0aGUgZmlsZVxyXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHRoZSBmaWxlcGF0aCB0byBleHRyYWN0IHRoZSBwYXRoIGZyb21cclxuICAgICAqIEByZXR1cm5zIFRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIGZpbGVwYXRoIHByb3ZpZGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQYXRoRnJvbUZpbGVQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgc3BsaXRQYXRoLnBvcCgpO1xyXG4gICAgICAgIHNwbGl0UGF0aC5wdXNoKFwiXCIpO1xyXG4gICAgICAgIHJldHVybiBzcGxpdFBhdGguam9pbihcIi9cIik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR2FtZSBmcm9tIFwiLi9Xb2xmaWUyRC9Mb29wL0dhbWVcIjtcclxuaW1wb3J0IFNwbGFzaFNjcmVlbiBmcm9tIFwiLi9TY2VuZXMvU3BsYXNoU2NyZWVuXCI7XHJcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4vV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBXZWFwb25SZWdpc3RyeSBmcm9tIFwiLi9HYW1lU3lzdGVtcy9SZWdpc3RyeS9XZWFwb25SZWdpc3RyeVwiO1xyXG5pbXBvcnQgV2VhcG9uVHlwZVJlZ2lzdHJ5IGZyb20gXCIuL0dhbWVTeXN0ZW1zL1JlZ2lzdHJ5L1dlYXBvblR5cGVSZWdpc3RyeVwiO1xyXG5cclxuLy8gVGhlIG1haW4gZnVuY3Rpb24gaXMgeW91ciBlbnRyeXBvaW50IGludG8gV29sZmllMkQuIFNwZWNpZnkgeW91ciBmaXJzdCBzY2VuZSBhbmQgYW55IG9wdGlvbnMgaGVyZS5cclxuKGZ1bmN0aW9uIG1haW4oKXtcclxuICAgIC8vIFJ1biBhbnkgdGVzdHNcclxuICAgIHJ1blRlc3RzKCk7XHJcblxyXG4gICAgLy8gU2V0IHVwIG9wdGlvbnMgZm9yIG91ciBnYW1lXHJcbiAgICBsZXQgb3B0aW9ucyA9IHtcclxuICAgICAgICBjYW52YXNTaXplOiB7eDogMTI4MCwgeTogNzIwfSwgICAgICAgICAgLy8gVGhlIHNpemUgb2YgdGhlIGdhbWVcclxuICAgICAgICBjbGVhckNvbG9yOiB7cjogMCwgZzogMCwgYjogMH0sICAgICAgICAgLy8gVGhlIGNvbG9yIHRoZSBnYW1lIGNsZWFycyB0b1xyXG4gICAgICAgIGlucHV0czogWyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR1cCBpbnB1dHNcclxuICAgICAgICAgICAge25hbWU6IFwidXBcIiwga2V5czogW1wid1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImRvd25cIiwga2V5czogW1wic1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImxlZnRcIiwga2V5czogW1wiYVwiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcInJpZ2h0XCIsIGtleXM6IFtcImRcIl19LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJpbnRlcmFjdFwiLCBrZXlzOiBbXCJlXCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwicGF1c2VcIiwga2V5czogW1wiZXNjYXBlXCJdfSxcclxuICAgICAgICBdXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0dXAgY3VzdG9tIHdlYXBvbiByZWdpc3RyeVxyXG4gICAgbGV0IHdlYXBvblRlbXBsYXRlUmVnaXN0cnkgPSBuZXcgV2VhcG9uUmVnaXN0cnkoKTtcclxuICAgIFJlZ2lzdHJ5TWFuYWdlci5hZGRDdXN0b21SZWdpc3RyeShcIndlYXBvblRlbXBsYXRlc1wiLCB3ZWFwb25UZW1wbGF0ZVJlZ2lzdHJ5KTtcclxuICAgIFxyXG4gICAgbGV0IHdlYXBvblR5cGVSZWdpc3RyeSA9IG5ldyBXZWFwb25UeXBlUmVnaXN0cnkoKTtcclxuICAgIFJlZ2lzdHJ5TWFuYWdlci5hZGRDdXN0b21SZWdpc3RyeShcIndlYXBvblR5cGVzXCIsIHdlYXBvblR5cGVSZWdpc3RyeSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgZ2FtZSB3aXRoIHRoZSBvcHRpb25zIHNwZWNpZmllZFxyXG4gICAgY29uc3QgZ2FtZSA9IG5ldyBHYW1lKG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIFN0YXJ0IG91ciBnYW1lXHJcbiAgICBnYW1lLnN0YXJ0KFNwbGFzaFNjcmVlbiwge30pO1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gcnVuVGVzdHMoKXt9OyJdfQ==
